import * as Lc from "react";
import le, { useState as de, useEffect as me, forwardRef as Oe, useRef as te, useImperativeHandle as In, useLayoutEffect as kp, useCallback as we, Children as to, isValidElement as Yn, cloneElement as Yi, useContext as Qt, useMemo as Ye, createContext as Ep, useId as y1 } from "react";
import Cp, { createPortal as Rn, flushSync as v1 } from "react-dom";
import _e from "dayjs";
import { LazyMotion as Gs, AnimatePresence as bd, m as Ks, useInView as $1, motion as x1 } from "framer-motion";
import { useReactTable as w1, getPaginationRowModel as k1, getSortedRowModel as E1, getCoreRowModel as C1, flexRender as jc } from "@tanstack/react-table";
var Sp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Np(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ll = { exports: {} }, mo = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dc;
function S1() {
  if (Dc) return mo;
  Dc = 1;
  var t = le, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, o = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(a, l, d) {
    var c, u = {}, f = null, p = null;
    d !== void 0 && (f = "" + d), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (p = l.ref);
    for (c in l) n.call(l, c) && !s.hasOwnProperty(c) && (u[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) u[c] === void 0 && (u[c] = l[c]);
    return { $$typeof: e, type: a, key: f, ref: p, props: u, _owner: o.current };
  }
  return mo.Fragment = r, mo.jsx = i, mo.jsxs = i, mo;
}
var go = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _c;
function N1() {
  return _c || (_c = 1, process.env.NODE_ENV !== "production" && function() {
    var t = le, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), h = Symbol.iterator, g = "@@iterator";
    function b(S) {
      if (S === null || typeof S != "object")
        return null;
      var K = h && S[h] || S[g];
      return typeof K == "function" ? K : null;
    }
    var y = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function $(S) {
      {
        for (var K = arguments.length, Q = new Array(K > 1 ? K - 1 : 0), ge = 1; ge < K; ge++)
          Q[ge - 1] = arguments[ge];
        k("error", S, Q);
      }
    }
    function k(S, K, Q) {
      {
        var ge = y.ReactDebugCurrentFrame, Pe = ge.getStackAddendum();
        Pe !== "" && (K += "%s", Q = Q.concat([Pe]));
        var De = Q.map(function(Te) {
          return String(Te);
        });
        De.unshift("Warning: " + K), Function.prototype.apply.call(console[S], console, De);
      }
    }
    var w = !1, C = !1, T = !1, H = !1, O = !1, j;
    j = Symbol.for("react.module.reference");
    function F(S) {
      return !!(typeof S == "string" || typeof S == "function" || S === n || S === s || O || S === o || S === d || S === c || H || S === p || w || C || T || typeof S == "object" && S !== null && (S.$$typeof === f || S.$$typeof === u || S.$$typeof === i || S.$$typeof === a || S.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      S.$$typeof === j || S.getModuleId !== void 0));
    }
    function v(S, K, Q) {
      var ge = S.displayName;
      if (ge)
        return ge;
      var Pe = K.displayName || K.name || "";
      return Pe !== "" ? Q + "(" + Pe + ")" : Q;
    }
    function M(S) {
      return S.displayName || "Context";
    }
    function E(S) {
      if (S == null)
        return null;
      if (typeof S.tag == "number" && $("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof S == "function")
        return S.displayName || S.name || null;
      if (typeof S == "string")
        return S;
      switch (S) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case o:
          return "StrictMode";
        case d:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof S == "object")
        switch (S.$$typeof) {
          case a:
            var K = S;
            return M(K) + ".Consumer";
          case i:
            var Q = S;
            return M(Q._context) + ".Provider";
          case l:
            return v(S, S.render, "ForwardRef");
          case u:
            var ge = S.displayName || null;
            return ge !== null ? ge : E(S.type) || "Memo";
          case f: {
            var Pe = S, De = Pe._payload, Te = Pe._init;
            try {
              return E(Te(De));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, R = 0, x, P, I, D, L, A, z;
    function Y() {
    }
    Y.__reactDisabledLog = !0;
    function q() {
      {
        if (R === 0) {
          x = console.log, P = console.info, I = console.warn, D = console.error, L = console.group, A = console.groupCollapsed, z = console.groupEnd;
          var S = {
            configurable: !0,
            enumerable: !0,
            value: Y,
            writable: !0
          };
          Object.defineProperties(console, {
            info: S,
            log: S,
            warn: S,
            error: S,
            group: S,
            groupCollapsed: S,
            groupEnd: S
          });
        }
        R++;
      }
    }
    function ee() {
      {
        if (R--, R === 0) {
          var S = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, S, {
              value: x
            }),
            info: N({}, S, {
              value: P
            }),
            warn: N({}, S, {
              value: I
            }),
            error: N({}, S, {
              value: D
            }),
            group: N({}, S, {
              value: L
            }),
            groupCollapsed: N({}, S, {
              value: A
            }),
            groupEnd: N({}, S, {
              value: z
            })
          });
        }
        R < 0 && $("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var B = y.ReactCurrentDispatcher, _;
    function W(S, K, Q) {
      {
        if (_ === void 0)
          try {
            throw Error();
          } catch (Pe) {
            var ge = Pe.stack.trim().match(/\n( *(at )?)/);
            _ = ge && ge[1] || "";
          }
        return `
` + _ + S;
      }
    }
    var ie = !1, pe;
    {
      var ye = typeof WeakMap == "function" ? WeakMap : Map;
      pe = new ye();
    }
    function Ce(S, K) {
      if (!S || ie)
        return "";
      {
        var Q = pe.get(S);
        if (Q !== void 0)
          return Q;
      }
      var ge;
      ie = !0;
      var Pe = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var De;
      De = B.current, B.current = null, q();
      try {
        if (K) {
          var Te = function() {
            throw Error();
          };
          if (Object.defineProperty(Te.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Te, []);
            } catch (It) {
              ge = It;
            }
            Reflect.construct(S, [], Te);
          } else {
            try {
              Te.call();
            } catch (It) {
              ge = It;
            }
            S.call(Te.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (It) {
            ge = It;
          }
          S();
        }
      } catch (It) {
        if (It && ge && typeof It.stack == "string") {
          for (var Se = It.stack.split(`
`), At = ge.stack.split(`
`), tt = Se.length - 1, ot = At.length - 1; tt >= 1 && ot >= 0 && Se[tt] !== At[ot]; )
            ot--;
          for (; tt >= 1 && ot >= 0; tt--, ot--)
            if (Se[tt] !== At[ot]) {
              if (tt !== 1 || ot !== 1)
                do
                  if (tt--, ot--, ot < 0 || Se[tt] !== At[ot]) {
                    var Ut = `
` + Se[tt].replace(" at new ", " at ");
                    return S.displayName && Ut.includes("<anonymous>") && (Ut = Ut.replace("<anonymous>", S.displayName)), typeof S == "function" && pe.set(S, Ut), Ut;
                  }
                while (tt >= 1 && ot >= 0);
              break;
            }
        }
      } finally {
        ie = !1, B.current = De, ee(), Error.prepareStackTrace = Pe;
      }
      var _n = S ? S.displayName || S.name : "", an = _n ? W(_n) : "";
      return typeof S == "function" && pe.set(S, an), an;
    }
    function Be(S, K, Q) {
      return Ce(S, !1);
    }
    function je(S) {
      var K = S.prototype;
      return !!(K && K.isReactComponent);
    }
    function ut(S, K, Q) {
      if (S == null)
        return "";
      if (typeof S == "function")
        return Ce(S, je(S));
      if (typeof S == "string")
        return W(S);
      switch (S) {
        case d:
          return W("Suspense");
        case c:
          return W("SuspenseList");
      }
      if (typeof S == "object")
        switch (S.$$typeof) {
          case l:
            return Be(S.render);
          case u:
            return ut(S.type, K, Q);
          case f: {
            var ge = S, Pe = ge._payload, De = ge._init;
            try {
              return ut(De(Pe), K, Q);
            } catch {
            }
          }
        }
      return "";
    }
    var Fe = Object.prototype.hasOwnProperty, vt = {}, et = y.ReactDebugCurrentFrame;
    function Vt(S) {
      if (S) {
        var K = S._owner, Q = ut(S.type, S._source, K ? K.type : null);
        et.setExtraStackFrame(Q);
      } else
        et.setExtraStackFrame(null);
    }
    function Pt(S, K, Q, ge, Pe) {
      {
        var De = Function.call.bind(Fe);
        for (var Te in S)
          if (De(S, Te)) {
            var Se = void 0;
            try {
              if (typeof S[Te] != "function") {
                var At = Error((ge || "React class") + ": " + Q + " type `" + Te + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof S[Te] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw At.name = "Invariant Violation", At;
              }
              Se = S[Te](K, Te, ge, Q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tt) {
              Se = tt;
            }
            Se && !(Se instanceof Error) && (Vt(Pe), $("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ge || "React class", Q, Te, typeof Se), Vt(null)), Se instanceof Error && !(Se.message in vt) && (vt[Se.message] = !0, Vt(Pe), $("Failed %s type: %s", Q, Se.message), Vt(null));
          }
      }
    }
    var Tt = Array.isArray;
    function at(S) {
      return Tt(S);
    }
    function br(S) {
      {
        var K = typeof Symbol == "function" && Symbol.toStringTag, Q = K && S[Symbol.toStringTag] || S.constructor.name || "Object";
        return Q;
      }
    }
    function yr(S) {
      try {
        return oe(S), !1;
      } catch {
        return !0;
      }
    }
    function oe(S) {
      return "" + S;
    }
    function Me(S) {
      if (yr(S))
        return $("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", br(S)), oe(S);
    }
    var se = y.ReactCurrentOwner, Z = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, G, ae;
    function ce(S) {
      if (Fe.call(S, "ref")) {
        var K = Object.getOwnPropertyDescriptor(S, "ref").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return S.ref !== void 0;
    }
    function ke(S) {
      if (Fe.call(S, "key")) {
        var K = Object.getOwnPropertyDescriptor(S, "key").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return S.key !== void 0;
    }
    function ft(S, K) {
      typeof S.ref == "string" && se.current;
    }
    function Dt(S, K) {
      {
        var Q = function() {
          G || (G = !0, $("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        Q.isReactWarning = !0, Object.defineProperty(S, "key", {
          get: Q,
          configurable: !0
        });
      }
    }
    function Wt(S, K) {
      {
        var Q = function() {
          ae || (ae = !0, $("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        Q.isReactWarning = !0, Object.defineProperty(S, "ref", {
          get: Q,
          configurable: !0
        });
      }
    }
    var vr = function(S, K, Q, ge, Pe, De, Te) {
      var Se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: S,
        key: K,
        ref: Q,
        props: Te,
        // Record the component responsible for creating this element.
        _owner: De
      };
      return Se._store = {}, Object.defineProperty(Se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ge
      }), Object.defineProperty(Se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Pe
      }), Object.freeze && (Object.freeze(Se.props), Object.freeze(Se)), Se;
    };
    function jn(S, K, Q, ge, Pe) {
      {
        var De, Te = {}, Se = null, At = null;
        Q !== void 0 && (Me(Q), Se = "" + Q), ke(K) && (Me(K.key), Se = "" + K.key), ce(K) && (At = K.ref, ft(K, Pe));
        for (De in K)
          Fe.call(K, De) && !Z.hasOwnProperty(De) && (Te[De] = K[De]);
        if (S && S.defaultProps) {
          var tt = S.defaultProps;
          for (De in tt)
            Te[De] === void 0 && (Te[De] = tt[De]);
        }
        if (Se || At) {
          var ot = typeof S == "function" ? S.displayName || S.name || "Unknown" : S;
          Se && Dt(Te, ot), At && Wt(Te, ot);
        }
        return vr(S, Se, At, Pe, ge, se.current, Te);
      }
    }
    var sn = y.ReactCurrentOwner, sr = y.ReactDebugCurrentFrame;
    function Dn(S) {
      if (S) {
        var K = S._owner, Q = ut(S.type, S._source, K ? K.type : null);
        sr.setExtraStackFrame(Q);
      } else
        sr.setExtraStackFrame(null);
    }
    var ya;
    ya = !1;
    function va(S) {
      return typeof S == "object" && S !== null && S.$$typeof === e;
    }
    function Ac() {
      {
        if (sn.current) {
          var S = E(sn.current.type);
          if (S)
            return `

Check the render method of \`` + S + "`.";
        }
        return "";
      }
    }
    function l1(S) {
      return "";
    }
    var Mc = {};
    function d1(S) {
      {
        var K = Ac();
        if (!K) {
          var Q = typeof S == "string" ? S : S.displayName || S.name;
          Q && (K = `

Check the top-level render call using <` + Q + ">.");
        }
        return K;
      }
    }
    function Pc(S, K) {
      {
        if (!S._store || S._store.validated || S.key != null)
          return;
        S._store.validated = !0;
        var Q = d1(K);
        if (Mc[Q])
          return;
        Mc[Q] = !0;
        var ge = "";
        S && S._owner && S._owner !== sn.current && (ge = " It was passed a child from " + E(S._owner.type) + "."), Dn(S), $('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Q, ge), Dn(null);
      }
    }
    function Ic(S, K) {
      {
        if (typeof S != "object")
          return;
        if (at(S))
          for (var Q = 0; Q < S.length; Q++) {
            var ge = S[Q];
            va(ge) && Pc(ge, K);
          }
        else if (va(S))
          S._store && (S._store.validated = !0);
        else if (S) {
          var Pe = b(S);
          if (typeof Pe == "function" && Pe !== S.entries)
            for (var De = Pe.call(S), Te; !(Te = De.next()).done; )
              va(Te.value) && Pc(Te.value, K);
        }
      }
    }
    function c1(S) {
      {
        var K = S.type;
        if (K == null || typeof K == "string")
          return;
        var Q;
        if (typeof K == "function")
          Q = K.propTypes;
        else if (typeof K == "object" && (K.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        K.$$typeof === u))
          Q = K.propTypes;
        else
          return;
        if (Q) {
          var ge = E(K);
          Pt(Q, S.props, "prop", ge, S);
        } else if (K.PropTypes !== void 0 && !ya) {
          ya = !0;
          var Pe = E(K);
          $("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Pe || "Unknown");
        }
        typeof K.getDefaultProps == "function" && !K.getDefaultProps.isReactClassApproved && $("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function u1(S) {
      {
        for (var K = Object.keys(S.props), Q = 0; Q < K.length; Q++) {
          var ge = K[Q];
          if (ge !== "children" && ge !== "key") {
            Dn(S), $("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ge), Dn(null);
            break;
          }
        }
        S.ref !== null && (Dn(S), $("Invalid attribute `ref` supplied to `React.Fragment`."), Dn(null));
      }
    }
    var Rc = {};
    function Oc(S, K, Q, ge, Pe, De) {
      {
        var Te = F(S);
        if (!Te) {
          var Se = "";
          (S === void 0 || typeof S == "object" && S !== null && Object.keys(S).length === 0) && (Se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var At = l1();
          At ? Se += At : Se += Ac();
          var tt;
          S === null ? tt = "null" : at(S) ? tt = "array" : S !== void 0 && S.$$typeof === e ? (tt = "<" + (E(S.type) || "Unknown") + " />", Se = " Did you accidentally export a JSX literal instead of a component?") : tt = typeof S, $("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", tt, Se);
        }
        var ot = jn(S, K, Q, Pe, De);
        if (ot == null)
          return ot;
        if (Te) {
          var Ut = K.children;
          if (Ut !== void 0)
            if (ge)
              if (at(Ut)) {
                for (var _n = 0; _n < Ut.length; _n++)
                  Ic(Ut[_n], S);
                Object.freeze && Object.freeze(Ut);
              } else
                $("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ic(Ut, S);
        }
        if (Fe.call(K, "key")) {
          var an = E(S), It = Object.keys(K).filter(function(b1) {
            return b1 !== "key";
          }), $a = It.length > 0 ? "{key: someKey, " + It.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Rc[an + $a]) {
            var g1 = It.length > 0 ? "{" + It.join(": ..., ") + ": ...}" : "{}";
            $(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, $a, an, g1, an), Rc[an + $a] = !0;
          }
        }
        return S === n ? u1(ot) : c1(ot), ot;
      }
    }
    function f1(S, K, Q) {
      return Oc(S, K, Q, !0);
    }
    function p1(S, K, Q) {
      return Oc(S, K, Q, !1);
    }
    var h1 = p1, m1 = f1;
    go.Fragment = n, go.jsx = h1, go.jsxs = m1;
  }()), go;
}
process.env.NODE_ENV === "production" ? ll.exports = S1() : ll.exports = N1();
var m = ll.exports;
function Tp(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var o = t.length;
    for (e = 0; e < o; e++) t[e] && (r = Tp(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function Ne() {
  for (var t, e, r = 0, n = "", o = arguments.length; r < o; r++) (t = arguments[r]) && (e = Tp(t)) && (n && (n += " "), n += e);
  return n;
}
const yd = "-", T1 = (t) => {
  const e = M1(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (i) => {
      const a = i.split(yd);
      return a[0] === "" && a.length !== 1 && a.shift(), Ap(a, e) || A1(i);
    },
    getConflictingClassGroupIds: (i, a) => {
      const l = r[i] || [];
      return a && n[i] ? [...l, ...n[i]] : l;
    }
  };
}, Ap = (t, e) => {
  var i;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), o = n ? Ap(t.slice(1), n) : void 0;
  if (o)
    return o;
  if (e.validators.length === 0)
    return;
  const s = t.join(yd);
  return (i = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : i.classGroupId;
}, Fc = /^\[(.+)\]$/, A1 = (t) => {
  if (Fc.test(t)) {
    const e = Fc.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, M1 = (t) => {
  const {
    theme: e,
    prefix: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return I1(Object.entries(t.classGroups), r).forEach(([s, i]) => {
    dl(i, n, s, e);
  }), n;
}, dl = (t, e, r, n) => {
  t.forEach((o) => {
    if (typeof o == "string") {
      const s = o === "" ? e : zc(e, o);
      s.classGroupId = r;
      return;
    }
    if (typeof o == "function") {
      if (P1(o)) {
        dl(o(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: o,
        classGroupId: r
      });
      return;
    }
    Object.entries(o).forEach(([s, i]) => {
      dl(i, zc(e, s), r, n);
    });
  });
}, zc = (t, e) => {
  let r = t;
  return e.split(yd).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, P1 = (t) => t.isThemeGetter, I1 = (t, e) => e ? t.map(([r, n]) => {
  const o = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([i, a]) => [e + i, a])) : s);
  return [r, o];
}) : t, R1 = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const o = (s, i) => {
    r.set(s, i), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let i = r.get(s);
      if (i !== void 0)
        return i;
      if ((i = n.get(s)) !== void 0)
        return o(s, i), i;
    },
    set(s, i) {
      r.has(s) ? r.set(s, i) : o(s, i);
    }
  };
}, Mp = "!", O1 = (t) => {
  const {
    separator: e,
    experimentalParseClassName: r
  } = t, n = e.length === 1, o = e[0], s = e.length, i = (a) => {
    const l = [];
    let d = 0, c = 0, u;
    for (let b = 0; b < a.length; b++) {
      let y = a[b];
      if (d === 0) {
        if (y === o && (n || a.slice(b, b + s) === e)) {
          l.push(a.slice(c, b)), c = b + s;
          continue;
        }
        if (y === "/") {
          u = b;
          continue;
        }
      }
      y === "[" ? d++ : y === "]" && d--;
    }
    const f = l.length === 0 ? a : a.substring(c), p = f.startsWith(Mp), h = p ? f.substring(1) : f, g = u && u > c ? u - c : void 0;
    return {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: h,
      maybePostfixModifierPosition: g
    };
  };
  return r ? (a) => r({
    className: a,
    parseClassName: i
  }) : i;
}, L1 = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let r = [];
  return t.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}, j1 = (t) => ({
  cache: R1(t.cacheSize),
  parseClassName: O1(t),
  ...T1(t)
}), D1 = /\s+/, _1 = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: o
  } = e, s = [], i = t.trim().split(D1);
  let a = "";
  for (let l = i.length - 1; l >= 0; l -= 1) {
    const d = i[l], {
      modifiers: c,
      hasImportantModifier: u,
      baseClassName: f,
      maybePostfixModifierPosition: p
    } = r(d);
    let h = !!p, g = n(h ? f.substring(0, p) : f);
    if (!g) {
      if (!h) {
        a = d + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (g = n(f), !g) {
        a = d + (a.length > 0 ? " " + a : a);
        continue;
      }
      h = !1;
    }
    const b = L1(c).join(":"), y = u ? b + Mp : b, $ = y + g;
    if (s.includes($))
      continue;
    s.push($);
    const k = o(g, h);
    for (let w = 0; w < k.length; ++w) {
      const C = k[w];
      s.push(y + C);
    }
    a = d + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function F1() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = Pp(e)) && (n && (n += " "), n += r);
  return n;
}
const Pp = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = Pp(t[n])) && (r && (r += " "), r += e);
  return r;
};
function z1(t, ...e) {
  let r, n, o, s = i;
  function i(l) {
    const d = e.reduce((c, u) => u(c), t());
    return r = j1(d), n = r.cache.get, o = r.cache.set, s = a, a(l);
  }
  function a(l) {
    const d = n(l);
    if (d)
      return d;
    const c = _1(l, r);
    return o(l, c), c;
  }
  return function() {
    return s(F1.apply(null, arguments));
  };
}
const Ve = (t) => {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}, Ip = /^\[(?:([a-z-]+):)?(.+)\]$/i, H1 = /^\d+\/\d+$/, B1 = /* @__PURE__ */ new Set(["px", "full", "screen"]), V1 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, W1 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, U1 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, G1 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, K1 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, $r = (t) => Jn(t) || B1.has(t) || H1.test(t), Dr = (t) => co(t, "length", tb), Jn = (t) => !!t && !Number.isNaN(Number(t)), xa = (t) => co(t, "number", Jn), bo = (t) => !!t && Number.isInteger(Number(t)), Y1 = (t) => t.endsWith("%") && Jn(t.slice(0, -1)), ve = (t) => Ip.test(t), _r = (t) => V1.test(t), J1 = /* @__PURE__ */ new Set(["length", "size", "percentage"]), q1 = (t) => co(t, J1, Rp), X1 = (t) => co(t, "position", Rp), Z1 = /* @__PURE__ */ new Set(["image", "url"]), Q1 = (t) => co(t, Z1, nb), eb = (t) => co(t, "", rb), yo = () => !0, co = (t, e, r) => {
  const n = Ip.exec(t);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1;
}, tb = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  W1.test(t) && !U1.test(t)
), Rp = () => !1, rb = (t) => G1.test(t), nb = (t) => K1.test(t), ob = () => {
  const t = Ve("colors"), e = Ve("spacing"), r = Ve("blur"), n = Ve("brightness"), o = Ve("borderColor"), s = Ve("borderRadius"), i = Ve("borderSpacing"), a = Ve("borderWidth"), l = Ve("contrast"), d = Ve("grayscale"), c = Ve("hueRotate"), u = Ve("invert"), f = Ve("gap"), p = Ve("gradientColorStops"), h = Ve("gradientColorStopPositions"), g = Ve("inset"), b = Ve("margin"), y = Ve("opacity"), $ = Ve("padding"), k = Ve("saturate"), w = Ve("scale"), C = Ve("sepia"), T = Ve("skew"), H = Ve("space"), O = Ve("translate"), j = () => ["auto", "contain", "none"], F = () => ["auto", "hidden", "clip", "visible", "scroll"], v = () => ["auto", ve, e], M = () => [ve, e], E = () => ["", $r, Dr], N = () => ["auto", Jn, ve], R = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], x = () => ["solid", "dashed", "dotted", "double", "none"], P = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], I = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], D = () => ["", "0", ve], L = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], A = () => [Jn, ve];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [yo],
      spacing: [$r, Dr],
      blur: ["none", "", _r, ve],
      brightness: A(),
      borderColor: [t],
      borderRadius: ["none", "", "full", _r, ve],
      borderSpacing: M(),
      borderWidth: E(),
      contrast: A(),
      grayscale: D(),
      hueRotate: A(),
      invert: D(),
      gap: M(),
      gradientColorStops: [t],
      gradientColorStopPositions: [Y1, Dr],
      inset: v(),
      margin: v(),
      opacity: A(),
      padding: M(),
      saturate: A(),
      scale: A(),
      sepia: D(),
      skew: A(),
      space: M(),
      translate: M()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ve]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [_r]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": L()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": L()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...R(), ve]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: F()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": F()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": F()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: j()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": j()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": j()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", bo, ve]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: v()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ve]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: D()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: D()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", bo, ve]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [yo]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", bo, ve]
        }, ve]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": N()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": N()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [yo]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [bo, ve]
        }, ve]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": N()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": N()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ve]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ve]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...I()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...I(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...I(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [$]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [$]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [$]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [$]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [$]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [$]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [$]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [$]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [$]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [b]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [b]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [b]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [b]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [b]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [b]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [b]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [b]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [b]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [H]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [H]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ve, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ve, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ve, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [_r]
        }, _r]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ve, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ve, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ve, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ve, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", _r, Dr]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", xa]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [yo]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ve]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Jn, xa]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", $r, ve]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ve]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ve]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [y]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [y]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...x(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", $r, Dr]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", $r, ve]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: M()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ve]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ve]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [y]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...R(), X1]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", q1]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Q1]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [h]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [p]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [y]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...x(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [y]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: x()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [o]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [o]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [o]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [o]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [o]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [o]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [o]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [o]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [o]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [o]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...x()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [$r, ve]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [$r, Dr]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: E()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [y]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [$r, Dr]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", _r, eb]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [yo]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [y]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...P(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": P()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", _r, ve]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [d]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [c]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [u]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [k]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [C]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [d]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [c]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [u]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [y]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [k]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [C]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ve]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: A()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ve]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: A()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ve]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [w]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [w]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [w]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [bo, ve]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [O]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [O]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [T]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [T]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ve]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ve]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": M()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": M()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": M()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": M()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": M()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": M()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": M()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": M()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": M()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": M()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": M()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": M()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": M()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": M()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": M()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": M()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": M()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": M()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ve]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [$r, Dr, xa]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, fr = /* @__PURE__ */ z1(ob);
function V(...t) {
  return fr(Ne(t));
}
const Hc = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, Bc = Ne, ct = (t, e) => (r) => {
  var n;
  if ((e == null ? void 0 : e.variants) == null) return Bc(t, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
  const { variants: o, defaultVariants: s } = e, i = Object.keys(o).map((d) => {
    const c = r == null ? void 0 : r[d], u = s == null ? void 0 : s[d];
    if (c === null) return null;
    const f = Hc(c) || Hc(u);
    return o[d][f];
  }), a = r && Object.entries(r).reduce((d, c) => {
    let [u, f] = c;
    return f === void 0 || (d[u] = f), d;
  }, {}), l = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce((d, c) => {
    let { class: u, className: f, ...p } = c;
    return Object.entries(p).every((h) => {
      let [g, b] = h;
      return Array.isArray(b) ? b.includes({
        ...s,
        ...a
      }[g]) : {
        ...s,
        ...a
      }[g] === b;
    }) ? [
      ...d,
      u,
      f
    ] : d;
  }, []);
  return Bc(t, i, l, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
}, $e = ({
  icon: t,
  className: e,
  size: r,
  color: n,
  rotate: o,
  flip: s,
  spin: i,
  inline: a = !0,
  mode: l = "svg",
  ...d
}) => {
  const [c, u] = de(null), [f, p] = de(!0), [h, g] = de(null);
  return me(() => {
    let b = !0;
    return (async () => {
      try {
        const { Icon: $ } = await import("./iconify-Dqt3MVen.mjs");
        b && (u(() => $), p(!1));
      } catch ($) {
        console.error("Failed to load icon:", $), b && (g($), p(!1));
      }
    })(), () => {
      b = !1;
    };
  }, []), f ? /* @__PURE__ */ m.jsx("span", { style: { width: r, height: r } }) : h || !c ? null : /* @__PURE__ */ m.jsx(
    c,
    {
      icon: t,
      className: V(
        i && "animate-spin",
        e
      ),
      style: {
        color: n,
        transform: `rotate(${o || 0}deg)`
      },
      height: r,
      width: r,
      flip: s,
      inline: a,
      mode: l,
      ...d
    }
  );
}, sb = ct(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "xl",
      fullWidth: !0
    }
  }
), Op = Oe(
  ({
    className: t,
    variant: e = "default",
    size: r = "md",
    rounded: n = "xl",
    error: o = !1,
    errorText: s,
    helperText: i,
    label: a,
    required: l = !1,
    labelPlacement: d = "top",
    fullWidth: c = !1,
    leftIcon: u,
    rightIcon: f,
    onRightIconClick: p,
    id: h,
    ...g
  }, b) => {
    const y = h || le.useId(), $ = `${y}-helper`, k = `${y}-error`, w = /* @__PURE__ */ m.jsxs("div", { className: V("relative", !c && "inline-block"), children: [
      u && /* @__PURE__ */ m.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral", children: /* @__PURE__ */ m.jsx($e, { icon: u, className: "w-4 h-4" }) }),
      /* @__PURE__ */ m.jsx(
        "input",
        {
          id: y,
          type: "text",
          ref: b,
          className: V(
            sb({ variant: o ? "error" : e, size: r, rounded: n, fullWidth: c }),
            u && "pl-10",
            f && "pr-10",
            t
          ),
          "aria-describedby": o ? k : i ? $ : void 0,
          "aria-invalid": o,
          "aria-required": l,
          ...g
        }
      ),
      f && /* @__PURE__ */ m.jsx(
        "div",
        {
          className: V(
            "absolute right-3 top-1/2 -translate-y-1/2 text-neutral",
            p && "cursor-pointer hover:text-primary-600"
          ),
          onClick: p,
          role: p ? "button" : void 0,
          tabIndex: p ? 0 : void 0,
          children: /* @__PURE__ */ m.jsx($e, { icon: f, className: "w-4 h-4" })
        }
      )
    ] }), C = /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      o && s && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", id: k, children: s }),
      !o && i && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", id: $, children: i })
    ] });
    return d === "left" ? /* @__PURE__ */ m.jsx("div", { className: V(c ? "w-full" : "inline-block", t), children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-start gap-4", children: [
      a && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: y,
          className: "block text-sm text-neutral-900 pt-2",
          children: [
            a,
            l && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ m.jsxs("div", { className: V("flex-1", !c && "inline-block"), children: [
        w,
        C
      ] })
    ] }) }) : /* @__PURE__ */ m.jsxs("div", { className: V(c ? "w-full" : "inline-block", t), children: [
      a && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: y,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            a,
            l && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      w,
      C
    ] });
  }
);
Op.displayName = "Input";
const Ji = le.forwardRef(
  ({ className: t, children: e, selected: r, disabled: n, ...o }, s) => /* @__PURE__ */ m.jsx(
    "div",
    {
      ref: s,
      className: V(
        "relative flex w-full cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors",
        "hover:bg-primary-50",
        r && "bg-primary-50 text-primary-900",
        n && "pointer-events-none opacity-50",
        t
      ),
      ...o,
      children: e
    }
  )
);
Ji.displayName = "SelectItem";
const Lp = typeof window < "u", Ir = () => Lp ? window : {
  innerHeight: 0,
  innerWidth: 0,
  addEventListener: () => {
  },
  removeEventListener: () => {
  }
}, wt = () => Lp ? document : {
  addEventListener: () => {
  },
  removeEventListener: () => {
  },
  dispatchEvent: () => {
  }
}, wa = "autocomplete-dropdown-opened", ib = Oe(
  ({
    className: t,
    options: e,
    onSelect: r,
    isOpen: n,
    loading: o = !1,
    renderOption: s,
    variant: i = "default",
    size: a = "md",
    rounded: l = "xl",
    leftIcon: d,
    rightIcon: c,
    error: u = !1,
    errorText: f,
    helperText: p,
    label: h,
    required: g = !1,
    labelPlacement: b = "top",
    fullWidth: y = !1,
    value: $,
    onChange: k,
    onFocus: w,
    onBlur: C,
    showClear: T = !1,
    onClear: H,
    searchType: O = "include",
    initialItemsToShow: j,
    itemsToLoad: F = 10,
    maxDropdownHeight: v = 300,
    noOptionsMessage: M = "No options found",
    scrollMoreMessage: E = "",
    allOptionsShownMessage: N = "",
    resetInvalidOnBlur: R = !1,
    onInvalidReset: x,
    ...P
  }, I) => {
    const [D, L] = de(!1), [A, z] = de($ || ""), [Y, q] = de(
      j || 0
    ), ee = te(null), B = te(null), _ = te(null), W = te(null), ie = n !== void 0, ye = `autocomplete-${le.useId().replace(/:/g, "")}`, Ce = () => {
      if (!D || !B.current || !_.current) return;
      const { bottom: Z, top: G, left: ae, width: ce } = B.current.getBoundingClientRect(), ke = _.current, ft = Ir(), Dt = ft.innerHeight - Z, Wt = G, vr = Math.min(v, 300), jn = Dt < vr, sn = Wt > Dt, sr = jn && sn;
      Object.assign(ke.style, {
        position: "fixed",
        left: `${ae}px`,
        width: `${ce}px`
      }), sr ? Object.assign(ke.style, {
        bottom: `${ft.innerHeight - G + 4}px`,
        top: "auto",
        maxHeight: `${Wt - 8}px`
      }) : Object.assign(ke.style, {
        top: `${Z + 4}px`,
        bottom: "auto",
        maxHeight: `${Dt - 8}px`
      });
    };
    me(() => {
      const Z = Ir(), G = wt(), ae = () => {
        D && Ce();
      }, ce = () => {
        D && Ce();
      }, ke = (Dt) => {
        Dt.detail.id !== ye && L(!1);
      }, ft = (Dt) => {
        const Wt = Dt.target;
        ee.current && !ee.current.contains(Wt) && _.current && !_.current.contains(Wt) && L(!1);
      };
      return D && (Ce(), Z.addEventListener("scroll", ae, !0), Z.addEventListener("resize", ce)), G.addEventListener(
        wa,
        ke
      ), G.addEventListener("click", ft), () => {
        Z.removeEventListener("scroll", ae, !0), Z.removeEventListener("resize", ce), G.removeEventListener(
          wa,
          ke
        ), G.removeEventListener("click", ft);
      };
    }, [D, ye]), me(() => {
      z($ || "");
    }, [$]);
    const Be = (Z) => {
      const { value: G } = Z.target;
      if (z(G), !G.trim()) {
        L(!1);
        return;
      }
      const ae = e.some(({ label: ce }) => {
        const ke = G.toLowerCase().trim(), ft = ce.toLowerCase();
        return O === "startsWith" ? ft.startsWith(ke) : ft.includes(ke);
      });
      L(ae), k == null || k(Z);
    }, je = (Z) => {
      Z.stopPropagation(), z(""), H == null || H();
      const G = new Event(
        "change"
      );
      G.target = { value: "" }, k == null || k(G);
    }, ut = (Z) => {
      var ke;
      if (!Z) return;
      const { value: G, label: ae } = Z;
      z(ae), L(!1), r == null || r(G);
      const ce = new CustomEvent("autocomplete-select", {
        detail: { selectedOption: Z }
      });
      (ke = B.current) == null || ke.dispatchEvent(ce);
    }, Fe = (Z) => Z.trim() ? e.some(({ label: G }) => {
      const ae = Z.toLowerCase().trim(), ce = G.toLowerCase();
      return O === "startsWith" ? ce.startsWith(ae) : ce.includes(ae);
    }) : !0, vt = (Z) => {
      if (R && A.trim() && !Fe(A)) {
        z(""), x == null || x();
        const G = new Event(
          "change"
        );
        G.target = { value: "" }, k == null || k(G);
      }
      C == null || C(Z);
    }, et = e.filter(({ label: Z }) => {
      const G = A.toLowerCase().trim(), ae = Z.toLowerCase();
      return O === "startsWith" ? ae.startsWith(G) : ae.includes(G);
    }), Vt = (Z) => {
      ie || (wt().dispatchEvent(
        new CustomEvent(wa, {
          detail: { id: ye }
        })
      ), et.length > 0 && L(!0)), w == null || w(Z);
    }, Pt = () => {
      if (!W.current || j === void 0 || j <= 0)
        return;
      const { scrollTop: Z, scrollHeight: G, clientHeight: ae } = W.current;
      Z + ae >= G - 10 && q(
        (ke) => Math.min(ke + F, et.length)
      );
    };
    me(() => {
      j !== void 0 && j > 0 && q(j);
    }, [A, j]);
    const Tt = j !== void 0 && j > 0 ? et.slice(0, Y) : et, at = (Z, G) => Z ? Z.replace(/\{(\w+)\}/g, (ae, ce) => {
      var ke;
      return ((ke = G[ce]) == null ? void 0 : ke.toString()) || ae;
    }) : "", br = ie ? n : D, yr = T && A && !P.disabled && !P.readOnly, oe = yr ? "mdi:close" : c, Me = (Z) => {
      if (!(!br || Tt.length === 0))
        switch (Z.key) {
          case "Enter":
            Z.preventDefault(), Tt.length === 1 && ut(Tt[0]);
            break;
          case "Tab":
            Tt.length === 1 && (Z.preventDefault(), ut(Tt[0]));
            break;
          case "Escape":
            Z.preventDefault(), L(!1);
            break;
        }
    }, se = () => {
      if (!br) return null;
      const Z = wt();
      if (!("body" in Z)) return null;
      const G = /* @__PURE__ */ m.jsx(
        "div",
        {
          ref: _,
          className: "fixed z-[9999] min-w-[8rem] rounded-md border border-neutral-200 bg-white py-1 shadow-lg overflow-hidden",
          style: { maxHeight: `${v}px` },
          onClick: (ae) => ae.stopPropagation(),
          children: /* @__PURE__ */ m.jsx(
            "div",
            {
              ref: W,
              className: "overflow-auto",
              style: { maxHeight: `${v}px` },
              onScroll: Pt,
              children: o ? /* @__PURE__ */ m.jsx("div", { className: "flex items-center justify-center py-2", children: /* @__PURE__ */ m.jsx("div", { className: "h-4 w-4 animate-spin rounded-full border-2 border-primary border-t-transparent" }) }) : Tt.length > 0 ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
                Tt.map((ae) => /* @__PURE__ */ m.jsx(
                  Ji,
                  {
                    value: ae.value,
                    selected: ae.label === A,
                    onClick: () => ut(ae),
                    children: s ? s(ae) : ae.label
                  },
                  ae.value
                )),
                j !== void 0 && j > 0 && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
                  Y < et.length && E && /* @__PURE__ */ m.jsx("div", { className: "px-2 py-2 text-sm text-neutral-500 text-center", children: at(E, {
                    current: Y,
                    total: et.length
                  }) }),
                  Y >= et.length && et.length > 0 && N && /* @__PURE__ */ m.jsx("div", { className: "px-2 py-2 text-sm text-neutral-500 text-center", children: at(N, {
                    total: et.length
                  }) })
                ] })
              ] }) : /* @__PURE__ */ m.jsx("div", { className: "px-2 py-2 text-sm text-neutral", children: M })
            }
          )
        }
      );
      return Rn(G, Z.body);
    };
    return /* @__PURE__ */ m.jsxs(
      "div",
      {
        ref: ee,
        className: V("relative", y ? "w-full" : "inline-block"),
        children: [
          /* @__PURE__ */ m.jsx("div", { ref: B, className: V(!y && "inline-block"), children: /* @__PURE__ */ m.jsx(
            Op,
            {
              ref: I,
              value: A,
              onChange: Be,
              onFocus: Vt,
              onBlur: vt,
              onKeyDown: Me,
              variant: i,
              size: a,
              rounded: l,
              leftIcon: d,
              rightIcon: oe,
              error: u,
              errorText: f,
              helperText: p,
              label: h,
              required: g,
              labelPlacement: b,
              fullWidth: y,
              className: t,
              ...P,
              onClick: yr ? je : P.onClick
            }
          ) }),
          se()
        ]
      }
    );
  }
);
ib.displayName = "AutoComplete";
const ab = {
  primary: {
    hover: "hover:bg-primary-50",
    active: "bg-primary-50",
    text: "text-primary-700"
  },
  secondary: {
    hover: "hover:bg-secondary-50",
    active: "bg-secondary-50",
    text: "text-secondary-700"
  },
  success: {
    hover: "hover:bg-success-50",
    active: "bg-success-50",
    text: "text-success-700"
  },
  warning: {
    hover: "hover:bg-warning-50",
    active: "bg-warning-50",
    text: "text-warning-700"
  },
  default: {
    hover: "hover:bg-gray-50",
    active: "bg-gray-50",
    text: "text-gray-700"
  },
  light: {
    hover: "hover:bg-light-50",
    active: "bg-light-50",
    text: "text-light-900"
  },
  dark: {
    hover: "hover:bg-dark-50",
    active: "bg-dark-50",
    text: "text-dark-50"
  },
  info: {
    hover: "hover:bg-info-50",
    active: "bg-info-50",
    text: "text-info-700"
  }
}, lb = {
  none: "",
  sm: "shadow-sm",
  md: "shadow-md",
  lg: "shadow-lg",
  xl: "shadow-xl"
}, db = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  xl: "rounded-xl",
  "2xl": "rounded-2xl",
  "3xl": "rounded-3xl",
  full: "rounded-full"
}, F7 = ({
  items: t,
  multiple: e = !1,
  defaultOpenIds: r = [],
  openIds: n,
  onOpenChange: o,
  icon: s = "mdi:chevron-down",
  iconPosition: i = "right",
  className: a,
  contentClassName: l,
  variant: d = "primary",
  shadow: c = "none",
  rounded: u = "xl"
}) => {
  const [f, p] = de(r), h = n !== void 0 ? n : f, g = n !== void 0, b = ($) => {
    let k;
    e ? k = h.includes($) ? h.filter((w) => w !== $) : [...h, $] : k = h.includes($) ? [] : [$], g ? o == null || o(k) : p(k);
  }, y = ab[d];
  return /* @__PURE__ */ m.jsx("div", { className: Ne("w-full space-y-2", a), children: t.map(($) => {
    const k = h.includes($.id), w = !!$.disabled;
    return /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: Ne(
          "border overflow-hidden",
          "bg-white",
          "border-gray-200",
          lb[c],
          db[u],
          "transition-shadow duration-200"
        ),
        children: [
          /* @__PURE__ */ m.jsxs(
            "button",
            {
              onClick: () => !w && b($.id),
              disabled: w,
              className: Ne(
                "w-full flex items-center justify-between p-4",
                "text-left transition-colors",
                y.hover,
                k && y.active,
                y.text,
                w && "opacity-50 cursor-not-allowed"
              ),
              children: [
                i === "left" && /* @__PURE__ */ m.jsx(
                  "div",
                  {
                    className: Ne(
                      "mr-3 transition-transform duration-200",
                      k && "rotate-180"
                    ),
                    children: /* @__PURE__ */ m.jsx($e, { icon: s, className: "w-5 h-5" })
                  }
                ),
                /* @__PURE__ */ m.jsx("div", { className: "flex-1", children: $.title }),
                i === "right" && /* @__PURE__ */ m.jsx(
                  "div",
                  {
                    className: Ne(
                      "ml-3 transition-transform duration-200",
                      k && "rotate-180"
                    ),
                    children: /* @__PURE__ */ m.jsx($e, { icon: s, className: "w-5 h-5" })
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: Ne(
                "grid transition-all duration-200 ease-in-out",
                k ? "grid-rows-[1fr]" : "grid-rows-[0fr]"
              ),
              children: /* @__PURE__ */ m.jsx("div", { className: "overflow-hidden", children: /* @__PURE__ */ m.jsx(
                "div",
                {
                  className: Ne(
                    "p-4 border-t border-gray-200",
                    l
                  ),
                  children: $.content
                }
              ) })
            }
          )
        ]
      },
      $.id
    );
  }) });
}, z7 = ({
  src: t,
  alt: e = "avatar",
  size: r = "medium",
  shape: n = "circle",
  className: o = "",
  variant: s = "cover"
}) => {
  const i = {
    small: "w-8 h-8",
    medium: "w-12 h-12",
    large: "w-16 h-16"
  }, a = {
    circle: "rounded-full",
    square: "rounded-lg"
  }, l = fr(
    "inline-flex items-center justify-center overflow-hidden bg-gray-200",
    i[r],
    a[n],
    o
  );
  return /* @__PURE__ */ m.jsx("div", { className: l, children: t ? /* @__PURE__ */ m.jsx(
    "img",
    {
      src: t,
      alt: e,
      className: fr("w-full h-full", s === "cover" ? "object-cover" : "object-contain")
    }
  ) : /* @__PURE__ */ m.jsx(
    "svg",
    {
      className: "w-6 h-6 text-gray",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ m.jsx(
        "path",
        {
          d: "M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z",
          fill: "currentColor"
        }
      )
    }
  ) });
}, H7 = ({
  children: t,
  variant: e = "primary",
  size: r = "medium",
  rounded: n = "xl",
  className: o = ""
}) => {
  const s = {
    primary: "bg-blue-100 text-blue-800",
    secondary: "bg-gray-100 text-gray-800",
    success: "bg-green-100 text-green-800",
    warning: "bg-yellow-100 text-yellow-800",
    error: "bg-red-100 text-red-800"
  }, i = {
    small: "px-2 py-0.5 text-xs",
    medium: "px-2.5 py-1 text-sm",
    large: "px-3 py-1.5 text-base"
  }, a = {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded-md",
    lg: "rounded-lg",
    xl: "rounded-xl",
    "2xl": "rounded-2xl",
    "3xl": "rounded-3xl",
    full: "rounded-full"
  }, l = fr(
    "inline-flex items-center font-medium",
    s[e],
    i[r],
    a[n],
    o
  );
  return /* @__PURE__ */ m.jsx("span", { className: l, children: t });
}, cb = ct(
  "inline-flex items-center justify-center gap-2 font-medium transition-all duration-200 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed",
  {
    variants: {
      variant: {
        primary: "bg-primary text-white hover:bg-primary-600 active:bg-primary-700 shadow-sm hover:shadow-md active:shadow-none",
        secondary: "bg-secondary text-white hover:bg-secondary-600 active:bg-secondary-700 shadow-sm hover:shadow-md active:shadow-none",
        outline: "border border-neutral-300 text-primary hover:bg-primary-50 active:bg-primary-100 hover:border-primary",
        "outline-primary": "border border-primary-600 text-primary-600 hover:bg-primary-50",
        "outline-secondary": "border border-secondary-600 text-secondary-600 hover:bg-secondary-50",
        "outline-success": "border border-success-600 text-success-600 hover:bg-success-50",
        "outline-warning": "border border-warning-600 text-warning-600 hover:bg-warning-50",
        "outline-danger": "border border-danger-600 text-danger-600 hover:bg-danger-50",
        ghost: "text-primary hover:bg-primary-50 active:bg-primary-100",
        link: "text-primary hover:underline p-0",
        success: "bg-success text-white hover:bg-success-600 active:bg-success-700 shadow-sm hover:shadow-md active:shadow-none",
        warning: "bg-warning text-white hover:bg-warning-600 active:bg-warning-700 shadow-sm hover:shadow-md active:shadow-none",
        danger: "bg-danger text-white hover:bg-danger-600 active:bg-danger-700 shadow-sm hover:shadow-md active:shadow-none"
      },
      size: {
        xs: "text-xs px-2 py-1",
        sm: "text-sm px-3 py-1.5",
        md: "text-base px-4 py-2",
        lg: "text-lg px-5 py-2.5"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full"
      },
      isIconOnly: {
        true: "p-2 aspect-square"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      rounded: "none",
      fullWidth: !1,
      isIconOnly: !1
    }
  }
), kt = Oe(
  ({
    className: t,
    variant: e = "primary",
    size: r = "md",
    rounded: n = "xl",
    fullWidth: o = !1,
    isLoading: s = !1,
    leftIcon: i,
    rightIcon: a,
    isIconOnly: l = !1,
    children: d,
    ...c
  }, u) => {
    const p = l || !!(i || a) && !d;
    return /* @__PURE__ */ m.jsxs(
      "button",
      {
        className: V(
          cb({
            variant: e,
            size: r,
            rounded: p ? "full" : n,
            fullWidth: o,
            isIconOnly: p,
            className: t
          })
        ),
        ref: u,
        disabled: c.disabled || s,
        ...c,
        children: [
          s && /* @__PURE__ */ m.jsx("span", { className: "animate-spin inline-block w-4 h-4 border-2 border-current border-r-transparent rounded-full" }),
          i && !s && /* @__PURE__ */ m.jsx($e, { icon: i, className: "w-4 h-4", inline: !0 }),
          d && /* @__PURE__ */ m.jsx("span", { children: d }),
          a && !s && /* @__PURE__ */ m.jsx($e, { icon: a, className: "w-4 h-4", inline: !0 })
        ]
      }
    );
  }
);
kt.displayName = "Button";
const ub = ct(
  "border bg-card text-card-foreground",
  {
    variants: {
      variant: {
        default: "border-border shadow-sm",
        elevated: "border-border shadow-lg",
        outline: "border-border bg-transparent",
        ghost: "border-transparent bg-transparent"
      },
      padding: {
        none: "p-0",
        sm: "p-4",
        md: "p-6",
        lg: "p-8"
      },
      shadow: {
        none: "",
        sm: "shadow-sm",
        md: "shadow-md",
        lg: "shadow-lg",
        xl: "shadow-xl"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      padding: "md",
      shadow: "sm",
      rounded: "xl"
    }
  }
), jp = Oe(
  ({
    className: t,
    variant: e = "default",
    padding: r = "md",
    shadow: n = "none",
    rounded: o = "2xl",
    asChild: s = !1,
    ...i
  }, a) => /* @__PURE__ */ m.jsx(
    "div",
    {
      className: V(ub({ variant: e, padding: r, shadow: n, rounded: o, className: t })),
      ref: a,
      ...i
    }
  )
);
jp.displayName = "Card";
const Ds = Oe(({
  label: t,
  error: e,
  disabled: r = !1,
  indeterminate: n = !1,
  variantSize: o = "sm",
  variant: s = "square",
  color: i = "primary",
  className: a = "",
  ...l
}, d) => {
  const c = {
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  }, u = {
    primary: "checked:bg-primary-600 checked:border-primary-600 hover:border-primary-600",
    secondary: "checked:bg-secondary-600 checked:border-secondary-600 hover:border-secondary-600",
    success: "checked:bg-success-600 checked:border-success-600 hover:border-success-600",
    warning: "checked:bg-warning-600 checked:border-warning-600 hover:border-warning-600",
    error: "checked:bg-danger-600 checked:border-danger-600 hover:border-danger-600"
  }, f = e ? "border-danger-600 hover:border-danger-700" : "", h = fr(
    "border-2 transition-colors duration-200",
    "appearance-none cursor-pointer",
    "checked:bg-no-repeat checked:bg-center",
    s === "circle" ? 'checked:bg-[url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI2IiBjeT0iNiIgcj0iNCIgZmlsbD0id2hpdGUiLz48L3N2Zz4=")]' : 'checked:bg-[url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTAgM0w0LjUgOC41TDIgNiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=")]',
    {
      square: "rounded",
      circle: "rounded-full"
    }[s],
    c[o],
    u[i],
    f,
    r && "opacity-50 cursor-not-allowed",
    a
  ), g = fr(
    "ml-2 text-sm font-medium",
    r && "opacity-50 cursor-not-allowed",
    e && "text-danger-600"
  );
  return /* @__PURE__ */ m.jsxs("div", { className: "items-center", children: [
    /* @__PURE__ */ m.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ m.jsx(
        "input",
        {
          type: "checkbox",
          className: h,
          disabled: r,
          ref: (b) => {
            typeof d == "function" ? d(b) : d && (d.current = b), b && (b.indeterminate = n);
          },
          ...l
        }
      ),
      t && /* @__PURE__ */ m.jsx("label", { className: g, children: t })
    ] }),
    e && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-sm text-danger-600", children: e })
  ] });
});
Ds.displayName = "Checkbox";
const ka = ct(
  "flex flex-col",
  {
    variants: {
      layout: {
        vertical: "flex-col",
        horizontal: "flex-row flex-wrap",
        grid: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"
      },
      size: {
        sm: "gap-1",
        md: "gap-2",
        lg: "gap-3"
      }
    },
    defaultVariants: {
      layout: "vertical",
      size: "md"
    }
  }
), fb = Oe(
  ({
    className: t,
    options: e = [],
    value: r,
    defaultValue: n = [],
    onChange: o,
    layout: s = "vertical",
    size: i = "md",
    error: a = !1,
    errorText: l,
    helperText: d,
    label: c,
    required: u = !1,
    labelPlacement: f = "top",
    fullWidth: p = !1,
    disabled: h = !1,
    variant: g = "square",
    color: b = "primary",
    checkboxSize: y = "sm",
    showSelectAll: $ = !1,
    selectAllText: k = "Select All",
    indeterminateSelectAll: w = !0,
    gap: C,
    selectAllGap: T,
    name: H,
    id: O,
    ...j
  }, F) => {
    const v = O || le.useId(), M = `${v}-helper`, E = `${v}-error`, N = `${v}-group`, [R, x] = le.useState(n), P = r !== void 0 ? r : R, I = (W, ie) => {
      const pe = ie ? [...P, W] : P.filter((ye) => ye !== W);
      r === void 0 && x(pe), o == null || o(pe);
    }, D = (W) => {
      const ie = W ? e.map((pe) => pe.value) : [];
      r === void 0 && x(ie), o == null || o(ie);
    }, L = e.length > 0 && P.length === e.length, A = P.length > 0 && P.length < e.length, z = w && A, Y = (W) => W === "none" ? "gap-0" : W === "xs" ? "gap-1" : W === "sm" ? "gap-2" : W === "md" ? "gap-3" : W === "lg" ? "gap-4" : W === "xl" ? "gap-6" : null, q = Y(C), ee = Y(T), B = /* @__PURE__ */ m.jsx("div", { className: V("relative", !p && "inline-block"), children: /* @__PURE__ */ m.jsxs(
      "fieldset",
      {
        ref: F,
        id: N,
        name: H,
        className: V(
          ka({ layout: s, size: i }),
          q,
          t
        ),
        "aria-describedby": a ? E : d ? M : void 0,
        "aria-invalid": a,
        "aria-required": u,
        ...j,
        children: [
          $ && e.length > 0 && /* @__PURE__ */ m.jsxs("div", { className: V(
            "flex flex-col",
            ee || q || ka({ layout: "vertical", size: i })
          ), children: [
            /* @__PURE__ */ m.jsx(
              Ds,
              {
                label: k,
                checked: L,
                indeterminate: z,
                onChange: (W) => D(W.target.checked),
                disabled: h,
                variant: g,
                color: a ? "error" : b,
                variantSize: y,
                error: a ? " " : void 0
              }
            ),
            /* @__PURE__ */ m.jsx("div", { className: V(
              "flex",
              s === "vertical" && "flex-col",
              s === "horizontal" && "flex-row flex-wrap",
              s === "grid" && "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3",
              q || ka({ layout: s, size: i })
            ), children: e.map((W) => /* @__PURE__ */ m.jsx(
              Ds,
              {
                label: W.label,
                checked: P.includes(W.value),
                onChange: (ie) => I(W.value, ie.target.checked),
                disabled: h || W.disabled,
                indeterminate: W.indeterminate,
                variant: g,
                color: a ? "error" : b,
                variantSize: y,
                error: a ? " " : void 0
              },
              W.value
            )) })
          ] }),
          !$ && /* @__PURE__ */ m.jsx(m.Fragment, { children: e.map((W) => /* @__PURE__ */ m.jsx(
            Ds,
            {
              label: W.label,
              checked: P.includes(W.value),
              onChange: (ie) => I(W.value, ie.target.checked),
              disabled: h || W.disabled,
              indeterminate: W.indeterminate,
              variant: g,
              color: a ? "error" : b,
              variantSize: y,
              error: a ? " " : void 0
            },
            W.value
          )) })
        ]
      }
    ) }), _ = /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      a && l && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", id: E, children: l }),
      !a && d && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", id: M, children: d })
    ] });
    return f === "left" ? /* @__PURE__ */ m.jsx("div", { className: V(p ? "w-full" : "inline-block", t), children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-start gap-4", children: [
      c && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: N,
          className: "block text-sm text-neutral-900 pt-2",
          children: [
            c,
            u && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ m.jsxs("div", { className: V("flex-1", !p && "inline-block"), children: [
        B,
        _
      ] })
    ] }) }) : /* @__PURE__ */ m.jsxs("div", { className: V(p ? "w-full" : "inline-block", t), children: [
      c && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: N,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            c,
            u && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      B,
      _
    ] });
  }
);
fb.displayName = "CheckBoxGroup";
const pb = {
  solid: {
    primary: "bg-primary text-white",
    success: "bg-success text-white",
    warning: "bg-warning text-white",
    error: "bg-danger text-white",
    info: "bg-info text-white",
    danger: "bg-danger text-white",
    default: "bg-neutral text-white"
  },
  outline: {
    primary: "border border-primary text-primary",
    success: "border border-success text-success",
    warning: "border border-warning text-warning",
    error: "border border-error text-error",
    info: "border border-info text-info",
    danger: "border border-danger text-danger",
    default: "border border-neutral text-neutral"
  },
  subtle: {
    primary: "bg-primary-100 text-primary-700",
    success: "bg-success-100 text-success-700",
    warning: "bg-warning-100 text-warning-700",
    error: "bg-error-100 text-error-700",
    info: "bg-info-100 text-info-700",
    danger: "bg-danger-100 text-danger-700",
    default: "bg-neutral-100 text-neutral-700"
  },
  soft: {
    primary: "bg-primary-50 text-primary-600",
    success: "bg-success-50 text-success-600",
    warning: "bg-warning-50 text-warning-600",
    error: "bg-error-50 text-error-600",
    info: "bg-info-50 text-info-600",
    danger: "bg-danger-50 text-danger-600",
    default: "bg-neutral-50 text-neutral-600"
  }
}, hb = {
  sm: "text-xs px-2 py-0.5",
  md: "text-sm px-3 py-1",
  lg: "text-base px-4 py-1.5"
}, mb = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  xl: "rounded-xl",
  "2xl": "rounded-2xl",
  "3xl": "rounded-3xl",
  full: "rounded-full"
}, B7 = ({
  children: t,
  variant: e = "solid",
  color: r = "primary",
  size: n = "md",
  rounded: o = "xl",
  onClose: s,
  className: i,
  icon: a
}) => /* @__PURE__ */ m.jsxs(
  "div",
  {
    className: V(
      "inline-flex items-center gap-1.5 font-medium",
      pb[e][r],
      hb[n],
      mb[o],
      i
    ),
    children: [
      a && /* @__PURE__ */ m.jsx("span", { className: "inline-flex items-center", children: /* @__PURE__ */ m.jsx($e, { icon: a, className: "w-4 h-4" }) }),
      t,
      s && /* @__PURE__ */ m.jsx(
        "button",
        {
          onClick: s,
          className: "ml-1 rounded-full hover:bg-black/10 p-0.5",
          "aria-label": "Close",
          children: /* @__PURE__ */ m.jsx($e, { icon: "mdi:close", className: "w-3 h-3" })
        }
      )
    ]
  }
);
var Dp = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(Sp, function() {
    return function(r, n) {
      n.prototype.isSameOrAfter = function(o, s) {
        return this.isSame(o, s) || this.isAfter(o, s);
      };
    };
  });
})(Dp);
var gb = Dp.exports;
const bb = /* @__PURE__ */ Np(gb);
var _p = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(Sp, function() {
    return function(r, n) {
      n.prototype.isSameOrBefore = function(o, s) {
        return this.isSame(o, s) || this.isBefore(o, s);
      };
    };
  });
})(_p);
var yb = _p.exports;
const vb = /* @__PURE__ */ Np(yb);
_e.extend(bb);
_e.extend(vb);
const $b = ct(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "xl",
      fullWidth: !0
    }
  }
), cl = Oe(
  ({
    value: t,
    onChange: e,
    minDate: r,
    maxDate: n,
    variant: o = "default",
    size: s = "md",
    rounded: i = "xl",
    disabled: a = !1,
    error: l = !1,
    errorText: d,
    helperText: c,
    label: u,
    required: f = !1,
    labelPlacement: p = "top",
    fullWidth: h = !1,
    className: g,
    placeholder: b = "Select date",
    leftIcon: y,
    rightIcon: $,
    monthsToShow: k = 1,
    valueFormatter: w,
    rangeStart: C,
    rangeEnd: T,
    closeOnSelect: H = !0,
    calendarFooter: O,
    format: j = "DD-MM-YYYY",
    allowInput: F = !1,
    ...v
  }, M) => {
    const [E, N] = de(!1), [R, x] = de(t), [P, I] = de(t || /* @__PURE__ */ new Date()), [D, L] = de(!1), [A, z] = de(""), Y = te(null), q = te(null), ee = te(null), B = te(null), _ = te(null);
    In(M, () => _.current, []), me(() => {
      x(t || void 0), z(t ? W(t, j) : "");
    }, [t, j]), me(() => {
      z(R ? W(R, j) : "");
    }, [R, j]);
    const W = (oe, Me) => {
      const se = oe.getDate().toString().padStart(2, "0"), Z = (oe.getMonth() + 1).toString().padStart(2, "0"), G = oe.getFullYear().toString();
      switch (Me) {
        case "DD-MM-YYYY":
          return `${se}-${Z}-${G}`;
        case "YYYY-MM-DD":
          return `${G}-${Z}-${se}`;
        case "MM-DD-YYYY":
          return `${Z}-${se}-${G}`;
        default:
          return `${se}-${Z}-${G}`;
      }
    }, ie = (oe, Me) => {
      const Z = oe.replace(/[^\d-]/g, "").split("-");
      if (Z.length !== 3) return null;
      let G, ae, ce;
      switch (Me) {
        case "DD-MM-YYYY":
          [G, ae, ce] = Z.map(Number);
          break;
        case "YYYY-MM-DD":
          [ce, ae, G] = Z.map(Number);
          break;
        case "MM-DD-YYYY":
          [ae, G, ce] = Z.map(Number);
          break;
        default:
          [G, ae, ce] = Z.map(Number);
      }
      if (isNaN(G) || isNaN(ae) || isNaN(ce) || ae < 1 || ae > 12 || G < 1 || G > 31 || ce < 1900 || ce > 2099) return null;
      const ke = new Date(ce, ae - 1, G);
      return ke.getDate() !== G || ke.getMonth() !== ae - 1 || ke.getFullYear() !== ce ? null : ke;
    };
    me(() => {
      if (D && B.current) {
        const oe = _e(P).year(), Me = B.current.querySelectorAll("[data-year]"), se = Array.from(Me).find(
          (Z) => parseInt(Z.getAttribute("data-year") || "0") === oe
        );
        se && se.scrollIntoView({
          behavior: "auto",
          block: "center",
          inline: "center"
        });
      }
    }, [D, P]);
    const pe = () => {
      if (!E || !q.current || !ee.current) return;
      const { bottom: oe, left: Me, width: se, top: Z } = q.current.getBoundingClientRect(), G = ee.current, ae = Ir(), ce = ae.innerHeight - oe, ke = Z, Dt = ce < (k === 2 ? 400 : 350), Wt = ke > ce, vr = Dt && Wt;
      k === 2 ? (Object.assign(G.style, {
        position: "fixed",
        left: `${Me}px`,
        minWidth: "500px",
        width: "auto",
        transform: ""
      }), vr ? Object.assign(G.style, {
        bottom: `${ae.innerHeight - Z + 4}px`,
        top: "auto",
        maxHeight: `${ke - 8}px`
      }) : Object.assign(G.style, {
        top: `${oe + 4}px`,
        bottom: "auto",
        maxHeight: `${ce - 8}px`
      })) : (Object.assign(G.style, {
        position: "fixed",
        left: `${Me + se / 2}px`,
        width: "320px",
        maxWidth: "100vw",
        transform: "translateX(-50%)"
      }), vr ? Object.assign(G.style, {
        bottom: `${ae.innerHeight - Z + 4}px`,
        top: "auto",
        maxHeight: `${ke - 8}px`
      }) : Object.assign(G.style, {
        top: `${oe + 4}px`,
        bottom: "auto",
        maxHeight: `${ce - 8}px`
      }));
    };
    me(() => {
      const oe = Ir(), Me = wt(), se = () => {
        E && pe();
      }, Z = () => {
        E && pe();
      }, G = (ae) => {
        ae.key === "Escape" && E && (N(!1), L(!1));
      };
      return E && (pe(), oe.addEventListener("scroll", se, !0), oe.addEventListener("resize", Z), Me.addEventListener("keydown", G)), () => {
        oe.removeEventListener("scroll", se, !0), oe.removeEventListener("resize", Z), Me.removeEventListener("keydown", G);
      };
    }, [E]);
    const ye = (oe) => {
      if (C !== void 0 || T !== void 0)
        if (C && T)
          x(oe), z(W(oe, j)), e == null || e(oe);
        else if (C) {
          const se = oe;
          _e(se).isBefore(C), x(se), z(W(se, j)), e == null || e(se), N(!1), L(!1);
        } else
          x(oe), z(W(oe, j)), e == null || e(oe);
      else
        x(oe), z(W(oe, j)), e == null || e(oe), H && (N(!1), L(!1));
    }, Ce = () => {
      I(_e(P).subtract(1, "month").toDate());
    }, Be = () => {
      I(_e(P).add(1, "month").toDate());
    }, je = (oe) => {
      const Me = _e(oe).startOf("month"), se = _e(oe).endOf("month"), Z = [];
      let G = Me;
      for (; G.isBefore(se) || G.isSame(se, "day"); )
        Z.push(G.toDate()), G = G.add(1, "day");
      return Z;
    }, ut = (oe) => !!(r && _e(oe).isBefore(r, "day") || n && _e(oe).isAfter(n, "day")), Fe = (oe) => {
      if (!F) return;
      const se = oe.target.value.replace(/[^\d-]/g, "");
      if (se.length < A.length) {
        z(se);
        return;
      }
      if (se.replace(/-/g, "").length > 8)
        return;
      let G = se;
      j === "DD-MM-YYYY" ? (se.length === 2 && !se.includes("-") || se.length === 5 && se.split("-").length === 2) && (G = se + "-") : j === "YYYY-MM-DD" ? (se.length === 4 && !se.includes("-") || se.length === 7 && se.split("-").length === 2) && (G = se + "-") : j === "MM-DD-YYYY" && (se.length === 2 && !se.includes("-") || se.length === 5 && se.split("-").length === 2) && (G = se + "-"), z(G);
    }, vt = () => {
      if (!F) return;
      const oe = ie(A, j);
      if (oe) {
        if (r && oe < r) {
          z(W(r, j)), x(r), e == null || e(r);
          return;
        }
        if (n && oe > n) {
          z(W(n, j)), x(n), e == null || e(n);
          return;
        }
        x(oe), e == null || e(oe), z(W(oe, j));
      } else
        z(R ? W(R, j) : "");
    }, et = () => {
      F && N(!1);
    }, Vt = (oe) => {
      F && oe.key === "Enter" && (oe.preventDefault(), vt());
    }, Pt = (oe) => {
      const Me = _e(P).year(oe).toDate();
      I(Me), L(!1);
    }, Tt = () => {
      if (!D) return null;
      const oe = _e(P).year(), Me = 1900, Z = Array.from(
        { length: 2099 - Me + 1 },
        (G, ae) => Me + ae
      );
      return /* @__PURE__ */ m.jsx(
        "div",
        {
          ref: B,
          className: "grid grid-cols-5 gap-2 p-2 overflow-y-auto max-h-[300px]",
          children: Z.map((G) => /* @__PURE__ */ m.jsx(
            "div",
            {
              "data-year": G,
              onClick: () => Pt(G),
              className: V(
                G === oe && "bg-primary-50 text-primary",
                "text-sm cursor-pointer p-2"
              ),
              children: G
            },
            G
          ))
        }
      );
    }, at = () => {
      if (!E) return null;
      const oe = wt();
      if (!("body" in oe)) return null;
      const Me = Array.from({ length: k }).map(
        (se, Z) => _e(P).add(Z, "month").toDate()
      );
      return Rn(
        /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: "fixed inset-0 z-[9998]",
              onClick: () => {
                D || N(!1);
              }
            }
          ),
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              ref: ee,
              className: "fixed z-[9999] bg-white border border-gray-200 rounded-md shadow-lg",
              onClick: (se) => se.stopPropagation(),
              children: [
                /* @__PURE__ */ m.jsxs("div", { className: "flex items-center justify-between p-2 border-b border-gray-200", children: [
                  /* @__PURE__ */ m.jsx(
                    kt,
                    {
                      onClick: Ce,
                      variant: "ghost",
                      size: "sm",
                      leftIcon: "mdi:chevron-left"
                    }
                  ),
                  /* @__PURE__ */ m.jsx("div", { className: "relative", children: /* @__PURE__ */ m.jsx("span", { className: "font-medium text-gray-900", children: k === 1 ? /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2", children: [
                    /* @__PURE__ */ m.jsx("span", { children: _e(P).format("MMMM") }),
                    /* @__PURE__ */ m.jsxs(
                      "div",
                      {
                        className: "cursor-pointer flex items-center gap-1",
                        onClick: () => L(!D),
                        children: [
                          /* @__PURE__ */ m.jsx("span", { children: _e(P).format("YYYY") }),
                          /* @__PURE__ */ m.jsx(kt, { variant: "ghost", size: "sm", leftIcon: D ? "mdi:chevron-up" : "mdi:chevron-down" })
                        ]
                      }
                    )
                  ] }) : `${_e(P).format("MMMM YYYY")} - ${_e(
                    P
                  ).add(k - 1, "month").format("MMMM YYYY")}` }) }),
                  /* @__PURE__ */ m.jsx(
                    kt,
                    {
                      onClick: Be,
                      variant: "ghost",
                      size: "sm",
                      rightIcon: "mdi:chevron-right"
                    }
                  )
                ] }),
                D ? Tt() : /* @__PURE__ */ m.jsx(
                  "div",
                  {
                    className: V(
                      k === 2 ? "flex gap-5 p-2 mx-auto w-fit" : "justify-between p-2 mx-auto w-fit"
                    ),
                    children: Me.map((se, Z) => {
                      const G = je(se), ae = _e(se).startOf("month").day();
                      return /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col", children: [
                        /* @__PURE__ */ m.jsxs("div", { className: "grid grid-cols-7 gap-y-1 my-1", children: [
                          ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map(
                            (ce, ke) => {
                              const ft = ke === 0 || ke === 6;
                              return /* @__PURE__ */ m.jsx(
                                "div",
                                {
                                  className: V(
                                    "text-center text-xs font-medium text-neutral",
                                    ft && "text-danger"
                                  ),
                                  children: ce
                                },
                                ce
                              );
                            }
                          ),
                          Array.from({ length: ae }).map(
                            (ce, ke) => /* @__PURE__ */ m.jsx("div", {}, `empty-${ke}`)
                          ),
                          G.map((ce) => {
                            const ke = R && _e(ce).isSame(R, "day"), ft = ut(ce), Dt = _e(ce).isSame(
                              se,
                              "month"
                            ), Wt = C && T && _e(ce).isSameOrAfter(C, "day") && _e(ce).isSameOrBefore(T, "day"), vr = C && _e(ce).isSame(C, "day"), jn = T && _e(ce).isSame(T, "day"), sn = _e(ce).day() === 0 || _e(ce).day() === 6, sr = C && T;
                            return /* @__PURE__ */ m.jsx("div", { className: "flex flex-col items-center justify-center", children: /* @__PURE__ */ m.jsx(
                              "div",
                              {
                                className: V(
                                  Wt && "rounded-none bg-primary-50",
                                  sr && vr && "rounded-l-full",
                                  sr && jn && "rounded-r-full"
                                ),
                                children: /* @__PURE__ */ m.jsx(
                                  "button",
                                  {
                                    onClick: () => !ft && ye(ce),
                                    disabled: ft,
                                    className: V(
                                      "p-2 text-sm transition-colors duration-200 w-10 h-10 rounded-full",
                                      sn && "!text-danger",
                                      ke && "bg-primary !text-white hover:bg-primary-600 active:bg-primary-700",
                                      ke && !sr && "rounded-full",
                                      !ke && !ft && "hover:bg-primary-50 active:bg-primary-100",
                                      !Dt && "text-neutral-400",
                                      ft && "opacity-50 cursor-not-allowed",
                                      // inRange && "bg-primary-50 text-primary-900 rounded-none",
                                      sr && vr && "!bg-primary !text-white !rounded-full",
                                      sr && jn && "!bg-primary !text-white !rounded-full"
                                    ),
                                    children: _e(ce).format("D")
                                  },
                                  ce.toString()
                                )
                              }
                            ) });
                          })
                        ] }),
                        O
                      ] }, Z);
                    })
                  }
                )
              ]
            }
          )
        ] }),
        oe.body
      );
    }, br = /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: V("relative", !h && "inline-block"),
        ref: q,
        onClick: () => !a && !F && N(!E),
        children: [
          y && /* @__PURE__ */ m.jsx(
            "div",
            {
              className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral cursor-pointer hover:text-primary transition-colors",
              onClick: (oe) => {
                oe.stopPropagation(), a || N(!E);
              },
              children: /* @__PURE__ */ m.jsx($e, { icon: y, className: "w-4 h-4" })
            }
          ),
          /* @__PURE__ */ m.jsx(
            "input",
            {
              ref: _,
              type: "text",
              value: F ? A : w ? w() : R ? W(R, j) : "",
              placeholder: F ? j : b,
              readOnly: !F,
              maxLength: F ? 10 : void 0,
              onChange: Fe,
              onBlur: vt,
              onFocus: et,
              onKeyDown: Vt,
              className: V(
                $b({ variant: l ? "error" : o, size: s, rounded: i, fullWidth: h }),
                y && "pl-10",
                $ && "pr-10",
                g
              ),
              disabled: a,
              ...v
            }
          ),
          $ && /* @__PURE__ */ m.jsx(
            "div",
            {
              className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral cursor-pointer hover:text-primary transition-colors",
              onClick: (oe) => {
                oe.stopPropagation(), a || N(!E);
              },
              children: /* @__PURE__ */ m.jsx($e, { icon: $, className: "w-4 h-4" })
            }
          )
        ]
      }
    ), yr = /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      d && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", children: d }),
      !d && c && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", children: c })
    ] });
    return p === "left" ? /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: V(h ? "w-full" : "inline-block", g),
        ref: Y,
        children: [
          /* @__PURE__ */ m.jsxs("div", { className: "flex items-start gap-4", children: [
            u && /* @__PURE__ */ m.jsxs("label", { className: "block text-sm text-neutral-900 pt-2", children: [
              u,
              f && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
            ] }),
            /* @__PURE__ */ m.jsxs("div", { className: V("flex-1", !h && "inline-block"), children: [
              br,
              yr
            ] })
          ] }),
          at()
        ]
      }
    ) : /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: V(h ? "w-full" : "inline-block", g),
        ref: Y,
        children: [
          u && /* @__PURE__ */ m.jsxs("label", { className: "mb-1.5 block text-sm text-neutral-900", children: [
            u,
            f && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ] }),
          br,
          yr,
          at()
        ]
      }
    );
  }
);
cl.displayName = "PrimitiveDatePicker";
const xb = Oe(
  ({
    mode: t = "single",
    value: e,
    onChange: r,
    monthsToShow: n = 1,
    calendarFooter: o,
    error: s = !1,
    errorText: i,
    format: a = "DD-MM-YYYY",
    allowInput: l = !1,
    ...d
  }, c) => {
    const [u, f] = de([
      void 0,
      void 0
    ]);
    if (t === "single") {
      const p = Array.isArray(e) ? e[0] : e;
      return /* @__PURE__ */ m.jsx(
        cl,
        {
          ref: c,
          value: p === null ? void 0 : p,
          onChange: (h) => r == null ? void 0 : r(h),
          monthsToShow: n,
          calendarFooter: o,
          error: s,
          errorText: i,
          format: a,
          allowInput: l,
          ...d
        }
      );
    }
    if (t === "range") {
      let [p, h] = Array.isArray(e) ? e : u;
      const g = (y) => {
        !p || p && h ? (f([y, void 0]), r == null || r([y, void 0])) : p && !h && (y < p ? (f([y, p]), r == null || r([y, p])) : (f([p, y]), r == null || r([p, y])));
      }, b = () => {
        if (!p) return "";
        const y = ($) => $ ? $.toLocaleDateString("en-GB", {
          day: "2-digit",
          month: "short",
          year: "numeric"
        }) : "";
        return p && h ? `${y(p)} - ${y(h)}` : y(p);
      };
      return /* @__PURE__ */ m.jsx(
        cl,
        {
          ref: c,
          value: p,
          onChange: g,
          monthsToShow: n,
          placeholder: d.placeholder || "Select date range",
          valueFormatter: b,
          rangeStart: p,
          rangeEnd: h,
          closeOnSelect: !!h,
          calendarFooter: o,
          error: s,
          errorText: i,
          format: a,
          allowInput: l,
          ...d
        }
      );
    }
    return null;
  }
);
xb.displayName = "DatePicker";
const Fp = Oe(
  ({ children: t, onClose: e, className: r, ...n }, o) => /* @__PURE__ */ m.jsxs(
    "div",
    {
      ref: o,
      className: V("mb-4 flex items-center justify-between", r),
      ...n,
      children: [
        /* @__PURE__ */ m.jsx("div", { className: "flex-1", children: t }),
        e && /* @__PURE__ */ m.jsx(
          "button",
          {
            onClick: e,
            className: "rounded-full p-1 text-gray hover:bg-gray-100 hover:text-gray-700",
            "aria-label": "Close dialog",
            children: /* @__PURE__ */ m.jsx($e, { icon: "mdi:close", className: "h-5 w-5" })
          }
        )
      ]
    }
  )
), Vc = {
  sm: "max-w-sm",
  md: "max-w-md",
  lg: "max-w-lg",
  // Historically `xl` used a larger cap; keep behavior for backward compatibility
  xl: "max-w-4xl",
  "2xl": "max-w-5xl",
  "3xl": "max-w-6xl",
  "4xl": "max-w-7xl",
  // Tailwind default stops at 7xl; for 5xl we use an explicit size
  "5xl": "max-w-[96rem]",
  fullscreen: "w-full h-full max-w-none max-h-none rounded-none"
}, wb = {
  sm: "w-64",
  // 16rem
  md: "w-80",
  // 20rem
  lg: "w-96",
  // 24rem
  xl: "w-[32rem]",
  "2xl": "w-[36rem]",
  "3xl": "w-[42rem]",
  "4xl": "w-[48rem]",
  "5xl": "w-[56rem]",
  fullscreen: "w-full"
}, kb = Oe(
  ({
    isOpen: t,
    onClose: e,
    children: r,
    className: n,
    backdrop: o = "dark",
    header: s,
    closeOnBackdropClick: i = !0,
    size: a = "md",
    sizeClassName: l,
    rounded: d = "xl",
    position: c = "center",
    scrollBehavior: u = "normal",
    animationDuration: f = 300,
    animationDelay: p = 0,
    ...h
  }, g) => {
    const [b, y] = de(t), [$, k] = de(!1), w = te(!1);
    if (kp(() => {
      if (t) {
        y(!0), k(!1);
        const M = wt();
        "body" in M && (u !== "outside" ? (M.body.style.overflow = "hidden", w.current = !0) : w.current = !1);
        const E = requestAnimationFrame(() => k(!0));
        return () => cancelAnimationFrame(E);
      }
      k(!1);
      const v = setTimeout(() => {
        y(!1);
        const M = wt();
        "body" in M && w.current && (M.body.style.overflow = "", w.current = !1);
      }, f + p);
      return () => clearTimeout(v);
    }, [t, u, f, p]), me(() => {
      const v = (M) => {
        M instanceof KeyboardEvent && M.key === "Escape" && e();
      };
      return t && wt().addEventListener("keydown", v), () => {
        wt().removeEventListener("keydown", v);
      };
    }, [t, e]), !b) return null;
    const C = {
      blur: "backdrop-blur-sm bg-black/30",
      dark: "bg-black/50",
      transparent: "bg-transparent"
    }, T = () => {
      i && e();
    }, H = wt();
    if (!("body" in H)) return null;
    const O = (v) => {
      switch (v) {
        case "none":
          return "rounded-none";
        case "sm":
          return "rounded-sm";
        case "md":
          return "rounded-md";
        case "lg":
          return "rounded-lg";
        case "xl":
          return "rounded-xl";
        case "2xl":
          return "rounded-2xl";
        case "3xl":
          return "rounded-3xl";
        case "full":
          return "rounded-full";
        default:
          return "rounded-lg";
      }
    }, j = (() => {
      if (u === "inside")
        return a === "fullscreen" || c === "left" || c === "right" ? "overflow-y-auto" : "max-h-screen overflow-y-auto";
    })(), F = {
      transitionDuration: `${f}ms`,
      transitionDelay: `${p}ms`
    };
    return Rn(
      /* @__PURE__ */ m.jsx(
        "div",
        {
          className: V(
            "fixed inset-0 z-50 flex transition-opacity",
            C[o],
            $ ? "opacity-100" : "opacity-0",
            c === "center" && "items-center justify-center",
            c === "top" && "items-start justify-center",
            c === "bottom" && "items-end justify-center",
            c === "left" && "items-stretch justify-start",
            c === "right" && "items-stretch justify-end"
          ),
          style: F,
          onClick: T,
          children: /* @__PURE__ */ m.jsxs(
            "div",
            {
              ref: g,
              className: V(
                "relative transform bg-white p-6 shadow-xl transition-all",
                // Width/Max-width behavior depends on position.
                // If `sizeClassName` is provided, it takes precedence except in fullscreen mode.
                a === "fullscreen" ? Vc.fullscreen : l ?? (c === "left" || c === "right" ? wb[a] : Vc[a]),
                // Position-based animations
                c === "center" && ($ ? "scale-100 opacity-100" : "scale-95 opacity-0"),
                c === "left" && ($ ? "translate-x-0 h-full" : "-translate-x-full h-full"),
                c === "right" && ($ ? "translate-x-0 h-full" : "translate-x-full h-full"),
                c === "top" && ($ ? "translate-y-0 opacity-100" : "-translate-y-full opacity-0"),
                c === "bottom" && ($ ? "translate-y-0 opacity-100" : "translate-y-full opacity-0"),
                n,
                a === "fullscreen" ? "rounded-none" : O(d),
                // Corner overrides so the edge touching the viewport is not rounded
                c === "left" && "rounded-l-none",
                c === "right" && "rounded-r-none",
                c === "top" && "rounded-t-none",
                c === "bottom" && "rounded-b-none",
                j
              ),
              style: F,
              onClick: (v) => v.stopPropagation(),
              ...h,
              children: [
                s && /* @__PURE__ */ m.jsx(Fp, { onClose: e, children: s }),
                r
              ]
            }
          )
        }
      ),
      H.body
    );
  }
), Eb = Oe(
  ({ children: t, className: e, ...r }, n) => /* @__PURE__ */ m.jsx(
    "h2",
    {
      ref: n,
      className: V("text-xl font-semibold text-gray-900", e),
      ...r,
      children: t
    }
  )
), Cb = Oe(
  ({ children: t, className: e, ...r }, n) => /* @__PURE__ */ m.jsx("div", { ref: n, className: V("text-gray-600", e), ...r, children: t })
), Sb = Oe(
  ({ children: t, className: e, ...r }, n) => /* @__PURE__ */ m.jsx(
    "div",
    {
      ref: n,
      className: V("mt-6 flex justify-end gap-3", e),
      ...r,
      children: t
    }
  )
);
kb.displayName = "Dialog";
Eb.displayName = "DialogTitle";
Cb.displayName = "DialogBody";
Sb.displayName = "DialogActions";
Fp.displayName = "DialogHeader";
const Nb = ({
  orientation: t = "horizontal",
  variant: e = "solid",
  color: r = "neutral",
  size: n = "sm",
  className: o = ""
}) => {
  const s = {
    horizontal: "w-full border-t-0 border-l-0 border-r-0 border-b",
    vertical: "h-full border-l border-t-0 border-r-0 border-b-0"
  }, i = {
    solid: "border-solid",
    dashed: "border-dashed",
    dotted: "border-dotted"
  }, a = {
    primary: "border-primary-300",
    secondary: "border-secondary-300",
    neutral: "border-neutral-300",
    success: "border-success-300",
    warning: "border-warning-300",
    error: "border-error-300"
  }, l = {
    sm: t === "horizontal" ? "border-b" : "border-l",
    md: t === "horizontal" ? "border-b-2" : "border-l-2",
    lg: t === "horizontal" ? "border-b-4" : "border-l-4"
  }, d = fr(
    "inline-block",
    s[t],
    i[e],
    a[r],
    l[n],
    o
  );
  return /* @__PURE__ */ m.jsx("div", { className: d });
}, Tb = {
  primary: {
    border: "border-primary-200",
    hover: "hover:border-primary-300",
    active: "border-primary-400",
    text: "text-primary-700",
    bg: "bg-primary-50"
  },
  secondary: {
    border: "border-secondary-200",
    hover: "hover:border-secondary-300",
    active: "border-secondary-400",
    text: "text-secondary-700",
    bg: "bg-secondary-50"
  },
  success: {
    border: "border-success-200",
    hover: "hover:border-success-300",
    active: "border-success-400",
    text: "text-success-700",
    bg: "bg-success-50"
  },
  warning: {
    border: "border-warning-200",
    hover: "hover:border-warning-300",
    active: "border-warning-400",
    text: "text-warning-700",
    bg: "bg-warning-50"
  },
  default: {
    border: "border-gray-200",
    hover: "hover:border-gray-300",
    active: "border-gray-400",
    text: "text-gray-700",
    bg: "bg-gray-50"
  },
  light: {
    border: "border-light-200",
    hover: "hover:border-light-300",
    active: "border-light-400",
    text: "text-light-900",
    bg: "bg-light-50"
  },
  dark: {
    border: "border-dark-200",
    hover: "hover:border-dark-300",
    active: "border-dark-400",
    text: "text-dark-50",
    bg: "bg-dark-50"
  },
  info: {
    border: "border-info-200",
    hover: "hover:border-info-300",
    active: "border-info-400",
    text: "text-info-700",
    bg: "bg-info-50"
  }
}, Ab = {
  none: "",
  sm: "shadow-sm",
  md: "shadow-md",
  lg: "shadow-lg",
  xl: "shadow-xl"
}, Wc = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  xl: "rounded-xl",
  full: "rounded-full"
}, Mb = Oe(({
  accept: t = ["*"],
  maxSize: e = 5 * 1024 * 1024,
  // 5MB default
  multiple: r = !1,
  value: n = [],
  onChange: o,
  className: s,
  disabled: i = !1,
  placeholder: a = "Drag and drop files here or click to browse",
  variant: l = "default",
  shadow: d = "none",
  rounded: c = "lg",
  children: u,
  showFileList: f = !0,
  showPlaceholder: p = !0,
  showMaxSize: h = !0,
  icon: g = "mdi:upload",
  name: b
}, y) => {
  const [$, k] = de(!1), [w, C] = de(null), T = te(null), H = te(null);
  In(y, () => T.current || H.current, []);
  const O = we((x) => {
    x.preventDefault(), i || k(!0);
  }, [i]), j = we((x) => {
    x.preventDefault(), k(!1);
  }, []), F = we((x) => x.size > e ? `File size exceeds ${e / (1024 * 1024)}MB limit` : t[0] !== "*" && !t.some((P) => P.startsWith(".") ? x.name.toLowerCase().endsWith(P.toLowerCase()) : x.type.startsWith(P)) ? `File type not allowed. Allowed types: ${t.join(", ")}` : null, [t, e]), v = we((x) => {
    if (x.preventDefault(), k(!1), C(null), i) return;
    const P = Array.from(x.dataTransfer.files), I = [], D = [];
    if (P.forEach((L) => {
      const A = F(L);
      A ? D.push(`${L.name}: ${A}`) : I.push(L);
    }), D.length > 0 && C(D.join(`
`)), I.length > 0) {
      const L = r ? [...n, ...I] : I;
      o == null || o(L);
    }
  }, [i, r, o, F, n]), M = we((x) => {
    if (C(null), i || !x.target.files) return;
    const P = Array.from(x.target.files), I = [], D = [];
    if (P.forEach((L) => {
      const A = F(L);
      A ? D.push(`${L.name}: ${A}`) : I.push(L);
    }), D.length > 0 && C(D.join(`
`)), I.length > 0) {
      const L = r ? [...n, ...I] : I;
      o == null || o(L);
    }
    T.current && (T.current.value = "");
  }, [i, r, o, F, n]), E = we((x) => {
    const P = [...n];
    P.splice(x, 1), o == null || o(P);
  }, [o, n]), N = (x) => x.type.startsWith("image/") ? /* @__PURE__ */ m.jsx($e, { icon: "mdi:image", className: "w-5 h-5" }) : x.type.startsWith("text/") ? /* @__PURE__ */ m.jsx($e, { icon: "mdi:file-document", className: "w-5 h-5" }) : /* @__PURE__ */ m.jsx($e, { icon: "mdi:file", className: "w-5 h-5" }), R = Tb[l];
  return /* @__PURE__ */ m.jsxs("div", { ref: H, className: Ne("w-full", s), children: [
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: Ne(
          "p-6 text-center transition-colors",
          !u && [
            "border-2 border-dashed",
            R.border,
            R.bg,
            $ && R.active,
            !i && R.hover
          ],
          i && "opacity-50 cursor-not-allowed",
          Ab[d],
          Wc[c],
          !u && "cursor-pointer"
        ),
        onDragOver: O,
        onDragLeave: j,
        onDrop: v,
        onClick: () => {
          var x;
          return !i && !u && ((x = T.current) == null ? void 0 : x.click());
        },
        children: [
          /* @__PURE__ */ m.jsx(
            "input",
            {
              ref: T,
              type: "file",
              accept: t.join(","),
              multiple: r,
              onChange: M,
              className: "hidden",
              disabled: i,
              name: b
            }
          ),
          u ? /* @__PURE__ */ m.jsx("div", { onClick: () => {
            var x;
            return !i && ((x = T.current) == null ? void 0 : x.click());
          }, children: u }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
            /* @__PURE__ */ m.jsx($e, { icon: g, className: "w-12 h-12 mx-auto mb-4 text-neutral-400" }),
            p && /* @__PURE__ */ m.jsx("p", { className: Ne("text-neutral-600", R.text), children: a }),
            h && /* @__PURE__ */ m.jsxs("p", { className: "text-sm text-neutral mt-2", children: [
              "Max file size: ",
              e / (1024 * 1024),
              "MB"
            ] })
          ] })
        ]
      }
    ),
    w && /* @__PURE__ */ m.jsx("p", { className: "mt-2 text-sm text-danger", children: w }),
    f && n.length > 0 && /* @__PURE__ */ m.jsx("div", { className: "mt-4 space-y-2", children: n.map((x, P) => /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: Ne(
          "flex items-center justify-between p-2",
          Wc[c],
          R.bg
        ),
        children: [
          /* @__PURE__ */ m.jsxs("div", { className: "flex items-center space-x-2", children: [
            N(x),
            /* @__PURE__ */ m.jsx("span", { className: Ne("text-sm", R.text), children: x.name }),
            /* @__PURE__ */ m.jsxs("span", { className: "text-xs text-neutral", children: [
              "(",
              (x.size / 1024).toFixed(1),
              " KB)"
            ] })
          ] }),
          !i && /* @__PURE__ */ m.jsx(
            "button",
            {
              onClick: () => E(P),
              className: "p-1 text-neutral hover:text-danger",
              children: /* @__PURE__ */ m.jsx($e, { icon: "mdi:close", className: "w-4 h-4" })
            }
          )
        ]
      },
      `${x.name}-${P}`
    )) })
  ] });
});
Mb.displayName = "FileUpload";
const Pb = ct(
  "flex items-start gap-3 p-4 shadow-sm",
  {
    variants: {
      variant: {
        default: "bg-white border border-neutral-200",
        primary: "bg-primary-50 border border-primary-200",
        success: "bg-success-50 border border-success-200",
        warning: "bg-warning-50 border border-warning-200",
        danger: "bg-danger-50 border border-danger-200",
        info: "bg-info-50 border border-info-200"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      rounded: "xl"
    }
  }
), V7 = ({
  title: t,
  children: e,
  icon: r,
  variant: n = "default",
  rounded: o = "xl",
  showClose: s = !1,
  onClose: i,
  className: a
}) => {
  const l = () => {
    switch (n) {
      case "primary":
        return "text-primary-600";
      case "success":
        return "text-success-600";
      case "warning":
        return "text-warning-600";
      case "danger":
        return "text-danger-600";
      case "info":
        return "text-info-600";
      default:
        return "text-neutral-600";
    }
  }, d = () => {
    if (r) return r;
    switch (n) {
      case "primary":
        return "mdi:information";
      case "success":
        return "mdi:check-circle";
      case "warning":
        return "mdi:alert";
      case "danger":
        return "mdi:alert-circle";
      case "info":
        return "mdi:information";
      default:
        return "mdi:information";
    }
  };
  return /* @__PURE__ */ m.jsxs("div", { className: V(Pb({ variant: n, rounded: o }), a), children: [
    r && /* @__PURE__ */ m.jsx($e, { icon: d(), className: V("h-5 w-5 flex-shrink-0", l()) }),
    /* @__PURE__ */ m.jsxs("div", { className: "flex-1", children: [
      t && /* @__PURE__ */ m.jsx("h3", { className: "text-sm font-medium text-neutral-900", children: t }),
      /* @__PURE__ */ m.jsx("div", { className: "mt-1 text-sm text-neutral", children: e })
    ] }),
    s && /* @__PURE__ */ m.jsx(
      "button",
      {
        type: "button",
        className: "ml-auto flex-shrink-0 text-neutral-400 hover:text-neutral",
        onClick: i,
        children: /* @__PURE__ */ m.jsx($e, { icon: "mdi:close", className: "h-5 w-5" })
      }
    )
  ] });
}, Ea = "select-dropdown-opened", Ib = ct(
  "rounded-md px-3 py-2 text-sm ring-0 transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50 bg-white",
        error: "border border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50 bg-white",
        success: "border border-success hover:border-success-600 focus:border-success-600 bg-white",
        ghost: "border-0 hover:bg-neutral-100 focus:bg-neutral-100 bg-transparent",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      fullWidth: !0,
      rounded: "xl"
    }
  }
), zp = Oe(
  ({
    className: t,
    variant: e = "default",
    size: r = "md",
    rounded: n = "xl",
    options: o,
    label: s,
    error: i = !1,
    errorText: a,
    helperText: l,
    required: d = !1,
    placeholder: c,
    value: u,
    onChange: f,
    disabled: p = !1,
    position: h = "bottom",
    fullWidth: g = !1,
    children: b,
    leftIcon: y,
    rightIcon: $,
    name: k,
    ...w
  }, C) => {
    const [T, H] = de(!1), O = te(null), j = te(null), F = te(null), v = te(null), E = `select-${le.useId().replace(/:/g, "")}`;
    In(C, () => F.current || v.current, []);
    const N = () => {
      if (T && O.current && j.current) {
        const L = O.current.getBoundingClientRect(), A = j.current, z = Ir(), Y = z.innerHeight - L.bottom, q = L.top, B = L.bottom + A.offsetHeight + 4 >= z.innerHeight, _ = q > Y, W = B && _;
        h === "bottom" || h === "top" ? (A.style.position = "fixed", A.style.left = `${L.left}px`, A.style.width = `${L.width}px`, h === "bottom" && W ? (A.style.bottom = `${z.innerHeight - L.top + 4}px`, A.style.top = "auto", A.style.maxHeight = `${q - 8}px`) : h === "bottom" ? (A.style.top = `${L.bottom + 4}px`, A.style.bottom = "auto", A.style.maxHeight = `${Y - 8}px`) : h === "top" && !W ? (A.style.top = `${L.bottom + 4}px`, A.style.bottom = "auto", A.style.maxHeight = `${Y - 8}px`) : (A.style.bottom = `${z.innerHeight - L.top + 4}px`, A.style.top = "auto", A.style.maxHeight = `${q - 8}px`)) : h === "left" ? (A.style.position = "fixed", A.style.right = `${z.innerWidth - L.left + 4}px`, A.style.top = `${L.top}px`, A.style.maxHeight = `${z.innerHeight - L.top - 8}px`) : h === "right" && (A.style.position = "fixed", A.style.left = `${L.right + 4}px`, A.style.top = `${L.top}px`, A.style.maxHeight = `${z.innerHeight - L.top - 8}px`);
      }
    };
    me(() => {
      const L = Ir(), A = () => {
        T && N();
      }, z = () => {
        T && N();
      };
      return T && (N(), L.addEventListener("scroll", A, !0), L.addEventListener("resize", z)), () => {
        L.removeEventListener("scroll", A, !0), L.removeEventListener("resize", z);
      };
    }, [T, h]), me(() => {
      F.current && u !== void 0 && (F.current.value = u);
    }, [u]), me(() => {
      const L = wt(), A = (Y) => {
        Y.detail.id !== E && H(!1);
      }, z = (Y) => {
        const q = Y.target, ee = O.current, B = j.current;
        ee && B && !ee.contains(q) && !B.contains(q) && H(!1);
      };
      return L.addEventListener(Ea, A), L.addEventListener("click", z), () => {
        L.removeEventListener(Ea, A), L.removeEventListener("click", z);
      };
    }, [E]);
    const R = () => {
      if (p) return;
      if (T) {
        H(!1);
        return;
      }
      wt().dispatchEvent(
        new CustomEvent(Ea, {
          detail: { id: E }
        })
      ), H(!0);
    }, x = () => {
      if (o) {
        const L = o.find((A) => A.value === u);
        return L == null ? void 0 : L.label;
      }
      if (b) {
        const A = to.toArray(b).find(
          (z) => Yn(z) && "value" in z.props && z.props.value === u
        );
        return Yn(A) ? A.props.children : null;
      }
      return null;
    }, P = (L) => {
      if (!p && (f == null || f(L), H(!1), F.current)) {
        F.current.value = L;
        const A = new Event("input", { bubbles: !0 });
        F.current.dispatchEvent(A);
      }
    }, I = () => o ? o.map((L) => /* @__PURE__ */ m.jsx(
      Ji,
      {
        value: L.value,
        disabled: L.disabled,
        selected: L.value === u,
        onClick: () => {
          L.onClick && L.onClick(L.value), P(L.value);
        },
        children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2", children: [
          L.icon,
          L.label
        ] })
      },
      L.value
    )) : b ? to.map(b, (L) => Yn(L) && "value" in L.props ? Yi(L, {
      selected: L.props.value === u,
      onClick: () => P(L.props.value)
    }) : null) : null, D = () => {
      if (!T || p) return null;
      const L = /* @__PURE__ */ m.jsx(
        "div",
        {
          ref: j,
          className: V(
            "fixed z-[9999] min-w-[8rem] border border-neutral-200 bg-white py-1 shadow-lg rounded-lg",
            h === "left" || h === "right" ? "w-max" : "w-full"
          ),
          onClick: (z) => z.stopPropagation(),
          style: {
            overflowY: "auto"
          },
          children: I()
        }
      ), A = wt();
      return "body" in A ? Rn(L, A.body) : null;
    };
    return /* @__PURE__ */ m.jsxs(
      "div",
      {
        ref: v,
        className: V(g ? "w-full" : "inline-block"),
        ...w,
        children: [
          /* @__PURE__ */ m.jsx(
            "input",
            {
              type: "hidden",
              ref: F,
              name: k,
              value: u || "",
              onChange: () => {
              }
            }
          ),
          s && /* @__PURE__ */ m.jsxs(
            "label",
            {
              htmlFor: E,
              className: "mb-1.5 block text-sm text-neutral-900",
              children: [
                s,
                d && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
              ]
            }
          ),
          /* @__PURE__ */ m.jsxs(
            "div",
            {
              className: V("relative", !g && "inline-block"),
              onClick: R,
              children: [
                /* @__PURE__ */ m.jsxs(
                  "button",
                  {
                    id: E,
                    ref: O,
                    type: "button",
                    className: V(
                      Ib({ variant: i ? "error" : e, size: r, rounded: n, fullWidth: g }),
                      "flex items-center justify-between",
                      p && "cursor-not-allowed opacity-50",
                      y && "pl-10",
                      $ && "pr-10",
                      t
                    ),
                    "aria-haspopup": "listbox",
                    "aria-expanded": T,
                    "aria-describedby": i ? `${E}-error` : l ? `${E}-helper` : void 0,
                    disabled: p,
                    children: [
                      y && /* @__PURE__ */ m.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral flex items-center", children: /* @__PURE__ */ m.jsx($e, { icon: y, className: "w-4 h-4" }) }),
                      /* @__PURE__ */ m.jsx("span", { className: "flex items-center gap-2 min-w-0 flex-1", children: /* @__PURE__ */ m.jsx("span", { className: V(
                        "truncate text-left",
                        x() ? "text-neutral-900" : "text-neutral"
                      ), children: x() || c }) }),
                      $ ? /* @__PURE__ */ m.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral flex items-center", children: /* @__PURE__ */ m.jsx($e, { icon: $, className: "w-4 h-4" }) }) : /* @__PURE__ */ m.jsx(
                        $e,
                        {
                          icon: "mdi:chevron-down",
                          className: V("transition-transform flex-shrink-0 ml-2 w-4 h-4", T && "rotate-180")
                        }
                      )
                    ]
                  }
                ),
                D()
              ]
            }
          ),
          i && a && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", id: `${E}-error`, children: a }),
          !i && l && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", id: `${E}-helper`, children: l })
        ]
      }
    );
  }
);
zp.displayName = "Select";
const Rb = ({
  currentPage: t,
  totalPages: e,
  totalData: r,
  onPageChange: n,
  siblingCount: o = 1,
  className: s,
  perPageOptions: i,
  perPage: a = 10,
  label: l = "",
  onPerPageChange: d
}) => {
  const c = (p, h) => {
    const g = h - p + 1;
    return Array.from({ length: g }, (b, y) => y + p);
  }, f = (() => {
    const p = o * 2 + 3, h = p + 2;
    if (e > h) {
      const g = Math.max(2, t - o), b = Math.min(e - 1, t + o);
      let y = c(g, b);
      const $ = g > 2, k = e - b > 1, w = p - (y.length + 1);
      if ($ && !k)
        y = [...c(g - w, g - 1), ...y];
      else if (!$ && k) {
        const C = c(b + 1, b + w);
        y = [...y, ...C];
      } else $ && k && (y = [...y]);
      return [1, ...y, e];
    }
    return c(1, e);
  })();
  return /* @__PURE__ */ m.jsxs(
    "nav",
    {
      className: Ne("flex items-center justify-between space-x-1", s),
      children: [
        /* @__PURE__ */ m.jsxs("div", { className: "hidden sm:block text-sm text-neutral-700", children: [
          /* @__PURE__ */ m.jsx("b", { children: `${t} - ${e}` }),
          " dari ",
          r,
          " ",
          l
        ] }),
        /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2", children: [
          i && i.length > 0 && /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2 mr-4", children: [
            /* @__PURE__ */ m.jsx("span", { className: "text-neutral-700 text-sm", children: "Menampilkan" }),
            /* @__PURE__ */ m.jsx(
              zp,
              {
                value: a == null ? void 0 : a.toString(),
                onChange: (p) => d && d(Number(p)),
                size: "sm",
                className: "w-16",
                fullWidth: !1,
                "aria-label": "Items per page",
                children: i.map((p) => /* @__PURE__ */ m.jsx(Ji, { value: p.toString(), children: p }, p))
              }
            ),
            /* @__PURE__ */ m.jsx("span", { className: "text-neutral-700 text-sm", children: "data per halaman" })
          ] }),
          /* @__PURE__ */ m.jsx(
            kt,
            {
              variant: "ghost",
              onClick: () => n(t - 1),
              disabled: t === 1,
              className: Ne(
                "px-3 py-1 rounded-md text-sm",
                t === 1 ? "text-gray-400 cursor-not-allowed" : "text-gray-700 hover:bg-gray-100"
              ),
              children: /* @__PURE__ */ m.jsx($e, { size: "18", icon: "mdi:chevron-left" })
            }
          ),
          f.map((p, h) => {
            const g = p === t, b = typeof p == "string" && p === "...";
            return /* @__PURE__ */ m.jsx(
              kt,
              {
                variant: "ghost",
                onClick: () => !b && n(p),
                className: Ne(
                  "px-3 py-1 rounded-md text-sm",
                  g ? "bg-primary text-white hover:bg-primary" : "text-gray-700",
                  b && "cursor-default"
                ),
                children: p
              },
              h
            );
          }),
          /* @__PURE__ */ m.jsx(
            kt,
            {
              variant: "ghost",
              onClick: () => n(t + 1),
              disabled: t === e,
              className: Ne(
                "px-3 py-1 rounded-md text-sm",
                t === e ? "text-gray-400 cursor-not-allowed" : "text-gray-700"
              ),
              children: /* @__PURE__ */ m.jsx($e, { size: "18", icon: "mdi:chevron-right" })
            }
          )
        ] })
      ]
    }
  );
}, Hp = Oe(({
  label: t,
  checked: e = !1,
  disabled: r = !1,
  onChange: n,
  name: o,
  value: s,
  error: i,
  color: a = "primary",
  variantSize: l = "sm",
  ...d
}, c) => {
  const u = (h) => {
    n == null || n(h.target.checked);
  }, f = {
    sm: "h-4 w-4 before:h-2 before:w-2",
    md: "h-5 w-5 before:h-2.5 before:w-2.5",
    lg: "h-6 w-6 before:h-3 before:w-3"
  }, p = {
    primary: "text-primary-600 checked:border-primary-600 hover:border-primary-600",
    secondary: "text-secondary-600 checked:border-secondary-600 hover:border-secondary-600",
    success: "text-success-600 checked:border-success-600 hover:border-success-600",
    warning: "text-warning-600 checked:border-warning-600 hover:border-warning-600",
    error: "text-danger-600 checked:border-danger-600 hover:border-danger-600"
  };
  return /* @__PURE__ */ m.jsxs(
    "label",
    {
      className: fr(
        "inline-flex items-center gap-2 cursor-pointer select-none",
        r && "opacity-60 cursor-not-allowed"
      ),
      children: [
        /* @__PURE__ */ m.jsx(
          "input",
          {
            type: "radio",
            name: o,
            value: s,
            checked: e,
            disabled: r,
            onChange: u,
            ref: c,
            ...d,
            className: fr(
              // Base control
              "appearance-none rounded-full border-2 bg-white shrink-0",
              // Center a pseudo-element dot
              "grid place-items-center",
              // Inner dot (smooth, perfectly centered)
              "before:content-[''] before:rounded-full before:bg-current before:scale-0",
              "before:transition-transform before:duration-150 before:ease-out",
              "checked:before:scale-100",
              // Sizes
              f[l],
              // Colors (currentColor + checked border color)
              p[a],
              e ? "" : i ? "border-danger-600" : "border-gray-300",
              !e && i && "hover:border-danger-700",
              // Focus only when keyboard navigating (prevents extra ring on click)
              "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-current"
            )
          }
        ),
        t && /* @__PURE__ */ m.jsx(
          "span",
          {
            className: fr(
              "text-sm font-medium leading-none",
              i && "text-danger-600"
            ),
            children: t
          }
        )
      ]
    }
  );
});
Hp.displayName = "Radio";
const Ob = ct(
  "flex flex-col",
  {
    variants: {
      layout: {
        vertical: "flex-col",
        horizontal: "flex-row flex-wrap",
        grid: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"
      },
      size: {
        sm: "gap-1",
        md: "gap-2",
        lg: "gap-3"
      }
    },
    defaultVariants: {
      layout: "vertical",
      size: "md"
    }
  }
), Lb = Oe(
  ({
    className: t,
    options: e = [],
    value: r,
    defaultValue: n,
    onChange: o,
    layout: s = "vertical",
    size: i = "md",
    error: a = !1,
    errorText: l,
    helperText: d,
    label: c,
    required: u = !1,
    labelPlacement: f = "top",
    fullWidth: p = !1,
    disabled: h = !1,
    name: g,
    gap: b,
    color: y = "primary",
    radioSize: $ = "sm",
    id: k,
    ...w
  }, C) => {
    const T = k || le.useId(), H = `${T}-helper`, O = `${T}-error`, j = `${T}-group`, F = g || `radio-group-${T}`, [v, M] = le.useState(n), E = r !== void 0 ? r : v, N = (D) => {
      r === void 0 && M(D), o == null || o(D);
    }, x = ((D) => D === "none" ? "gap-0" : D === "xs" ? "gap-1" : D === "sm" ? "gap-2" : D === "md" ? "gap-3" : D === "lg" ? "gap-4" : D === "xl" ? "gap-6" : null)(b), P = /* @__PURE__ */ m.jsx("div", { className: V("relative", !p && "inline-block"), children: /* @__PURE__ */ m.jsx(
      "fieldset",
      {
        ref: C,
        id: j,
        className: V(
          Ob({ layout: s, size: i }),
          x,
          t
        ),
        "aria-describedby": a ? O : d ? H : void 0,
        "aria-invalid": a,
        "aria-required": u,
        ...w,
        children: e.map((D) => /* @__PURE__ */ m.jsx(
          Hp,
          {
            label: D.label,
            checked: E === D.value,
            onChange: () => N(D.value),
            disabled: h || D.disabled,
            name: F,
            value: D.value,
            color: a ? "error" : y,
            error: a ? " " : void 0,
            variantSize: $
          },
          D.value
        ))
      }
    ) }), I = /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      a && l && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", id: O, children: l }),
      !a && d && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", id: H, children: d })
    ] });
    return f === "left" ? /* @__PURE__ */ m.jsx("div", { className: V(p ? "w-full" : "inline-block", t), children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-start gap-4", children: [
      c && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: j,
          className: "block text-sm text-neutral-900 pt-2",
          children: [
            c,
            u && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ m.jsxs("div", { className: V("flex-1", !p && "inline-block"), children: [
        P,
        I
      ] })
    ] }) }) : /* @__PURE__ */ m.jsxs("div", { className: V(p ? "w-full" : "inline-block", t), children: [
      c && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: j,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            c,
            u && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      P,
      I
    ] });
  }
);
Lb.displayName = "RadioGroup";
const Uc = ct("animate-pulse bg-neutral-200", {
  variants: {
    variant: {
      default: "bg-neutral-200",
      primary: "bg-primary-200",
      success: "bg-success-200",
      warning: "bg-warning-200",
      danger: "bg-danger-200",
      info: "bg-info-200"
    },
    rounded: {
      none: "rounded-none",
      sm: "rounded-sm",
      md: "rounded-md",
      lg: "rounded-lg",
      xl: "rounded-xl",
      "2xl": "rounded-2xl",
      "3xl": "rounded-3xl",
      full: "rounded-full"
    },
    fullWidth: {
      true: "w-full",
      false: "w-fit"
    },
    pulseVariant: {
      default: "",
      "left-to-right": "relative overflow-hidden"
    }
  },
  defaultVariants: {
    variant: "default",
    rounded: "md",
    fullWidth: !1,
    pulseVariant: "default"
  }
}), jb = ({
  width: t,
  height: e,
  variant: r = "default",
  rounded: n = "xl",
  fullWidth: o = !1,
  pulseVariant: s = "default",
  className: i
}) => s === "left-to-right" ? /* @__PURE__ */ m.jsxs("div", { className: "relative overflow-hidden", children: [
  /* @__PURE__ */ m.jsx(
    "div",
    {
      className: V(
        Uc({ variant: r, rounded: n, fullWidth: o, pulseVariant: "default" }),
        i
      ),
      style: {
        width: !o && typeof t == "number" ? `${t}px` : t,
        height: typeof e == "number" ? `${e}px` : e
      }
    }
  ),
  /* @__PURE__ */ m.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/80 to-transparent animate-pulse-left-to-right pointer-events-none" })
] }) : /* @__PURE__ */ m.jsx(
  "div",
  {
    className: V(
      Uc({ variant: r, rounded: n, fullWidth: o, pulseVariant: s }),
      i
    ),
    style: {
      width: !o && typeof t == "number" ? `${t}px` : t,
      height: typeof e == "number" ? `${e}px` : e
    }
  }
), Db = Oe(({
  min: t = 0,
  max: e = 100,
  step: r = 1,
  value: n,
  defaultValue: o = t,
  onChange: s,
  className: i,
  disabled: a = !1,
  showValue: l = !1,
  marks: d = [],
  range: c = !1,
  name: u,
  ...f
}, p) => {
  const h = c, [g, b] = de(
    n !== void 0 ? n : o !== void 0 ? o : h ? [t, e] : t
  ), [y, $] = de(null), k = te(null), w = te(null), C = te(null);
  le.useImperativeHandle(p, () => w.current || C.current, []);
  const T = n !== void 0 ? n : g, [H, O] = h ? Array.isArray(T) ? T : [t, e] : [typeof T == "number" ? T : t, e], j = (A) => Math.min(Math.max(A, t), e), F = (A) => {
    if (a) return;
    let z;
    if (h && Array.isArray(A) ? z = [j(A[0]), j(A[1])] : !h && typeof A == "number" ? z = j(A) : z = h ? [t, e] : t, n === void 0 && b(z), s == null || s(z), w.current) {
      w.current.value = JSON.stringify(z);
      const Y = new Event("input", { bubbles: !0 });
      w.current.dispatchEvent(Y);
    }
  }, v = (A) => {
    if (!k.current) return t;
    const z = k.current.getBoundingClientRect(), q = (A - z.left) / z.width, ee = t + (e - t) * q, B = Math.round(ee / r) * r;
    return j(B);
  }, M = (A) => (z) => {
    a || ($(A), z.stopPropagation());
  }, E = (A) => {
    if (!a)
      if (!h)
        $(0), N(A, 0);
      else {
        const z = v(A.clientX), Y = Math.abs(z - H), q = Math.abs(z - O), ee = Y < q ? 0 : 1;
        $(ee), N(A, ee);
      }
  }, N = le.useCallback((A, z) => {
    const Y = v(A.clientX);
    if (!h)
      F(Y);
    else {
      let q = [H, O];
      z === 0 ? q = [Math.min(Y, O - r), O] : q = [H, Math.max(Y, H + r)], q[0] > q[1] && (q = [q[1], q[0]]), F(q);
    }
  }, [h, H, O, r, F, v]), R = le.useRef(y);
  R.current = y;
  const x = le.useCallback(function(A) {
    R.current === null || a || N(A, R.current);
  }, [a, N]), P = le.useCallback(function() {
    $(null);
  }, []);
  me(() => {
    if (y !== null) {
      const A = Ir();
      return A.addEventListener("mousemove", x), A.addEventListener("mouseup", P), () => {
        A.removeEventListener("mousemove", x), A.removeEventListener("mouseup", P);
      };
    }
  }, [y, x, P]);
  const I = (A) => (A - t) / (e - t) * 100, D = I(H), L = I(O);
  return /* @__PURE__ */ m.jsxs("div", { ref: C, className: Ne("relative w-full", i), ...f, children: [
    /* @__PURE__ */ m.jsx(
      "input",
      {
        type: "hidden",
        ref: w,
        name: u,
        value: JSON.stringify(T),
        onChange: () => {
        }
      }
    ),
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        ref: k,
        className: Ne(
          "relative h-2 bg-gray-200 rounded-full cursor-pointer",
          a && "opacity-50 cursor-not-allowed"
        ),
        onMouseDown: E,
        children: [
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: "absolute h-full bg-primary rounded-full",
              style: { left: `${h ? D : 0}%`, width: `${h ? L - D : D}%` }
            }
          ),
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: Ne(
                "absolute top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full shadow-md",
                "border-2 border-primary",
                a && "cursor-not-allowed"
              ),
              style: { left: `${D}%`, transform: "translate(-50%, -50%)" },
              onMouseDown: M(0)
            }
          ),
          h && /* @__PURE__ */ m.jsx(
            "div",
            {
              className: Ne(
                "absolute top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full shadow-md",
                "border-2 border-primary",
                a && "cursor-not-allowed"
              ),
              style: { left: `${L}%`, transform: "translate(-50%, -50%)" },
              onMouseDown: M(1)
            }
          )
        ]
      }
    ),
    d.length > 0 && /* @__PURE__ */ m.jsx("div", { className: "flex justify-between mt-2", children: d.map((A) => /* @__PURE__ */ m.jsx(
      "div",
      {
        className: "text-xs text-gray",
        style: { left: `${(A.value - t) / (e - t) * 100}%` },
        children: A.label
      },
      A.value
    )) }),
    l && /* @__PURE__ */ m.jsx("div", { className: "mt-2 text-sm text-gray-600", children: h ? `${H} - ${O}` : H })
  ] });
});
Db.displayName = "Slider";
const _b = {
  sm: "w-4 h-4",
  md: "w-6 h-6",
  lg: "w-8 h-8"
}, Fb = {
  primary: "text-primary",
  warning: "text-warning",
  default: "text-default-400"
}, W7 = ({
  rating: t,
  maxRating: e = 5,
  size: r = "md",
  color: n = "primary",
  readOnly: o = !1,
  onRatingChange: s,
  className: i
}) => {
  const [a, l] = de(null), d = (p) => {
    o || l(p);
  }, c = () => {
    o || l(null);
  }, u = (p) => {
    !o && s && s(p);
  }, f = a !== null ? a : t;
  return /* @__PURE__ */ m.jsx("div", { className: V("flex items-center gap-1", i), children: [...Array(e)].map((p, h) => {
    const g = h + 1, b = g <= f, y = a !== null && g <= a;
    return /* @__PURE__ */ m.jsx(
      "button",
      {
        className: V(
          "transition-colors duration-200",
          _b[r],
          b || y ? Fb[n] : "text-default-200",
          !o && "cursor-pointer"
        ),
        onMouseEnter: () => d(g),
        onMouseLeave: c,
        onClick: () => u(g),
        disabled: o,
        "aria-label": `Rate ${g} out of ${e}`,
        children: /* @__PURE__ */ m.jsx(
          $e,
          {
            icon: b || y ? "mdi:star" : "mdi:star-outline",
            className: "w-full h-full"
          }
        )
      },
      h
    );
  }) });
}, zb = {
  active: {
    bgColor: "bg-success",
    label: "Active"
  },
  inactive: {
    bgColor: "bg-default",
    label: "Inactive"
  },
  pending: {
    bgColor: "bg-warning",
    label: "Pending"
  },
  warning: {
    bgColor: "bg-warning",
    label: "Warning"
  },
  error: {
    bgColor: "bg-danger",
    label: "Error"
  }
}, Hb = {
  sm: "w-2 h-2",
  md: "w-3 h-3",
  lg: "w-4 h-4"
}, U7 = ({
  status: t,
  size: e = "md",
  withLabel: r = !1,
  className: n
}) => {
  const { bgColor: o, label: s } = zb[t], i = Hb[e];
  return /* @__PURE__ */ m.jsxs("div", { className: V("flex items-center gap-2", n), children: [
    /* @__PURE__ */ m.jsx("div", { className: V("rounded-full animate-pulse", o, i) }),
    r && /* @__PURE__ */ m.jsx("span", { className: "text-sm", children: s })
  ] });
}, Bp = (t, e) => {
  if (e) return e;
  switch (t) {
    case "completed":
      return "mdi:check";
    case "active":
      return "mdi:circle-medium";
    default:
      return "mdi:circle-outline";
  }
}, Vp = (t) => {
  switch (t) {
    case "completed":
      return "text-white bg-primary ring-4 ring-primary-50";
    case "active":
      return "text-primary bg-primary-50 ring-4 ring-primary-50";
    default:
      return "text-neutral bg-neutral-50 ring-4 ring-neutral-50";
  }
}, Bb = ({
  steps: t,
  activeStep: e,
  className: r,
  variant: n = "default"
}) => /* @__PURE__ */ m.jsx("div", { className: V("flex flex-row items-center w-full justify-between", r), children: t.map((o, s) => {
  const i = s < e ? "completed" : s === e ? "active" : "pending";
  return /* @__PURE__ */ m.jsxs(
    "div",
    {
      className: "flex items-center flex-1",
      children: [
        /* @__PURE__ */ m.jsxs("div", { className: V(
          "flex flex-col items-center z-10",
          n === "default" ? "gap-4" : "gap-2",
          n === "default" ? "px-5" : "px-3"
        ), children: [
          n === "default" && /* @__PURE__ */ m.jsx(
            "div",
            {
              className: V(
                "flex h-8 w-8 items-center justify-center rounded-full transition-all duration-200",
                Vp(i)
              ),
              children: /* @__PURE__ */ m.jsx(
                $e,
                {
                  icon: Bp(i, o.icon),
                  className: "h-5 w-5"
                }
              )
            }
          ),
          /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col items-center text-center", children: [
            /* @__PURE__ */ m.jsx(
              "span",
              {
                className: V(
                  "text-sm font-medium",
                  i === "active" ? "text-primary" : i === "completed" ? "text-neutral-900" : "text-neutral"
                ),
                children: o.label
              }
            ),
            o.description && /* @__PURE__ */ m.jsx("span", { className: "text-xs text-neutral", children: o.description })
          ] })
        ] }),
        s < t.length - 1 && /* @__PURE__ */ m.jsx(
          Nb,
          {
            className: V(
              "transition-all duration-200",
              s < e ? "bg-primary" : "bg-neutral-200"
            )
          }
        )
      ]
    },
    s
  );
}) }), Vb = ({
  steps: t,
  activeStep: e,
  className: r,
  variant: n = "default"
}) => /* @__PURE__ */ m.jsx("div", { className: V("flex flex-col items-start gap-8", r), children: t.map((o, s) => {
  const i = s < e ? "completed" : s === e ? "active" : "pending";
  return /* @__PURE__ */ m.jsxs(
    "div",
    {
      className: "flex flex-row w-full items-center relative",
      children: [
        /* @__PURE__ */ m.jsxs("div", { className: V(
          "flex flex-row items-center z-10",
          n === "default" ? "gap-4" : "gap-2"
        ), children: [
          n === "default" && /* @__PURE__ */ m.jsx(
            "div",
            {
              className: V(
                "flex h-8 w-8 items-center justify-center rounded-full transition-all duration-200",
                Vp(i)
              ),
              children: /* @__PURE__ */ m.jsx(
                $e,
                {
                  icon: Bp(i, o.icon),
                  className: "h-5 w-5"
                }
              )
            }
          ),
          /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col items-start", children: [
            /* @__PURE__ */ m.jsx(
              "span",
              {
                className: V(
                  "text-sm font-medium",
                  i === "active" ? "text-primary00" : i === "completed" ? "text-neutral-900" : "text-neutral"
                ),
                children: o.label
              }
            ),
            o.description && /* @__PURE__ */ m.jsx("span", { className: "text-xs text-neutral", children: o.description })
          ] })
        ] }),
        s < t.length - 1 && /* @__PURE__ */ m.jsx(
          "div",
          {
            className: V(
              "absolute transition-all duration-200",
              n === "default" ? "left-4 w-[1px] top-10 bottom-[-24px]" : "left-0 w-[1px] top-6 bottom-[-24px]",
              s < e ? "bg-primary" : "bg-neutral-200"
            )
          }
        )
      ]
    },
    s
  );
}) }), G7 = ({
  orientation: t = "horizontal",
  variant: e = "default",
  ...r
}) => t === "vertical" ? /* @__PURE__ */ m.jsx(Vb, { variant: e, ...r }) : /* @__PURE__ */ m.jsx(Bb, { variant: e, ...r }), Wb = Oe(({
  label: t,
  checked: e = !1,
  disabled: r = !1,
  onChange: n,
  size: o = "md",
  ...s
}, i) => {
  const a = (c) => {
    n && n(c.target.checked);
  }, l = {
    sm: "w-8 h-4",
    md: "w-11 h-6",
    lg: "w-14 h-7"
  }, d = {
    sm: "w-3 h-3",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  };
  return /* @__PURE__ */ m.jsxs(
    "label",
    {
      className: Ne(
        "inline-flex items-center cursor-pointer",
        r && "opacity-60 cursor-not-allowed"
      ),
      children: [
        /* @__PURE__ */ m.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ m.jsx(
            "input",
            {
              type: "checkbox",
              className: "sr-only",
              checked: e,
              disabled: r,
              onChange: a,
              ref: i,
              ...s
            }
          ),
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: Ne(
                "block rounded-full transition-colors duration-200 ease-in-out",
                l[o],
                e ? "bg-primary" : "bg-gray-200 dark:bg-gray-700",
                r && "cursor-not-allowed"
              )
            }
          ),
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: Ne(
                "absolute rounded-full bg-white shadow-sm transition-transform duration-200 ease-in-out",
                d[o],
                e ? o === "sm" ? "translate-x-4" : o === "md" ? "translate-x-5" : "translate-x-7" : "translate-x-0.5",
                "top-1/2 -translate-y-1/2"
              )
            }
          )
        ] }),
        t && /* @__PURE__ */ m.jsx("span", { className: "ml-3 text-sm text-gray-700 dark:text-gray-300", children: t })
      ]
    }
  );
});
Wb.displayName = "Switch";
const K7 = ({
  items: t,
  defaultActiveId: e,
  variant: r = "default",
  size: n = "md",
  className: o,
  tabListClassName: s,
  tabClassName: i,
  contentClassName: a,
  onChange: l
}) => {
  var y, $;
  const [d, c] = de(e || ((y = t[0]) == null ? void 0 : y.id) || ""), u = le.useRef(null), [f, p] = de({ left: 0, width: 0 });
  le.useEffect(() => {
    var k;
    if (r === "active-underline" && u.current) {
      const w = u.current.getBoundingClientRect(), C = (k = u.current.parentElement) == null ? void 0 : k.getBoundingClientRect();
      C && p({
        left: w.left - C.left,
        width: w.width
      });
    }
  }, [r, t, d]), le.useEffect(() => {
    if (r === "active-underline") {
      const k = () => {
        var w;
        if (u.current) {
          const C = u.current.getBoundingClientRect(), T = (w = u.current.parentElement) == null ? void 0 : w.getBoundingClientRect();
          T && p({
            left: C.left - T.left,
            width: C.width
          });
        }
      };
      return window.addEventListener("resize", k), () => window.removeEventListener("resize", k);
    }
  }, [r, t, d]);
  const h = we((k) => {
    c(k), l == null || l(k);
  }, [l]), g = () => {
    switch (n) {
      case "sm":
        return "text-sm px-3 py-1.5";
      case "lg":
        return "text-lg px-6 py-3";
      default:
        return "text-base px-4 py-2";
    }
  }, b = (k, w) => {
    const C = Ne(
      "flex items-center space-x-2 transition-colors",
      "font-medium",
      g(),
      w && "opacity-50 cursor-not-allowed",
      !w && "cursor-pointer"
    );
    switch (r) {
      case "pills":
        return Ne(
          C,
          "rounded-full",
          k ? "bg-primary text-white" : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
        );
      case "underline":
        return Ne(
          C,
          "border-b-2",
          k ? "border-primary text-primary" : "border-transparent text-gray-600 dark:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"
        );
      case "active-underline":
        return Ne(
          C,
          "border-b-0",
          k ? "text-primary" : "text-gray-600 dark:text-gray-300 hover:text-primary"
        );
      default:
        return Ne(
          C,
          "border-b-2",
          k ? "border-primary text-primary" : "border-transparent text-gray-600 dark:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"
        );
    }
  };
  return /* @__PURE__ */ m.jsxs("div", { className: Ne("w-full", o), children: [
    /* @__PURE__ */ m.jsxs("div", { className: Ne(
      r === "active-underline" ? "relative" : "",
      "flex space-x-1",
      r === "pills" && "space-x-2 border-b-0",
      r !== "active-underline" && "border-b border-gray-200 dark:border-gray-700",
      s
    ), children: [
      t.map((k) => {
        const w = k.id === d, C = !!k.disabled;
        return /* @__PURE__ */ m.jsxs(
          "button",
          {
            ref: r === "active-underline" && w ? u : void 0,
            onClick: () => !C && h(k.id),
            disabled: C,
            className: Ne(
              b(w, C),
              i
            ),
            children: [
              k.icon && /* @__PURE__ */ m.jsx(
                $e,
                {
                  icon: k.icon,
                  className: "w-5 h-5 flex-shrink-0"
                }
              ),
              /* @__PURE__ */ m.jsx("span", { children: k.label })
            ]
          },
          k.id
        );
      }),
      r === "active-underline" && /* @__PURE__ */ m.jsx(
        "span",
        {
          className: "absolute bottom-0 h-0.5 bg-primary transition-all duration-300",
          style: { left: f.left, width: f.width }
        }
      )
    ] }),
    /* @__PURE__ */ m.jsx("div", { className: Ne("mt-4", a), children: ($ = t.find((k) => k.id === d)) == null ? void 0 : $.content })
  ] });
}, Ho = ({
  variant: t = "p",
  children: e,
  className: r,
  as: n
}) => {
  const o = {
    h1: "text-4xl font-bold",
    h2: "text-3xl font-bold",
    h3: "text-2xl font-bold",
    h4: "text-xl font-bold",
    h5: "text-lg font-bold",
    h6: "text-base font-bold",
    p: "text-base",
    span: "text-base",
    label: "text-sm font-medium",
    heading3: "text-2xl font-bold",
    body1: "text-base",
    display1: "text-5xl font-bold",
    display2: "text-4xl font-bold",
    heading1: "text-4xl font-bold",
    heading2: "text-3xl font-bold",
    heading4: "text-xl font-bold",
    subtitle1: "text-lg font-medium",
    subtitle2: "text-base font-medium",
    body2: "text-sm",
    caption: "text-xs",
    value: "text-base font-medium"
  }, i = n || ((a) => {
    switch (a) {
      case "display1":
      case "display2":
      case "heading1":
      case "heading2":
      case "heading3":
      case "heading4":
        return "h" + a.slice(-1);
      case "body1":
      case "body2":
      case "subtitle1":
      case "subtitle2":
        return "p";
      case "caption":
      case "value":
        return "span";
      default:
        return a;
    }
  })(t);
  return /* @__PURE__ */ m.jsx(i, { className: V("text-gray-900", o[t], r), children: e });
}, Ub = ct(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 resize-none",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "min-h-[60px] px-2 py-1 text-sm",
        md: "min-h-[80px] px-3 py-2 text-base",
        lg: "min-h-[100px] px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      },
      resize: {
        none: "resize-none",
        vertical: "resize-y",
        horizontal: "resize-x",
        both: "resize"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "xl",
      fullWidth: !0,
      resize: "vertical"
    }
  }
), Gb = Oe(
  ({
    className: t,
    variant: e = "default",
    size: r = "md",
    rounded: n = "xl",
    error: o = !1,
    errorText: s,
    helperText: i,
    label: a,
    required: l = !1,
    labelPlacement: d = "top",
    fullWidth: c = !1,
    resize: u = "vertical",
    showCharCount: f = !1,
    maxLength: p,
    minRows: h = 3,
    maxRows: g = 10,
    id: b,
    value: y,
    ...$
  }, k) => {
    const w = b || le.useId(), C = `${w}-helper`, T = `${w}-error`, H = `${w}-char-count`, O = typeof y == "string" ? y.length : 0, j = p && O > p, F = /* @__PURE__ */ m.jsxs("div", { className: V("relative", !c && "inline-block"), children: [
      /* @__PURE__ */ m.jsx(
        "textarea",
        {
          id: w,
          ref: k,
          rows: h,
          maxLength: p,
          className: V(
            Ub({
              variant: o ? "error" : e,
              size: r,
              rounded: n,
              fullWidth: c,
              resize: u === "none" ? "none" : u
            }),
            t
          ),
          "aria-describedby": V(
            o ? T : i ? C : void 0,
            f ? H : void 0
          ),
          "aria-invalid": o,
          "aria-required": l,
          style: {
            minHeight: `${h * 1.5}em`,
            maxHeight: `${g * 1.5}em`
          },
          value: y,
          ...$
        }
      ),
      f && p && /* @__PURE__ */ m.jsx("div", { className: "absolute bottom-2 right-2 text-xs text-neutral-500 bg-white px-1 rounded", children: /* @__PURE__ */ m.jsxs("span", { id: H, className: j ? "text-danger" : "", children: [
        O,
        "/",
        p
      ] }) })
    ] }), v = /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      o && s && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", id: T, children: s }),
      !o && i && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", id: C, children: i }),
      f && p && !o && !i && /* @__PURE__ */ m.jsxs("p", { className: "mt-1 text-xs text-neutral", id: H, children: [
        O,
        " of ",
        p,
        " characters"
      ] })
    ] });
    return d === "left" ? /* @__PURE__ */ m.jsx("div", { className: V(c ? "w-full" : "inline-block", t), children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-start gap-4", children: [
      a && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: w,
          className: "block text-sm text-neutral-900 pt-2",
          children: [
            a,
            l && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ m.jsxs("div", { className: V("flex-1", !c && "inline-block"), children: [
        F,
        v
      ] })
    ] }) }) : /* @__PURE__ */ m.jsxs("div", { className: V(c ? "w-full" : "inline-block", t), children: [
      a && /* @__PURE__ */ m.jsxs(
        "label",
        {
          htmlFor: w,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            a,
            l && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ]
        }
      ),
      F,
      v
    ] });
  }
);
Gb.displayName = "Textarea";
const Ca = "timepicker-dropdown-opened", Kb = ct(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "xl",
      fullWidth: !0
    }
  }
), Wp = Oe(
  ({
    value: t,
    onChange: e,
    use24Hour: r = !1,
    variant: n = "default",
    size: o = "md",
    rounded: s = "xl",
    disabled: i = !1,
    errorText: a,
    helperText: l,
    label: d,
    required: c = !1,
    labelPlacement: u = "top",
    fullWidth: f = !1,
    className: p,
    placeholder: h = "Select time",
    leftIcon: g,
    rightIcon: b,
    valueFormatter: y,
    closeOnSelect: $ = !0,
    ...k
  }, w) => {
    const [C, T] = de(!1), [H, O] = de(t || ""), [j, F] = de(0), [v, M] = de(0), [E, N] = de(!0), R = te(null), x = te(null), P = te(null), D = `timepicker-${le.useId().replace(/:/g, "")}`, L = () => {
      if (!C || !x.current || !P.current) return;
      const _ = x.current.getBoundingClientRect(), W = P.current, pe = Ir().innerHeight - _.bottom;
      W.style.top = `${_.bottom + 4}px`, W.style.bottom = "auto", W.style.left = `${_.left}px`, W.style.maxHeight = `${pe - 8}px`, W.style.width = `${_.width}px`;
    };
    me(() => {
      const _ = Ir(), W = wt(), ie = () => {
        C && L();
      }, pe = () => {
        C && L();
      }, ye = (Be) => {
        Be.detail.id !== D && T(!1);
      }, Ce = (Be) => {
        const je = Be.target;
        R.current && P.current && !R.current.contains(je) && !P.current.contains(je) && T(!1);
      };
      return C && (L(), _.addEventListener("scroll", ie, !0), _.addEventListener("resize", pe)), W.addEventListener(Ca, ye), W.addEventListener("mousedown", Ce), () => {
        _.removeEventListener("scroll", ie, !0), _.removeEventListener("resize", pe), W.removeEventListener(Ca, ye), W.removeEventListener("mousedown", Ce);
      };
    }, [C, D]);
    const A = () => {
      i || (C || wt().dispatchEvent(
        new CustomEvent(Ca, {
          detail: { id: D }
        })
      ), T(!C));
    };
    me(() => {
      if (t) {
        O(t);
        const [_, W] = t.split(":").map(Number);
        r ? F(_) : (F(_ % 12 || 12), N(_ < 12)), M(W);
      }
    }, [t, r]);
    const z = () => {
      const W = `${(r || E ? j : j + 12).toString().padStart(2, "0")}:${v.toString().padStart(2, "0")}`;
      O(W), e == null || e(W), $ && T(!1);
    }, Y = () => r ? Array.from({ length: 24 }, (_, W) => W) : Array.from({ length: 12 }, (_, W) => W + 1), q = () => Array.from({ length: 60 }, (_, W) => W), ee = y ? y(H) : H, B = wt();
    return "body" in B ? /* @__PURE__ */ m.jsxs("div", { ref: R, className: V("relative", f && "w-full", p), children: [
      d && /* @__PURE__ */ m.jsxs(
        "label",
        {
          className: V(
            "block text-sm font-medium text-gray-700 mb-1",
            u === "left" && "inline-block mr-2"
          ),
          children: [
            d,
            c && /* @__PURE__ */ m.jsx("span", { className: "text-red ml-1", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ m.jsxs(
        "div",
        {
          ref: x,
          className: "relative",
          onClick: A,
          children: [
            g && /* @__PURE__ */ m.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral flex items-center justify-center", children: /* @__PURE__ */ m.jsx($e, { icon: g, size: 20 }) }),
            /* @__PURE__ */ m.jsx(
              "input",
              {
                ref: w,
                type: "text",
                value: ee,
                placeholder: h,
                readOnly: !0,
                className: V(
                  Kb({ variant: n, size: o, rounded: s, fullWidth: f }),
                  g && "pl-10",
                  b && "pr-10",
                  "text-left"
                ),
                disabled: i,
                ...k
              }
            ),
            b && /* @__PURE__ */ m.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral flex items-center justify-center", children: /* @__PURE__ */ m.jsx($e, { icon: b, size: 20 }) })
          ]
        }
      ),
      C && Rn(
        /* @__PURE__ */ m.jsx(
          "div",
          {
            ref: P,
            className: "fixed z-[9999] w-fit rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5",
            onClick: (_) => _.stopPropagation(),
            children: /* @__PURE__ */ m.jsxs("div", { className: "p-0", children: [
              /* @__PURE__ */ m.jsxs(jp, { variant: "ghost", className: V(
                "flex mx-2 my-1 p-0",
                r ? "justify-start gap-8" : "justify-start gap-4"
              ), children: [
                /* @__PURE__ */ m.jsx("div", { className: "flex flex-col", children: /* @__PURE__ */ m.jsx("div", { className: "overflow-y-auto [scrollbar-width:none] [-ms-overflow-style:none] hover:scrollbar-thumb-neutral-200 hover:scrollbar-track-transparent [&::-webkit-scrollbar]:hidden hover:[&::-webkit-scrollbar]:block hover:[&::-webkit-scrollbar]:w-1.5 hover:[&::-webkit-scrollbar-thumb]:rounded-full", style: { maxHeight: "200px" }, children: /* @__PURE__ */ m.jsx("div", { className: "flex flex-col gap-2", children: Y().map((_) => /* @__PURE__ */ m.jsx(
                  kt,
                  {
                    variant: "ghost",
                    onClick: () => F(_),
                    className: V(j === _ && "bg-primary text-white"),
                    children: _.toString().padStart(2, "0")
                  },
                  _
                )) }) }) }),
                /* @__PURE__ */ m.jsx("div", { className: "flex flex-col", children: /* @__PURE__ */ m.jsx("div", { className: "overflow-y-auto [scrollbar-width:none] [-ms-overflow-style:none] hover:scrollbar-thumb-neutral-200 hover:scrollbar-track-transparent [&::-webkit-scrollbar]:hidden hover:[&::-webkit-scrollbar]:block hover:[&::-webkit-scrollbar]:w-1.5 hover:[&::-webkit-scrollbar-thumb]:rounded-full", style: { maxHeight: "200px" }, children: /* @__PURE__ */ m.jsx("div", { className: "flex flex-col gap-2", children: q().map((_) => /* @__PURE__ */ m.jsx(
                  kt,
                  {
                    variant: "ghost",
                    onClick: () => M(_),
                    className: V(v === _ && "bg-primary text-white"),
                    children: _.toString().padStart(2, "0")
                  },
                  _
                )) }) }) }),
                !r && /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col gap-2", children: [
                  /* @__PURE__ */ m.jsx(
                    kt,
                    {
                      variant: "ghost",
                      onClick: () => N(!0),
                      className: V(E && "bg-primary text-white"),
                      children: "AM"
                    }
                  ),
                  /* @__PURE__ */ m.jsx(
                    kt,
                    {
                      variant: "ghost",
                      onClick: () => N(!1),
                      className: V(!E && "bg-primary text-white"),
                      children: "PM"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ m.jsx("div", { className: "mb-2 mx-2", children: /* @__PURE__ */ m.jsx(
                kt,
                {
                  variant: "primary",
                  onClick: z,
                  size: "sm",
                  fullWidth: !0,
                  children: "Select"
                }
              ) })
            ] })
          }
        ),
        B.body
      ),
      a && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-sm text-danger-600", children: a }),
      l && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-sm text-gray", children: l })
    ] }) : null;
  }
);
Wp.displayName = "PrimitiveTimePicker";
const Yb = Oe(({
  value: t,
  onChange: e,
  valueFormatter: r,
  closeOnSelect: n,
  ...o
}, s) => /* @__PURE__ */ m.jsx(
  Wp,
  {
    ref: s,
    value: t,
    onChange: e,
    valueFormatter: r,
    closeOnSelect: n,
    ...o
  }
));
Yb.displayName = "TimePicker";
const Jb = ct(
  "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        primary: "bg-neutral-200 data-[state=checked]:bg-primary focus-visible:ring-primary",
        success: "bg-neutral-200 data-[state=checked]:bg-success focus-visible:ring-success",
        warning: "bg-neutral-200 data-[state=checked]:bg-warning focus-visible:ring-warning",
        danger: "bg-neutral-200 data-[state=checked]:bg-danger focus-visible:ring-danger"
      },
      size: {
        sm: "h-4 w-7",
        md: "h-6 w-11",
        lg: "h-7 w-14"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md"
    }
  }
), qb = ct(
  "pointer-events-none block rounded-full bg-white shadow-lg ring-0 transition-transform",
  {
    variants: {
      size: {
        sm: "h-3 w-3 data-[state=checked]:translate-x-3",
        md: "h-5 w-5 data-[state=checked]:translate-x-5",
        lg: "h-6 w-6 data-[state=checked]:translate-x-7"
      }
    },
    defaultVariants: {
      size: "md"
    }
  }
), Xb = Oe(
  ({
    checked: t = !1,
    onCheckedChange: e,
    variant: r = "primary",
    size: n = "md",
    label: o,
    required: s = !1,
    helperText: i,
    errorText: a,
    error: l = !1,
    className: d,
    name: c,
    ...u
  }, f) => {
    const p = le.useId(), h = `${p}-helper`, g = `${p}-error`, b = te(null), y = te(null), $ = te(null);
    In(f, () => b.current || $.current, []), me(() => {
      if (b.current) {
        b.current.checked = t;
        const w = new Event("change", { bubbles: !0 });
        b.current.dispatchEvent(w);
      }
    }, [t]);
    const k = () => {
      const w = !t;
      if (e == null || e(w), b.current) {
        b.current.checked = w;
        const C = new Event("change", { bubbles: !0 });
        b.current.dispatchEvent(C);
      }
    };
    return /* @__PURE__ */ m.jsxs("div", { ref: $, className: "inline-flex flex-col gap-1.5", children: [
      /* @__PURE__ */ m.jsx(
        "input",
        {
          type: "checkbox",
          ref: b,
          name: c,
          checked: t,
          onChange: () => {
          },
          className: "sr-only",
          "aria-hidden": "true"
        }
      ),
      /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ m.jsx(
          "button",
          {
            type: "button",
            role: "switch",
            "aria-checked": t,
            "data-state": t ? "checked" : "unchecked",
            onClick: k,
            ref: y,
            className: V(Jb({ variant: l ? "danger" : r, size: n }), d),
            "aria-describedby": l ? g : i ? h : void 0,
            "aria-invalid": l,
            "aria-required": s,
            ...u,
            children: /* @__PURE__ */ m.jsx(
              "span",
              {
                "data-state": t ? "checked" : "unchecked",
                className: V(
                  qb({ size: n }),
                  t ? "translate-x-5" : "translate-x-1"
                )
              }
            )
          }
        ),
        o && /* @__PURE__ */ m.jsxs(
          "label",
          {
            htmlFor: p,
            className: "text-sm text-neutral-900",
            children: [
              o,
              s && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
            ]
          }
        )
      ] }),
      l && a && /* @__PURE__ */ m.jsx("p", { className: "text-xs text-danger", id: g, children: a }),
      !l && i && /* @__PURE__ */ m.jsx("p", { className: "text-xs text-neutral", id: h, children: i })
    ] });
  }
);
Xb.displayName = "Toggle";
function vd(t = {}) {
  const {
    strict: e = !0,
    errorMessage: r = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
    name: n
  } = t, o = Lc.createContext(void 0);
  o.displayName = n;
  function s() {
    var i;
    const a = Lc.useContext(o);
    if (!a && e) {
      const l = new Error(r);
      throw l.name = "ContextError", (i = Error.captureStackTrace) == null || i.call(Error, l, s), l;
    }
    return a;
  }
  return [o.Provider, s, o];
}
function Zb(t) {
  return {
    UNSAFE_getDOMNode() {
      return t.current;
    }
  };
}
function Up(t) {
  const e = te(null);
  return In(t, () => e.current), e;
}
process.env.NODE_ENV;
process.env.NODE_ENV;
function Qb(t) {
  return typeof t == "function";
}
var ht = (t) => t ? "true" : void 0;
function Gp(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number")
    n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = Gp(t[e])) && (n && (n += " "), n += r);
    else
      for (e in t)
        t[e] && (n && (n += " "), n += e);
  return n;
}
function hn(...t) {
  for (var e = 0, r, n, o = ""; e < t.length; )
    (r = t[e++]) && (n = Gp(r)) && (o && (o += " "), o += n);
  return o;
}
function e2(t) {
  return `${t}-${Math.floor(Math.random() * 1e6)}`;
}
function $d(t) {
  if (!t || typeof t != "object")
    return "";
  try {
    return JSON.stringify(t);
  } catch {
    return "";
  }
}
function t2(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
var Gc = {};
function r2(t, e, ...r) {
  const o = `[Hero UI] : ${t}`;
  if (!(typeof console > "u") && !Gc[o] && (Gc[o] = !0, process.env.NODE_ENV !== "production"))
    return console.warn(o, r);
}
function Kp(...t) {
  return (...e) => {
    for (let r of t)
      typeof r == "function" && r(...e);
  };
}
var Kc = /* @__PURE__ */ new Map();
function n2(t, e) {
  if (t === e)
    return t;
  let r = Kc.get(t);
  if (r)
    return r.forEach((o) => o.current = e), e;
  let n = Kc.get(e);
  return n ? (n.forEach((o) => o.current = t), t) : e;
}
function zt(...t) {
  let e = { ...t[0] };
  for (let r = 1; r < t.length; r++) {
    let n = t[r];
    for (let o in n) {
      let s = e[o], i = n[o];
      typeof s == "function" && typeof i == "function" && // This is a lot faster than a regex.
      o[0] === "o" && o[1] === "n" && o.charCodeAt(2) >= /* 'A' */
      65 && o.charCodeAt(2) <= /* 'Z' */
      90 ? e[o] = Kp(s, i) : (o === "className" || o === "UNSAFE_className") && typeof s == "string" && typeof i == "string" ? e[o] = hn(s, i) : o === "id" && s && i ? e.id = n2(s, i) : e[o] = i !== void 0 ? i : s;
    }
  }
  return e;
}
function o2(...t) {
  return t.length === 1 && t[0] ? t[0] : (e) => {
    let r = !1;
    const n = t.map((o) => {
      const s = Yc(o, e);
      return r || (r = typeof s == "function"), s;
    });
    if (r)
      return () => {
        n.forEach((o, s) => {
          typeof o == "function" ? o == null || o() : Yc(t[s], null);
        });
      };
  };
}
function Yc(t, e) {
  if (typeof t == "function")
    return () => t(e);
  t != null && "current" in t && (t.current = e);
}
function s2(t, e) {
  if (t != null) {
    if (Qb(t)) {
      t(e);
      return;
    }
    try {
      t.current = e;
    } catch {
      throw new Error(`Cannot assign value '${e}' to ref '${t}'`);
    }
  }
}
function i2(...t) {
  return (e) => {
    t.forEach((r) => s2(r, e));
  };
}
var a2 = (t, e) => {
  var r;
  let n = [];
  const o = (r = to.map(t, (i) => Yn(i) && i.type === e ? (n.push(i), null) : i)) == null ? void 0 : r.filter(Boolean), s = n.length >= 0 ? n : void 0;
  return [o, s];
}, l2 = /* @__PURE__ */ new Set([
  "id",
  "type",
  "style",
  "title",
  "role",
  "tabIndex",
  "htmlFor",
  "width",
  "height",
  "abbr",
  "accept",
  "acceptCharset",
  "accessKey",
  "action",
  "allowFullScreen",
  "allowTransparency",
  "alt",
  "async",
  "autoComplete",
  "autoFocus",
  "autoPlay",
  "cellPadding",
  "cellSpacing",
  "challenge",
  "charset",
  "checked",
  "cite",
  "class",
  "className",
  "cols",
  "colSpan",
  "command",
  "content",
  "contentEditable",
  "contextMenu",
  "controls",
  "coords",
  "crossOrigin",
  "data",
  "dateTime",
  "default",
  "defer",
  "dir",
  "disabled",
  "download",
  "draggable",
  "dropzone",
  "encType",
  "enterKeyHint",
  "for",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "frameBorder",
  "headers",
  "hidden",
  "high",
  "href",
  "hrefLang",
  "httpEquiv",
  "icon",
  "inputMode",
  "isMap",
  "itemId",
  "itemProp",
  "itemRef",
  "itemScope",
  "itemType",
  "kind",
  "label",
  "lang",
  "list",
  "loop",
  "manifest",
  "max",
  "maxLength",
  "media",
  "mediaGroup",
  "method",
  "min",
  "minLength",
  "multiple",
  "muted",
  "name",
  "noValidate",
  "open",
  "optimum",
  "pattern",
  "ping",
  "placeholder",
  "poster",
  "preload",
  "radioGroup",
  "referrerPolicy",
  "readOnly",
  "rel",
  "required",
  "rows",
  "rowSpan",
  "sandbox",
  "scope",
  "scoped",
  "scrolling",
  "seamless",
  "selected",
  "shape",
  "size",
  "sizes",
  "slot",
  "sortable",
  "span",
  "spellCheck",
  "src",
  "srcDoc",
  "srcSet",
  "start",
  "step",
  "target",
  "translate",
  "typeMustMatch",
  "useMap",
  "value",
  "wmode",
  "wrap"
]), d2 = /* @__PURE__ */ new Set([
  "onCopy",
  "onCut",
  "onPaste",
  "onLoad",
  "onError",
  "onWheel",
  "onScroll",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  "onFocus",
  "onBlur",
  "onChange",
  "onInput",
  "onSubmit",
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerUp",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration",
  "onTransitionEnd"
]), Jc = /^(data-.*)$/, c2 = /^(aria-.*)$/, ds = /^(on[A-Z].*)$/;
function qc(t, e = {}) {
  let {
    labelable: r = !0,
    enabled: n = !0,
    propNames: o,
    omitPropNames: s,
    omitEventNames: i,
    omitDataProps: a,
    omitEventProps: l
  } = e, d = {};
  if (!n)
    return t;
  for (const c in t)
    s != null && s.has(c) || i != null && i.has(c) && ds.test(c) || ds.test(c) && !d2.has(c) || a && Jc.test(c) || l && ds.test(c) || (Object.prototype.hasOwnProperty.call(t, c) && (l2.has(c) || r && c2.test(c) || o != null && o.has(c) || Jc.test(c)) || ds.test(c)) && (d[c] = t[c]);
  return d;
}
var [Y7, qi] = vd({
  name: "ProviderContext",
  strict: !1
});
const u2 = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]), f2 = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function p2(t) {
  if (Intl.Locale) {
    let r = new Intl.Locale(t).maximize(), n = typeof r.getTextInfo == "function" ? r.getTextInfo() : r.textInfo;
    if (n) return n.direction === "rtl";
    if (r.script) return u2.has(r.script);
  }
  let e = t.split("-")[0];
  return f2.has(e);
}
const Ys = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
}, Yp = /* @__PURE__ */ le.createContext(Ys), h2 = /* @__PURE__ */ le.createContext(!1);
let m2 = !!(typeof window < "u" && window.document && window.document.createElement), Sa = /* @__PURE__ */ new WeakMap();
function g2(t = !1) {
  let e = Qt(Yp), r = te(null);
  if (r.current === null && !t) {
    var n, o;
    let s = (o = le.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || o === void 0 || (n = o.ReactCurrentOwner) === null || n === void 0 ? void 0 : n.current;
    if (s) {
      let i = Sa.get(s);
      i == null ? Sa.set(s, {
        id: e.current,
        state: s.memoizedState
      }) : s.memoizedState !== i.state && (e.current = i.id, Sa.delete(s));
    }
    r.current = ++e.current;
  }
  return r.current;
}
function b2(t) {
  let e = Qt(Yp);
  e === Ys && !m2 && process.env.NODE_ENV !== "production" && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let r = g2(!!t), n = e === Ys && process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${e.prefix}`;
  return t || `${n}-${r}`;
}
function y2(t) {
  let e = le.useId(), [r] = de(Xi()), n = r || process.env.NODE_ENV === "test" ? "react-aria" : `react-aria${Ys.prefix}`;
  return t || `${n}-${e}`;
}
const v2 = typeof le.useId == "function" ? y2 : b2;
function $2() {
  return !1;
}
function x2() {
  return !0;
}
function w2(t) {
  return () => {
  };
}
function Xi() {
  return typeof le.useSyncExternalStore == "function" ? le.useSyncExternalStore(w2, $2, x2) : Qt(h2);
}
const k2 = Symbol.for("react-aria.i18n.locale");
function Jp() {
  let t = typeof window < "u" && window[k2] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      t
    ]);
  } catch {
    t = "en-US";
  }
  return {
    locale: t,
    direction: p2(t) ? "rtl" : "ltr"
  };
}
let ul = Jp(), ko = /* @__PURE__ */ new Set();
function Xc() {
  ul = Jp();
  for (let t of ko) t(ul);
}
function E2() {
  let t = Xi(), [e, r] = de(ul);
  return me(() => (ko.size === 0 && window.addEventListener("languagechange", Xc), ko.add(r), () => {
    ko.delete(r), ko.size === 0 && window.removeEventListener("languagechange", Xc);
  }), []), t ? {
    locale: "en-US",
    direction: "ltr"
  } : e;
}
const C2 = /* @__PURE__ */ le.createContext(null);
function qp() {
  let t = E2();
  return Qt(C2) || t;
}
const S2 = Symbol.for("react-aria.i18n.locale"), N2 = Symbol.for("react-aria.i18n.strings");
let Fn;
class Zi {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(e, r) {
    let o = this.getStringsForLocale(r)[e];
    if (!o) throw new Error(`Could not find intl message ${e} in ${r} locale`);
    return o;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(e) {
    let r = this.strings[e];
    return r || (r = T2(e, this.strings, this.defaultLocale), this.strings[e] = r), r;
  }
  static getGlobalDictionaryForPackage(e) {
    if (typeof window > "u") return null;
    let r = window[S2];
    if (Fn === void 0) {
      let o = window[N2];
      if (!o) return null;
      Fn = {};
      for (let s in o) Fn[s] = new Zi({
        [r]: o[s]
      }, r);
    }
    let n = Fn == null ? void 0 : Fn[e];
    if (!n) throw new Error(`Strings for package "${e}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return n;
  }
  constructor(e, r = "en-US") {
    this.strings = Object.fromEntries(Object.entries(e).filter(([, n]) => n)), this.defaultLocale = r;
  }
}
function T2(t, e, r = "en-US") {
  if (e[t]) return e[t];
  let n = A2(t);
  if (e[n]) return e[n];
  for (let o in e)
    if (o.startsWith(n + "-")) return e[o];
  return e[r];
}
function A2(t) {
  return Intl.Locale ? new Intl.Locale(t).language : t.split("-")[0];
}
const Zc = /* @__PURE__ */ new Map(), Qc = /* @__PURE__ */ new Map();
class M2 {
  /** Formats a localized string for the given key with the provided variables. */
  format(e, r) {
    let n = this.strings.getStringForLocale(e, this.locale);
    return typeof n == "function" ? n(r, this) : n;
  }
  plural(e, r, n = "cardinal") {
    let o = r["=" + e];
    if (o) return typeof o == "function" ? o() : o;
    let s = this.locale + ":" + n, i = Zc.get(s);
    i || (i = new Intl.PluralRules(this.locale, {
      type: n
    }), Zc.set(s, i));
    let a = i.select(e);
    return o = r[a] || r.other, typeof o == "function" ? o() : o;
  }
  number(e) {
    let r = Qc.get(this.locale);
    return r || (r = new Intl.NumberFormat(this.locale), Qc.set(this.locale, r)), r.format(e);
  }
  select(e, r) {
    let n = e[r] || e.other;
    return typeof n == "function" ? n() : n;
  }
  constructor(e, r) {
    this.locale = e, this.strings = r;
  }
}
const eu = /* @__PURE__ */ new WeakMap();
function P2(t) {
  let e = eu.get(t);
  return e || (e = new Zi(t), eu.set(t, e)), e;
}
function I2(t, e) {
  return e && Zi.getGlobalDictionaryForPackage(e) || P2(t);
}
function R2(t, e) {
  let { locale: r } = qp(), n = I2(t, e);
  return Ye(() => new M2(r, n), [
    r,
    n
  ]);
}
function O2(t, e) {
  if (e.has(t))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function L2(t, e, r) {
  O2(t, e), e.set(t, r);
}
const nt = typeof document < "u" ? le.useLayoutEffect : () => {
};
var Na;
const j2 = (Na = le.useInsertionEffect) !== null && Na !== void 0 ? Na : nt;
function Yt(t) {
  const e = te(null);
  return j2(() => {
    e.current = t;
  }, [
    t
  ]), we((...r) => {
    const n = e.current;
    return n == null ? void 0 : n(...r);
  }, []);
}
function D2(t) {
  let [e, r] = de(t), n = te(null), o = Yt(() => {
    if (!n.current) return;
    let i = n.current.next();
    if (i.done) {
      n.current = null;
      return;
    }
    e === i.value ? o() : r(i.value);
  });
  nt(() => {
    n.current && o();
  });
  let s = Yt((i) => {
    n.current = i(e), o();
  });
  return [
    e,
    s
  ];
}
let _2 = !!(typeof window < "u" && window.document && window.document.createElement), qn = /* @__PURE__ */ new Map(), Eo;
typeof FinalizationRegistry < "u" && (Eo = new FinalizationRegistry((t) => {
  qn.delete(t);
}));
function Qi(t) {
  let [e, r] = de(t), n = te(null), o = v2(e), s = te(null);
  if (Eo && Eo.register(s, o), _2) {
    const i = qn.get(o);
    i && !i.includes(n) ? i.push(n) : qn.set(o, [
      n
    ]);
  }
  return nt(() => {
    let i = o;
    return () => {
      Eo && Eo.unregister(s), qn.delete(i);
    };
  }, [
    o
  ]), me(() => {
    let i = n.current;
    return i && r(i), () => {
      i && (n.current = null);
    };
  }), o;
}
function F2(t, e) {
  if (t === e) return t;
  let r = qn.get(t);
  if (r)
    return r.forEach((o) => o.current = e), e;
  let n = qn.get(e);
  return n ? (n.forEach((o) => o.current = t), t) : e;
}
function z2(t = []) {
  let e = Qi(), [r, n] = D2(e), o = we(() => {
    n(function* () {
      yield e, yield document.getElementById(e) ? e : void 0;
    });
  }, [
    e,
    n
  ]);
  return nt(o, [
    e,
    o,
    ...t
  ]), r;
}
function ea(...t) {
  return (...e) => {
    for (let r of t) typeof r == "function" && r(...e);
  };
}
const Ie = (t) => {
  var e;
  return (e = t == null ? void 0 : t.ownerDocument) !== null && e !== void 0 ? e : document;
}, Xt = (t) => t && "window" in t && t.window === t ? t : Ie(t).defaultView || window;
function H2(t) {
  return t !== null && typeof t == "object" && "nodeType" in t && typeof t.nodeType == "number";
}
function B2(t) {
  return H2(t) && t.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in t;
}
let V2 = !1;
function ta() {
  return V2;
}
function Ge(t, e) {
  if (!ta()) return e && t ? t.contains(e) : !1;
  if (!t || !e) return !1;
  let r = e;
  for (; r !== null; ) {
    if (r === t) return !0;
    r.tagName === "SLOT" && r.assignedSlot ? r = r.assignedSlot.parentNode : B2(r) ? r = r.host : r = r.parentNode;
  }
  return !1;
}
const jt = (t = document) => {
  var e;
  if (!ta()) return t.activeElement;
  let r = t.activeElement;
  for (; r && "shadowRoot" in r && (!((e = r.shadowRoot) === null || e === void 0) && e.activeElement); ) r = r.shadowRoot.activeElement;
  return r;
};
function Ae(t) {
  return ta() && t.target.shadowRoot && t.composedPath ? t.composedPath()[0] : t.target;
}
class W2 {
  get currentNode() {
    return this._currentNode;
  }
  set currentNode(e) {
    if (!Ge(this.root, e)) throw new Error("Cannot set currentNode to a node that is not contained by the root node.");
    const r = [];
    let n = e, o = e;
    for (this._currentNode = e; n && n !== this.root; ) if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      const i = n, a = this._doc.createTreeWalker(i, this.whatToShow, {
        acceptNode: this._acceptNode
      });
      r.push(a), a.currentNode = o, this._currentSetFor.add(a), n = o = i.host;
    } else n = n.parentNode;
    const s = this._doc.createTreeWalker(this.root, this.whatToShow, {
      acceptNode: this._acceptNode
    });
    r.push(s), s.currentNode = o, this._currentSetFor.add(s), this._walkerStack = r;
  }
  get doc() {
    return this._doc;
  }
  firstChild() {
    let e = this.currentNode, r = this.nextNode();
    return Ge(e, r) ? (r && (this.currentNode = r), r) : (this.currentNode = e, null);
  }
  lastChild() {
    let r = this._walkerStack[0].lastChild();
    return r && (this.currentNode = r), r;
  }
  nextNode() {
    const e = this._walkerStack[0].nextNode();
    if (e) {
      if (e.shadowRoot) {
        var r;
        let o;
        if (typeof this.filter == "function" ? o = this.filter(e) : !((r = this.filter) === null || r === void 0) && r.acceptNode && (o = this.filter.acceptNode(e)), o === NodeFilter.FILTER_ACCEPT)
          return this.currentNode = e, e;
        let s = this.nextNode();
        return s && (this.currentNode = s), s;
      }
      return e && (this.currentNode = e), e;
    } else if (this._walkerStack.length > 1) {
      this._walkerStack.shift();
      let n = this.nextNode();
      return n && (this.currentNode = n), n;
    } else return null;
  }
  previousNode() {
    const e = this._walkerStack[0];
    if (e.currentNode === e.root) {
      if (this._currentSetFor.has(e))
        if (this._currentSetFor.delete(e), this._walkerStack.length > 1) {
          this._walkerStack.shift();
          let o = this.previousNode();
          return o && (this.currentNode = o), o;
        } else return null;
      return null;
    }
    const r = e.previousNode();
    if (r) {
      if (r.shadowRoot) {
        var n;
        let s;
        if (typeof this.filter == "function" ? s = this.filter(r) : !((n = this.filter) === null || n === void 0) && n.acceptNode && (s = this.filter.acceptNode(r)), s === NodeFilter.FILTER_ACCEPT)
          return r && (this.currentNode = r), r;
        let i = this.lastChild();
        return i && (this.currentNode = i), i;
      }
      return r && (this.currentNode = r), r;
    } else if (this._walkerStack.length > 1) {
      this._walkerStack.shift();
      let o = this.previousNode();
      return o && (this.currentNode = o), o;
    } else return null;
  }
  /**
   * @deprecated
   */
  nextSibling() {
    return null;
  }
  /**
   * @deprecated
   */
  previousSibling() {
    return null;
  }
  /**
   * @deprecated
   */
  parentNode() {
    return null;
  }
  constructor(e, r, n, o) {
    this._walkerStack = [], this._currentSetFor = /* @__PURE__ */ new Set(), this._acceptNode = (i) => {
      if (i.nodeType === Node.ELEMENT_NODE) {
        const l = i.shadowRoot;
        if (l) {
          const d = this._doc.createTreeWalker(l, this.whatToShow, {
            acceptNode: this._acceptNode
          });
          return this._walkerStack.unshift(d), NodeFilter.FILTER_ACCEPT;
        } else {
          var a;
          if (typeof this.filter == "function") return this.filter(i);
          if (!((a = this.filter) === null || a === void 0) && a.acceptNode) return this.filter.acceptNode(i);
          if (this.filter === null) return NodeFilter.FILTER_ACCEPT;
        }
      }
      return NodeFilter.FILTER_SKIP;
    }, this._doc = e, this.root = r, this.filter = o ?? null, this.whatToShow = n ?? NodeFilter.SHOW_ALL, this._currentNode = r, this._walkerStack.unshift(e.createTreeWalker(r, n, this._acceptNode));
    const s = r.shadowRoot;
    if (s) {
      const i = this._doc.createTreeWalker(s, this.whatToShow, {
        acceptNode: this._acceptNode
      });
      this._walkerStack.unshift(i);
    }
  }
}
function U2(t, e, r, n) {
  return ta() ? new W2(t, e, r, n) : t.createTreeWalker(e, r, n);
}
function Rr(...t) {
  let e = {
    ...t[0]
  };
  for (let r = 1; r < t.length; r++) {
    let n = t[r];
    for (let o in n) {
      let s = e[o], i = n[o];
      typeof s == "function" && typeof i == "function" && // This is a lot faster than a regex.
      o[0] === "o" && o[1] === "n" && o.charCodeAt(2) >= /* 'A' */
      65 && o.charCodeAt(2) <= /* 'Z' */
      90 ? e[o] = ea(s, i) : (o === "className" || o === "UNSAFE_className") && typeof s == "string" && typeof i == "string" ? e[o] = Ne(s, i) : o === "id" && s && i ? e.id = F2(s, i) : e[o] = i !== void 0 ? i : s;
    }
  }
  return e;
}
const G2 = /* @__PURE__ */ new Set([
  "id"
]), K2 = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]), Y2 = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]), J2 = /* @__PURE__ */ new Set([
  "dir",
  "lang",
  "hidden",
  "inert",
  "translate"
]), tu = /* @__PURE__ */ new Set([
  "onClick",
  "onAuxClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onScroll",
  "onWheel",
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration",
  "onTransitionCancel",
  "onTransitionEnd",
  "onTransitionRun",
  "onTransitionStart"
]), q2 = /^(data-.*)$/;
function xd(t, e = {}) {
  let { labelable: r, isLink: n, global: o, events: s = o, propNames: i } = e, a = {};
  for (const l in t) Object.prototype.hasOwnProperty.call(t, l) && (G2.has(l) || r && K2.has(l) || n && Y2.has(l) || o && J2.has(l) || s && tu.has(l) || l.endsWith("Capture") && tu.has(l.slice(0, -7)) || i != null && i.has(l) || q2.test(l)) && (a[l] = t[l]);
  return a;
}
function ro(t) {
  if (X2()) t.focus({
    preventScroll: !0
  });
  else {
    let e = Z2(t);
    t.focus(), Q2(e);
  }
}
let cs = null;
function X2() {
  if (cs == null) {
    cs = !1;
    try {
      document.createElement("div").focus({
        get preventScroll() {
          return cs = !0, !0;
        }
      });
    } catch {
    }
  }
  return cs;
}
function Z2(t) {
  let e = t.parentNode, r = [], n = document.scrollingElement || document.documentElement;
  for (; e instanceof HTMLElement && e !== n; )
    (e.offsetHeight < e.scrollHeight || e.offsetWidth < e.scrollWidth) && r.push({
      element: e,
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft
    }), e = e.parentNode;
  return n instanceof HTMLElement && r.push({
    element: n,
    scrollTop: n.scrollTop,
    scrollLeft: n.scrollLeft
  }), r;
}
function Q2(t) {
  for (let { element: e, scrollTop: r, scrollLeft: n } of t)
    e.scrollTop = r, e.scrollLeft = n;
}
function ra(t) {
  var e;
  if (typeof window > "u" || window.navigator == null) return !1;
  let r = (e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.brands;
  return Array.isArray(r) && r.some((n) => t.test(n.brand)) || t.test(window.navigator.userAgent);
}
function wd(t) {
  var e;
  return typeof window < "u" && window.navigator != null ? t.test(((e = window.navigator.userAgentData) === null || e === void 0 ? void 0 : e.platform) || window.navigator.platform) : !1;
}
function Lr(t) {
  if (process.env.NODE_ENV === "test") return t;
  let e = null;
  return () => (e == null && (e = t()), e);
}
const no = Lr(function() {
  return wd(/^Mac/i);
}), ey = Lr(function() {
  return wd(/^iPhone/i);
}), Xp = Lr(function() {
  return wd(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  no() && navigator.maxTouchPoints > 1;
}), na = Lr(function() {
  return ey() || Xp();
});
Lr(function() {
  return no() || na();
});
const Zp = Lr(function() {
  return ra(/AppleWebKit/i) && !Qp();
}), Qp = Lr(function() {
  return ra(/Chrome/i);
}), kd = Lr(function() {
  return ra(/Android/i);
}), ty = Lr(function() {
  return ra(/Firefox/i);
});
function Bo(t, e, r = !0) {
  var n, o;
  let { metaKey: s, ctrlKey: i, altKey: a, shiftKey: l } = e;
  ty() && (!((o = window.event) === null || o === void 0 || (n = o.type) === null || n === void 0) && n.startsWith("key")) && t.target === "_blank" && (no() ? s = !0 : i = !0);
  let d = Zp() && no() && !Xp() && process.env.NODE_ENV !== "test" ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey: s,
    ctrlKey: i,
    altKey: a,
    shiftKey: l
  }) : new MouseEvent("click", {
    metaKey: s,
    ctrlKey: i,
    altKey: a,
    shiftKey: l,
    bubbles: !0,
    cancelable: !0
  });
  Bo.isOpening = r, ro(t), t.dispatchEvent(d), Bo.isOpening = !1;
}
Bo.isOpening = !1;
let Ur = /* @__PURE__ */ new Map(), fl = /* @__PURE__ */ new Set();
function ru() {
  if (typeof window > "u") return;
  function t(n) {
    return "propertyName" in n;
  }
  let e = (n) => {
    if (!t(n) || !n.target) return;
    let o = Ur.get(n.target);
    o || (o = /* @__PURE__ */ new Set(), Ur.set(n.target, o), n.target.addEventListener("transitioncancel", r, {
      once: !0
    })), o.add(n.propertyName);
  }, r = (n) => {
    if (!t(n) || !n.target) return;
    let o = Ur.get(n.target);
    if (o && (o.delete(n.propertyName), o.size === 0 && (n.target.removeEventListener("transitioncancel", r), Ur.delete(n.target)), Ur.size === 0)) {
      for (let s of fl) s();
      fl.clear();
    }
  };
  document.body.addEventListener("transitionrun", e), document.body.addEventListener("transitionend", r);
}
typeof document < "u" && (document.readyState !== "loading" ? ru() : document.addEventListener("DOMContentLoaded", ru));
function ry() {
  for (const [t] of Ur)
    "isConnected" in t && !t.isConnected && Ur.delete(t);
}
function eh(t) {
  requestAnimationFrame(() => {
    ry(), Ur.size === 0 ? t() : fl.add(t);
  });
}
function Ed() {
  let t = te(/* @__PURE__ */ new Map()), e = we((o, s, i, a) => {
    let l = a != null && a.once ? (...d) => {
      t.current.delete(i), i(...d);
    } : i;
    t.current.set(i, {
      type: s,
      eventTarget: o,
      fn: l,
      options: a
    }), o.addEventListener(s, l, a);
  }, []), r = we((o, s, i, a) => {
    var l;
    let d = ((l = t.current.get(i)) === null || l === void 0 ? void 0 : l.fn) || i;
    o.removeEventListener(s, d, a), t.current.delete(i);
  }, []), n = we(() => {
    t.current.forEach((o, s) => {
      r(o.eventTarget, o.type, s, o.options);
    });
  }, [
    r
  ]);
  return me(() => n, [
    n
  ]), {
    addGlobalListener: e,
    removeGlobalListener: r,
    removeAllGlobalListeners: n
  };
}
function ny(t, e) {
  let { id: r, "aria-label": n, "aria-labelledby": o } = t;
  return r = Qi(r), o && n ? o = [
    .../* @__PURE__ */ new Set([
      r,
      ...o.trim().split(/\s+/)
    ])
  ].join(" ") : o && (o = o.trim().split(/\s+/).join(" ")), !n && !o && e && (n = e), {
    id: r,
    "aria-label": n,
    "aria-labelledby": o
  };
}
function oy() {
  return typeof window.ResizeObserver < "u";
}
function nu(t) {
  const { ref: e, box: r, onResize: n } = t;
  me(() => {
    let o = e == null ? void 0 : e.current;
    if (o)
      if (oy()) {
        const s = new window.ResizeObserver((i) => {
          i.length && n();
        });
        return s.observe(o, {
          box: r
        }), () => {
          o && s.unobserve(o);
        };
      } else
        return window.addEventListener("resize", n, !1), () => {
          window.removeEventListener("resize", n, !1);
        };
  }, [
    n,
    e,
    r
  ]);
}
function th(t, e) {
  nt(() => {
    if (t && t.ref && e)
      return t.ref.current = e.current, () => {
        t.ref && (t.ref.current = null);
      };
  });
}
function pl(t, e) {
  if (!t) return !1;
  let r = window.getComputedStyle(t), n = /(auto|scroll)/.test(r.overflow + r.overflowX + r.overflowY);
  return n && e && (n = t.scrollHeight !== t.clientHeight || t.scrollWidth !== t.clientWidth), n;
}
function rh(t, e) {
  let r = t;
  for (pl(r, e) && (r = r.parentElement); r && !pl(r, e); ) r = r.parentElement;
  return r || document.scrollingElement || document.documentElement;
}
const sy = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function Ta(t) {
  return t instanceof HTMLInputElement && !sy.has(t.type) || t instanceof HTMLTextAreaElement || t instanceof HTMLElement && t.isContentEditable;
}
function hl(t) {
  return t.pointerType === "" && t.isTrusted ? !0 : kd() && t.pointerType ? t.type === "click" && t.buttons === 1 : t.detail === 0 && !t.pointerType;
}
function iy(t) {
  return !kd() && t.width === 0 && t.height === 0 || t.width === 1 && t.height === 1 && t.pressure === 0 && t.detail === 0 && t.pointerType === "mouse";
}
const ay = typeof Element < "u" && "checkVisibility" in Element.prototype;
function ly(t) {
  const e = Xt(t);
  if (!(t instanceof e.HTMLElement) && !(t instanceof e.SVGElement)) return !1;
  let { display: r, visibility: n } = t.style, o = r !== "none" && n !== "hidden" && n !== "collapse";
  if (o) {
    const { getComputedStyle: s } = t.ownerDocument.defaultView;
    let { display: i, visibility: a } = s(t);
    o = i !== "none" && a !== "hidden" && a !== "collapse";
  }
  return o;
}
function dy(t, e) {
  return !t.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !t.hasAttribute("data-react-aria-prevent-focus") && (t.nodeName === "DETAILS" && e && e.nodeName !== "SUMMARY" ? t.hasAttribute("open") : !0);
}
function Cd(t, e) {
  return ay ? t.checkVisibility({
    visibilityProperty: !0
  }) && !t.closest("[data-react-aria-prevent-focus]") : t.nodeName !== "#comment" && ly(t) && dy(t, e) && (!t.parentElement || Cd(t.parentElement, t));
}
const Sd = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable^="false"])',
  "permission"
], cy = Sd.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
Sd.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const uy = Sd.join(':not([hidden]):not([tabindex="-1"]),');
function nh(t) {
  return t.matches(cy) && Cd(t) && !oh(t);
}
function fy(t) {
  return t.matches(uy) && Cd(t) && !oh(t);
}
function oh(t) {
  let e = t;
  for (; e != null; ) {
    if (e instanceof e.ownerDocument.defaultView.HTMLElement && e.inert) return !0;
    e = e.parentElement;
  }
  return !1;
}
function py(t, e, r) {
  let [n, o] = de(t || e), s = te(t !== void 0), i = t !== void 0;
  me(() => {
    let d = s.current;
    d !== i && process.env.NODE_ENV !== "production" && console.warn(`WARN: A component changed from ${d ? "controlled" : "uncontrolled"} to ${i ? "controlled" : "uncontrolled"}.`), s.current = i;
  }, [
    i
  ]);
  let a = i ? t : n, l = we((d, ...c) => {
    let u = (f, ...p) => {
      r && (Object.is(a, f) || r(f, ...p)), i || (a = f);
    };
    typeof d == "function" ? (process.env.NODE_ENV !== "production" && console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), o((p, ...h) => {
      let g = d(i ? a : p, ...h);
      return u(g, ...c), i ? p : g;
    })) : (i || o(d), u(d, ...c));
  }, [
    i,
    a,
    r
  ]);
  return [
    a,
    l
  ];
}
function ml(t, e = -1 / 0, r = 1 / 0) {
  return Math.min(Math.max(t, e), r);
}
const ur = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
}, Js = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, hy = {
  top: "left",
  left: "top"
}, gl = {
  top: "height",
  left: "width"
}, sh = {
  width: "totalWidth",
  height: "totalHeight"
}, us = {};
let pt = typeof document < "u" ? window.visualViewport : null;
function ou(t) {
  let e = 0, r = 0, n = 0, o = 0, s = 0, i = 0, a = {};
  var l;
  let d = ((l = pt == null ? void 0 : pt.scale) !== null && l !== void 0 ? l : 1) > 1;
  if (t.tagName === "BODY") {
    let h = document.documentElement;
    n = h.clientWidth, o = h.clientHeight;
    var c;
    e = (c = pt == null ? void 0 : pt.width) !== null && c !== void 0 ? c : n;
    var u;
    r = (u = pt == null ? void 0 : pt.height) !== null && u !== void 0 ? u : o, a.top = h.scrollTop || t.scrollTop, a.left = h.scrollLeft || t.scrollLeft, pt && (s = pt.offsetTop, i = pt.offsetLeft);
  } else
    ({ width: e, height: r, top: s, left: i } = Xn(t, !1)), a.top = t.scrollTop, a.left = t.scrollLeft, n = e, o = r;
  if (Zp() && (t.tagName === "BODY" || t.tagName === "HTML") && d) {
    a.top = 0, a.left = 0;
    var f;
    s = (f = pt == null ? void 0 : pt.pageTop) !== null && f !== void 0 ? f : 0;
    var p;
    i = (p = pt == null ? void 0 : pt.pageLeft) !== null && p !== void 0 ? p : 0;
  }
  return {
    width: e,
    height: r,
    totalWidth: n,
    totalHeight: o,
    scroll: a,
    top: s,
    left: i
  };
}
function my(t) {
  return {
    top: t.scrollTop,
    left: t.scrollLeft,
    width: t.scrollWidth,
    height: t.scrollHeight
  };
}
function su(t, e, r, n, o, s, i) {
  var a;
  let l = (a = o.scroll[t]) !== null && a !== void 0 ? a : 0, d = n[gl[t]], c = n.scroll[ur[t]] + s, u = d + n.scroll[ur[t]] - s, f = e - l + i[t] - n[ur[t]], p = e - l + r + i[t] - n[ur[t]];
  return f < c ? c - f : p > u ? Math.max(u - p, c - f) : 0;
}
function gy(t) {
  let e = window.getComputedStyle(t);
  return {
    top: parseInt(e.marginTop, 10) || 0,
    bottom: parseInt(e.marginBottom, 10) || 0,
    left: parseInt(e.marginLeft, 10) || 0,
    right: parseInt(e.marginRight, 10) || 0
  };
}
function iu(t) {
  if (us[t]) return us[t];
  let [e, r] = t.split(" "), n = ur[e] || "right", o = hy[n];
  ur[r] || (r = "center");
  let s = gl[n], i = gl[o];
  return us[t] = {
    placement: e,
    crossPlacement: r,
    axis: n,
    crossAxis: o,
    size: s,
    crossSize: i
  }, us[t];
}
function Aa(t, e, r, n, o, s, i, a, l, d) {
  let { placement: c, crossPlacement: u, axis: f, crossAxis: p, size: h, crossSize: g } = n, b = {};
  var y;
  b[p] = (y = t[p]) !== null && y !== void 0 ? y : 0;
  var $, k, w, C;
  u === "center" ? b[p] += ((($ = t[g]) !== null && $ !== void 0 ? $ : 0) - ((k = r[g]) !== null && k !== void 0 ? k : 0)) / 2 : u !== p && (b[p] += ((w = t[g]) !== null && w !== void 0 ? w : 0) - ((C = r[g]) !== null && C !== void 0 ? C : 0)), b[p] += s;
  const T = t[p] - r[g] + l + d, H = t[p] + t[g] - l - d;
  if (b[p] = ml(b[p], T, H), c === f) {
    const O = a ? i[h] : e[sh[h]];
    b[Js[f]] = Math.floor(O - t[f] + o);
  } else b[f] = Math.floor(t[f] + t[h] + o);
  return b;
}
function by(t, e, r, n, o, s, i, a) {
  const l = n ? r.height : e[sh.height];
  var d;
  let c = t.top != null ? r.top + t.top : r.top + (l - ((d = t.bottom) !== null && d !== void 0 ? d : 0) - i);
  var u, f, p, h, g, b;
  let y = a !== "top" ? (
    // We want the distance between the top of the overlay to the bottom of the boundary
    Math.max(0, e.height + e.top + ((u = e.scroll.top) !== null && u !== void 0 ? u : 0) - c - (((f = o.top) !== null && f !== void 0 ? f : 0) + ((p = o.bottom) !== null && p !== void 0 ? p : 0) + s))
  ) : Math.max(0, c + i - (e.top + ((h = e.scroll.top) !== null && h !== void 0 ? h : 0)) - (((g = o.top) !== null && g !== void 0 ? g : 0) + ((b = o.bottom) !== null && b !== void 0 ? b : 0) + s));
  return Math.min(e.height - s * 2, y);
}
function au(t, e, r, n, o, s) {
  let { placement: i, axis: a, size: l } = s;
  var d, c;
  if (i === a) return Math.max(0, r[a] - t[a] - ((d = t.scroll[a]) !== null && d !== void 0 ? d : 0) + e[a] - ((c = n[a]) !== null && c !== void 0 ? c : 0) - n[Js[a]] - o);
  var u;
  return Math.max(0, t[l] + t[a] + t.scroll[a] - e[a] - r[a] - r[l] - ((u = n[a]) !== null && u !== void 0 ? u : 0) - n[Js[a]] - o);
}
function yy(t, e, r, n, o, s, i, a, l, d, c, u, f, p, h, g) {
  let b = iu(t), { size: y, crossAxis: $, crossSize: k, placement: w, crossPlacement: C } = b, T = Aa(e, a, r, b, c, u, d, f, h, g), H = c, O = au(a, d, e, o, s + c, b);
  if (i && n[y] > O) {
    let _ = iu(`${Js[w]} ${C}`), W = Aa(e, a, r, _, c, u, d, f, h, g);
    au(a, d, e, o, s + c, _) > O && (b = _, T = W, H = c);
  }
  let j = "bottom";
  b.axis === "top" ? b.placement === "top" ? j = "top" : b.placement === "bottom" && (j = "bottom") : b.crossAxis === "top" && (b.crossPlacement === "top" ? j = "bottom" : b.crossPlacement === "bottom" && (j = "top"));
  let F = su($, T[$], r[k], a, l, s, d);
  T[$] += F;
  let v = by(T, a, d, f, o, s, r.height, j);
  p && p < v && (v = p), r.height = Math.min(r.height, v), T = Aa(e, a, r, b, H, u, d, f, h, g), F = su($, T[$], r[k], a, l, s, d), T[$] += F;
  let M = {}, E = e[$] - T[$] - o[ur[$]], N = E + 0.5 * e[k];
  const R = h / 2 + g;
  var x, P, I, D;
  const L = ur[$] === "left" ? ((x = o.left) !== null && x !== void 0 ? x : 0) + ((P = o.right) !== null && P !== void 0 ? P : 0) : ((I = o.top) !== null && I !== void 0 ? I : 0) + ((D = o.bottom) !== null && D !== void 0 ? D : 0), A = r[k] - L - h / 2 - g, z = e[$] + h / 2 - (T[$] + o[ur[$]]), Y = e[$] + e[k] - h / 2 - (T[$] + o[ur[$]]), q = ml(N, z, Y);
  M[$] = ml(q, R, A), { placement: w, crossPlacement: C } = b, h ? E = M[$] : C === "right" ? E += e[k] : C === "center" && (E += e[k] / 2);
  let ee = w === "left" || w === "top" ? r[y] : 0, B = {
    x: w === "top" || w === "bottom" ? E : ee,
    y: w === "left" || w === "right" ? E : ee
  };
  return {
    position: T,
    maxHeight: v,
    arrowOffsetLeft: M.left,
    arrowOffsetTop: M.top,
    placement: w,
    triggerAnchorPoint: B
  };
}
function vy(t) {
  let { placement: e, targetNode: r, overlayNode: n, scrollNode: o, padding: s, shouldFlip: i, boundaryElement: a, offset: l, crossOffset: d, maxHeight: c, arrowSize: u = 0, arrowBoundaryOffset: f = 0 } = t, p = n instanceof HTMLElement ? $y(n) : document.documentElement, h = p === document.documentElement;
  const g = window.getComputedStyle(p).position;
  let b = !!g && g !== "static", y = h ? Xn(r, !1) : lu(r, p, !1);
  if (!h) {
    let { marginTop: M, marginLeft: E } = window.getComputedStyle(r);
    y.top += parseInt(M, 10) || 0, y.left += parseInt(E, 10) || 0;
  }
  let $ = Xn(n, !0), k = gy(n);
  var w, C;
  $.width += ((w = k.left) !== null && w !== void 0 ? w : 0) + ((C = k.right) !== null && C !== void 0 ? C : 0);
  var T, H;
  $.height += ((T = k.top) !== null && T !== void 0 ? T : 0) + ((H = k.bottom) !== null && H !== void 0 ? H : 0);
  let O = my(o), j = ou(a), F = ou(p), v = a.tagName === "BODY" ? Xn(p, !1) : lu(p, a, !1);
  return p.tagName === "HTML" && a.tagName === "BODY" && (F.scroll.top = 0, F.scroll.left = 0), yy(e, y, $, O, k, s, i, j, F, v, l, d, b, c, u, f);
}
function Nd(t, e) {
  let { top: r, left: n, width: o, height: s } = t.getBoundingClientRect();
  return e && t instanceof t.ownerDocument.defaultView.HTMLElement && (o = t.offsetWidth, s = t.offsetHeight), {
    top: r,
    left: n,
    width: o,
    height: s
  };
}
function Xn(t, e) {
  let { top: r, left: n, width: o, height: s } = Nd(t, e), { scrollTop: i, scrollLeft: a, clientTop: l, clientLeft: d } = document.documentElement;
  return {
    top: r + i - l,
    left: n + a - d,
    width: o,
    height: s
  };
}
function lu(t, e, r) {
  let n = window.getComputedStyle(t), o;
  if (n.position === "fixed") o = Nd(t, r);
  else {
    o = Xn(t, r);
    let s = Xn(e, r), i = window.getComputedStyle(e);
    s.top += (parseInt(i.borderTopWidth, 10) || 0) - e.scrollTop, s.left += (parseInt(i.borderLeftWidth, 10) || 0) - e.scrollLeft, o.top -= s.top, o.left -= s.left;
  }
  return o.top -= parseInt(n.marginTop, 10) || 0, o.left -= parseInt(n.marginLeft, 10) || 0, o;
}
function $y(t) {
  let e = t.offsetParent;
  if (e && e === document.body && window.getComputedStyle(e).position === "static" && !du(e) && (e = document.documentElement), e == null)
    for (e = t.parentElement; e && !du(e); ) e = e.parentElement;
  return e || document.documentElement;
}
function du(t) {
  let e = window.getComputedStyle(t);
  return e.transform !== "none" || /transform|perspective/.test(e.willChange) || e.filter !== "none" || e.contain === "paint" || "backdropFilter" in e && e.backdropFilter !== "none" || "WebkitBackdropFilter" in e && e.WebkitBackdropFilter !== "none";
}
const ih = /* @__PURE__ */ new WeakMap();
function xy(t) {
  let { triggerRef: e, isOpen: r, onClose: n } = t;
  me(() => {
    if (!r || n === null) return;
    let o = (s) => {
      let i = s.target;
      if (!e.current || i instanceof Node && !i.contains(e.current) || s.target instanceof HTMLInputElement || s.target instanceof HTMLTextAreaElement) return;
      let a = n || ih.get(e.current);
      a && a();
    };
    return window.addEventListener("scroll", o, !0), () => {
      window.removeEventListener("scroll", o, !0);
    };
  }, [
    r,
    n,
    e
  ]);
}
let rt = typeof document < "u" ? window.visualViewport : null;
function ah(t) {
  let { direction: e } = qp(), { arrowSize: r, targetRef: n, overlayRef: o, arrowRef: s, scrollRef: i = o, placement: a = "bottom", containerPadding: l = 12, shouldFlip: d = !0, boundaryElement: c = typeof document < "u" ? document.body : null, offset: u = 0, crossOffset: f = 0, shouldUpdatePosition: p = !0, isOpen: h = !0, onClose: g, maxHeight: b, arrowBoundaryOffset: y = 0 } = t, [$, k] = de(null), w = [
    p,
    a,
    o.current,
    n.current,
    s == null ? void 0 : s.current,
    i.current,
    l,
    d,
    c,
    u,
    f,
    h,
    e,
    b,
    y,
    r
  ], C = te(rt == null ? void 0 : rt.scale);
  me(() => {
    h && (C.current = rt == null ? void 0 : rt.scale);
  }, [
    h
  ]);
  let T = we(() => {
    if (p === !1 || !h || !o.current || !n.current || !c || (rt == null ? void 0 : rt.scale) !== C.current) return;
    let M = null;
    if (i.current && i.current.contains(document.activeElement)) {
      var E;
      let L = (E = document.activeElement) === null || E === void 0 ? void 0 : E.getBoundingClientRect(), A = i.current.getBoundingClientRect();
      var N;
      if (M = {
        type: "top",
        offset: ((N = L == null ? void 0 : L.top) !== null && N !== void 0 ? N : 0) - A.top
      }, M.offset > A.height / 2) {
        M.type = "bottom";
        var R;
        M.offset = ((R = L == null ? void 0 : L.bottom) !== null && R !== void 0 ? R : 0) - A.bottom;
      }
    }
    let x = o.current;
    if (!b && o.current) {
      var P;
      x.style.top = "0px", x.style.bottom = "";
      var I;
      x.style.maxHeight = ((I = (P = window.visualViewport) === null || P === void 0 ? void 0 : P.height) !== null && I !== void 0 ? I : window.innerHeight) + "px";
    }
    let D = vy({
      placement: ky(a, e),
      overlayNode: o.current,
      targetNode: n.current,
      scrollNode: i.current || o.current,
      padding: l,
      shouldFlip: d,
      boundaryElement: c,
      offset: u,
      crossOffset: f,
      maxHeight: b,
      arrowSize: r ?? (s != null && s.current ? Nd(s.current, !0).width : 0),
      arrowBoundaryOffset: y
    });
    if (D.position) {
      if (x.style.top = "", x.style.bottom = "", x.style.left = "", x.style.right = "", Object.keys(D.position).forEach((L) => x.style[L] = D.position[L] + "px"), x.style.maxHeight = D.maxHeight != null ? D.maxHeight + "px" : "", M && document.activeElement && i.current) {
        let L = document.activeElement.getBoundingClientRect(), A = i.current.getBoundingClientRect(), z = L[M.type] - A[M.type];
        i.current.scrollTop += z - M.offset;
      }
      k(D);
    }
  }, w);
  nt(T, w), wy(T), nu({
    ref: o,
    onResize: T
  }), nu({
    ref: n,
    onResize: T
  });
  let H = te(!1);
  nt(() => {
    let M, E = () => {
      H.current = !0, clearTimeout(M), M = setTimeout(() => {
        H.current = !1;
      }, 500), T();
    }, N = () => {
      H.current && E();
    };
    return rt == null || rt.addEventListener("resize", E), rt == null || rt.addEventListener("scroll", N), () => {
      rt == null || rt.removeEventListener("resize", E), rt == null || rt.removeEventListener("scroll", N);
    };
  }, [
    T
  ]);
  let O = we(() => {
    H.current || g == null || g();
  }, [
    g,
    H
  ]);
  xy({
    triggerRef: n,
    isOpen: h,
    onClose: g && O
  });
  var j, F, v;
  return {
    overlayProps: {
      style: {
        position: $ ? "absolute" : "fixed",
        top: $ ? void 0 : 0,
        left: $ ? void 0 : 0,
        zIndex: 1e5,
        ...$ == null ? void 0 : $.position,
        maxHeight: (j = $ == null ? void 0 : $.maxHeight) !== null && j !== void 0 ? j : "100vh"
      }
    },
    placement: (F = $ == null ? void 0 : $.placement) !== null && F !== void 0 ? F : null,
    triggerAnchorPoint: (v = $ == null ? void 0 : $.triggerAnchorPoint) !== null && v !== void 0 ? v : null,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: $ == null ? void 0 : $.arrowOffsetLeft,
        top: $ == null ? void 0 : $.arrowOffsetTop
      }
    },
    updatePosition: T
  };
}
function wy(t) {
  nt(() => (window.addEventListener("resize", t, !1), () => {
    window.removeEventListener("resize", t, !1);
  }), [
    t
  ]);
}
function ky(t, e) {
  return e === "rtl" ? t.replace("start", "right").replace("end", "left") : t.replace("start", "left").replace("end", "right");
}
function Td(t) {
  let e = t;
  return e.nativeEvent = t, e.isDefaultPrevented = () => e.defaultPrevented, e.isPropagationStopped = () => e.cancelBubble, e.persist = () => {
  }, e;
}
function lh(t, e) {
  Object.defineProperty(t, "target", {
    value: e
  }), Object.defineProperty(t, "currentTarget", {
    value: e
  });
}
function dh(t) {
  let e = te({
    isFocused: !1,
    observer: null
  });
  nt(() => {
    const n = e.current;
    return () => {
      n.observer && (n.observer.disconnect(), n.observer = null);
    };
  }, []);
  let r = Yt((n) => {
    t == null || t(n);
  });
  return we((n) => {
    if (n.target instanceof HTMLButtonElement || n.target instanceof HTMLInputElement || n.target instanceof HTMLTextAreaElement || n.target instanceof HTMLSelectElement) {
      e.current.isFocused = !0;
      let o = n.target, s = (i) => {
        if (e.current.isFocused = !1, o.disabled) {
          let a = Td(i);
          r(a);
        }
        e.current.observer && (e.current.observer.disconnect(), e.current.observer = null);
      };
      o.addEventListener("focusout", s, {
        once: !0
      }), e.current.observer = new MutationObserver(() => {
        if (e.current.isFocused && o.disabled) {
          var i;
          (i = e.current.observer) === null || i === void 0 || i.disconnect();
          let a = o === document.activeElement ? null : document.activeElement;
          o.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: a
          })), o.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: a
          }));
        }
      }), e.current.observer.observe(o, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    r
  ]);
}
let qs = !1;
function cu(t) {
  for (; t && !nh(t); ) t = t.parentElement;
  let e = Xt(t), r = e.document.activeElement;
  if (!r || r === t) return;
  qs = !0;
  let n = !1, o = (c) => {
    (c.target === r || n) && c.stopImmediatePropagation();
  }, s = (c) => {
    (c.target === r || n) && (c.stopImmediatePropagation(), !t && !n && (n = !0, ro(r), l()));
  }, i = (c) => {
    (c.target === t || n) && c.stopImmediatePropagation();
  }, a = (c) => {
    (c.target === t || n) && (c.stopImmediatePropagation(), n || (n = !0, ro(r), l()));
  };
  e.addEventListener("blur", o, !0), e.addEventListener("focusout", s, !0), e.addEventListener("focusin", a, !0), e.addEventListener("focus", i, !0);
  let l = () => {
    cancelAnimationFrame(d), e.removeEventListener("blur", o, !0), e.removeEventListener("focusout", s, !0), e.removeEventListener("focusin", a, !0), e.removeEventListener("focus", i, !0), qs = !1, n = !1;
  }, d = requestAnimationFrame(l);
  return l;
}
let Kn = "default", bl = "", _s = /* @__PURE__ */ new WeakMap();
function uu(t) {
  if (na()) {
    if (Kn === "default") {
      const e = Ie(t);
      bl = e.documentElement.style.webkitUserSelect, e.documentElement.style.webkitUserSelect = "none";
    }
    Kn = "disabled";
  } else if (t instanceof HTMLElement || t instanceof SVGElement) {
    let e = "userSelect" in t.style ? "userSelect" : "webkitUserSelect";
    _s.set(t, t.style[e]), t.style[e] = "none";
  }
}
function Ma(t) {
  if (na()) {
    if (Kn !== "disabled") return;
    Kn = "restoring", setTimeout(() => {
      eh(() => {
        if (Kn === "restoring") {
          const e = Ie(t);
          e.documentElement.style.webkitUserSelect === "none" && (e.documentElement.style.webkitUserSelect = bl || ""), bl = "", Kn = "default";
        }
      });
    }, 300);
  } else if ((t instanceof HTMLElement || t instanceof SVGElement) && t && _s.has(t)) {
    let e = _s.get(t), r = "userSelect" in t.style ? "userSelect" : "webkitUserSelect";
    t.style[r] === "none" && (t.style[r] = e), t.getAttribute("style") === "" && t.removeAttribute("style"), _s.delete(t);
  }
}
const Ad = le.createContext({
  register: () => {
  }
});
Ad.displayName = "PressResponderContext";
function Ey(t, e) {
  return e.get ? e.get.call(t) : e.value;
}
function ch(t, e, r) {
  if (!e.has(t)) throw new TypeError("attempted to " + r + " private field on non-instance");
  return e.get(t);
}
function Cy(t, e) {
  var r = ch(t, e, "get");
  return Ey(t, r);
}
function Sy(t, e, r) {
  if (e.set) e.set.call(t, r);
  else {
    if (!e.writable)
      throw new TypeError("attempted to set read only private field");
    e.value = r;
  }
}
function fu(t, e, r) {
  var n = ch(t, e, "set");
  return Sy(t, n, r), r;
}
function Ny(t) {
  let e = Qt(Ad);
  if (e) {
    let { register: r, ...n } = e;
    t = Rr(n, t), r();
  }
  return th(e, t.ref), t;
}
var fs = /* @__PURE__ */ new WeakMap();
class ps {
  continuePropagation() {
    fu(this, fs, !1);
  }
  get shouldStopPropagation() {
    return Cy(this, fs);
  }
  constructor(e, r, n, o) {
    L2(this, fs, {
      writable: !0,
      value: void 0
    }), fu(this, fs, !0);
    var s;
    let i = (s = o == null ? void 0 : o.target) !== null && s !== void 0 ? s : n.currentTarget;
    const a = i == null ? void 0 : i.getBoundingClientRect();
    let l, d = 0, c, u = null;
    n.clientX != null && n.clientY != null && (c = n.clientX, u = n.clientY), a && (c != null && u != null ? (l = c - a.left, d = u - a.top) : (l = a.width / 2, d = a.height / 2)), this.type = e, this.pointerType = r, this.target = n.currentTarget, this.shiftKey = n.shiftKey, this.metaKey = n.metaKey, this.ctrlKey = n.ctrlKey, this.altKey = n.altKey, this.x = l, this.y = d;
  }
}
const pu = Symbol("linkClicked"), hu = "react-aria-pressable-style", mu = "data-react-aria-pressable";
function Ty(t) {
  let { onPress: e, onPressChange: r, onPressStart: n, onPressEnd: o, onPressUp: s, onClick: i, isDisabled: a, isPressed: l, preventFocusOnPress: d, shouldCancelOnPointerExit: c, allowTextSelectionOnPress: u, ref: f, ...p } = Ny(t), [h, g] = de(!1), b = te({
    isPressed: !1,
    ignoreEmulatedMouseEvents: !1,
    didFirePressStart: !1,
    isTriggeringEvent: !1,
    activePointerId: null,
    target: null,
    isOverTarget: !1,
    pointerType: null,
    disposables: []
  }), { addGlobalListener: y, removeAllGlobalListeners: $ } = Ed(), k = Yt((v, M) => {
    let E = b.current;
    if (a || E.didFirePressStart) return !1;
    let N = !0;
    if (E.isTriggeringEvent = !0, n) {
      let R = new ps("pressstart", M, v);
      n(R), N = R.shouldStopPropagation;
    }
    return r && r(!0), E.isTriggeringEvent = !1, E.didFirePressStart = !0, g(!0), N;
  }), w = Yt((v, M, E = !0) => {
    let N = b.current;
    if (!N.didFirePressStart) return !1;
    N.didFirePressStart = !1, N.isTriggeringEvent = !0;
    let R = !0;
    if (o) {
      let x = new ps("pressend", M, v);
      o(x), R = x.shouldStopPropagation;
    }
    if (r && r(!1), g(!1), e && E && !a) {
      let x = new ps("press", M, v);
      e(x), R && (R = x.shouldStopPropagation);
    }
    return N.isTriggeringEvent = !1, R;
  }), C = Yt((v, M) => {
    let E = b.current;
    if (a) return !1;
    if (s) {
      E.isTriggeringEvent = !0;
      let N = new ps("pressup", M, v);
      return s(N), E.isTriggeringEvent = !1, N.shouldStopPropagation;
    }
    return !0;
  }), T = Yt((v) => {
    let M = b.current;
    if (M.isPressed && M.target) {
      M.didFirePressStart && M.pointerType != null && w(ln(M.target, v), M.pointerType, !1), M.isPressed = !1, M.isOverTarget = !1, M.activePointerId = null, M.pointerType = null, $(), u || Ma(M.target);
      for (let E of M.disposables) E();
      M.disposables = [];
    }
  }), H = Yt((v) => {
    c && T(v);
  }), O = Yt((v) => {
    a || i == null || i(v);
  }), j = Yt((v, M) => {
    if (!a && i) {
      let E = new MouseEvent("click", v);
      lh(E, M), i(Td(E));
    }
  }), F = Ye(() => {
    let v = b.current, M = {
      onKeyDown(N) {
        if (Pa(N.nativeEvent, N.currentTarget) && Ge(N.currentTarget, Ae(N.nativeEvent))) {
          var R;
          yu(Ae(N.nativeEvent), N.key) && N.preventDefault();
          let x = !0;
          if (!v.isPressed && !N.repeat) {
            v.target = N.currentTarget, v.isPressed = !0, v.pointerType = "keyboard", x = k(N, "keyboard");
            let P = N.currentTarget, I = (D) => {
              Pa(D, P) && !D.repeat && Ge(P, Ae(D)) && v.target && C(ln(v.target, D), "keyboard");
            };
            y(Ie(N.currentTarget), "keyup", ea(I, E), !0);
          }
          x && N.stopPropagation(), N.metaKey && no() && ((R = v.metaKeyEvents) === null || R === void 0 || R.set(N.key, N.nativeEvent));
        } else N.key === "Meta" && (v.metaKeyEvents = /* @__PURE__ */ new Map());
      },
      onClick(N) {
        if (!(N && !Ge(N.currentTarget, Ae(N.nativeEvent))) && N && N.button === 0 && !v.isTriggeringEvent && !Bo.isOpening) {
          let R = !0;
          if (a && N.preventDefault(), !v.ignoreEmulatedMouseEvents && !v.isPressed && (v.pointerType === "virtual" || hl(N.nativeEvent))) {
            let x = k(N, "virtual"), P = C(N, "virtual"), I = w(N, "virtual");
            O(N), R = x && P && I;
          } else if (v.isPressed && v.pointerType !== "keyboard") {
            let x = v.pointerType || N.nativeEvent.pointerType || "virtual", P = C(ln(N.currentTarget, N), x), I = w(ln(N.currentTarget, N), x, !0);
            R = P && I, v.isOverTarget = !1, O(N), T(N);
          }
          v.ignoreEmulatedMouseEvents = !1, R && N.stopPropagation();
        }
      }
    }, E = (N) => {
      var R;
      if (v.isPressed && v.target && Pa(N, v.target)) {
        var x;
        yu(Ae(N), N.key) && N.preventDefault();
        let I = Ae(N), D = Ge(v.target, Ae(N));
        w(ln(v.target, N), "keyboard", D), D && j(N, v.target), $(), N.key !== "Enter" && Md(v.target) && Ge(v.target, I) && !N[pu] && (N[pu] = !0, Bo(v.target, N, !1)), v.isPressed = !1, (x = v.metaKeyEvents) === null || x === void 0 || x.delete(N.key);
      } else if (N.key === "Meta" && (!((R = v.metaKeyEvents) === null || R === void 0) && R.size)) {
        var P;
        let I = v.metaKeyEvents;
        v.metaKeyEvents = void 0;
        for (let D of I.values()) (P = v.target) === null || P === void 0 || P.dispatchEvent(new KeyboardEvent("keyup", D));
      }
    };
    if (typeof PointerEvent < "u") {
      M.onPointerDown = (x) => {
        if (x.button !== 0 || !Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        if (iy(x.nativeEvent)) {
          v.pointerType = "virtual";
          return;
        }
        v.pointerType = x.pointerType;
        let P = !0;
        if (!v.isPressed) {
          v.isPressed = !0, v.isOverTarget = !0, v.activePointerId = x.pointerId, v.target = x.currentTarget, u || uu(v.target), P = k(x, v.pointerType);
          let I = Ae(x.nativeEvent);
          "releasePointerCapture" in I && I.releasePointerCapture(x.pointerId), y(Ie(x.currentTarget), "pointerup", N, !1), y(Ie(x.currentTarget), "pointercancel", R, !1);
        }
        P && x.stopPropagation();
      }, M.onMouseDown = (x) => {
        if (Ge(x.currentTarget, Ae(x.nativeEvent)) && x.button === 0) {
          if (d) {
            let P = cu(x.target);
            P && v.disposables.push(P);
          }
          x.stopPropagation();
        }
      }, M.onPointerUp = (x) => {
        !Ge(x.currentTarget, Ae(x.nativeEvent)) || v.pointerType === "virtual" || x.button === 0 && !v.isPressed && C(x, v.pointerType || x.pointerType);
      }, M.onPointerEnter = (x) => {
        x.pointerId === v.activePointerId && v.target && !v.isOverTarget && v.pointerType != null && (v.isOverTarget = !0, k(ln(v.target, x), v.pointerType));
      }, M.onPointerLeave = (x) => {
        x.pointerId === v.activePointerId && v.target && v.isOverTarget && v.pointerType != null && (v.isOverTarget = !1, w(ln(v.target, x), v.pointerType, !1), H(x));
      };
      let N = (x) => {
        if (x.pointerId === v.activePointerId && v.isPressed && x.button === 0 && v.target) {
          if (Ge(v.target, Ae(x)) && v.pointerType != null) {
            let P = !1, I = setTimeout(() => {
              v.isPressed && v.target instanceof HTMLElement && (P ? T(x) : (ro(v.target), v.target.click()));
            }, 80);
            y(x.currentTarget, "click", () => P = !0, !0), v.disposables.push(() => clearTimeout(I));
          } else T(x);
          v.isOverTarget = !1;
        }
      }, R = (x) => {
        T(x);
      };
      M.onDragStart = (x) => {
        Ge(x.currentTarget, Ae(x.nativeEvent)) && T(x);
      };
    } else if (process.env.NODE_ENV === "test") {
      M.onMouseDown = (x) => {
        if (x.button !== 0 || !Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        if (v.ignoreEmulatedMouseEvents) {
          x.stopPropagation();
          return;
        }
        if (v.isPressed = !0, v.isOverTarget = !0, v.target = x.currentTarget, v.pointerType = hl(x.nativeEvent) ? "virtual" : "mouse", v1(() => k(x, v.pointerType)) && x.stopPropagation(), d) {
          let I = cu(x.target);
          I && v.disposables.push(I);
        }
        y(Ie(x.currentTarget), "mouseup", N, !1);
      }, M.onMouseEnter = (x) => {
        if (!Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        let P = !0;
        v.isPressed && !v.ignoreEmulatedMouseEvents && v.pointerType != null && (v.isOverTarget = !0, P = k(x, v.pointerType)), P && x.stopPropagation();
      }, M.onMouseLeave = (x) => {
        if (!Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        let P = !0;
        v.isPressed && !v.ignoreEmulatedMouseEvents && v.pointerType != null && (v.isOverTarget = !1, P = w(x, v.pointerType, !1), H(x)), P && x.stopPropagation();
      }, M.onMouseUp = (x) => {
        Ge(x.currentTarget, Ae(x.nativeEvent)) && !v.ignoreEmulatedMouseEvents && x.button === 0 && !v.isPressed && C(x, v.pointerType || "mouse");
      };
      let N = (x) => {
        if (x.button === 0) {
          if (v.ignoreEmulatedMouseEvents) {
            v.ignoreEmulatedMouseEvents = !1;
            return;
          }
          v.target && v.target.contains(x.target) && v.pointerType != null || T(x), v.isOverTarget = !1;
        }
      };
      M.onTouchStart = (x) => {
        if (!Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        let P = Ay(x.nativeEvent);
        if (!P) return;
        v.activePointerId = P.identifier, v.ignoreEmulatedMouseEvents = !0, v.isOverTarget = !0, v.isPressed = !0, v.target = x.currentTarget, v.pointerType = "touch", u || uu(v.target), k(Fr(v.target, x), v.pointerType) && x.stopPropagation(), y(Xt(x.currentTarget), "scroll", R, !0);
      }, M.onTouchMove = (x) => {
        if (!Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        if (!v.isPressed) {
          x.stopPropagation();
          return;
        }
        let P = gu(x.nativeEvent, v.activePointerId), I = !0;
        P && bu(P, x.currentTarget) ? !v.isOverTarget && v.pointerType != null && (v.isOverTarget = !0, I = k(Fr(v.target, x), v.pointerType)) : v.isOverTarget && v.pointerType != null && (v.isOverTarget = !1, I = w(Fr(v.target, x), v.pointerType, !1), H(Fr(v.target, x))), I && x.stopPropagation();
      }, M.onTouchEnd = (x) => {
        if (!Ge(x.currentTarget, Ae(x.nativeEvent))) return;
        if (!v.isPressed) {
          x.stopPropagation();
          return;
        }
        let P = gu(x.nativeEvent, v.activePointerId), I = !0;
        P && bu(P, x.currentTarget) && v.pointerType != null ? (C(Fr(v.target, x), v.pointerType), I = w(Fr(v.target, x), v.pointerType), j(x.nativeEvent, v.target)) : v.isOverTarget && v.pointerType != null && (I = w(Fr(v.target, x), v.pointerType, !1)), I && x.stopPropagation(), v.isPressed = !1, v.activePointerId = null, v.isOverTarget = !1, v.ignoreEmulatedMouseEvents = !0, v.target && !u && Ma(v.target), $();
      }, M.onTouchCancel = (x) => {
        Ge(x.currentTarget, Ae(x.nativeEvent)) && (x.stopPropagation(), v.isPressed && T(Fr(v.target, x)));
      };
      let R = (x) => {
        v.isPressed && Ge(Ae(x), v.target) && T({
          currentTarget: v.target,
          shiftKey: !1,
          ctrlKey: !1,
          metaKey: !1,
          altKey: !1
        });
      };
      M.onDragStart = (x) => {
        Ge(x.currentTarget, Ae(x.nativeEvent)) && T(x);
      };
    }
    return M;
  }, [
    y,
    a,
    d,
    $,
    u,
    T,
    H,
    w,
    k,
    C,
    O,
    j
  ]);
  return me(() => {
    if (!f || process.env.NODE_ENV === "test") return;
    const v = Ie(f.current);
    if (!v || !v.head || v.getElementById(hu)) return;
    const M = v.createElement("style");
    M.id = hu, M.textContent = `
@layer {
  [${mu}] {
    touch-action: pan-x pan-y pinch-zoom;
  }
}
    `.trim(), v.head.prepend(M);
  }, [
    f
  ]), me(() => {
    let v = b.current;
    return () => {
      var M;
      u || Ma((M = v.target) !== null && M !== void 0 ? M : void 0);
      for (let E of v.disposables) E();
      v.disposables = [];
    };
  }, [
    u
  ]), {
    isPressed: l || h,
    pressProps: Rr(p, F, {
      [mu]: !0
    })
  };
}
function Md(t) {
  return t.tagName === "A" && t.hasAttribute("href");
}
function Pa(t, e) {
  const { key: r, code: n } = t, o = e, s = o.getAttribute("role");
  return (r === "Enter" || r === " " || r === "Spacebar" || n === "Space") && !(o instanceof Xt(o).HTMLInputElement && !uh(o, r) || o instanceof Xt(o).HTMLTextAreaElement || o.isContentEditable) && // Links should only trigger with Enter key
  !((s === "link" || !s && Md(o)) && r !== "Enter");
}
function Ay(t) {
  const { targetTouches: e } = t;
  return e.length > 0 ? e[0] : null;
}
function gu(t, e) {
  const r = t.changedTouches;
  for (let n = 0; n < r.length; n++) {
    const o = r[n];
    if (o.identifier === e) return o;
  }
  return null;
}
function Fr(t, e) {
  let r = 0, n = 0;
  return e.targetTouches && e.targetTouches.length === 1 && (r = e.targetTouches[0].clientX, n = e.targetTouches[0].clientY), {
    currentTarget: t,
    shiftKey: e.shiftKey,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey,
    altKey: e.altKey,
    clientX: r,
    clientY: n
  };
}
function ln(t, e) {
  let r = e.clientX, n = e.clientY;
  return {
    currentTarget: t,
    shiftKey: e.shiftKey,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey,
    altKey: e.altKey,
    clientX: r,
    clientY: n
  };
}
function My(t) {
  let e = 0, r = 0;
  return t.width !== void 0 ? e = t.width / 2 : t.radiusX !== void 0 && (e = t.radiusX), t.height !== void 0 ? r = t.height / 2 : t.radiusY !== void 0 && (r = t.radiusY), {
    top: t.clientY - r,
    right: t.clientX + e,
    bottom: t.clientY + r,
    left: t.clientX - e
  };
}
function Py(t, e) {
  return !(t.left > e.right || e.left > t.right || t.top > e.bottom || e.top > t.bottom);
}
function bu(t, e) {
  let r = e.getBoundingClientRect(), n = My(t);
  return Py(r, n);
}
function Iy(t) {
  return t instanceof HTMLInputElement ? !1 : t instanceof HTMLButtonElement ? t.type !== "submit" && t.type !== "reset" : !Md(t);
}
function yu(t, e) {
  return t instanceof HTMLInputElement ? !uh(t, e) : Iy(t);
}
const Ry = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function uh(t, e) {
  return t.type === "checkbox" || t.type === "radio" ? e === " " : Ry.has(t.type);
}
let uo = null, yl = /* @__PURE__ */ new Set(), Mo = /* @__PURE__ */ new Map(), Cn = !1, vl = !1;
const Oy = {
  Tab: !0,
  Escape: !0
};
function Pd(t, e) {
  for (let r of yl) r(t, e);
}
function Ly(t) {
  return !(t.metaKey || !no() && t.altKey || t.ctrlKey || t.key === "Control" || t.key === "Shift" || t.key === "Meta");
}
function Xs(t) {
  Cn = !0, Ly(t) && (uo = "keyboard", Pd("keyboard", t));
}
function qt(t) {
  uo = "pointer", (t.type === "mousedown" || t.type === "pointerdown") && (Cn = !0, Pd("pointer", t));
}
function fh(t) {
  hl(t) && (Cn = !0, uo = "virtual");
}
function ph(t) {
  t.target === window || t.target === document || qs || !t.isTrusted || (!Cn && !vl && (uo = "virtual", Pd("virtual", t)), Cn = !1, vl = !1);
}
function hh() {
  qs || (Cn = !1, vl = !0);
}
function $l(t) {
  if (typeof window > "u" || typeof document > "u" || Mo.get(Xt(t))) return;
  const e = Xt(t), r = Ie(t);
  let n = e.HTMLElement.prototype.focus;
  e.HTMLElement.prototype.focus = function() {
    Cn = !0, n.apply(this, arguments);
  }, r.addEventListener("keydown", Xs, !0), r.addEventListener("keyup", Xs, !0), r.addEventListener("click", fh, !0), e.addEventListener("focus", ph, !0), e.addEventListener("blur", hh, !1), typeof PointerEvent < "u" ? (r.addEventListener("pointerdown", qt, !0), r.addEventListener("pointermove", qt, !0), r.addEventListener("pointerup", qt, !0)) : process.env.NODE_ENV === "test" && (r.addEventListener("mousedown", qt, !0), r.addEventListener("mousemove", qt, !0), r.addEventListener("mouseup", qt, !0)), e.addEventListener("beforeunload", () => {
    mh(t);
  }, {
    once: !0
  }), Mo.set(e, {
    focus: n
  });
}
const mh = (t, e) => {
  const r = Xt(t), n = Ie(t);
  e && n.removeEventListener("DOMContentLoaded", e), Mo.has(r) && (r.HTMLElement.prototype.focus = Mo.get(r).focus, n.removeEventListener("keydown", Xs, !0), n.removeEventListener("keyup", Xs, !0), n.removeEventListener("click", fh, !0), r.removeEventListener("focus", ph, !0), r.removeEventListener("blur", hh, !1), typeof PointerEvent < "u" ? (n.removeEventListener("pointerdown", qt, !0), n.removeEventListener("pointermove", qt, !0), n.removeEventListener("pointerup", qt, !0)) : process.env.NODE_ENV === "test" && (n.removeEventListener("mousedown", qt, !0), n.removeEventListener("mousemove", qt, !0), n.removeEventListener("mouseup", qt, !0)), Mo.delete(r));
};
function jy(t) {
  const e = Ie(t);
  let r;
  return e.readyState !== "loading" ? $l(t) : (r = () => {
    $l(t);
  }, e.addEventListener("DOMContentLoaded", r)), () => mh(t, r);
}
typeof document < "u" && jy();
function Id() {
  return uo !== "pointer";
}
function Rd() {
  return uo;
}
const Dy = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function _y(t, e, r) {
  let n = Ie(r == null ? void 0 : r.target);
  const o = typeof window < "u" ? Xt(r == null ? void 0 : r.target).HTMLInputElement : HTMLInputElement, s = typeof window < "u" ? Xt(r == null ? void 0 : r.target).HTMLTextAreaElement : HTMLTextAreaElement, i = typeof window < "u" ? Xt(r == null ? void 0 : r.target).HTMLElement : HTMLElement, a = typeof window < "u" ? Xt(r == null ? void 0 : r.target).KeyboardEvent : KeyboardEvent;
  return t = t || n.activeElement instanceof o && !Dy.has(n.activeElement.type) || n.activeElement instanceof s || n.activeElement instanceof i && n.activeElement.isContentEditable, !(t && e === "keyboard" && r instanceof a && !Oy[r.key]);
}
function Fy(t, e, r) {
  $l(), me(() => {
    let n = (o, s) => {
      _y(!!(r != null && r.isTextInput), o, s) && t(Id());
    };
    return yl.add(n), () => {
      yl.delete(n);
    };
  }, e);
}
function Zs(t) {
  const e = Ie(t), r = jt(e);
  if (Rd() === "virtual") {
    let n = r;
    eh(() => {
      jt(e) === n && t.isConnected && ro(t);
    });
  } else ro(t);
}
function gh(t) {
  let { isDisabled: e, onFocus: r, onBlur: n, onFocusChange: o } = t;
  const s = we((l) => {
    if (l.target === l.currentTarget)
      return n && n(l), o && o(!1), !0;
  }, [
    n,
    o
  ]), i = dh(s), a = we((l) => {
    const d = Ie(l.target), c = d ? jt(d) : jt();
    l.target === l.currentTarget && c === Ae(l.nativeEvent) && (r && r(l), o && o(!0), i(l));
  }, [
    o,
    r,
    i
  ]);
  return {
    focusProps: {
      onFocus: !e && (r || o || n) ? a : void 0,
      onBlur: !e && (n || o) ? s : void 0
    }
  };
}
function vu(t) {
  if (!t) return;
  let e = !0;
  return (r) => {
    let n = {
      ...r,
      preventDefault() {
        r.preventDefault();
      },
      isDefaultPrevented() {
        return r.isDefaultPrevented();
      },
      stopPropagation() {
        e && process.env.NODE_ENV !== "production" ? console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.") : e = !0;
      },
      continuePropagation() {
        e = !1;
      },
      isPropagationStopped() {
        return e;
      }
    };
    t(n), e && r.stopPropagation();
  };
}
function zy(t) {
  return {
    keyboardProps: t.isDisabled ? {} : {
      onKeyDown: vu(t.onKeyDown),
      onKeyUp: vu(t.onKeyUp)
    }
  };
}
let Hy = /* @__PURE__ */ le.createContext(null);
function By(t) {
  let e = Qt(Hy) || {};
  th(e, t);
  let { ref: r, ...n } = e;
  return n;
}
function bh(t, e) {
  let { focusProps: r } = gh(t), { keyboardProps: n } = zy(t), o = Rr(r, n), s = By(e), i = t.isDisabled ? {} : s, a = te(t.autoFocus);
  me(() => {
    a.current && e.current && Zs(e.current), a.current = !1;
  }, [
    e
  ]);
  let l = t.excludeFromTabOrder ? -1 : 0;
  return t.isDisabled && (l = void 0), {
    focusableProps: Rr({
      ...o,
      tabIndex: l
    }, i)
  };
}
function Vy({ children: t }) {
  let e = Ye(() => ({
    register: () => {
    }
  }), []);
  return /* @__PURE__ */ le.createElement(Ad.Provider, {
    value: e
  }, t);
}
function Od(t) {
  let { isDisabled: e, onBlurWithin: r, onFocusWithin: n, onFocusWithinChange: o } = t, s = te({
    isFocusWithin: !1
  }), { addGlobalListener: i, removeAllGlobalListeners: a } = Ed(), l = we((u) => {
    u.currentTarget.contains(u.target) && s.current.isFocusWithin && !u.currentTarget.contains(u.relatedTarget) && (s.current.isFocusWithin = !1, a(), r && r(u), o && o(!1));
  }, [
    r,
    o,
    s,
    a
  ]), d = dh(l), c = we((u) => {
    if (!u.currentTarget.contains(u.target)) return;
    const f = Ie(u.target), p = jt(f);
    if (!s.current.isFocusWithin && p === Ae(u.nativeEvent)) {
      n && n(u), o && o(!0), s.current.isFocusWithin = !0, d(u);
      let h = u.currentTarget;
      i(f, "focus", (g) => {
        if (s.current.isFocusWithin && !Ge(h, g.target)) {
          let b = new f.defaultView.FocusEvent("blur", {
            relatedTarget: g.target
          });
          lh(b, h);
          let y = Td(b);
          l(y);
        }
      }, {
        capture: !0
      });
    }
  }, [
    n,
    o,
    d,
    i,
    l
  ]);
  return e ? {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: c,
      onBlur: l
    }
  };
}
let Qs = !1, hs = 0;
function xl() {
  Qs = !0, setTimeout(() => {
    Qs = !1;
  }, 50);
}
function $u(t) {
  t.pointerType === "touch" && xl();
}
function Wy() {
  if (!(typeof document > "u"))
    return hs === 0 && (typeof PointerEvent < "u" ? document.addEventListener("pointerup", $u) : process.env.NODE_ENV === "test" && document.addEventListener("touchend", xl)), hs++, () => {
      hs--, !(hs > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $u) : process.env.NODE_ENV === "test" && document.removeEventListener("touchend", xl));
    };
}
function Ld(t) {
  let { onHoverStart: e, onHoverChange: r, onHoverEnd: n, isDisabled: o } = t, [s, i] = de(!1), a = te({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  me(Wy, []);
  let { addGlobalListener: l, removeAllGlobalListeners: d } = Ed(), { hoverProps: c, triggerHoverEnd: u } = Ye(() => {
    let f = (g, b) => {
      if (a.pointerType = b, o || b === "touch" || a.isHovered || !g.currentTarget.contains(g.target)) return;
      a.isHovered = !0;
      let y = g.currentTarget;
      a.target = y, l(Ie(g.target), "pointerover", ($) => {
        a.isHovered && a.target && !Ge(a.target, $.target) && p($, $.pointerType);
      }, {
        capture: !0
      }), e && e({
        type: "hoverstart",
        target: y,
        pointerType: b
      }), r && r(!0), i(!0);
    }, p = (g, b) => {
      let y = a.target;
      a.pointerType = "", a.target = null, !(b === "touch" || !a.isHovered || !y) && (a.isHovered = !1, d(), n && n({
        type: "hoverend",
        target: y,
        pointerType: b
      }), r && r(!1), i(!1));
    }, h = {};
    return typeof PointerEvent < "u" ? (h.onPointerEnter = (g) => {
      Qs && g.pointerType === "mouse" || f(g, g.pointerType);
    }, h.onPointerLeave = (g) => {
      !o && g.currentTarget.contains(g.target) && p(g, g.pointerType);
    }) : process.env.NODE_ENV === "test" && (h.onTouchStart = () => {
      a.ignoreEmulatedMouseEvents = !0;
    }, h.onMouseEnter = (g) => {
      !a.ignoreEmulatedMouseEvents && !Qs && f(g, "mouse"), a.ignoreEmulatedMouseEvents = !1;
    }, h.onMouseLeave = (g) => {
      !o && g.currentTarget.contains(g.target) && p(g, "mouse");
    }), {
      hoverProps: h,
      triggerHoverEnd: p
    };
  }, [
    e,
    r,
    n,
    o,
    a,
    l,
    d
  ]);
  return me(() => {
    o && u({
      currentTarget: a.target
    }, a.pointerType);
  }, [
    o
  ]), {
    hoverProps: c,
    isHovered: s
  };
}
function Uy(t) {
  let { ref: e, onInteractOutside: r, isDisabled: n, onInteractOutsideStart: o } = t, s = te({
    isPointerDown: !1,
    ignoreEmulatedMouseEvents: !1
  }), i = Yt((l) => {
    r && ms(l, e) && (o && o(l), s.current.isPointerDown = !0);
  }), a = Yt((l) => {
    r && r(l);
  });
  me(() => {
    let l = s.current;
    if (n) return;
    const d = e.current, c = Ie(d);
    if (typeof PointerEvent < "u") {
      let u = (f) => {
        l.isPointerDown && ms(f, e) && a(f), l.isPointerDown = !1;
      };
      return c.addEventListener("pointerdown", i, !0), c.addEventListener("click", u, !0), () => {
        c.removeEventListener("pointerdown", i, !0), c.removeEventListener("click", u, !0);
      };
    } else if (process.env.NODE_ENV === "test") {
      let u = (p) => {
        l.ignoreEmulatedMouseEvents ? l.ignoreEmulatedMouseEvents = !1 : l.isPointerDown && ms(p, e) && a(p), l.isPointerDown = !1;
      }, f = (p) => {
        l.ignoreEmulatedMouseEvents = !0, l.isPointerDown && ms(p, e) && a(p), l.isPointerDown = !1;
      };
      return c.addEventListener("mousedown", i, !0), c.addEventListener("mouseup", u, !0), c.addEventListener("touchstart", i, !0), c.addEventListener("touchend", f, !0), () => {
        c.removeEventListener("mousedown", i, !0), c.removeEventListener("mouseup", u, !0), c.removeEventListener("touchstart", i, !0), c.removeEventListener("touchend", f, !0);
      };
    }
  }, [
    e,
    n,
    i,
    a
  ]);
}
function ms(t, e) {
  if (t.button > 0) return !1;
  if (t.target) {
    const r = t.target.ownerDocument;
    if (!r || !r.documentElement.contains(t.target) || t.target.closest("[data-react-aria-top-layer]")) return !1;
  }
  return e.current ? !t.composedPath().includes(e.current) : !1;
}
const xu = /* @__PURE__ */ le.createContext(null), wl = "react-aria-focus-scope-restore";
let ze = null;
function Gy(t) {
  let { children: e, contain: r, restoreFocus: n, autoFocus: o } = t, s = te(null), i = te(null), a = te([]), { parentNode: l } = Qt(xu) || {}, d = Ye(() => new El({
    scopeRef: a
  }), [
    a
  ]);
  nt(() => {
    let f = l || st.root;
    if (st.getTreeNode(f.scopeRef) && ze && !ei(ze, f.scopeRef)) {
      let p = st.getTreeNode(ze);
      p && (f = p);
    }
    f.addChild(d), st.addNode(d);
  }, [
    d,
    l
  ]), nt(() => {
    let f = st.getTreeNode(a);
    f && (f.contain = !!r);
  }, [
    r
  ]), nt(() => {
    var f;
    let p = (f = s.current) === null || f === void 0 ? void 0 : f.nextSibling, h = [], g = (b) => b.stopPropagation();
    for (; p && p !== i.current; )
      h.push(p), p.addEventListener(wl, g), p = p.nextSibling;
    return a.current = h, () => {
      for (let b of h) b.removeEventListener(wl, g);
    };
  }, [
    e
  ]), Zy(a, n, r), Jy(a, r), Qy(a, n, r), Xy(a, o), me(() => {
    const f = jt(Ie(a.current ? a.current[0] : void 0));
    let p = null;
    if (Zt(f, a.current)) {
      for (let h of st.traverse()) h.scopeRef && Zt(f, h.scopeRef.current) && (p = h);
      p === st.getTreeNode(a) && (ze = p.scopeRef);
    }
  }, [
    a
  ]), nt(() => () => {
    var f, p, h;
    let g = (h = (p = st.getTreeNode(a)) === null || p === void 0 || (f = p.parent) === null || f === void 0 ? void 0 : f.scopeRef) !== null && h !== void 0 ? h : null;
    (a === ze || ei(a, ze)) && (!g || st.getTreeNode(g)) && (ze = g), st.removeTreeNode(a);
  }, [
    a
  ]);
  let c = Ye(() => Ky(a), []), u = Ye(() => ({
    focusManager: c,
    parentNode: d
  }), [
    d,
    c
  ]);
  return /* @__PURE__ */ le.createElement(xu.Provider, {
    value: u
  }, /* @__PURE__ */ le.createElement("span", {
    "data-focus-scope-start": !0,
    hidden: !0,
    ref: s
  }), e, /* @__PURE__ */ le.createElement("span", {
    "data-focus-scope-end": !0,
    hidden: !0,
    ref: i
  }));
}
function Ky(t) {
  return {
    focusNext(e = {}) {
      let r = t.current, { from: n, tabbable: o, wrap: s, accept: i } = e;
      var a;
      let l = n || jt(Ie((a = r[0]) !== null && a !== void 0 ? a : void 0)), d = r[0].previousElementSibling, c = mn(r), u = Jr(c, {
        tabbable: o,
        accept: i
      }, r);
      u.currentNode = Zt(l, r) ? l : d;
      let f = u.nextNode();
      return !f && s && (u.currentNode = d, f = u.nextNode()), f && Mr(f, !0), f;
    },
    focusPrevious(e = {}) {
      let r = t.current, { from: n, tabbable: o, wrap: s, accept: i } = e;
      var a;
      let l = n || jt(Ie((a = r[0]) !== null && a !== void 0 ? a : void 0)), d = r[r.length - 1].nextElementSibling, c = mn(r), u = Jr(c, {
        tabbable: o,
        accept: i
      }, r);
      u.currentNode = Zt(l, r) ? l : d;
      let f = u.previousNode();
      return !f && s && (u.currentNode = d, f = u.previousNode()), f && Mr(f, !0), f;
    },
    focusFirst(e = {}) {
      let r = t.current, { tabbable: n, accept: o } = e, s = mn(r), i = Jr(s, {
        tabbable: n,
        accept: o
      }, r);
      i.currentNode = r[0].previousElementSibling;
      let a = i.nextNode();
      return a && Mr(a, !0), a;
    },
    focusLast(e = {}) {
      let r = t.current, { tabbable: n, accept: o } = e, s = mn(r), i = Jr(s, {
        tabbable: n,
        accept: o
      }, r);
      i.currentNode = r[r.length - 1].nextElementSibling;
      let a = i.previousNode();
      return a && Mr(a, !0), a;
    }
  };
}
function mn(t) {
  return t[0].parentElement;
}
function Co(t) {
  let e = st.getTreeNode(ze);
  for (; e && e.scopeRef !== t; ) {
    if (e.contain) return !1;
    e = e.parent;
  }
  return !0;
}
function Yy(t) {
  if (t.checked) return !0;
  let e = [];
  if (!t.form) e = [
    ...Ie(t).querySelectorAll(`input[type="radio"][name="${CSS.escape(t.name)}"]`)
  ].filter((s) => !s.form);
  else {
    var r, n;
    let s = (n = t.form) === null || n === void 0 || (r = n.elements) === null || r === void 0 ? void 0 : r.namedItem(t.name);
    e = [
      ...s ?? []
    ];
  }
  return e ? !e.some((s) => s.checked) : !1;
}
function Jy(t, e) {
  let r = te(void 0), n = te(void 0);
  nt(() => {
    let o = t.current;
    if (!e) {
      n.current && (cancelAnimationFrame(n.current), n.current = void 0);
      return;
    }
    const s = Ie(o ? o[0] : void 0);
    let i = (d) => {
      if (d.key !== "Tab" || d.altKey || d.ctrlKey || d.metaKey || !Co(t) || d.isComposing) return;
      let c = jt(s), u = t.current;
      if (!u || !Zt(c, u)) return;
      let f = mn(u), p = Jr(f, {
        tabbable: !0
      }, u);
      if (!c) return;
      p.currentNode = c;
      let h = d.shiftKey ? p.previousNode() : p.nextNode();
      h || (p.currentNode = d.shiftKey ? u[u.length - 1].nextElementSibling : u[0].previousElementSibling, h = d.shiftKey ? p.previousNode() : p.nextNode()), d.preventDefault(), h && Mr(h, !0);
    }, a = (d) => {
      (!ze || ei(ze, t)) && Zt(Ae(d), t.current) ? (ze = t, r.current = Ae(d)) : Co(t) && !Yr(Ae(d), t) ? r.current ? r.current.focus() : ze && ze.current && kl(ze.current) : Co(t) && (r.current = Ae(d));
    }, l = (d) => {
      n.current && cancelAnimationFrame(n.current), n.current = requestAnimationFrame(() => {
        let c = Rd(), u = (c === "virtual" || c === null) && kd() && Qp(), f = jt(s);
        if (!u && f && Co(t) && !Yr(f, t)) {
          ze = t;
          let h = Ae(d);
          if (h && h.isConnected) {
            var p;
            r.current = h, (p = r.current) === null || p === void 0 || p.focus();
          } else ze.current && kl(ze.current);
        }
      });
    };
    return s.addEventListener("keydown", i, !1), s.addEventListener("focusin", a, !1), o == null || o.forEach((d) => d.addEventListener("focusin", a, !1)), o == null || o.forEach((d) => d.addEventListener("focusout", l, !1)), () => {
      s.removeEventListener("keydown", i, !1), s.removeEventListener("focusin", a, !1), o == null || o.forEach((d) => d.removeEventListener("focusin", a, !1)), o == null || o.forEach((d) => d.removeEventListener("focusout", l, !1));
    };
  }, [
    t,
    e
  ]), nt(() => () => {
    n.current && cancelAnimationFrame(n.current);
  }, [
    n
  ]);
}
function yh(t) {
  return Yr(t);
}
function Zt(t, e) {
  return !t || !e ? !1 : e.some((r) => r.contains(t));
}
function Yr(t, e = null) {
  if (t instanceof Element && t.closest("[data-react-aria-top-layer]")) return !0;
  for (let { scopeRef: r } of st.traverse(st.getTreeNode(e)))
    if (r && Zt(t, r.current)) return !0;
  return !1;
}
function qy(t) {
  return Yr(t, ze);
}
function ei(t, e) {
  var r;
  let n = (r = st.getTreeNode(e)) === null || r === void 0 ? void 0 : r.parent;
  for (; n; ) {
    if (n.scopeRef === t) return !0;
    n = n.parent;
  }
  return !1;
}
function Mr(t, e = !1) {
  if (t != null && !e) try {
    Zs(t);
  } catch {
  }
  else if (t != null) try {
    t.focus();
  } catch {
  }
}
function vh(t, e = !0) {
  let r = t[0].previousElementSibling, n = mn(t), o = Jr(n, {
    tabbable: e
  }, t);
  o.currentNode = r;
  let s = o.nextNode();
  return e && !s && (n = mn(t), o = Jr(n, {
    tabbable: !1
  }, t), o.currentNode = r, s = o.nextNode()), s;
}
function kl(t, e = !0) {
  Mr(vh(t, e));
}
function Xy(t, e) {
  const r = le.useRef(e);
  me(() => {
    if (r.current) {
      ze = t;
      const n = Ie(t.current ? t.current[0] : void 0);
      !Zt(jt(n), ze.current) && t.current && kl(t.current);
    }
    r.current = !1;
  }, [
    t
  ]);
}
function Zy(t, e, r) {
  nt(() => {
    if (e || r) return;
    let n = t.current;
    const o = Ie(n ? n[0] : void 0);
    let s = (i) => {
      let a = Ae(i);
      Zt(a, t.current) ? ze = t : yh(a) || (ze = null);
    };
    return o.addEventListener("focusin", s, !1), n == null || n.forEach((i) => i.addEventListener("focusin", s, !1)), () => {
      o.removeEventListener("focusin", s, !1), n == null || n.forEach((i) => i.removeEventListener("focusin", s, !1));
    };
  }, [
    t,
    e,
    r
  ]);
}
function wu(t) {
  let e = st.getTreeNode(ze);
  for (; e && e.scopeRef !== t; ) {
    if (e.nodeToRestore) return !1;
    e = e.parent;
  }
  return (e == null ? void 0 : e.scopeRef) === t;
}
function Qy(t, e, r) {
  const n = te(typeof document < "u" ? jt(Ie(t.current ? t.current[0] : void 0)) : null);
  nt(() => {
    let o = t.current;
    const s = Ie(o ? o[0] : void 0);
    if (!e || r) return;
    let i = () => {
      (!ze || ei(ze, t)) && Zt(jt(s), t.current) && (ze = t);
    };
    return s.addEventListener("focusin", i, !1), o == null || o.forEach((a) => a.addEventListener("focusin", i, !1)), () => {
      s.removeEventListener("focusin", i, !1), o == null || o.forEach((a) => a.removeEventListener("focusin", i, !1));
    };
  }, [
    t,
    r
  ]), nt(() => {
    const o = Ie(t.current ? t.current[0] : void 0);
    if (!e) return;
    let s = (i) => {
      if (i.key !== "Tab" || i.altKey || i.ctrlKey || i.metaKey || !Co(t) || i.isComposing) return;
      let a = o.activeElement;
      if (!Yr(a, t) || !wu(t)) return;
      let l = st.getTreeNode(t);
      if (!l) return;
      let d = l.nodeToRestore, c = Jr(o.body, {
        tabbable: !0
      });
      c.currentNode = a;
      let u = i.shiftKey ? c.previousNode() : c.nextNode();
      if ((!d || !d.isConnected || d === o.body) && (d = void 0, l.nodeToRestore = void 0), (!u || !Yr(u, t)) && d) {
        c.currentNode = d;
        do
          u = i.shiftKey ? c.previousNode() : c.nextNode();
        while (Yr(u, t));
        i.preventDefault(), i.stopPropagation(), u ? Mr(u, !0) : yh(d) ? Mr(d, !0) : a.blur();
      }
    };
    return r || o.addEventListener("keydown", s, !0), () => {
      r || o.removeEventListener("keydown", s, !0);
    };
  }, [
    t,
    e,
    r
  ]), nt(() => {
    const o = Ie(t.current ? t.current[0] : void 0);
    if (!e) return;
    let s = st.getTreeNode(t);
    if (s) {
      var i;
      return s.nodeToRestore = (i = n.current) !== null && i !== void 0 ? i : void 0, () => {
        let a = st.getTreeNode(t);
        if (!a) return;
        let l = a.nodeToRestore, d = jt(o);
        if (e && l && (d && Yr(d, t) || d === o.body && wu(t))) {
          let c = st.clone();
          requestAnimationFrame(() => {
            if (o.activeElement === o.body) {
              let u = c.getTreeNode(t);
              for (; u; ) {
                if (u.nodeToRestore && u.nodeToRestore.isConnected) {
                  ku(u.nodeToRestore);
                  return;
                }
                u = u.parent;
              }
              for (u = c.getTreeNode(t); u; ) {
                if (u.scopeRef && u.scopeRef.current && st.getTreeNode(u.scopeRef)) {
                  let f = vh(u.scopeRef.current, !0);
                  ku(f);
                  return;
                }
                u = u.parent;
              }
            }
          });
        }
      };
    }
  }, [
    t,
    e
  ]);
}
function ku(t) {
  t.dispatchEvent(new CustomEvent(wl, {
    bubbles: !0,
    cancelable: !0
  })) && Mr(t);
}
function Jr(t, e, r) {
  let n = e != null && e.tabbable ? fy : nh, o = (t == null ? void 0 : t.nodeType) === Node.ELEMENT_NODE ? t : null, s = Ie(o), i = U2(s, t || s, NodeFilter.SHOW_ELEMENT, {
    acceptNode(a) {
      var l;
      return !(e == null || (l = e.from) === null || l === void 0) && l.contains(a) || e != null && e.tabbable && a.tagName === "INPUT" && a.getAttribute("type") === "radio" && (!Yy(a) || i.currentNode.tagName === "INPUT" && i.currentNode.type === "radio" && i.currentNode.name === a.name) ? NodeFilter.FILTER_REJECT : n(a) && (!r || Zt(a, r)) && (!(e != null && e.accept) || e.accept(a)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  return e != null && e.from && (i.currentNode = e.from), i;
}
class jd {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(e) {
    return this.fastMap.get(e);
  }
  addTreeNode(e, r, n) {
    let o = this.fastMap.get(r ?? null);
    if (!o) return;
    let s = new El({
      scopeRef: e
    });
    o.addChild(s), s.parent = o, this.fastMap.set(e, s), n && (s.nodeToRestore = n);
  }
  addNode(e) {
    this.fastMap.set(e.scopeRef, e);
  }
  removeTreeNode(e) {
    if (e === null) return;
    let r = this.fastMap.get(e);
    if (!r) return;
    let n = r.parent;
    for (let s of this.traverse()) s !== r && r.nodeToRestore && s.nodeToRestore && r.scopeRef && r.scopeRef.current && Zt(s.nodeToRestore, r.scopeRef.current) && (s.nodeToRestore = r.nodeToRestore);
    let o = r.children;
    n && (n.removeChild(r), o.size > 0 && o.forEach((s) => n && n.addChild(s))), this.fastMap.delete(r.scopeRef);
  }
  // Pre Order Depth First
  *traverse(e = this.root) {
    if (e.scopeRef != null && (yield e), e.children.size > 0) for (let r of e.children) yield* this.traverse(r);
  }
  clone() {
    var e;
    let r = new jd();
    var n;
    for (let o of this.traverse()) r.addTreeNode(o.scopeRef, (n = (e = o.parent) === null || e === void 0 ? void 0 : e.scopeRef) !== null && n !== void 0 ? n : null, o.nodeToRestore);
    return r;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map(), this.root = new El({
      scopeRef: null
    }), this.fastMap.set(null, this.root);
  }
}
class El {
  addChild(e) {
    this.children.add(e), e.parent = this;
  }
  removeChild(e) {
    this.children.delete(e), e.parent = void 0;
  }
  constructor(e) {
    this.children = /* @__PURE__ */ new Set(), this.contain = !1, this.scopeRef = e.scopeRef;
  }
}
let st = new jd();
function $h(t = {}) {
  let { autoFocus: e = !1, isTextInput: r, within: n } = t, o = te({
    isFocused: !1,
    isFocusVisible: e || Id()
  }), [s, i] = de(!1), [a, l] = de(() => o.current.isFocused && o.current.isFocusVisible), d = we(() => l(o.current.isFocused && o.current.isFocusVisible), []), c = we((p) => {
    o.current.isFocused = p, i(p), d();
  }, [
    d
  ]);
  Fy((p) => {
    o.current.isFocusVisible = p, d();
  }, [], {
    isTextInput: r
  });
  let { focusProps: u } = gh({
    isDisabled: n,
    onFocusChange: c
  }), { focusWithinProps: f } = Od({
    isDisabled: !n,
    onFocusWithinChange: c
  });
  return {
    isFocused: s,
    isFocusVisible: a,
    focusProps: n ? f : u
  };
}
function ev(t, e, r) {
  let { type: n } = t, { isOpen: o } = e;
  me(() => {
    r && r.current && ih.set(r.current, e.close);
  });
  let s;
  n === "menu" ? s = !0 : n === "listbox" && (s = "listbox");
  let i = Qi();
  return {
    triggerProps: {
      "aria-haspopup": s,
      "aria-expanded": o,
      "aria-controls": o ? i : void 0,
      onPress: e.toggle
    },
    overlayProps: {
      id: i
    }
  };
}
const Po = typeof document < "u" && window.visualViewport;
let gs = 0, Ia;
function tv(t = {}) {
  let { isDisabled: e } = t;
  nt(() => {
    if (!e)
      return gs++, gs === 1 && (na() ? Ia = nv() : Ia = rv()), () => {
        gs--, gs === 0 && Ia();
      };
  }, [
    e
  ]);
}
function rv() {
  let t = window.innerWidth - document.documentElement.clientWidth;
  return ea(t > 0 && // Use scrollbar-gutter when supported because it also works for fixed positioned elements.
  ("scrollbarGutter" in document.documentElement.style ? Ra(document.documentElement, "scrollbarGutter", "stable") : Ra(document.documentElement, "paddingRight", `${t}px`)), Ra(document.documentElement, "overflow", "hidden"));
}
function nv() {
  let t, e = !1, r = (l) => {
    let d = l.target;
    t = pl(d) ? d : rh(d, !0), e = !1;
    let c = d.ownerDocument.defaultView.getSelection();
    c && !c.isCollapsed && c.containsNode(d, !0) && (e = !0), "selectionStart" in d && "selectionEnd" in d && d.selectionStart < d.selectionEnd && d.ownerDocument.activeElement === d && (e = !0);
  }, n = document.createElement("style");
  n.textContent = `
@layer {
  * {
    overscroll-behavior: contain;
  }
}`.trim(), document.head.prepend(n);
  let o = (l) => {
    if (!(l.touches.length === 2 || e)) {
      if (!t || t === document.documentElement || t === document.body) {
        l.preventDefault();
        return;
      }
      t.scrollHeight === t.clientHeight && t.scrollWidth === t.clientWidth && l.preventDefault();
    }
  }, s = (l) => {
    let d = l.target, c = l.relatedTarget;
    if (c && Ta(c))
      c.focus({
        preventScroll: !0
      }), Eu(c, Ta(d));
    else if (!c) {
      var u;
      let f = (u = d.parentElement) === null || u === void 0 ? void 0 : u.closest("[tabindex]");
      f == null || f.focus({
        preventScroll: !0
      });
    }
  }, i = HTMLElement.prototype.focus;
  HTMLElement.prototype.focus = function(l) {
    let d = document.activeElement != null && Ta(document.activeElement);
    i.call(this, {
      ...l,
      preventScroll: !0
    }), (!l || !l.preventScroll) && Eu(this, d);
  };
  let a = ea(Oa(document, "touchstart", r, {
    passive: !1,
    capture: !0
  }), Oa(document, "touchmove", o, {
    passive: !1,
    capture: !0
  }), Oa(document, "blur", s, !0));
  return () => {
    a(), n.remove(), HTMLElement.prototype.focus = i;
  };
}
function Ra(t, e, r) {
  let n = t.style[e];
  return t.style[e] = r, () => {
    t.style[e] = n;
  };
}
function Oa(t, e, r, n) {
  return t.addEventListener(e, r, n), () => {
    t.removeEventListener(e, r, n);
  };
}
function Eu(t, e) {
  e || !Po ? Cu(t) : Po.addEventListener("resize", () => Cu(t), {
    once: !0
  });
}
function Cu(t) {
  let e = document.scrollingElement || document.documentElement, r = t;
  for (; r && r !== e; ) {
    let n = rh(r);
    if (n !== document.documentElement && n !== document.body && n !== r) {
      let o = n.getBoundingClientRect(), s = r.getBoundingClientRect();
      if (s.top < o.top || s.bottom > o.top + r.clientHeight) {
        let i = o.bottom;
        Po && (i = Math.min(i, Po.offsetTop + Po.height));
        let a = s.top - o.top - ((i - o.top) / 2 - s.height / 2);
        n.scrollTo({
          // Clamp to the valid range to prevent over-scrolling.
          top: Math.max(0, Math.min(n.scrollHeight - n.clientHeight, n.scrollTop + a)),
          behavior: "smooth"
        });
      }
    }
    r = n.parentElement;
  }
}
const ov = /* @__PURE__ */ Ep({});
function xh() {
  var t;
  return (t = Qt(ov)) !== null && t !== void 0 ? t : {};
}
const Cl = /* @__PURE__ */ le.createContext(null);
function sv(t) {
  let { children: e } = t, r = Qt(Cl), [n, o] = de(0), s = Ye(() => ({
    parent: r,
    modalCount: n,
    addModal() {
      o((i) => i + 1), r && r.addModal();
    },
    removeModal() {
      o((i) => i - 1), r && r.removeModal();
    }
  }), [
    r,
    n
  ]);
  return /* @__PURE__ */ le.createElement(Cl.Provider, {
    value: s
  }, e);
}
function iv() {
  let t = Qt(Cl);
  return {
    modalProviderProps: {
      "aria-hidden": t && t.modalCount > 0 ? !0 : void 0
    }
  };
}
function av(t) {
  let { modalProviderProps: e } = iv();
  return /* @__PURE__ */ le.createElement("div", {
    "data-overlay-container": !0,
    ...t,
    ...e
  });
}
function lv(t) {
  return /* @__PURE__ */ le.createElement(sv, null, /* @__PURE__ */ le.createElement(av, t));
}
function Su(t) {
  let e = Xi(), { portalContainer: r = e ? null : document.body, ...n } = t, { getContainer: o } = xh();
  if (!t.portalContainer && o && (r = o()), le.useEffect(() => {
    if (r != null && r.closest("[data-overlay-container]")) throw new Error("An OverlayContainer must not be inside another container. Please change the portalContainer prop.");
  }, [
    r
  ]), !r) return null;
  let s = /* @__PURE__ */ le.createElement(lv, n);
  return /* @__PURE__ */ Cp.createPortal(s, r);
}
var wh = {};
wh = {
  dismiss: ""
};
var kh = {};
kh = {
  dismiss: ""
};
var Eh = {};
Eh = {
  dismiss: "Odstranit"
};
var Ch = {};
Ch = {
  dismiss: "Luk"
};
var Sh = {};
Sh = {
  dismiss: "Schlieen"
};
var Nh = {};
Nh = {
  dismiss: ""
};
var Th = {};
Th = {
  dismiss: "Dismiss"
};
var Ah = {};
Ah = {
  dismiss: "Descartar"
};
var Mh = {};
Mh = {
  dismiss: "Lpeta"
};
var Ph = {};
Ph = {
  dismiss: "Hylk"
};
var Ih = {};
Ih = {
  dismiss: "Rejeter"
};
var Rh = {};
Rh = {
  dismiss: ""
};
var Oh = {};
Oh = {
  dismiss: "Odbaci"
};
var Lh = {};
Lh = {
  dismiss: "Elutasts"
};
var jh = {};
jh = {
  dismiss: "Ignora"
};
var Dh = {};
Dh = {
  dismiss: ""
};
var _h = {};
_h = {
  dismiss: ""
};
var Fh = {};
Fh = {
  dismiss: "Atmesti"
};
var zh = {};
zh = {
  dismiss: "Nerdt"
};
var Hh = {};
Hh = {
  dismiss: "Lukk"
};
var Bh = {};
Bh = {
  dismiss: "Negeren"
};
var Vh = {};
Vh = {
  dismiss: "Zignoruj"
};
var Wh = {};
Wh = {
  dismiss: "Descartar"
};
var Uh = {};
Uh = {
  dismiss: "Dispensar"
};
var Gh = {};
Gh = {
  dismiss: "Revocare"
};
var Kh = {};
Kh = {
  dismiss: ""
};
var Yh = {};
Yh = {
  dismiss: "Zrui"
};
var Jh = {};
Jh = {
  dismiss: "Opusti"
};
var qh = {};
qh = {
  dismiss: "Odbaci"
};
var Xh = {};
Xh = {
  dismiss: "Avvisa"
};
var Zh = {};
Zh = {
  dismiss: "Kapat"
};
var Qh = {};
Qh = {
  dismiss: ""
};
var em = {};
em = {
  dismiss: ""
};
var tm = {};
tm = {
  dismiss: ""
};
var rm = {};
rm = {
  "ar-AE": wh,
  "bg-BG": kh,
  "cs-CZ": Eh,
  "da-DK": Ch,
  "de-DE": Sh,
  "el-GR": Nh,
  "en-US": Th,
  "es-ES": Ah,
  "et-EE": Mh,
  "fi-FI": Ph,
  "fr-FR": Ih,
  "he-IL": Rh,
  "hr-HR": Oh,
  "hu-HU": Lh,
  "it-IT": jh,
  "ja-JP": Dh,
  "ko-KR": _h,
  "lt-LT": Fh,
  "lv-LV": zh,
  "nb-NO": Hh,
  "nl-NL": Bh,
  "pl-PL": Vh,
  "pt-BR": Wh,
  "pt-PT": Uh,
  "ro-RO": Gh,
  "ru-RU": Kh,
  "sk-SK": Yh,
  "sl-SI": Jh,
  "sr-SP": qh,
  "sv-SE": Xh,
  "tr-TR": Zh,
  "uk-UA": Qh,
  "zh-CN": em,
  "zh-TW": tm
};
const Nu = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function dv(t = {}) {
  let { style: e, isFocusable: r } = t, [n, o] = de(!1), { focusWithinProps: s } = Od({
    isDisabled: !r,
    onFocusWithinChange: (a) => o(a)
  }), i = Ye(() => n ? e : e ? {
    ...Nu,
    ...e
  } : Nu, [
    n
  ]);
  return {
    visuallyHiddenProps: {
      ...s,
      style: i
    }
  };
}
function cv(t) {
  let { children: e, elementType: r = "div", isFocusable: n, style: o, ...s } = t, { visuallyHiddenProps: i } = dv(t);
  return /* @__PURE__ */ le.createElement(r, Rr(s, i), e);
}
function uv(t) {
  return t && t.__esModule ? t.default : t;
}
function Tu(t) {
  let { onDismiss: e, ...r } = t, n = R2(uv(rm), "@react-aria/overlays"), o = ny(r, n.format("dismiss")), s = () => {
    e && e();
  };
  return /* @__PURE__ */ le.createElement(cv, null, /* @__PURE__ */ le.createElement("button", {
    ...o,
    tabIndex: -1,
    onClick: s,
    style: {
      width: 1,
      height: 1
    }
  }));
}
const nm = /* @__PURE__ */ le.createContext(null);
function fv(t) {
  let e = Xi(), { portalContainer: r = e ? null : document.body, isExiting: n } = t, [o, s] = de(!1), i = Ye(() => ({
    contain: o,
    setContain: s
  }), [
    o,
    s
  ]), { getContainer: a } = xh();
  if (!t.portalContainer && a && (r = a()), !r) return null;
  let l = t.children;
  return t.disableFocusManagement || (l = /* @__PURE__ */ le.createElement(Gy, {
    restoreFocus: !0,
    contain: (t.shouldContainFocus || o) && !n
  }, l)), l = /* @__PURE__ */ le.createElement(nm.Provider, {
    value: i
  }, /* @__PURE__ */ le.createElement(Vy, null, l)), /* @__PURE__ */ Cp.createPortal(l, r);
}
function pv() {
  let t = Qt(nm), e = t == null ? void 0 : t.setContain;
  nt(() => {
    e == null || e(!0);
  }, [
    e
  ]);
}
function Dd(t) {
  return Oe(t);
}
var om = (t, e, r = !0) => {
  if (!e)
    return [t, {}];
  const n = e.reduce((o, s) => s in t ? { ...o, [s]: t[s] } : o, {});
  return r ? [Object.keys(t).filter((s) => !e.includes(s)).reduce((s, i) => ({ ...s, [i]: t[i] }), {}), n] : [t, n];
}, hv = {
  default: "bg-default text-default-foreground",
  primary: "bg-primary text-primary-foreground",
  secondary: "bg-secondary text-secondary-foreground",
  success: "bg-success text-success-foreground",
  warning: "bg-warning text-warning-foreground",
  danger: "bg-danger text-danger-foreground",
  foreground: "bg-foreground text-background"
}, mv = {
  default: "shadow-lg shadow-default/50 bg-default text-default-foreground",
  primary: "shadow-lg shadow-primary/40 bg-primary text-primary-foreground",
  secondary: "shadow-lg shadow-secondary/40 bg-secondary text-secondary-foreground",
  success: "shadow-lg shadow-success/40 bg-success text-success-foreground",
  warning: "shadow-lg shadow-warning/40 bg-warning text-warning-foreground",
  danger: "shadow-lg shadow-danger/40 bg-danger text-danger-foreground"
}, gv = {
  default: "bg-transparent border-default text-foreground",
  primary: "bg-transparent border-primary text-primary",
  secondary: "bg-transparent border-secondary text-secondary",
  success: "bg-transparent border-success text-success",
  warning: "bg-transparent border-warning text-warning",
  danger: "bg-transparent border-danger text-danger"
}, bv = {
  default: "bg-default/40 text-default-700",
  primary: "bg-primary/20 text-primary-600",
  secondary: "bg-secondary/20 text-secondary-600",
  success: "bg-success/20 text-success-700 dark:text-success",
  warning: "bg-warning/20 text-warning-700 dark:text-warning",
  danger: "bg-danger/20 text-danger-600 dark:text-danger-500"
}, yv = {
  default: "border-default bg-default-100 text-default-foreground",
  primary: "border-default bg-default-100 text-primary",
  secondary: "border-default bg-default-100 text-secondary",
  success: "border-default bg-default-100 text-success",
  warning: "border-default bg-default-100 text-warning",
  danger: "border-default bg-default-100 text-danger"
}, vv = {
  default: "bg-transparent text-default-foreground",
  primary: "bg-transparent text-primary",
  secondary: "bg-transparent text-secondary",
  success: "bg-transparent text-success",
  warning: "bg-transparent text-warning",
  danger: "bg-transparent text-danger"
}, $v = {
  default: "border-default text-default-foreground",
  primary: "border-primary text-primary",
  secondary: "border-secondary text-secondary",
  success: "border-success text-success",
  warning: "border-warning text-warning",
  danger: "border-danger text-danger"
}, he = {
  solid: hv,
  shadow: mv,
  bordered: gv,
  flat: bv,
  faded: yv,
  light: vv,
  ghost: $v
}, xv = {
  /** Animation Utilities */
  ".spinner-bar-animation": {
    "animation-delay": "calc(-1.2s + (0.1s * var(--bar-index)))",
    transform: "rotate(calc(30deg * var(--bar-index)))translate(140%)"
  },
  ".spinner-dot-animation": {
    "animation-delay": "calc(250ms * var(--dot-index))"
  },
  ".spinner-dot-blink-animation": {
    "animation-delay": "calc(200ms * var(--dot-index))"
  }
}, wv = {
  /**
   * Custom utilities
   */
  ".leading-inherit": {
    "line-height": "inherit"
  },
  ".bg-img-inherit": {
    "background-image": "inherit"
  },
  ".bg-clip-inherit": {
    "background-clip": "inherit"
  },
  ".text-fill-inherit": {
    "-webkit-text-fill-color": "inherit"
  },
  ".tap-highlight-transparent": {
    "-webkit-tap-highlight-color": "transparent"
  },
  ".input-search-cancel-button-none": {
    "&::-webkit-search-cancel-button": {
      "-webkit-appearance": "none"
    }
  }
}, kv = {
  /**
   * Scroll Hide
   */
  ".scrollbar-hide": {
    /* IE and Edge */
    "-ms-overflow-style": "none",
    /* Firefox */
    "scrollbar-width": "none",
    /* Safari and Chrome */
    "&::-webkit-scrollbar": {
      display: "none"
    }
  },
  ".scrollbar-default": {
    /* IE and Edge */
    "-ms-overflow-style": "auto",
    /* Firefox */
    "scrollbar-width": "auto",
    /* Safari and Chrome */
    "&::-webkit-scrollbar": {
      display: "block"
    }
  }
}, Ev = {
  /**
   * Text utilities
   */
  ".text-tiny": {
    "font-size": "var(--heroui-font-size-tiny)",
    "line-height": "var(--heroui-line-height-tiny)"
  },
  ".text-small": {
    "font-size": "var(--heroui-font-size-small)",
    "line-height": "var(--heroui-line-height-small)"
  },
  ".text-medium": {
    "font-size": "var(--heroui-font-size-medium)",
    "line-height": "var(--heroui-line-height-medium)"
  },
  ".text-large": {
    "font-size": "var(--heroui-font-size-large)",
    "line-height": "var(--heroui-line-height-large)"
  }
}, ir = "250ms", Cv = {
  /**
   * Transition utilities
   */
  ".transition-background": {
    "transition-property": "background",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-colors-opacity": {
    "transition-property": "color, background-color, border-color, text-decoration-color, fill, stroke, opacity",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-width": {
    "transition-property": "width",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-height": {
    "transition-property": "height",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-size": {
    "transition-property": "width, height",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-left": {
    "transition-property": "left",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-transform-opacity": {
    "transition-property": "transform, scale, opacity rotate",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-transform-background": {
    "transition-property": "transform, scale, background",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-transform-colors": {
    "transition-property": "transform, scale, color, background, background-color, border-color, text-decoration-color, fill, stroke",
    "transition-timing-function": "ease",
    "transition-duration": ir
  },
  ".transition-transform-colors-opacity": {
    "transition-property": "transform, scale, color, background, background-color, border-color, text-decoration-color, fill, stroke, opacity",
    "transition-timing-function": "ease",
    "transition-duration": ir
  }
}, Sv = {
  ...wv,
  ...Cv,
  ...kv,
  ...Ev,
  ...xv
}, bs = ["small", "medium", "large"], Au = {
  theme: {
    spacing: ["divider"],
    radius: bs
  },
  classGroups: {
    shadow: [{ shadow: bs }],
    opacity: [{ opacity: ["disabled"] }],
    "font-size": [{ text: ["tiny", ...bs] }],
    "border-w": [{ border: bs }],
    "bg-image": [
      "bg-stripe-gradient-default",
      "bg-stripe-gradient-primary",
      "bg-stripe-gradient-secondary",
      "bg-stripe-gradient-success",
      "bg-stripe-gradient-warning",
      "bg-stripe-gradient-danger"
    ],
    transition: Object.keys(Sv).filter((t) => t.includes(".transition")).map((t) => t.replace(".", ""))
    // remove the dot from the key, .transition-background -> transition-background
  }
}, Nv = /\s+/g, Sl = (t) => typeof t != "string" || !t ? t : t.replace(Nv, " ").trim(), ti = (...t) => {
  let e = [], r = (n) => {
    if (!n && n !== 0 && n !== 0n) return;
    if (Array.isArray(n)) {
      for (let s = 0, i = n.length; s < i; s++) r(n[s]);
      return;
    }
    let o = typeof n;
    if (o === "string" || o === "number" || o === "bigint") {
      if (o === "number" && n !== n) return;
      e.push(String(n));
    } else if (o === "object") {
      let s = Object.keys(n);
      for (let i = 0, a = s.length; i < a; i++) {
        let l = s[i];
        n[l] && e.push(l);
      }
    }
  };
  for (let n = 0, o = t.length; n < o; n++) {
    let s = t[n];
    s != null && r(s);
  }
  return e.length > 0 ? Sl(e.join(" ")) : void 0;
}, Mu = (t) => t === !1 ? "false" : t === !0 ? "true" : t === 0 ? "0" : t, Rt = (t) => {
  if (!t || typeof t != "object") return !0;
  for (let e in t) return !1;
  return !0;
}, Tv = (t, e) => {
  if (t === e) return !0;
  if (!t || !e) return !1;
  let r = Object.keys(t), n = Object.keys(e);
  if (r.length !== n.length) return !1;
  for (let o = 0; o < r.length; o++) {
    let s = r[o];
    if (!n.includes(s) || t[s] !== e[s]) return !1;
  }
  return !0;
}, Pu = (t, e) => {
  for (let r in e) if (Object.prototype.hasOwnProperty.call(e, r)) {
    let n = e[r];
    r in t ? t[r] = ti(t[r], n) : t[r] = n;
  }
  return t;
}, sm = (t, e) => {
  for (let r = 0; r < t.length; r++) {
    let n = t[r];
    Array.isArray(n) ? sm(n, e) : n && e.push(n);
  }
}, im = (...t) => {
  let e = [];
  sm(t, e);
  let r = [];
  for (let n = 0; n < e.length; n++) e[n] && r.push(e[n]);
  return r;
}, Nl = (t, e) => {
  let r = {};
  for (let n in t) {
    let o = t[n];
    if (n in e) {
      let s = e[n];
      Array.isArray(o) || Array.isArray(s) ? r[n] = im(s, o) : typeof o == "object" && typeof s == "object" && o && s ? r[n] = Nl(o, s) : r[n] = s + " " + o;
    } else r[n] = o;
  }
  for (let n in e) n in t || (r[n] = e[n]);
  return r;
}, Av = { twMerge: !0, twMergeConfig: {}, responsiveVariants: !1 };
function Mv() {
  let t = null, e = {}, r = !1;
  return { get cachedTwMerge() {
    return t;
  }, set cachedTwMerge(n) {
    t = n;
  }, get cachedTwMergeConfig() {
    return e;
  }, set cachedTwMergeConfig(n) {
    e = n;
  }, get didTwMergeConfigChange() {
    return r;
  }, set didTwMergeConfigChange(n) {
    r = n;
  }, reset() {
    t = null, e = {}, r = !1;
  } };
}
var Tr = Mv(), Pv = (t) => {
  let e = (r, n) => {
    let { extend: o = null, slots: s = {}, variants: i = {}, compoundVariants: a = [], compoundSlots: l = [], defaultVariants: d = {} } = r, c = { ...Av, ...n }, u = o != null && o.base ? ti(o.base, r == null ? void 0 : r.base) : r == null ? void 0 : r.base, f = o != null && o.variants && !Rt(o.variants) ? Nl(i, o.variants) : i, p = o != null && o.defaultVariants && !Rt(o.defaultVariants) ? { ...o.defaultVariants, ...d } : d;
    !Rt(c.twMergeConfig) && !Tv(c.twMergeConfig, Tr.cachedTwMergeConfig) && (Tr.didTwMergeConfigChange = !0, Tr.cachedTwMergeConfig = c.twMergeConfig);
    let h = Rt(o == null ? void 0 : o.slots), g = Rt(s) ? {} : { base: ti(r == null ? void 0 : r.base, h && (o == null ? void 0 : o.base)), ...s }, b = h ? g : Pu({ ...o == null ? void 0 : o.slots }, Rt(g) ? { base: r == null ? void 0 : r.base } : g), y = Rt(o == null ? void 0 : o.compoundVariants) ? a : im(o == null ? void 0 : o.compoundVariants, a), $ = (w) => {
      if (Rt(f) && Rt(s) && h) return t(u, w == null ? void 0 : w.class, w == null ? void 0 : w.className)(c);
      if (y && !Array.isArray(y)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof y}`);
      if (l && !Array.isArray(l)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof l}`);
      let C = (N, R, x = [], P) => {
        let I = x;
        if (typeof R == "string") {
          let D = Sl(R).split(" ");
          for (let L = 0; L < D.length; L++) I.push(`${N}:${D[L]}`);
        } else if (Array.isArray(R)) for (let D = 0; D < R.length; D++) I.push(`${N}:${R[D]}`);
        else if (typeof R == "object" && typeof P == "string" && P in R) {
          let D = R[P];
          if (D && typeof D == "string") {
            let L = Sl(D).split(" "), A = [];
            for (let z = 0; z < L.length; z++) A.push(`${N}:${L[z]}`);
            I[P] = I[P] ? I[P].concat(A) : A;
          } else if (Array.isArray(D) && D.length > 0) {
            let L = [];
            for (let A = 0; A < D.length; A++) L.push(`${N}:${D[A]}`);
            I[P] = L;
          }
        }
        return I;
      }, T = (N, R = f, x = null, P = null) => {
        let I = R[N];
        if (!I || Rt(I)) return null;
        let D = (P == null ? void 0 : P[N]) ?? (w == null ? void 0 : w[N]);
        if (D === null) return null;
        let L = Mu(D), A = Array.isArray(c.responsiveVariants) && c.responsiveVariants.length > 0 || c.responsiveVariants === !0, z = p == null ? void 0 : p[N], Y = [];
        if (typeof L == "object" && A) for (let [B, _] of Object.entries(L)) {
          let W = I[_];
          if (B === "initial") {
            z = _;
            continue;
          }
          Array.isArray(c.responsiveVariants) && !c.responsiveVariants.includes(B) || (Y = C(B, W, Y, x));
        }
        let q = L != null && typeof L != "object" ? L : Mu(z), ee = I[q || "false"];
        return typeof Y == "object" && typeof x == "string" && Y[x] ? Pu(Y, ee) : Y.length > 0 ? (Y.push(ee), x === "base" ? Y.join(" ") : Y) : ee;
      }, H = () => {
        if (!f) return null;
        let N = Object.keys(f), R = [];
        for (let x = 0; x < N.length; x++) {
          let P = T(N[x], f);
          P && R.push(P);
        }
        return R;
      }, O = (N, R) => {
        if (!f || typeof f != "object") return null;
        let x = [];
        for (let P in f) {
          let I = T(P, f, N, R), D = N === "base" && typeof I == "string" ? I : I && I[N];
          D && x.push(D);
        }
        return x;
      }, j = {};
      for (let N in w) {
        let R = w[N];
        R !== void 0 && (j[N] = R);
      }
      let F = (N, R) => {
        var P;
        let x = typeof (w == null ? void 0 : w[N]) == "object" ? { [N]: (P = w[N]) == null ? void 0 : P.initial } : {};
        return { ...p, ...j, ...x, ...R };
      }, v = (N = [], R) => {
        let x = [], P = N.length;
        for (let I = 0; I < P; I++) {
          let { class: D, className: L, ...A } = N[I], z = !0, Y = F(null, R);
          for (let q in A) {
            let ee = A[q], B = Y[q];
            if (Array.isArray(ee)) {
              if (!ee.includes(B)) {
                z = !1;
                break;
              }
            } else {
              if ((ee == null || ee === !1) && (B == null || B === !1)) continue;
              if (B !== ee) {
                z = !1;
                break;
              }
            }
          }
          z && (D && x.push(D), L && x.push(L));
        }
        return x;
      }, M = (N) => {
        let R = v(y, N);
        if (!Array.isArray(R)) return R;
        let x = {}, P = t;
        for (let I = 0; I < R.length; I++) {
          let D = R[I];
          if (typeof D == "string") x.base = P(x.base, D)(c);
          else if (typeof D == "object") for (let L in D) x[L] = P(x[L], D[L])(c);
        }
        return x;
      }, E = (N) => {
        if (l.length < 1) return null;
        let R = {}, x = F(null, N);
        for (let P = 0; P < l.length; P++) {
          let { slots: I = [], class: D, className: L, ...A } = l[P];
          if (!Rt(A)) {
            let z = !0;
            for (let Y in A) {
              let q = x[Y], ee = A[Y];
              if (q === void 0 || (Array.isArray(ee) ? !ee.includes(q) : ee !== q)) {
                z = !1;
                break;
              }
            }
            if (!z) continue;
          }
          for (let z = 0; z < I.length; z++) {
            let Y = I[z];
            R[Y] || (R[Y] = []), R[Y].push([D, L]);
          }
        }
        return R;
      };
      if (!Rt(s) || !h) {
        let N = {};
        if (typeof b == "object" && !Rt(b)) {
          let R = t;
          for (let x in b) N[x] = (P) => {
            let I = M(P), D = E(P);
            return R(b[x], O(x, P), I ? I[x] : void 0, D ? D[x] : void 0, P == null ? void 0 : P.class, P == null ? void 0 : P.className)(c);
          };
        }
        return N;
      }
      return t(u, H(), v(y), w == null ? void 0 : w.class, w == null ? void 0 : w.className)(c);
    }, k = () => {
      if (!(!f || typeof f != "object")) return Object.keys(f);
    };
    return $.variantKeys = k(), $.extend = o, $.base = u, $.slots = b, $.variants = f, $.defaultVariants = p, $.compoundSlots = l, $.compoundVariants = y, $;
  };
  return { tv: e, createTV: (r) => (n, o) => e(n, o ? Nl(r, o) : r) };
};
const _d = "-", Iv = (t) => {
  const e = Ov(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (i) => {
      const a = i.split(_d);
      return a[0] === "" && a.length !== 1 && a.shift(), am(a, e) || Rv(i);
    },
    getConflictingClassGroupIds: (i, a) => {
      const l = r[i] || [];
      return a && n[i] ? [...l, ...n[i]] : l;
    }
  };
}, am = (t, e) => {
  var i;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), o = n ? am(t.slice(1), n) : void 0;
  if (o)
    return o;
  if (e.validators.length === 0)
    return;
  const s = t.join(_d);
  return (i = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : i.classGroupId;
}, Iu = /^\[(.+)\]$/, Rv = (t) => {
  if (Iu.test(t)) {
    const e = Iu.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, Ov = (t) => {
  const {
    theme: e,
    classGroups: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const o in r)
    Tl(r[o], n, o, e);
  return n;
}, Tl = (t, e, r, n) => {
  t.forEach((o) => {
    if (typeof o == "string") {
      const s = o === "" ? e : Ru(e, o);
      s.classGroupId = r;
      return;
    }
    if (typeof o == "function") {
      if (Lv(o)) {
        Tl(o(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: o,
        classGroupId: r
      });
      return;
    }
    Object.entries(o).forEach(([s, i]) => {
      Tl(i, Ru(e, s), r, n);
    });
  });
}, Ru = (t, e) => {
  let r = t;
  return e.split(_d).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, Lv = (t) => t.isThemeGetter, jv = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const o = (s, i) => {
    r.set(s, i), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let i = r.get(s);
      if (i !== void 0)
        return i;
      if ((i = n.get(s)) !== void 0)
        return o(s, i), i;
    },
    set(s, i) {
      r.has(s) ? r.set(s, i) : o(s, i);
    }
  };
}, Al = "!", Ml = ":", Dv = Ml.length, _v = (t) => {
  const {
    prefix: e,
    experimentalParseClassName: r
  } = t;
  let n = (o) => {
    const s = [];
    let i = 0, a = 0, l = 0, d;
    for (let h = 0; h < o.length; h++) {
      let g = o[h];
      if (i === 0 && a === 0) {
        if (g === Ml) {
          s.push(o.slice(l, h)), l = h + Dv;
          continue;
        }
        if (g === "/") {
          d = h;
          continue;
        }
      }
      g === "[" ? i++ : g === "]" ? i-- : g === "(" ? a++ : g === ")" && a--;
    }
    const c = s.length === 0 ? o : o.substring(l), u = Fv(c), f = u !== c, p = d && d > l ? d - l : void 0;
    return {
      modifiers: s,
      hasImportantModifier: f,
      baseClassName: u,
      maybePostfixModifierPosition: p
    };
  };
  if (e) {
    const o = e + Ml, s = n;
    n = (i) => i.startsWith(o) ? s(i.substring(o.length)) : {
      isExternal: !0,
      modifiers: [],
      hasImportantModifier: !1,
      baseClassName: i,
      maybePostfixModifierPosition: void 0
    };
  }
  if (r) {
    const o = n;
    n = (s) => r({
      className: s,
      parseClassName: o
    });
  }
  return n;
}, Fv = (t) => t.endsWith(Al) ? t.substring(0, t.length - 1) : t.startsWith(Al) ? t.substring(1) : t, zv = (t) => {
  const e = Object.fromEntries(t.orderSensitiveModifiers.map((n) => [n, !0]));
  return (n) => {
    if (n.length <= 1)
      return n;
    const o = [];
    let s = [];
    return n.forEach((i) => {
      i[0] === "[" || e[i] ? (o.push(...s.sort(), i), s = []) : s.push(i);
    }), o.push(...s.sort()), o;
  };
}, Hv = (t) => ({
  cache: jv(t.cacheSize),
  parseClassName: _v(t),
  sortModifiers: zv(t),
  ...Iv(t)
}), Bv = /\s+/, Vv = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: o,
    sortModifiers: s
  } = e, i = [], a = t.trim().split(Bv);
  let l = "";
  for (let d = a.length - 1; d >= 0; d -= 1) {
    const c = a[d], {
      isExternal: u,
      modifiers: f,
      hasImportantModifier: p,
      baseClassName: h,
      maybePostfixModifierPosition: g
    } = r(c);
    if (u) {
      l = c + (l.length > 0 ? " " + l : l);
      continue;
    }
    let b = !!g, y = n(b ? h.substring(0, g) : h);
    if (!y) {
      if (!b) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      if (y = n(h), !y) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      b = !1;
    }
    const $ = s(f).join(":"), k = p ? $ + Al : $, w = k + y;
    if (i.includes(w))
      continue;
    i.push(w);
    const C = o(y, b);
    for (let T = 0; T < C.length; ++T) {
      const H = C[T];
      i.push(k + H);
    }
    l = c + (l.length > 0 ? " " + l : l);
  }
  return l;
};
function Wv() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = lm(e)) && (n && (n += " "), n += r);
  return n;
}
const lm = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = lm(t[n])) && (r && (r += " "), r += e);
  return r;
};
function Pl(t, ...e) {
  let r, n, o, s = i;
  function i(l) {
    const d = e.reduce((c, u) => u(c), t());
    return r = Hv(d), n = r.cache.get, o = r.cache.set, s = a, a(l);
  }
  function a(l) {
    const d = n(l);
    if (d)
      return d;
    const c = Vv(l, r);
    return o(l, c), c;
  }
  return function() {
    return s(Wv.apply(null, arguments));
  };
}
const lt = (t) => {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}, dm = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, cm = /^\((?:(\w[\w-]*):)?(.+)\)$/i, Uv = /^\d+\/\d+$/, Gv = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Kv = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Yv = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, Jv = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, qv = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, zn = (t) => Uv.test(t), Ee = (t) => !!t && !Number.isNaN(Number(t)), zr = (t) => !!t && Number.isInteger(Number(t)), La = (t) => t.endsWith("%") && Ee(t.slice(0, -1)), xr = (t) => Gv.test(t), Xv = () => !0, Zv = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Kv.test(t) && !Yv.test(t)
), um = () => !1, Qv = (t) => Jv.test(t), e$ = (t) => qv.test(t), t$ = (t) => !re(t) && !ne(t), r$ = (t) => fo(t, hm, um), re = (t) => dm.test(t), dn = (t) => fo(t, mm, Zv), ja = (t) => fo(t, a$, Ee), Ou = (t) => fo(t, fm, um), n$ = (t) => fo(t, pm, e$), ys = (t) => fo(t, gm, Qv), ne = (t) => cm.test(t), vo = (t) => po(t, mm), o$ = (t) => po(t, l$), Lu = (t) => po(t, fm), s$ = (t) => po(t, hm), i$ = (t) => po(t, pm), vs = (t) => po(t, gm, !0), fo = (t, e, r) => {
  const n = dm.exec(t);
  return n ? n[1] ? e(n[1]) : r(n[2]) : !1;
}, po = (t, e, r = !1) => {
  const n = cm.exec(t);
  return n ? n[1] ? e(n[1]) : r : !1;
}, fm = (t) => t === "position" || t === "percentage", pm = (t) => t === "image" || t === "url", hm = (t) => t === "length" || t === "size" || t === "bg-size", mm = (t) => t === "length", a$ = (t) => t === "number", l$ = (t) => t === "family-name", gm = (t) => t === "shadow", Il = () => {
  const t = lt("color"), e = lt("font"), r = lt("text"), n = lt("font-weight"), o = lt("tracking"), s = lt("leading"), i = lt("breakpoint"), a = lt("container"), l = lt("spacing"), d = lt("radius"), c = lt("shadow"), u = lt("inset-shadow"), f = lt("text-shadow"), p = lt("drop-shadow"), h = lt("blur"), g = lt("perspective"), b = lt("aspect"), y = lt("ease"), $ = lt("animate"), k = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], w = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], C = () => [...w(), ne, re], T = () => ["auto", "hidden", "clip", "visible", "scroll"], H = () => ["auto", "contain", "none"], O = () => [ne, re, l], j = () => [zn, "full", "auto", ...O()], F = () => [zr, "none", "subgrid", ne, re], v = () => ["auto", {
    span: ["full", zr, ne, re]
  }, zr, ne, re], M = () => [zr, "auto", ne, re], E = () => ["auto", "min", "max", "fr", ne, re], N = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], R = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], x = () => ["auto", ...O()], P = () => [zn, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...O()], I = () => [t, ne, re], D = () => [...w(), Lu, Ou, {
    position: [ne, re]
  }], L = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], A = () => ["auto", "cover", "contain", s$, r$, {
    size: [ne, re]
  }], z = () => [La, vo, dn], Y = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    d,
    ne,
    re
  ], q = () => ["", Ee, vo, dn], ee = () => ["solid", "dashed", "dotted", "double"], B = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], _ = () => [Ee, La, Lu, Ou], W = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    h,
    ne,
    re
  ], ie = () => ["none", Ee, ne, re], pe = () => ["none", Ee, ne, re], ye = () => [Ee, ne, re], Ce = () => [zn, "full", ...O()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [xr],
      breakpoint: [xr],
      color: [Xv],
      container: [xr],
      "drop-shadow": [xr],
      ease: ["in", "out", "in-out"],
      font: [t$],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [xr],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [xr],
      shadow: [xr],
      spacing: ["px", Ee],
      text: [xr],
      "text-shadow": [xr],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", zn, re, ne, b]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ee, re, ne, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": k()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": k()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: C()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: T()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": T()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": T()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: H()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": H()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": H()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: j()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": j()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": j()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: j()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: j()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: j()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: j()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: j()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: j()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [zr, "auto", ne, re]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [zn, "full", "auto", a, ...O()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Ee, zn, "auto", "initial", "none", re]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Ee, ne, re]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Ee, ne, re]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [zr, "first", "last", "none", ne, re]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": F()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: v()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": M()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": M()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": F()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: v()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": M()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": M()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": E()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": E()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: O()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": O()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": O()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...N(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...R(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...R()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...N()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...R(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...R(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": N()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...R(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...R()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: O()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: O()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: O()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: O()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: O()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: O()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: O()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: O()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: O()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: x()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: x()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: x()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: x()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: x()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: x()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: x()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: x()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: x()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": O()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": O()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: P()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...P()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...P()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [i]
          },
          ...P()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...P()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...P()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...P()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", r, vo, dn]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [n, ne, ja]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", La, re]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [o$, re, e]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [o, ne, re]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Ee, "none", ne, ja]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          s,
          ...O()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ne, re]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", ne, re]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: I()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: I()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ee(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Ee, "from-font", "auto", ne, dn]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: I()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Ee, "auto", ne, re]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: O()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ne, re]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ne, re]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: D()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: L()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: A()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, zr, ne, re],
          radial: ["", ne, re],
          conic: [zr, ne, re]
        }, i$, n$]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: I()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: z()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: z()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: z()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: I()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: I()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: I()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: Y()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": Y()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": Y()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": Y()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": Y()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": Y()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": Y()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": Y()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": Y()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": Y()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": Y()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": Y()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": Y()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": Y()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": Y()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: q()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": q()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": q()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": q()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": q()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": q()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": q()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": q()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": q()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": q()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": q()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ee(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...ee(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: I()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": I()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": I()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": I()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": I()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": I()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": I()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": I()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": I()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: I()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...ee(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ee, ne, re]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Ee, vo, dn]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: I()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          vs,
          ys
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: I()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", u, vs, ys]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": I()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: q()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: I()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Ee, dn]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": I()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": q()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": I()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", f, vs, ys]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": I()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Ee, ne, re]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...B(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": B()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Ee]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": _()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": _()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": I()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": I()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": _()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": _()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": I()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": I()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": _()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": _()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": I()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": I()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": _()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": _()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": I()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": I()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": _()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": _()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": I()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": I()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": _()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": _()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": I()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": I()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": _()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": _()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": I()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": I()
      }],
      "mask-image-radial": [{
        "mask-radial": [ne, re]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": _()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": _()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": I()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": I()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": w()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Ee]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": _()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": _()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": I()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": I()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: D()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: L()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: A()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", ne, re]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ne,
          re
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: W()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ee, ne, re]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Ee, ne, re]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          p,
          vs,
          ys
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": I()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Ee, ne, re]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Ee, ne, re]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Ee, ne, re]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ee, ne, re]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Ee, ne, re]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ne,
          re
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": W()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ee, ne, re]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Ee, ne, re]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Ee, ne, re]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Ee, ne, re]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Ee, ne, re]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Ee, ne, re]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ee, ne, re]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Ee, ne, re]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": O()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": O()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": O()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ne, re]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Ee, "initial", ne, re]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", y, ne, re]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Ee, ne, re]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", $, ne, re]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [g, ne, re]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": C()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: ie()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": ie()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": ie()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": ie()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: pe()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": pe()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": pe()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": pe()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: ye()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": ye()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": ye()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [ne, re, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: C()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Ce()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Ce()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Ce()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Ce()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: I()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: I()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ne, re]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": O()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": O()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": O()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": O()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": O()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": O()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": O()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": O()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": O()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": O()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": O()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": O()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": O()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": O()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": O()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": O()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": O()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": O()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ne, re]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...I()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ee, vo, dn, ja]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...I()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, d$ = (t, {
  cacheSize: e,
  prefix: r,
  experimentalParseClassName: n,
  extend: o = {},
  override: s = {}
}) => (So(t, "cacheSize", e), So(t, "prefix", r), So(t, "experimentalParseClassName", n), $s(t.theme, s.theme), $s(t.classGroups, s.classGroups), $s(t.conflictingClassGroups, s.conflictingClassGroups), $s(t.conflictingClassGroupModifiers, s.conflictingClassGroupModifiers), So(t, "orderSensitiveModifiers", s.orderSensitiveModifiers), xs(t.theme, o.theme), xs(t.classGroups, o.classGroups), xs(t.conflictingClassGroups, o.conflictingClassGroups), xs(t.conflictingClassGroupModifiers, o.conflictingClassGroupModifiers), bm(t, o, "orderSensitiveModifiers"), t), So = (t, e, r) => {
  r !== void 0 && (t[e] = r);
}, $s = (t, e) => {
  if (e)
    for (const r in e)
      So(t, r, e[r]);
}, xs = (t, e) => {
  if (e)
    for (const r in e)
      bm(t, e, r);
}, bm = (t, e, r) => {
  const n = e[r];
  n !== void 0 && (t[r] = t[r] ? t[r].concat(n) : n);
}, c$ = (t, ...e) => typeof t == "function" ? Pl(Il, t, ...e) : Pl(() => d$(Il(), t), ...e), u$ = /* @__PURE__ */ Pl(Il);
var f$ = (t) => Rt(t) ? u$ : c$({ ...t, extend: { theme: t.theme, classGroups: t.classGroups, conflictingClassGroupModifiers: t.conflictingClassGroupModifiers, conflictingClassGroups: t.conflictingClassGroups, ...t.extend } }), p$ = (...t) => (e) => {
  let r = ti(t);
  return !r || !e.twMerge ? r : ((!Tr.cachedTwMerge || Tr.didTwMergeConfigChange) && (Tr.didTwMergeConfigChange = !1, Tr.cachedTwMerge = f$(Tr.cachedTwMergeConfig)), Tr.cachedTwMerge(r) || void 0);
}, { tv: h$ } = Pv(p$), oa = (t, e) => {
  var r, n, o;
  return h$(t, {
    ...e,
    twMerge: (r = void 0) != null ? r : !0,
    twMergeConfig: {
      theme: {
        ...(n = void 0) == null ? void 0 : n.theme,
        ...Au.theme
      },
      classGroups: {
        ...(o = void 0) == null ? void 0 : o.classGroups,
        ...Au.classGroups
      }
    }
  });
}, ju = oa({
  slots: {
    base: "relative inline-flex flex-col gap-2 items-center justify-center",
    wrapper: "relative flex",
    label: "text-foreground dark:text-foreground-dark font-regular",
    circle1: "absolute w-full h-full rounded-full",
    circle2: "absolute w-full h-full rounded-full",
    dots: "relative rounded-full mx-auto",
    spinnerBars: [
      "absolute",
      "animate-fade-out",
      "rounded-full",
      "w-[25%]",
      "h-[8%]",
      "left-[calc(37.5%)]",
      "top-[calc(46%)]",
      "spinner-bar-animation"
    ]
  },
  variants: {
    size: {
      sm: {
        wrapper: "w-5 h-5",
        circle1: "border-2",
        circle2: "border-2",
        dots: "size-1",
        label: "text-small"
      },
      md: {
        wrapper: "w-8 h-8",
        circle1: "border-3",
        circle2: "border-3",
        dots: "size-1.5",
        label: "text-medium"
      },
      lg: {
        wrapper: "w-10 h-10",
        circle1: "border-3",
        circle2: "border-3",
        dots: "size-2",
        label: "text-large"
      }
    },
    color: {
      current: {
        circle1: "border-b-current",
        circle2: "border-b-current",
        dots: "bg-current",
        spinnerBars: "bg-current"
      },
      white: {
        circle1: "border-b-white",
        circle2: "border-b-white",
        dots: "bg-white",
        spinnerBars: "bg-white"
      },
      default: {
        circle1: "border-b-default",
        circle2: "border-b-default",
        dots: "bg-default",
        spinnerBars: "bg-default"
      },
      primary: {
        circle1: "border-b-primary",
        circle2: "border-b-primary",
        dots: "bg-primary",
        spinnerBars: "bg-primary"
      },
      secondary: {
        circle1: "border-b-secondary",
        circle2: "border-b-secondary",
        dots: "bg-secondary",
        spinnerBars: "bg-secondary"
      },
      success: {
        circle1: "border-b-success",
        circle2: "border-b-success",
        dots: "bg-success",
        spinnerBars: "bg-success"
      },
      warning: {
        circle1: "border-b-warning",
        circle2: "border-b-warning",
        dots: "bg-warning",
        spinnerBars: "bg-warning"
      },
      danger: {
        circle1: "border-b-danger",
        circle2: "border-b-danger",
        dots: "bg-danger",
        spinnerBars: "bg-danger"
      }
    },
    labelColor: {
      foreground: {
        label: "text-foreground"
      },
      primary: {
        label: "text-primary"
      },
      secondary: {
        label: "text-secondary"
      },
      success: {
        label: "text-success"
      },
      warning: {
        label: "text-warning"
      },
      danger: {
        label: "text-danger"
      }
    },
    variant: {
      default: {
        circle1: [
          "animate-spinner-ease-spin",
          "border-solid",
          "border-t-transparent",
          "border-l-transparent",
          "border-r-transparent"
        ],
        circle2: [
          "opacity-75",
          "animate-spinner-linear-spin",
          "border-dotted",
          "border-t-transparent",
          "border-l-transparent",
          "border-r-transparent"
        ]
      },
      gradient: {
        circle1: [
          "border-0",
          "bg-gradient-to-b",
          "from-transparent",
          "via-transparent",
          "to-primary",
          "animate-spinner-linear-spin",
          "[animation-duration:1s]",
          "[-webkit-mask:radial-gradient(closest-side,rgba(0,0,0,0.0)calc(100%-3px),rgba(0,0,0,1)calc(100%-3px))]"
        ],
        circle2: ["hidden"]
      },
      wave: {
        wrapper: "translate-y-3/4",
        dots: ["animate-sway", "spinner-dot-animation"]
      },
      dots: {
        wrapper: "translate-y-2/4",
        dots: ["animate-blink", "spinner-dot-blink-animation"]
      },
      spinner: {},
      simple: {
        wrapper: "text-foreground h-5 w-5 animate-spin",
        circle1: "opacity-25",
        circle2: "opacity-75"
      }
    }
  },
  defaultVariants: {
    size: "md",
    color: "primary",
    labelColor: "foreground",
    variant: "default"
  },
  compoundVariants: [
    { variant: "gradient", color: "current", class: { circle1: "to-current" } },
    { variant: "gradient", color: "white", class: { circle1: "to-white" } },
    { variant: "gradient", color: "default", class: { circle1: "to-default" } },
    { variant: "gradient", color: "primary", class: { circle1: "to-primary" } },
    { variant: "gradient", color: "secondary", class: { circle1: "to-secondary" } },
    { variant: "gradient", color: "success", class: { circle1: "to-success" } },
    { variant: "gradient", color: "warning", class: { circle1: "to-warning" } },
    { variant: "gradient", color: "danger", class: { circle1: "to-danger" } },
    {
      variant: "wave",
      size: "sm",
      class: {
        wrapper: "w-5 h-5"
      }
    },
    {
      variant: "wave",
      size: "md",
      class: {
        wrapper: "w-8 h-8"
      }
    },
    {
      variant: "wave",
      size: "lg",
      class: {
        wrapper: "w-12 h-12"
      }
    },
    {
      variant: "dots",
      size: "sm",
      class: {
        wrapper: "w-5 h-5"
      }
    },
    {
      variant: "dots",
      size: "md",
      class: {
        wrapper: "w-8 h-8"
      }
    },
    {
      variant: "dots",
      size: "lg",
      class: {
        wrapper: "w-12 h-12"
      }
    },
    // Simple variants
    // Size
    {
      variant: "simple",
      size: "sm",
      class: {
        wrapper: "w-5 h-5"
      }
    },
    {
      variant: "simple",
      size: "md",
      class: {
        wrapper: "w-8 h-8"
      }
    },
    {
      variant: "simple",
      size: "lg",
      class: {
        wrapper: "w-12 h-12"
      }
    },
    // Color
    {
      variant: "simple",
      color: "current",
      class: {
        wrapper: "text-current"
      }
    },
    {
      variant: "simple",
      color: "white",
      class: {
        wrapper: "text-white"
      }
    },
    {
      variant: "simple",
      color: "default",
      class: {
        wrapper: "text-default"
      }
    },
    {
      variant: "simple",
      color: "primary",
      class: {
        wrapper: "text-primary"
      }
    },
    {
      variant: "simple",
      color: "secondary",
      class: {
        wrapper: "text-secondary"
      }
    },
    {
      variant: "simple",
      color: "success",
      class: {
        wrapper: "text-success"
      }
    },
    {
      variant: "simple",
      color: "warning",
      class: {
        wrapper: "text-warning"
      }
    },
    {
      variant: "simple",
      color: "danger",
      class: {
        wrapper: "text-danger"
      }
    }
  ]
}), ym = [
  "outline-solid outline-transparent",
  "data-[focus-visible=true]:z-10",
  "data-[focus-visible=true]:outline-2",
  "data-[focus-visible=true]:outline-focus",
  "data-[focus-visible=true]:outline-offset-2"
], Hn = {
  default: ["[&+.border-medium.border-default]:ms-[calc(var(--heroui-border-width-medium)*-1)]"],
  primary: ["[&+.border-medium.border-primary]:ms-[calc(var(--heroui-border-width-medium)*-1)]"],
  secondary: [
    "[&+.border-medium.border-secondary]:ms-[calc(var(--heroui-border-width-medium)*-1)]"
  ],
  success: ["[&+.border-medium.border-success]:ms-[calc(var(--heroui-border-width-medium)*-1)]"],
  warning: ["[&+.border-medium.border-warning]:ms-[calc(var(--heroui-border-width-medium)*-1)]"],
  danger: ["[&+.border-medium.border-danger]:ms-[calc(var(--heroui-border-width-medium)*-1)]"]
}, ri = oa({
  slots: {
    base: [
      "z-0",
      "relative",
      "bg-transparent",
      "[transform-origin:var(--trigger-anchor-point)]",
      // arrow
      "before:content-['']",
      "before:hidden",
      "before:z-[-1]",
      "before:absolute",
      "before:rotate-45",
      "before:w-2.5",
      "before:h-2.5",
      "before:rounded-sm",
      // visibility
      "data-[arrow=true]:before:block",
      // top
      "data-[placement=top]:before:-bottom-[calc(theme(spacing.5)/4_-_1.5px)]",
      "data-[placement=top]:before:left-1/2",
      "data-[placement=top]:before:-translate-x-1/2",
      "data-[placement=top-start]:before:-bottom-[calc(theme(spacing.5)/4_-_1.5px)]",
      "data-[placement=top-start]:before:left-3",
      "data-[placement=top-end]:before:-bottom-[calc(theme(spacing.5)/4_-_1.5px)]",
      "data-[placement=top-end]:before:right-3",
      // bottom
      "data-[placement=bottom]:before:-top-[calc(theme(spacing.5)/4_-_1.5px)]",
      "data-[placement=bottom]:before:left-1/2",
      "data-[placement=bottom]:before:-translate-x-1/2",
      "data-[placement=bottom-start]:before:-top-[calc(theme(spacing.5)/4_-_1.5px)]",
      "data-[placement=bottom-start]:before:left-3",
      "data-[placement=bottom-end]:before:-top-[calc(theme(spacing.5)/4_-_1.5px)]",
      "data-[placement=bottom-end]:before:right-3",
      // left
      "data-[placement=left]:before:-right-[calc(theme(spacing.5)/4_-_2px)]",
      "data-[placement=left]:before:top-1/2",
      "data-[placement=left]:before:-translate-y-1/2",
      "data-[placement=left-start]:before:-right-[calc(theme(spacing.5)/4_-_3px)]",
      "data-[placement=left-start]:before:top-1/4",
      "data-[placement=left-end]:before:-right-[calc(theme(spacing.5)/4_-_3px)]",
      "data-[placement=left-end]:before:bottom-1/4",
      // right
      "data-[placement=right]:before:-left-[calc(theme(spacing.5)/4_-_2px)]",
      "data-[placement=right]:before:top-1/2",
      "data-[placement=right]:before:-translate-y-1/2",
      "data-[placement=right-start]:before:-left-[calc(theme(spacing.5)/4_-_3px)]",
      "data-[placement=right-start]:before:top-1/4",
      "data-[placement=right-end]:before:-left-[calc(theme(spacing.5)/4_-_3px)]",
      "data-[placement=right-end]:before:bottom-1/4",
      // focus ring
      ...ym
    ],
    content: [
      "z-10",
      "px-2.5",
      "py-1",
      "w-full",
      "inline-flex",
      "flex-col",
      "items-center",
      "justify-center",
      "box-border",
      "subpixel-antialiased",
      "outline-solid outline-transparent",
      "box-border"
    ],
    trigger: ["z-10"],
    backdrop: ["hidden"],
    arrow: []
  },
  variants: {
    size: {
      sm: { content: "text-tiny" },
      md: { content: "text-small" },
      lg: { content: "text-medium" }
    },
    color: {
      default: {
        base: "before:bg-content1 before:shadow-small",
        content: "bg-content1"
      },
      foreground: {
        base: "before:bg-foreground",
        content: he.solid.foreground
      },
      primary: {
        base: "before:bg-primary",
        content: he.solid.primary
      },
      secondary: {
        base: "before:bg-secondary",
        content: he.solid.secondary
      },
      success: {
        base: "before:bg-success",
        content: he.solid.success
      },
      warning: {
        base: "before:bg-warning",
        content: he.solid.warning
      },
      danger: {
        base: "before:bg-danger",
        content: he.solid.danger
      }
    },
    radius: {
      none: { content: "rounded-none" },
      sm: { content: "rounded-small" },
      md: { content: "rounded-medium" },
      lg: { content: "rounded-large" },
      full: { content: "rounded-full" }
    },
    shadow: {
      none: {
        content: "shadow-none"
      },
      sm: {
        content: "shadow-small"
      },
      md: {
        content: "shadow-medium"
      },
      lg: {
        content: "shadow-large"
      }
    },
    backdrop: {
      transparent: {},
      opaque: {
        backdrop: "bg-overlay/50 backdrop-opacity-disabled"
      },
      blur: {
        backdrop: "backdrop-blur-sm backdrop-saturate-150 bg-overlay/30"
      }
    },
    triggerScaleOnOpen: {
      true: {
        trigger: ["aria-expanded:scale-[0.97]", "aria-expanded:opacity-70", "subpixel-antialiased"]
      },
      false: {}
    },
    disableAnimation: {
      true: {
        base: "animate-none"
      }
    },
    isTriggerDisabled: {
      true: {
        trigger: "opacity-disabled pointer-events-none"
      },
      false: {}
    }
  },
  defaultVariants: {
    color: "default",
    radius: "lg",
    size: "md",
    shadow: "md",
    backdrop: "transparent",
    triggerScaleOnOpen: !0
  },
  compoundVariants: [
    // backdrop (opaque/blur)
    {
      backdrop: ["opaque", "blur"],
      class: {
        backdrop: "block w-full h-full fixed inset-0 -z-30"
      }
    }
  ]
}), m$ = oa({
  base: [
    "z-0",
    "group",
    "relative",
    "inline-flex",
    "items-center",
    "justify-center",
    "box-border",
    "appearance-none",
    "outline-solid outline-transparent",
    "select-none",
    "whitespace-nowrap",
    "min-w-max",
    "font-normal",
    "subpixel-antialiased",
    "overflow-hidden",
    "tap-highlight-transparent",
    "transform-gpu data-[pressed=true]:scale-[0.97]",
    "cursor-pointer",
    // focus ring
    ...ym
  ],
  variants: {
    variant: {
      solid: "",
      bordered: "border-medium bg-transparent",
      light: "bg-transparent",
      flat: "",
      faded: "border-medium",
      shadow: "",
      ghost: "border-medium bg-transparent"
    },
    size: {
      sm: "px-3 min-w-16 h-8 text-tiny gap-2 rounded-small",
      md: "px-4 min-w-20 h-10 text-small gap-2 rounded-medium",
      lg: "px-6 min-w-24 h-12 text-medium gap-3 rounded-large"
    },
    color: {
      default: "",
      primary: "",
      secondary: "",
      success: "",
      warning: "",
      danger: ""
    },
    radius: {
      none: "rounded-none",
      sm: "rounded-small",
      md: "rounded-medium",
      lg: "rounded-large",
      full: "rounded-full"
    },
    fullWidth: {
      true: "w-full"
    },
    isDisabled: {
      true: "opacity-disabled pointer-events-none"
    },
    isInGroup: {
      true: "[&:not(:first-child):not(:last-child)]:rounded-none"
    },
    isIconOnly: {
      true: "px-0 !gap-0",
      false: "[&>svg]:max-w-[theme(spacing.8)]"
    },
    disableAnimation: {
      true: "!transition-none data-[pressed=true]:scale-100",
      false: "transition-transform-colors-opacity motion-reduce:transition-none"
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    color: "default",
    fullWidth: !1,
    isDisabled: !1,
    isInGroup: !1
  },
  compoundVariants: [
    // solid / color
    {
      variant: "solid",
      color: "default",
      class: he.solid.default
    },
    {
      variant: "solid",
      color: "primary",
      class: he.solid.primary
    },
    {
      variant: "solid",
      color: "secondary",
      class: he.solid.secondary
    },
    {
      variant: "solid",
      color: "success",
      class: he.solid.success
    },
    {
      variant: "solid",
      color: "warning",
      class: he.solid.warning
    },
    {
      variant: "solid",
      color: "danger",
      class: he.solid.danger
    },
    // shadow / color
    {
      variant: "shadow",
      color: "default",
      class: he.shadow.default
    },
    {
      variant: "shadow",
      color: "primary",
      class: he.shadow.primary
    },
    {
      variant: "shadow",
      color: "secondary",
      class: he.shadow.secondary
    },
    {
      variant: "shadow",
      color: "success",
      class: he.shadow.success
    },
    {
      variant: "shadow",
      color: "warning",
      class: he.shadow.warning
    },
    {
      variant: "shadow",
      color: "danger",
      class: he.shadow.danger
    },
    // bordered / color
    {
      variant: "bordered",
      color: "default",
      class: he.bordered.default
    },
    {
      variant: "bordered",
      color: "primary",
      class: he.bordered.primary
    },
    {
      variant: "bordered",
      color: "secondary",
      class: he.bordered.secondary
    },
    {
      variant: "bordered",
      color: "success",
      class: he.bordered.success
    },
    {
      variant: "bordered",
      color: "warning",
      class: he.bordered.warning
    },
    {
      variant: "bordered",
      color: "danger",
      class: he.bordered.danger
    },
    // flat / color
    {
      variant: "flat",
      color: "default",
      class: he.flat.default
    },
    {
      variant: "flat",
      color: "primary",
      class: he.flat.primary
    },
    {
      variant: "flat",
      color: "secondary",
      class: he.flat.secondary
    },
    {
      variant: "flat",
      color: "success",
      class: he.flat.success
    },
    {
      variant: "flat",
      color: "warning",
      class: he.flat.warning
    },
    {
      variant: "flat",
      color: "danger",
      class: he.flat.danger
    },
    // faded / color
    {
      variant: "faded",
      color: "default",
      class: he.faded.default
    },
    {
      variant: "faded",
      color: "primary",
      class: he.faded.primary
    },
    {
      variant: "faded",
      color: "secondary",
      class: he.faded.secondary
    },
    {
      variant: "faded",
      color: "success",
      class: he.faded.success
    },
    {
      variant: "faded",
      color: "warning",
      class: he.faded.warning
    },
    {
      variant: "faded",
      color: "danger",
      class: he.faded.danger
    },
    // light / color
    {
      variant: "light",
      color: "default",
      class: [he.light.default, "data-[hover=true]:bg-default/40"]
    },
    {
      variant: "light",
      color: "primary",
      class: [he.light.primary, "data-[hover=true]:bg-primary/20"]
    },
    {
      variant: "light",
      color: "secondary",
      class: [he.light.secondary, "data-[hover=true]:bg-secondary/20"]
    },
    {
      variant: "light",
      color: "success",
      class: [he.light.success, "data-[hover=true]:bg-success/20"]
    },
    {
      variant: "light",
      color: "warning",
      class: [he.light.warning, "data-[hover=true]:bg-warning/20"]
    },
    {
      variant: "light",
      color: "danger",
      class: [he.light.danger, "data-[hover=true]:bg-danger/20"]
    },
    // ghost / color
    {
      variant: "ghost",
      color: "default",
      class: [he.ghost.default, "data-[hover=true]:!bg-default"]
    },
    {
      variant: "ghost",
      color: "primary",
      class: [
        he.ghost.primary,
        "data-[hover=true]:!bg-primary data-[hover=true]:!text-primary-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "secondary",
      class: [
        he.ghost.secondary,
        "data-[hover=true]:!bg-secondary data-[hover=true]:!text-secondary-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "success",
      class: [
        he.ghost.success,
        "data-[hover=true]:!bg-success data-[hover=true]:!text-success-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "warning",
      class: [
        he.ghost.warning,
        "data-[hover=true]:!bg-warning data-[hover=true]:!text-warning-foreground"
      ]
    },
    {
      variant: "ghost",
      color: "danger",
      class: [
        he.ghost.danger,
        "data-[hover=true]:!bg-danger data-[hover=true]:!text-danger-foreground"
      ]
    },
    // isInGroup / radius / size <-- radius not provided
    {
      isInGroup: !0,
      class: "rounded-none first:rounded-s-medium last:rounded-e-medium"
    },
    {
      isInGroup: !0,
      size: "sm",
      class: "rounded-none first:rounded-s-small last:rounded-e-small"
    },
    {
      isInGroup: !0,
      size: "md",
      class: "rounded-none first:rounded-s-medium last:rounded-e-medium"
    },
    {
      isInGroup: !0,
      size: "lg",
      class: "rounded-none first:rounded-s-large last:rounded-e-large"
    },
    {
      isInGroup: !0,
      isRounded: !0,
      class: "rounded-none first:rounded-s-full last:rounded-e-full"
    },
    // isInGroup / radius <-- radius provided
    {
      isInGroup: !0,
      radius: "none",
      class: "rounded-none first:rounded-s-none last:rounded-e-none"
    },
    {
      isInGroup: !0,
      radius: "sm",
      class: "rounded-none first:rounded-s-small last:rounded-e-small"
    },
    {
      isInGroup: !0,
      radius: "md",
      class: "rounded-none first:rounded-s-medium last:rounded-e-medium"
    },
    {
      isInGroup: !0,
      radius: "lg",
      class: "rounded-none first:rounded-s-large last:rounded-e-large"
    },
    {
      isInGroup: !0,
      radius: "full",
      class: "rounded-none first:rounded-s-full last:rounded-e-full"
    },
    // isInGroup / bordered / ghost
    {
      isInGroup: !0,
      variant: ["ghost", "bordered"],
      color: "default",
      className: Hn.default
    },
    {
      isInGroup: !0,
      variant: ["ghost", "bordered"],
      color: "primary",
      className: Hn.primary
    },
    {
      isInGroup: !0,
      variant: ["ghost", "bordered"],
      color: "secondary",
      className: Hn.secondary
    },
    {
      isInGroup: !0,
      variant: ["ghost", "bordered"],
      color: "success",
      className: Hn.success
    },
    {
      isInGroup: !0,
      variant: ["ghost", "bordered"],
      color: "warning",
      className: Hn.warning
    },
    {
      isInGroup: !0,
      variant: ["ghost", "bordered"],
      color: "danger",
      className: Hn.danger
    },
    {
      isIconOnly: !0,
      size: "sm",
      class: "min-w-8 w-8 h-8"
    },
    {
      isIconOnly: !0,
      size: "md",
      class: "min-w-10 w-10 h-10"
    },
    {
      isIconOnly: !0,
      size: "lg",
      class: "min-w-12 w-12 h-12"
    },
    // variant / hover
    {
      variant: ["solid", "faded", "flat", "bordered", "shadow"],
      class: "data-[hover=true]:opacity-hover"
    }
  ]
});
oa({
  base: "inline-flex items-center justify-center h-auto",
  variants: {
    fullWidth: {
      true: "w-full"
    }
  },
  defaultVariants: {
    fullWidth: !1
  }
});
var Du = {
  ease: [0.36, 0.66, 0.4, 1]
}, Rl = {
  scaleSpring: {
    enter: {
      transform: "scale(1)",
      opacity: 1,
      transition: {
        type: "spring",
        bounce: 0,
        duration: 0.2
      }
    },
    exit: {
      transform: "scale(0.85)",
      opacity: 0,
      transition: {
        type: "easeOut",
        duration: 0.15
      }
    }
  },
  scaleSpringOpacity: {
    initial: {
      opacity: 0,
      transform: "scale(0.8)"
    },
    enter: {
      opacity: 1,
      transform: "scale(1)",
      transition: {
        type: "spring",
        bounce: 0,
        duration: 0.3
      }
    },
    exit: {
      opacity: 0,
      transform: "scale(0.96)",
      transition: {
        type: "easeOut",
        bounce: 0,
        duration: 0.15
      }
    }
  },
  fade: {
    enter: {
      opacity: 1,
      transition: {
        duration: 0.4,
        ease: Du.ease
      }
    },
    exit: {
      opacity: 0,
      transition: {
        duration: 0.3,
        ease: Du.ease
      }
    }
  }
};
function g$(t) {
  return Oe(t);
}
var b$ = (t, e, r = !0) => {
  if (!e)
    return [t, {}];
  const n = e.reduce((o, s) => s in t ? { ...o, [s]: t[s] } : o, {});
  return r ? [Object.keys(t).filter((s) => !e.includes(s)).reduce((s, i) => ({ ...s, [i]: t[i] }), {}), n] : [t, n];
}, vm = (t) => {
  const e = {
    top: {
      originY: 1
    },
    bottom: {
      originY: 0
    },
    left: {
      originX: 1
    },
    right: {
      originX: 0
    },
    "top-start": {
      originX: 0,
      originY: 1
    },
    "top-end": {
      originX: 1,
      originY: 1
    },
    "bottom-start": {
      originX: 0,
      originY: 0
    },
    "bottom-end": {
      originX: 1,
      originY: 0
    },
    "right-start": {
      originX: 0,
      originY: 0
    },
    "right-end": {
      originX: 0,
      originY: 1
    },
    "left-start": {
      originX: 1,
      originY: 0
    },
    "left-end": {
      originX: 1,
      originY: 1
    }
  };
  return (e == null ? void 0 : e[t]) || {};
}, $m = (t) => ({
  top: "top",
  bottom: "bottom",
  left: "left",
  right: "right",
  "top-start": "top start",
  "top-end": "top end",
  "bottom-start": "bottom start",
  "bottom-end": "bottom end",
  "left-start": "left top",
  "left-end": "left bottom",
  "right-start": "right top",
  "right-end": "right bottom"
})[t], y$ = (t, e) => {
  if (e.includes("-")) {
    const [r] = e.split("-");
    if (r.includes(t))
      return !1;
  }
  return !0;
}, ni = (t, e) => {
  if (e.includes("-")) {
    const [, r] = e.split("-");
    return `${t}-${r}`;
  }
  return t;
}, $o = /* @__PURE__ */ new WeakMap(), Ot = [];
function v$(t, e = document.body) {
  let r = new Set(t), n = /* @__PURE__ */ new Set(), o = (l) => {
    for (let f of l.querySelectorAll(
      "[data-live-announcer], [data-react-aria-top-layer]"
    ))
      r.add(f);
    let d = (f) => {
      if (r.has(f) || f.parentElement && n.has(f.parentElement) && f.parentElement.getAttribute("role") !== "row")
        return NodeFilter.FILTER_REJECT;
      for (let p of r)
        if (f.contains(p))
          return NodeFilter.FILTER_SKIP;
      return NodeFilter.FILTER_ACCEPT;
    }, c = document.createTreeWalker(l, NodeFilter.SHOW_ELEMENT, { acceptNode: d }), u = d(l);
    if (u === NodeFilter.FILTER_ACCEPT && s(l), u !== NodeFilter.FILTER_REJECT) {
      let f = c.nextNode();
      for (; f != null; )
        s(f), f = c.nextNode();
    }
  }, s = (l) => {
    var d;
    let c = (d = $o.get(l)) != null ? d : 0;
    l.getAttribute("aria-hidden") === "true" && c === 0 || (c === 0 && l.setAttribute("aria-hidden", "true"), n.add(l), $o.set(l, c + 1));
  };
  Ot.length && Ot[Ot.length - 1].disconnect(), o(e);
  let i = new MutationObserver((l) => {
    for (let d of l)
      if (!(d.type !== "childList" || d.addedNodes.length === 0) && ![...r, ...n].some((c) => c.contains(d.target))) {
        for (let c of d.removedNodes)
          c instanceof Element && (r.delete(c), n.delete(c));
        for (let c of d.addedNodes)
          (c instanceof HTMLElement || c instanceof SVGElement) && (c.dataset.liveAnnouncer === "true" || c.dataset.reactAriaTopLayer === "true") ? r.add(c) : c instanceof Element && o(c);
      }
  });
  i.observe(e, { childList: !0, subtree: !0 });
  let a = {
    visibleNodes: r,
    hiddenNodes: n,
    observe() {
      i.observe(e, { childList: !0, subtree: !0 });
    },
    disconnect() {
      i.disconnect();
    }
  };
  return Ot.push(a), () => {
    i.disconnect();
    for (let l of n) {
      let d = $o.get(l);
      d != null && (d === 1 ? (l.removeAttribute("aria-hidden"), $o.delete(l)) : $o.set(l, d - 1));
    }
    a === Ot[Ot.length - 1] ? (Ot.pop(), Ot.length && Ot[Ot.length - 1].observe()) : Ot.splice(Ot.indexOf(a), 1);
  };
}
function $$(t) {
  let e = Ot[Ot.length - 1];
  if (e && !e.visibleNodes.has(t))
    return e.visibleNodes.add(t), () => {
      e.visibleNodes.delete(t);
    };
}
var xm = globalThis != null && globalThis.document ? kp : me, [J7, x$] = vd({
  name: "ButtonGroupContext",
  strict: !1
});
function wm(t, e) {
  let {
    elementType: r = "button",
    isDisabled: n,
    onPress: o,
    onPressStart: s,
    onPressEnd: i,
    onPressUp: a,
    onPressChange: l,
    // @ts-ignore - undocumented
    preventFocusOnPress: d,
    // @ts-ignore - undocumented
    allowFocusWhenDisabled: c,
    onClick: u,
    href: f,
    target: p,
    rel: h,
    type: g = "button",
    allowTextSelectionOnPress: b
  } = t, y;
  r === "button" ? y = {
    type: g,
    disabled: n
  } : y = {
    role: "button",
    href: r === "a" && !n ? f : void 0,
    target: r === "a" ? p : void 0,
    type: r === "input" ? g : void 0,
    disabled: r === "input" ? n : void 0,
    "aria-disabled": !n || r === "input" ? void 0 : n,
    rel: r === "a" ? h : void 0
  };
  let { pressProps: $, isPressed: k } = Ty({
    onClick: u,
    onPressStart: s,
    onPressEnd: i,
    onPressUp: a,
    onPressChange: l,
    onPress: o,
    isDisabled: n,
    preventFocusOnPress: d,
    allowTextSelectionOnPress: b,
    ref: e
  }), { focusableProps: w } = bh(t, e);
  c && (w.tabIndex = n ? -1 : w.tabIndex);
  let C = Rr(
    w,
    $,
    xd(t, { labelable: !0 })
  );
  return {
    isPressed: k,
    // Used to indicate press state for visual
    buttonProps: Rr(y, C, {
      "aria-haspopup": t["aria-haspopup"],
      "aria-expanded": t["aria-expanded"],
      "aria-controls": t["aria-controls"],
      "aria-pressed": t["aria-pressed"],
      "aria-current": t["aria-current"]
    })
  };
}
var w$ = () => import("./index-SfZMAM5z.mjs").then((t) => t.default), km = (t) => {
  const { ripples: e = [], motionProps: r, color: n = "currentColor", style: o, onClear: s } = t;
  return /* @__PURE__ */ m.jsx(m.Fragment, { children: e.map((i) => {
    const a = t2(0.01 * i.size, 0.2, i.size > 100 ? 0.75 : 0.5);
    return /* @__PURE__ */ m.jsx(Gs, { features: w$, children: /* @__PURE__ */ m.jsx(bd, { mode: "popLayout", children: /* @__PURE__ */ m.jsx(
      Ks.span,
      {
        animate: { transform: "scale(2)", opacity: 0 },
        className: "heroui-ripple",
        exit: { opacity: 0 },
        initial: { transform: "scale(0)", opacity: 0.35 },
        style: {
          position: "absolute",
          backgroundColor: n,
          borderRadius: "100%",
          transformOrigin: "center",
          pointerEvents: "none",
          overflow: "hidden",
          inset: 0,
          zIndex: 0,
          top: i.y,
          left: i.x,
          width: `${i.size}px`,
          height: `${i.size}px`,
          ...o
        },
        transition: { duration: a },
        onAnimationComplete: () => {
          s(i.key);
        },
        ...r
      }
    ) }) }, i.key);
  }) });
};
km.displayName = "HeroUI.Ripple";
var k$ = km;
function E$(t = {}) {
  const [e, r] = de([]), n = we((s) => {
    const i = s.target, a = Math.max(i.clientWidth, i.clientHeight);
    r((l) => [
      ...l,
      {
        key: e2(l.length.toString()),
        size: a,
        x: s.x - a / 2,
        y: s.y - a / 2
      }
    ]);
  }, []), o = we((s) => {
    r((i) => i.filter((a) => a.key !== s));
  }, []);
  return { ripples: e, onClear: o, onPress: n, ...t };
}
function C$(t) {
  var e, r, n, o, s, i, a, l, d;
  const c = x$(), u = qi(), f = !!c, {
    ref: p,
    as: h,
    children: g,
    startContent: b,
    endContent: y,
    autoFocus: $,
    className: k,
    spinner: w,
    isLoading: C = !1,
    disableRipple: T = !1,
    fullWidth: H = (e = c == null ? void 0 : c.fullWidth) != null ? e : !1,
    radius: O = c == null ? void 0 : c.radius,
    size: j = (r = c == null ? void 0 : c.size) != null ? r : "md",
    color: F = (n = c == null ? void 0 : c.color) != null ? n : "default",
    variant: v = (o = c == null ? void 0 : c.variant) != null ? o : "solid",
    disableAnimation: M = (i = (s = c == null ? void 0 : c.disableAnimation) != null ? s : u == null ? void 0 : u.disableAnimation) != null ? i : !1,
    isDisabled: E = (a = c == null ? void 0 : c.isDisabled) != null ? a : !1,
    isIconOnly: N = (l = c == null ? void 0 : c.isIconOnly) != null ? l : !1,
    spinnerPlacement: R = "start",
    onPress: x,
    onClick: P,
    ...I
  } = t, D = h || "button", L = typeof D == "string", A = Up(p), z = (d = T || (u == null ? void 0 : u.disableRipple)) != null ? d : M, { isFocusVisible: Y, isFocused: q, focusProps: ee } = $h({
    autoFocus: $
  }), B = E || C, _ = Ye(
    () => m$({
      size: j,
      color: F,
      variant: v,
      radius: O,
      fullWidth: H,
      isDisabled: B,
      isInGroup: f,
      disableAnimation: M,
      isIconOnly: N,
      className: k
    }),
    [
      j,
      F,
      v,
      O,
      H,
      B,
      f,
      N,
      M,
      k
    ]
  ), { onPress: W, onClear: ie, ripples: pe } = E$(), ye = we(
    (at) => {
      z || B || M || A.current && W(at);
    },
    [z, B, M, A, W]
  ), { buttonProps: Ce, isPressed: Be } = wm(
    {
      elementType: h,
      isDisabled: B,
      onPress: Kp(x, ye),
      onClick: P,
      ...I
    },
    A
  ), { isHovered: je, hoverProps: ut } = Ld({ isDisabled: B }), Fe = we(
    (at = {}) => ({
      "data-disabled": ht(B),
      "data-focus": ht(q),
      "data-pressed": ht(Be),
      "data-focus-visible": ht(Y),
      "data-hover": ht(je),
      "data-loading": ht(C),
      ...zt(
        Ce,
        ee,
        ut,
        qc(I, {
          enabled: L
        }),
        qc(at)
      ),
      className: _
    }),
    [
      C,
      B,
      q,
      Be,
      L,
      Y,
      je,
      Ce,
      ee,
      ut,
      I,
      _
    ]
  ), vt = (at) => Yn(at) ? Yi(at, {
    // @ts-ignore
    "aria-hidden": !0,
    focusable: !1
  }) : null, et = vt(b), Vt = vt(y), Pt = Ye(() => ({
    sm: "sm",
    md: "sm",
    lg: "md"
  })[j], [j]), Tt = we(
    () => ({ ripples: pe, onClear: ie }),
    [pe, ie]
  );
  return {
    Component: D,
    children: g,
    domRef: A,
    spinner: w,
    styles: _,
    startContent: et,
    endContent: Vt,
    isLoading: C,
    spinnerPlacement: R,
    spinnerSize: Pt,
    disableRipple: z,
    getButtonProps: Fe,
    getRippleProps: Tt,
    isIconOnly: N
  };
}
function S$(t) {
  var e, r;
  const [n, o] = b$(t, ju.variantKeys), s = qi(), i = (r = (e = t == null ? void 0 : t.variant) != null ? e : s == null ? void 0 : s.spinnerVariant) != null ? r : "default", { children: a, className: l, classNames: d, label: c, ...u } = n, f = Ye(() => ju({ ...o }), [$d(o)]), p = hn(d == null ? void 0 : d.base, l), h = c || a, g = Ye(() => h && typeof h == "string" ? h : u["aria-label"] ? "" : "Loading", [a, h, u["aria-label"]]), b = we(
    () => ({
      "aria-label": g,
      className: f.base({
        class: p
      }),
      ...u
    }),
    [g, f, p, u]
  );
  return { label: h, slots: f, classNames: d, variant: i, getSpinnerProps: b };
}
var Em = g$((t, e) => {
  const { slots: r, classNames: n, label: o, variant: s, getSpinnerProps: i } = S$({ ...t });
  return s === "wave" || s === "dots" ? /* @__PURE__ */ m.jsxs("div", { ref: e, ...i(), children: [
    /* @__PURE__ */ m.jsx("div", { className: r.wrapper({ class: n == null ? void 0 : n.wrapper }), children: [...new Array(3)].map((a, l) => /* @__PURE__ */ m.jsx(
      "i",
      {
        className: r.dots({ class: n == null ? void 0 : n.dots }),
        style: {
          "--dot-index": l
        }
      },
      `dot-${l}`
    )) }),
    o && /* @__PURE__ */ m.jsx("span", { className: r.label({ class: n == null ? void 0 : n.label }), children: o })
  ] }) : s === "simple" ? /* @__PURE__ */ m.jsxs("div", { ref: e, ...i(), children: [
    /* @__PURE__ */ m.jsxs(
      "svg",
      {
        className: r.wrapper({ class: n == null ? void 0 : n.wrapper }),
        fill: "none",
        viewBox: "0 0 24 24",
        children: [
          /* @__PURE__ */ m.jsx(
            "circle",
            {
              className: r.circle1({ class: n == null ? void 0 : n.circle1 }),
              cx: "12",
              cy: "12",
              r: "10",
              stroke: "currentColor",
              strokeWidth: "4"
            }
          ),
          /* @__PURE__ */ m.jsx(
            "path",
            {
              className: r.circle2({ class: n == null ? void 0 : n.circle2 }),
              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z",
              fill: "currentColor"
            }
          )
        ]
      }
    ),
    o && /* @__PURE__ */ m.jsx("span", { className: r.label({ class: n == null ? void 0 : n.label }), children: o })
  ] }) : s === "spinner" ? /* @__PURE__ */ m.jsxs("div", { ref: e, ...i(), children: [
    /* @__PURE__ */ m.jsx("div", { className: r.wrapper({ class: n == null ? void 0 : n.wrapper }), children: [...new Array(12)].map((a, l) => /* @__PURE__ */ m.jsx(
      "i",
      {
        className: r.spinnerBars({ class: n == null ? void 0 : n.spinnerBars }),
        style: {
          "--bar-index": l
        }
      },
      `star-${l}`
    )) }),
    o && /* @__PURE__ */ m.jsx("span", { className: r.label({ class: n == null ? void 0 : n.label }), children: o })
  ] }) : /* @__PURE__ */ m.jsxs("div", { ref: e, ...i(), children: [
    /* @__PURE__ */ m.jsxs("div", { className: r.wrapper({ class: n == null ? void 0 : n.wrapper }), children: [
      /* @__PURE__ */ m.jsx("i", { className: r.circle1({ class: n == null ? void 0 : n.circle1 }) }),
      /* @__PURE__ */ m.jsx("i", { className: r.circle2({ class: n == null ? void 0 : n.circle2 }) })
    ] }),
    o && /* @__PURE__ */ m.jsx("span", { className: r.label({ class: n == null ? void 0 : n.label }), children: o })
  ] });
});
Em.displayName = "HeroUI.Spinner";
var N$ = Em, Cm = Dd((t, e) => {
  const {
    Component: r,
    domRef: n,
    children: o,
    spinnerSize: s,
    spinner: i = /* @__PURE__ */ m.jsx(N$, { color: "current", size: s }),
    spinnerPlacement: a,
    startContent: l,
    endContent: d,
    isLoading: c,
    disableRipple: u,
    getButtonProps: f,
    getRippleProps: p,
    isIconOnly: h
  } = C$({ ...t, ref: e });
  return /* @__PURE__ */ m.jsxs(r, { ref: n, ...f(), children: [
    l,
    c && a === "start" && i,
    c && h ? null : o,
    c && a === "end" && i,
    d,
    !u && /* @__PURE__ */ m.jsx(k$, { ...p() })
  ] });
});
Cm.displayName = "HeroUI.Button";
var T$ = Cm;
function Sm(t) {
  let [e, r] = py(t.isOpen, t.defaultOpen || !1, t.onOpenChange);
  const n = we(() => {
    r(!0);
  }, [
    r
  ]), o = we(() => {
    r(!1);
  }, [
    r
  ]), s = we(() => {
    r(!e);
  }, [
    r,
    e
  ]);
  return {
    isOpen: e,
    setOpen: r,
    open: n,
    close: o,
    toggle: s
  };
}
const A$ = 1500, _u = 500;
let cn = {}, M$ = 0, xo = !1, wr = null, un = null;
function P$(t = {}) {
  let { delay: e = A$, closeDelay: r = _u } = t, { isOpen: n, open: o, close: s } = Sm(t), i = Ye(() => `${++M$}`, []), a = te(null), l = te(s), d = () => {
    cn[i] = f;
  }, c = () => {
    for (let h in cn) h !== i && (cn[h](!0), delete cn[h]);
  }, u = () => {
    a.current && clearTimeout(a.current), a.current = null, c(), d(), xo = !0, o(), wr && (clearTimeout(wr), wr = null), un && (clearTimeout(un), un = null);
  }, f = (h) => {
    h || r <= 0 ? (a.current && clearTimeout(a.current), a.current = null, l.current()) : a.current || (a.current = setTimeout(() => {
      a.current = null, l.current();
    }, r)), wr && (clearTimeout(wr), wr = null), xo && (un && clearTimeout(un), un = setTimeout(() => {
      delete cn[i], un = null, xo = !1;
    }, Math.max(_u, r)));
  }, p = () => {
    c(), d(), !n && !wr && !xo ? wr = setTimeout(() => {
      wr = null, xo = !0, u();
    }, e) : n || u();
  };
  return me(() => {
    l.current = s;
  }, [
    s
  ]), me(() => () => {
    a.current && clearTimeout(a.current), cn[i] && delete cn[i];
  }, [
    i
  ]), {
    isOpen: n,
    open: (h) => {
      !h && e > 0 && !a.current ? p() : u();
    },
    close: f
  };
}
function I$(t, e) {
  let r = xd(t, {
    labelable: !0
  }), { hoverProps: n } = Ld({
    onHoverStart: () => e == null ? void 0 : e.open(!0),
    onHoverEnd: () => e == null ? void 0 : e.close()
  });
  return {
    tooltipProps: Rr(r, n, {
      role: "tooltip"
    })
  };
}
function R$(t, e, r) {
  let { isDisabled: n, trigger: o } = t, s = Qi(), i = te(!1), a = te(!1), l = () => {
    (i.current || a.current) && e.open(a.current);
  }, d = (y) => {
    !i.current && !a.current && e.close(y);
  };
  me(() => {
    let y = ($) => {
      r && r.current && $.key === "Escape" && ($.stopPropagation(), e.close(!0));
    };
    if (e.isOpen)
      return document.addEventListener("keydown", y, !0), () => {
        document.removeEventListener("keydown", y, !0);
      };
  }, [
    r,
    e
  ]);
  let c = () => {
    o !== "focus" && (Rd() === "pointer" ? i.current = !0 : i.current = !1, l());
  }, u = () => {
    o !== "focus" && (a.current = !1, i.current = !1, d());
  }, f = () => {
    a.current = !1, i.current = !1, d(!0);
  }, p = () => {
    Id() && (a.current = !0, l());
  }, h = () => {
    a.current = !1, i.current = !1, d(!0);
  }, { hoverProps: g } = Ld({
    isDisabled: n,
    onHoverStart: c,
    onHoverEnd: u
  }), { focusableProps: b } = bh({
    isDisabled: n,
    onFocus: p,
    onBlur: h
  }, r);
  return {
    triggerProps: {
      "aria-describedby": e.isOpen ? s : void 0,
      ...Rr(b, g, {
        onPointerDown: f,
        onKeyDown: f
      }),
      tabIndex: void 0
    },
    tooltipProps: {
      id: s
    }
  };
}
var ar = [];
function Nm(t, e) {
  const {
    disableOutsideEvents: r = !0,
    isDismissable: n = !1,
    isKeyboardDismissDisabled: o = !1,
    isOpen: s,
    onClose: i,
    shouldCloseOnBlur: a,
    shouldCloseOnInteractOutside: l
  } = t;
  me(() => {
    if (s && !ar.includes(e))
      return ar.push(e), () => {
        let b = ar.indexOf(e);
        b >= 0 && ar.splice(b, 1);
      };
  }, [s, e]);
  const d = () => {
    ar[ar.length - 1] === e && i && i();
  }, c = (b) => {
    (!l || l(b.target)) && (ar[ar.length - 1] === e && r && (b.stopPropagation(), b.preventDefault()), g(e) !== "pressEnd" && d());
  }, u = (b) => {
    (!l || l(b.target)) && (ar[ar.length - 1] === e && r && (b.stopPropagation(), b.preventDefault()), d());
  }, f = (b) => {
    b.key === "Escape" && !o && !b.nativeEvent.isComposing && (b.stopPropagation(), b.preventDefault(), d());
  };
  Uy({
    isDisabled: !(n && s),
    onInteractOutside: n && s ? u : void 0,
    onInteractOutsideStart: c,
    ref: e
  });
  const { focusWithinProps: p } = Od({
    isDisabled: !a,
    onBlurWithin: (b) => {
      !b.relatedTarget || qy(b.relatedTarget) || (!l || l(b.relatedTarget)) && d();
    }
  }), h = (b) => {
    b.target === b.currentTarget && b.preventDefault();
  };
  function g(b) {
    const y = b.current;
    if (!y) return "unknown";
    const $ = (y.getAttribute("role") || "").toLowerCase(), k = y.getAttribute("aria-modal");
    return ($ === "dialog" || $ === "alertdialog") && (k === null || k.toLowerCase() === "true") ? "pressEnd" : ["listbox", "menu", "tree", "grid", "combobox"].includes($) ? "pressStart" : "unknown";
  }
  return {
    overlayProps: {
      onKeyDown: f,
      ...p
    },
    underlayProps: {
      onPointerDown: h
    }
  };
}
function O$(t) {
  var e, r;
  const n = qi(), [o, s] = om(t, ri.variantKeys), {
    ref: i,
    as: a,
    isOpen: l,
    content: d,
    children: c,
    defaultOpen: u,
    onOpenChange: f,
    isDisabled: p,
    trigger: h,
    shouldFlip: g = !0,
    containerPadding: b = 12,
    placement: y = "top",
    delay: $ = 0,
    closeDelay: k = 500,
    showArrow: w = !1,
    offset: C = 7,
    crossOffset: T = 0,
    isDismissable: H,
    shouldCloseOnBlur: O = !0,
    portalContainer: j,
    isKeyboardDismissDisabled: F = !1,
    updatePositionDeps: v = [],
    shouldCloseOnInteractOutside: M,
    className: E,
    onClose: N,
    motionProps: R,
    classNames: x,
    ...P
  } = o, I = a || "div", D = (r = (e = t == null ? void 0 : t.disableAnimation) != null ? e : n == null ? void 0 : n.disableAnimation) != null ? r : !1, L = P$({
    delay: $,
    closeDelay: k,
    isDisabled: p,
    defaultOpen: u,
    isOpen: l,
    onOpenChange: (Fe) => {
      f == null || f(Fe), Fe || N == null || N();
    }
  }), A = te(null), z = te(null), Y = y1(), q = L.isOpen && !p;
  In(
    i,
    () => (
      // @ts-ignore
      Zb(z)
    )
  );
  const { triggerProps: ee, tooltipProps: B } = R$(
    {
      isDisabled: p,
      trigger: h
    },
    L,
    A
  ), { tooltipProps: _ } = I$(
    {
      isOpen: q,
      ...zt(o, B)
    },
    L
  ), {
    overlayProps: W,
    placement: ie,
    updatePosition: pe
  } = ah({
    isOpen: q,
    targetRef: A,
    placement: $m(y),
    overlayRef: z,
    offset: w ? C + 3 : C,
    crossOffset: T,
    shouldFlip: g,
    containerPadding: b
  });
  xm(() => {
    v.length && pe();
  }, v);
  const { overlayProps: ye } = Nm(
    {
      isOpen: q,
      onClose: L.close,
      isDismissable: H,
      shouldCloseOnBlur: O,
      isKeyboardDismissDisabled: F,
      shouldCloseOnInteractOutside: M
    },
    z
  ), Ce = Ye(
    () => {
      var Fe, vt, et;
      return ri({
        ...s,
        disableAnimation: D,
        radius: (Fe = t == null ? void 0 : t.radius) != null ? Fe : "md",
        size: (vt = t == null ? void 0 : t.size) != null ? vt : "md",
        shadow: (et = t == null ? void 0 : t.shadow) != null ? et : "sm"
      });
    },
    [
      $d(s),
      D,
      t == null ? void 0 : t.radius,
      t == null ? void 0 : t.size,
      t == null ? void 0 : t.shadow
    ]
  ), Be = we(
    (Fe = {}, vt = null) => ({
      ...zt(ee, Fe),
      ref: i2(vt, A),
      "aria-describedby": q ? Y : void 0
    }),
    [ee, q, Y, L]
  ), je = we(
    () => ({
      ref: z,
      "data-slot": "base",
      "data-open": ht(q),
      "data-arrow": ht(w),
      "data-disabled": ht(p),
      "data-placement": ni(ie || "top", y),
      ...zt(_, ye, P),
      style: zt(W.style, P.style, o.style),
      className: Ce.base({ class: x == null ? void 0 : x.base }),
      id: Y
    }),
    [
      Ce,
      q,
      w,
      p,
      ie,
      y,
      _,
      ye,
      P,
      W,
      o,
      Y
    ]
  ), ut = we(
    () => ({
      "data-slot": "content",
      "data-open": ht(q),
      "data-arrow": ht(w),
      "data-disabled": ht(p),
      "data-placement": ni(ie || "top", y),
      className: Ce.content({ class: hn(x == null ? void 0 : x.content, E) })
    }),
    [Ce, q, w, p, ie, y, x]
  );
  return {
    Component: I,
    content: d,
    children: c,
    isOpen: q,
    triggerRef: A,
    showArrow: w,
    portalContainer: j,
    placement: y,
    disableAnimation: D,
    isDisabled: p,
    motionProps: R,
    getTooltipContentProps: ut,
    getTriggerProps: Be,
    getTooltipProps: je
  };
}
var L$ = () => import("./index-SfZMAM5z.mjs").then((t) => t.default), Tm = Dd((t, e) => {
  var r;
  const {
    Component: n,
    children: o,
    content: s,
    isOpen: i,
    portalContainer: a,
    placement: l,
    disableAnimation: d,
    motionProps: c,
    getTriggerProps: u,
    getTooltipProps: f,
    getTooltipContentProps: p
  } = O$({
    ...t,
    ref: e
  });
  let h;
  try {
    if (to.count(o) !== 1) throw new Error();
    if (!Yn(o))
      h = /* @__PURE__ */ m.jsx("p", { ...u(), children: o });
    else {
      const C = o, T = (r = C.props.ref) != null ? r : C.ref;
      h = Yi(C, u(C.props, T));
    }
  } catch {
    h = /* @__PURE__ */ m.jsx("span", {}), r2("Tooltip must have only one child node. Please, check your code.");
  }
  const { ref: g, id: b, style: y, ...$ } = f(), k = /* @__PURE__ */ m.jsx("div", { ref: g, id: b, style: y, children: /* @__PURE__ */ m.jsx(
    Ks.div,
    {
      animate: "enter",
      exit: "exit",
      initial: "exit",
      variants: Rl.scaleSpring,
      ...zt(c, $),
      style: {
        ...vm(l)
      },
      children: /* @__PURE__ */ m.jsx(n, { ...p(), children: s })
    },
    `${b}-tooltip-inner`
  ) }, `${b}-tooltip-content`);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    h,
    d ? i && /* @__PURE__ */ m.jsx(Su, { portalContainer: a, children: /* @__PURE__ */ m.jsx("div", { ref: g, id: b, style: y, ...$, children: /* @__PURE__ */ m.jsx(n, { ...p(), children: s }) }) }) : /* @__PURE__ */ m.jsx(Gs, { features: L$, children: /* @__PURE__ */ m.jsx(bd, { children: i && /* @__PURE__ */ m.jsx(Su, { portalContainer: a, children: k }) }) })
  ] });
});
Tm.displayName = "HeroUI.Tooltip";
var j$ = Tm;
function D$(t, e) {
  const {
    groupRef: r,
    triggerRef: n,
    popoverRef: o,
    showArrow: s,
    offset: i = 7,
    crossOffset: a = 0,
    scrollRef: l,
    shouldFlip: d,
    boundaryElement: c,
    isDismissable: u = !0,
    shouldCloseOnBlur: f = !0,
    shouldCloseOnScroll: p = !0,
    placement: h = "top",
    containerPadding: g,
    shouldCloseOnInteractOutside: b,
    isNonModal: y,
    isKeyboardDismissDisabled: $,
    updatePositionDeps: k = [],
    ...w
  } = t, C = y ?? !0, T = w.trigger === "SubmenuTrigger", { overlayProps: H, underlayProps: O } = Nm(
    {
      isOpen: e.isOpen,
      onClose: e.close,
      shouldCloseOnBlur: f,
      isDismissable: u || T,
      isKeyboardDismissDisabled: $,
      shouldCloseOnInteractOutside: b || ((N) => {
        var R;
        return !((R = n.current) != null && R.contains(N));
      }),
      disableOutsideEvents: !C
    },
    o
  ), {
    overlayProps: j,
    arrowProps: F,
    placement: v,
    updatePosition: M,
    triggerAnchorPoint: E
  } = ah({
    ...w,
    shouldFlip: d,
    crossOffset: a,
    targetRef: n,
    overlayRef: o,
    isOpen: e.isOpen,
    scrollRef: l,
    boundaryElement: c,
    containerPadding: g,
    placement: $m(h),
    offset: s ? i + 3 : i,
    onClose: C && !T && p ? e.close : () => {
    }
  });
  return xm(() => {
    k.length && M();
  }, k), me(() => {
    var N, R;
    if (e.isOpen && o.current)
      return C ? $$((N = r == null ? void 0 : r.current) != null ? N : o.current) : v$([(R = r == null ? void 0 : r.current) != null ? R : o.current]);
  }, [C, e.isOpen, o, r]), {
    popoverProps: zt(H, j),
    arrowProps: F,
    underlayProps: O,
    placement: v,
    triggerAnchorPoint: E
  };
}
var _$ = "top";
function F$(t) {
  var e, r, n;
  const o = qi(), [s, i] = om(t, ri.variantKeys), {
    as: a,
    ref: l,
    children: d,
    state: c,
    triggerRef: u,
    scrollRef: f,
    defaultOpen: p,
    onOpenChange: h,
    isOpen: g,
    isNonModal: b = !0,
    shouldFlip: y = !0,
    containerPadding: $ = 12,
    shouldBlockScroll: k = !1,
    isDismissable: w = !0,
    shouldCloseOnBlur: C,
    portalContainer: T,
    updatePositionDeps: H,
    dialogProps: O,
    placement: j = _$,
    triggerType: F = "dialog",
    showArrow: v = !1,
    offset: M = 7,
    crossOffset: E = 0,
    boundaryElement: N,
    isKeyboardDismissDisabled: R,
    shouldCloseOnInteractOutside: x,
    shouldCloseOnScroll: P,
    triggerAnchorPoint: I,
    motionProps: D,
    className: L,
    classNames: A,
    onClose: z,
    ...Y
  } = s, q = a || "div", ee = Up(l), B = te(null), _ = te(!1), W = u || B, ie = (r = (e = t.disableAnimation) != null ? e : o == null ? void 0 : o.disableAnimation) != null ? r : !1, pe = Sm({
    isOpen: g,
    defaultOpen: p,
    onOpenChange: (G) => {
      h == null || h(G), G || z == null || z();
    }
  }), ye = c || pe, {
    popoverProps: Ce,
    underlayProps: Be,
    placement: je
  } = D$(
    {
      triggerRef: W,
      isNonModal: b,
      popoverRef: ee,
      placement: j,
      offset: M,
      scrollRef: f,
      isDismissable: w,
      shouldCloseOnBlur: C,
      boundaryElement: N,
      crossOffset: E,
      shouldFlip: y,
      containerPadding: $,
      updatePositionDeps: H,
      isKeyboardDismissDisabled: R,
      shouldCloseOnScroll: P,
      shouldCloseOnInteractOutside: x,
      triggerAnchorPoint: I
    },
    ye
  ), ut = Ye(() => je ? y$(je, j) ? je : j : null, [je, j]), { triggerProps: Fe } = ev({ type: F }, ye, W), { isFocusVisible: vt, isFocused: et, focusProps: Vt } = $h(), Pt = Ye(
    () => ri({
      ...i
    }),
    [$d(i)]
  ), Tt = hn(A == null ? void 0 : A.base, L), at = {
    "--trigger-anchor-point": I ? `${I.x}px ${I.y}px` : void 0
  };
  tv({
    isDisabled: !(k && ye.isOpen)
  });
  const br = (G = {}) => ({
    ref: ee,
    ...zt(Ce, Y, G),
    style: zt(Ce.style, Y.style, G.style)
  }), yr = (G = {}) => ({
    // `ref` and `dialogProps` from `useDialog` are passed from props
    // if we use `useDialog` here, dialogRef won't be focused on mount
    "data-slot": "base",
    "data-open": ht(ye.isOpen),
    "data-focus": ht(et),
    "data-arrow": ht(v),
    "data-focus-visible": ht(vt),
    "data-placement": je ? ni(je, j) : void 0,
    ...zt(Vt, O, G),
    className: Pt.base({ class: hn(Tt) }),
    style: {
      // this prevent the dialog to have a default outline
      outline: "none",
      ...at
    }
  }), oe = we(
    (G = {}) => ({
      "data-slot": "content",
      "data-open": ht(ye.isOpen),
      "data-arrow": ht(v),
      "data-placement": je ? ni(je, j) : void 0,
      className: Pt.content({ class: hn(A == null ? void 0 : A.content, G.className) })
    }),
    [Pt, ye.isOpen, v, ut, j, A, je]
  ), Me = we(
    (G) => {
      var ae;
      let ce;
      return G.pointerType === "touch" && ((t == null ? void 0 : t.backdrop) === "blur" || (t == null ? void 0 : t.backdrop) === "opaque") ? ce = setTimeout(() => {
        _.current = !0;
      }, 100) : _.current = !0, (ae = Fe.onPress) == null || ae.call(Fe, G), () => {
        clearTimeout(ce);
      };
    },
    [Fe == null ? void 0 : Fe.onPress]
  ), se = we(
    (G = {}, ae = null) => {
      const { isDisabled: ce, ...ke } = G;
      return {
        "data-slot": "trigger",
        ...zt({ "aria-haspopup": "dialog" }, Fe, ke),
        onPress: Me,
        isDisabled: ce,
        className: Pt.trigger({
          class: hn(A == null ? void 0 : A.trigger, G.className),
          // apply isDisabled class names to make the trigger child disabled
          // e.g. for elements like div or HeroUI elements that don't have `isDisabled` prop
          isTriggerDisabled: ce
        }),
        ref: o2(ae, W)
      };
    },
    [ye, Fe, Me, W]
  ), Z = we(
    (G = {}) => ({
      "data-slot": "backdrop",
      className: Pt.backdrop({ class: A == null ? void 0 : A.backdrop }),
      onClick: (ae) => {
        if (!_.current) {
          ae.preventDefault();
          return;
        }
        ye.close(), _.current = !1;
      },
      ...Be,
      ...G
    }),
    [Pt, ye.isOpen, A, Be]
  );
  return {
    state: ye,
    Component: q,
    children: d,
    classNames: A,
    showArrow: v,
    triggerRef: W,
    placement: ut,
    isNonModal: b,
    popoverRef: ee,
    portalContainer: T,
    isOpen: ye.isOpen,
    onClose: ye.close,
    disableAnimation: ie,
    shouldBlockScroll: k,
    backdrop: (n = t.backdrop) != null ? n : "transparent",
    motionProps: D,
    getBackdropProps: Z,
    getPopoverProps: br,
    getTriggerProps: se,
    getDialogProps: yr,
    getContentProps: oe
  };
}
function z$(t, e) {
  let { role: r = "dialog" } = t, n = z2();
  n = t["aria-label"] ? void 0 : n;
  let o = te(!1);
  return me(() => {
    if (e.current && !e.current.contains(document.activeElement)) {
      Zs(e.current);
      let s = setTimeout(() => {
        (document.activeElement === e.current || document.activeElement === document.body) && (o.current = !0, e.current && (e.current.blur(), Zs(e.current)), o.current = !1);
      }, 500);
      return () => {
        clearTimeout(s);
      };
    }
  }, [
    e
  ]), pv(), {
    dialogProps: {
      ...xd(t, {
        labelable: !0
      }),
      role: r,
      tabIndex: -1,
      "aria-labelledby": t["aria-labelledby"] || n,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (s) => {
        o.current && s.stopPropagation();
      }
    },
    titleProps: {
      id: n
    }
  };
}
var [H$, Am] = vd({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
}), Fu = () => import("./index-SfZMAM5z.mjs").then((t) => t.default), Mm = (t) => {
  const { as: e, children: r, className: n, ...o } = t, {
    Component: s,
    placement: i,
    backdrop: a,
    motionProps: l,
    disableAnimation: d,
    getPopoverProps: c,
    getDialogProps: u,
    getBackdropProps: f,
    getContentProps: p,
    isNonModal: h,
    onClose: g
  } = Am(), b = te(null), { dialogProps: y, titleProps: $ } = z$({}, b), k = u({
    ref: b,
    ...y,
    ...o
  }), w = e || s || "div", C = r && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    !h && /* @__PURE__ */ m.jsx(Tu, { onDismiss: g }),
    /* @__PURE__ */ m.jsx(w, { ...k, children: /* @__PURE__ */ m.jsx("div", { ...p({ className: n }), children: typeof r == "function" ? r($) : r }) }),
    /* @__PURE__ */ m.jsx(Tu, { onDismiss: g })
  ] }), T = Ye(() => a === "transparent" ? null : d ? /* @__PURE__ */ m.jsx("div", { ...f() }) : /* @__PURE__ */ m.jsx(Gs, { features: Fu, children: /* @__PURE__ */ m.jsx(
    Ks.div,
    {
      animate: "enter",
      exit: "exit",
      initial: "exit",
      variants: Rl.fade,
      ...f()
    }
  ) }), [a, d, f]), H = i ? vm(i === "center" ? "top" : i) : void 0, O = /* @__PURE__ */ m.jsx(m.Fragment, { children: d ? C : /* @__PURE__ */ m.jsx(Gs, { features: Fu, children: /* @__PURE__ */ m.jsx(
    Ks.div,
    {
      animate: "enter",
      exit: "exit",
      initial: "initial",
      style: H,
      variants: Rl.scaleSpringOpacity,
      ...l,
      children: C
    }
  ) }) });
  return /* @__PURE__ */ m.jsxs("div", { ...c(), children: [
    T,
    O
  ] });
};
Mm.displayName = "HeroUI.PopoverContent";
var B$ = Mm, Pm = (t) => {
  var e;
  const { triggerRef: r, getTriggerProps: n } = Am(), { children: o, ...s } = t, i = Ye(() => typeof o == "string" ? /* @__PURE__ */ m.jsx("p", { children: o }) : to.only(o), [o]), a = (e = i.props.ref) != null ? e : i.ref, { onPress: l, isDisabled: d, ...c } = Ye(() => n(zt(s, i.props), a), [n, i.props, s, a]), [, u] = a2(o, T$), { buttonProps: f } = wm({ onPress: l, isDisabled: d }, r), p = Ye(() => (u == null ? void 0 : u[0]) !== void 0, [u]);
  return p || delete c.preventFocusOnPress, Yi(
    i,
    zt(c, p ? { onPress: l, isDisabled: d } : f)
  );
};
Pm.displayName = "HeroUI.PopoverTrigger";
var V$ = Pm, Im = Dd((t, e) => {
  const { children: r, ...n } = t, o = F$({ ...n, ref: e }), [s, i] = to.toArray(r), a = /* @__PURE__ */ m.jsx(fv, { portalContainer: o.portalContainer, children: i });
  return /* @__PURE__ */ m.jsxs(H$, { value: o, children: [
    s,
    o.disableAnimation && o.isOpen ? a : /* @__PURE__ */ m.jsx(bd, { children: o.isOpen ? a : null })
  ] });
});
Im.displayName = "HeroUI.Popover";
var W$ = Im;
const U$ = ct("border bg-popover text-popover-foreground", {
  variants: {
    variant: {
      default: "border-border shadow-sm",
      elevated: "border-border shadow-lg",
      outline: "border-border bg-transparent",
      ghost: "border-transparent bg-transparent"
    },
    color: {
      primary: "border-primary bg-primary text-primary-foreground",
      secondary: "border-secondary bg-secondary text-secondary-foreground",
      success: "border-success bg-success text-success-foreground",
      warning: "border-warning bg-warning text-warning-foreground",
      danger: "border-danger bg-danger text-danger-foreground",
      info: "border-blue-500 bg-blue-500 text-white",
      neutral: "border-gray-500 bg-gray-500 text-white",
      light: "border-gray-200 bg-white text-gray-900",
      custom: ""
    },
    shadow: {
      none: "",
      sm: "shadow-sm",
      md: "shadow-md",
      lg: "shadow-lg",
      xl: "shadow-xl"
    },
    rounded: {
      none: "rounded-none",
      sm: "rounded-sm",
      md: "rounded-md",
      lg: "rounded-lg",
      xl: "rounded-xl",
      "2xl": "rounded-2xl",
      "3xl": "rounded-3xl",
      full: "rounded-full"
    }
  },
  defaultVariants: {
    variant: "default",
    color: "light",
    shadow: "md",
    rounded: "lg"
  }
}), q7 = ({
  content: t,
  children: e,
  placement: r = "top",
  showArrow: n = !0,
  variant: o = "default",
  color: s = "light",
  customColor: i,
  rounded: a = "lg",
  shadow: l = "md",
  className: d,
  isOpen: c,
  onOpenChange: u,
  isDisabled: f = !1,
  delay: p,
  closeDelay: h = 0,
  offset: g = 6,
  trigger: b = "hover",
  shouldCloseOnScroll: y = !0,
  portalContainer: $ = typeof document < "u" ? document.body : void 0,
  zIndex: k = 50,
  contentZIndex: w
}) => {
  const C = () => {
    switch (s) {
      case "primary":
        return "primary";
      case "secondary":
        return "secondary";
      case "success":
        return "success";
      case "warning":
        return "warning";
      case "danger":
        return "danger";
      case "info":
      case "neutral":
      case "light":
      case "custom":
      default:
        return "default";
    }
  }, H = s === "custom" && i ? { backgroundColor: i, color: "#ffffff" } : {
    info: "bg-blue-500 text-white border-blue-500",
    neutral: "bg-gray-500 text-white border-gray-500",
    light: "bg-white text-gray-900 border-gray-200"
  }[s] || "", O = C(), j = w !== void 0 ? w : k, F = {
    content: t,
    placement: r,
    showArrow: n,
    color: O,
    radius: a,
    shadow: l,
    isOpen: c,
    onOpenChange: u,
    isDisabled: f,
    delay: p,
    closeDelay: h,
    offset: g,
    trigger: b,
    shouldCloseOnScroll: y,
    portalContainer: $,
    // container z-index to manage layering
    style: {
      zIndex: k
    }
  };
  return Object.keys(F).forEach((v) => {
    F[v] === void 0 && delete F[v];
  }), /* @__PURE__ */ m.jsx(
    j$,
    {
      ...F,
      classNames: {
        content: V(
          U$({ variant: o, color: s, shadow: l, rounded: a }),
          d,
          H,
          s === "custom" && i ? "border-0" : ""
        )
      },
      content: /* @__PURE__ */ m.jsx(
        "div",
        {
          style: {
            zIndex: j,
            ...s === "custom" && i ? { backgroundColor: i, color: "#ffffff" } : {}
          },
          children: t
        }
      ),
      children: e
    }
  );
}, G$ = ct("relative overflow-hidden", {
  variants: {
    variant: {
      bar: "w-full bg-neutral-100",
      circular: "inline-block"
    },
    color: {
      primary: "text-primary",
      secondary: "text-secondary",
      success: "text-success",
      warning: "text-warning",
      danger: "text-danger",
      info: "text-info"
    },
    size: {
      sm: "h-1",
      md: "h-2",
      lg: "h-3"
    }
  },
  defaultVariants: {
    variant: "bar",
    color: "primary",
    size: "md"
  }
}), K$ = {
  sm: 24,
  md: 36,
  lg: 48
}, Y$ = {
  primary: "bg-primary",
  secondary: "bg-secondary",
  success: "bg-success",
  warning: "bg-warning",
  danger: "bg-danger",
  info: "bg-info"
}, J$ = {
  primary: "#007C99",
  // Tailwind primary
  secondary: "#CEEAE7",
  success: "#00B37D",
  warning: "#F59E0B",
  danger: "#EF4444",
  info: "#0EA5E9"
}, q$ = le.forwardRef(
  ({
    className: t,
    variant: e = "bar",
    color: r = "primary",
    size: n = "md",
    value: o = 0,
    isIndeterminate: s = !1,
    showValue: i = !1,
    label: a,
    rounded: l = "full",
    icon: d,
    indicator: c,
    indicatorPosition: u = "on",
    indicatorSize: f,
    hideIndicatorOnMax: p = !0,
    ...h
  }, g) => {
    const b = Math.min(Math.max(o, 0), 100), y = K$[n], $ = n === "sm" ? 2 : n === "md" ? 3 : 4, k = (y - $) / 2, w = 2 * Math.PI * k, C = w - b / 100 * w, H = f || (n === "sm" ? 16 : n === "md" ? 20 : 24);
    let O = "";
    if (e === "loading" ? O = "rounded-full" : l ? O = l === "none" ? "" : `rounded-${l}` : O = "rounded-md", e === "circular")
      return /* @__PURE__ */ m.jsxs("div", { className: "inline-flex flex-col items-center gap-2", children: [
        /* @__PURE__ */ m.jsxs(
          "div",
          {
            className: "relative",
            style: { width: y, height: y },
            children: [
              /* @__PURE__ */ m.jsxs(
                "svg",
                {
                  className: V(
                    "transform -rotate-90",
                    s ? "animate-spin" : ""
                  ),
                  width: y,
                  height: y,
                  children: [
                    /* @__PURE__ */ m.jsx(
                      "circle",
                      {
                        strokeWidth: $,
                        stroke: "#e5e7eb",
                        fill: "transparent",
                        r: k,
                        cx: y / 2,
                        cy: y / 2
                      }
                    ),
                    /* @__PURE__ */ m.jsx(
                      "circle",
                      {
                        className: V(
                          "transition-all duration-300 ease-in-out",
                          s ? "animate-dash" : ""
                        ),
                        strokeWidth: $,
                        strokeDasharray: w,
                        strokeDashoffset: s ? 0 : C,
                        strokeLinecap: "round",
                        stroke: J$[r],
                        fill: "transparent",
                        r: k,
                        cx: y / 2,
                        cy: y / 2
                      }
                    )
                  ]
                }
              ),
              d && /* @__PURE__ */ m.jsx("span", { className: "absolute inset-0 flex items-center justify-center pointer-events-none", children: /* @__PURE__ */ m.jsx($e, { icon: d, size: y * 0.5 }) }),
              i && !s && !d && /* @__PURE__ */ m.jsxs("div", { className: "absolute inset-0 flex items-center justify-center text-xs font-medium", children: [
                Math.round(b),
                "%"
              ] })
            ]
          }
        ),
        a && /* @__PURE__ */ m.jsx("span", { className: "text-sm text-neutral-600", children: a })
      ] });
    const j = () => {
      if (!c || p && b >= 100)
        return null;
      const v = typeof c == "string" ? /* @__PURE__ */ m.jsx($e, { icon: c, size: H }) : c, M = {
        position: "absolute",
        left: `${b}%`,
        transition: "left 300ms cubic-bezier(0.4, 0, 0.2, 1)",
        pointerEvents: "none",
        zIndex: 10
      };
      return u === "above" ? (M.bottom = "100%", M.marginBottom = "6px", M.transform = "translateX(-50%)") : (M.top = "50%", M.transform = "translate(-50%, -50%)"), /* @__PURE__ */ m.jsx(
        "div",
        {
          style: M,
          className: "flex items-center justify-center",
          children: v
        }
      );
    };
    return /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ m.jsxs(
        "div",
        {
          className: V(
            "relative",
            c && u === "above" && "pb-8"
          ),
          children: [
            c && u === "above" && !s && j(),
            /* @__PURE__ */ m.jsxs(
              "div",
              {
                ref: g,
                className: V(
                  G$({
                    variant: e === "loading" ? "bar" : e,
                    size: n
                  }),
                  O,
                  c && u === "on" && "relative overflow-visible",
                  t
                ),
                role: "progressbar",
                "aria-valuenow": s ? void 0 : b,
                "aria-valuemin": 0,
                "aria-valuemax": 100,
                ...h,
                children: [
                  c && u === "on" && !s && j(),
                  /* @__PURE__ */ m.jsx(
                    "div",
                    {
                      className: V(
                        "h-full",
                        s ? "animate-progress-indeterminate" : "",
                        Y$[r],
                        O
                      ),
                      style: {
                        width: s ? "100%" : `${b}%`,
                        transition: s ? "none" : "width 300ms cubic-bezier(0.4, 0, 0.2, 1)"
                      }
                    }
                  )
                ]
              }
            )
          ]
        }
      ),
      (i || a) && /* @__PURE__ */ m.jsxs("div", { className: "flex justify-between text-xs text-neutral-600", children: [
        a && /* @__PURE__ */ m.jsx("span", { children: a }),
        i && !s && /* @__PURE__ */ m.jsxs("span", { children: [
          Math.round(b),
          "%"
        ] })
      ] })
    ] });
  }
);
q$.displayName = "Progress";
const Nr = [
  { name: "Afghanistan", code: "+93", iso: "af", flag: "flagpack:af" },
  { name: "Albania", code: "+355", iso: "al", flag: "flagpack:al" },
  { name: "Algeria", code: "+213", iso: "dz", flag: "flagpack:dz" },
  { name: "American Samoa", code: "+1684", iso: "as", flag: "flagpack:as" },
  { name: "Andorra", code: "+376", iso: "ad", flag: "flagpack:ad" },
  { name: "Angola", code: "+244", iso: "ao", flag: "flagpack:ao" },
  { name: "Anguilla", code: "+1264", iso: "ai", flag: "flagpack:ai" },
  { name: "Antarctica", code: "+672", iso: "aq", flag: "flagpack:aq" },
  { name: "Antigua and Barbuda", code: "+1268", iso: "ag", flag: "flagpack:ag" },
  { name: "Argentina", code: "+54", iso: "ar", flag: "flagpack:ar" },
  { name: "Armenia", code: "+374", iso: "am", flag: "flagpack:am" },
  { name: "Aruba", code: "+297", iso: "aw", flag: "flagpack:aw" },
  { name: "Australia", code: "+61", iso: "au", flag: "flagpack:au" },
  { name: "Austria", code: "+43", iso: "at", flag: "flagpack:at" },
  { name: "Azerbaijan", code: "+994", iso: "az", flag: "flagpack:az" },
  { name: "Bahamas", code: "+1242", iso: "bs", flag: "flagpack:bs" },
  { name: "Bahrain", code: "+973", iso: "bh", flag: "flagpack:bh" },
  { name: "Bangladesh", code: "+880", iso: "bd", flag: "flagpack:bd" },
  { name: "Barbados", code: "+1246", iso: "bb", flag: "flagpack:bb" },
  { name: "Belarus", code: "+375", iso: "by", flag: "flagpack:by" },
  { name: "Belgium", code: "+32", iso: "be", flag: "flagpack:be" },
  { name: "Belize", code: "+501", iso: "bz", flag: "flagpack:bz" },
  { name: "Benin", code: "+229", iso: "bj", flag: "flagpack:bj" },
  { name: "Bermuda", code: "+1441", iso: "bm", flag: "flagpack:bm" },
  { name: "Bhutan", code: "+975", iso: "bt", flag: "flagpack:bt" },
  { name: "Bolivia", code: "+591", iso: "bo", flag: "flagpack:bo" },
  { name: "Bosnia and Herzegovina", code: "+387", iso: "ba", flag: "flagpack:ba" },
  { name: "Botswana", code: "+267", iso: "bw", flag: "flagpack:bw" },
  { name: "Brazil", code: "+55", iso: "br", flag: "flagpack:br" },
  { name: "British Indian Ocean Territory", code: "+246", iso: "io", flag: "flagpack:io" },
  { name: "British Virgin Islands", code: "+1284", iso: "vg", flag: "flagpack:vg" },
  { name: "Brunei", code: "+673", iso: "bn", flag: "flagpack:bn" },
  { name: "Bulgaria", code: "+359", iso: "bg", flag: "flagpack:bg" },
  { name: "Burkina Faso", code: "+226", iso: "bf", flag: "flagpack:bf" },
  { name: "Burundi", code: "+257", iso: "bi", flag: "flagpack:bi" },
  { name: "Cambodia", code: "+855", iso: "kh", flag: "flagpack:kh" },
  { name: "Cameroon", code: "+237", iso: "cm", flag: "flagpack:cm" },
  { name: "Cape Verde", code: "+238", iso: "cv", flag: "flagpack:cv" },
  { name: "Cayman Islands", code: "+1345", iso: "ky", flag: "flagpack:ky" },
  { name: "Central African Republic", code: "+236", iso: "cf", flag: "flagpack:cf" },
  { name: "Chad", code: "+235", iso: "td", flag: "flagpack:td" },
  { name: "Chile", code: "+56", iso: "cl", flag: "flagpack:cl" },
  { name: "China", code: "+86", iso: "cn", flag: "flagpack:cn" },
  { name: "Christmas Island", code: "+61", iso: "cx", flag: "flagpack:cx" },
  { name: "Cocos Islands", code: "+61", iso: "cc", flag: "flagpack:cc" },
  { name: "Colombia", code: "+57", iso: "co", flag: "flagpack:co" },
  { name: "Comoros", code: "+269", iso: "km", flag: "flagpack:km" },
  { name: "Cook Islands", code: "+682", iso: "ck", flag: "flagpack:ck" },
  { name: "Costa Rica", code: "+506", iso: "cr", flag: "flagpack:cr" },
  { name: "Croatia", code: "+385", iso: "hr", flag: "flagpack:hr" },
  { name: "Cuba", code: "+53", iso: "cu", flag: "flagpack:cu" },
  { name: "Curacao", code: "+599", iso: "cw", flag: "flagpack:cw" },
  { name: "Cyprus", code: "+357", iso: "cy", flag: "flagpack:cy" },
  { name: "Czech Republic", code: "+420", iso: "cz", flag: "flagpack:cz" },
  { name: "Democratic Republic of the Congo", code: "+243", iso: "cd", flag: "flagpack:cd" },
  { name: "Denmark", code: "+45", iso: "dk", flag: "flagpack:dk" },
  { name: "Djibouti", code: "+253", iso: "dj", flag: "flagpack:dj" },
  { name: "Dominica", code: "+1767", iso: "dm", flag: "flagpack:dm" },
  { name: "Dominican Republic", code: "+1809", iso: "do", flag: "flagpack:do" },
  { name: "East Timor", code: "+670", iso: "tl", flag: "flagpack:tl" },
  { name: "Ecuador", code: "+593", iso: "ec", flag: "flagpack:ec" },
  { name: "Egypt", code: "+20", iso: "eg", flag: "flagpack:eg" },
  { name: "El Salvador", code: "+503", iso: "sv", flag: "flagpack:sv" },
  { name: "Equatorial Guinea", code: "+240", iso: "gq", flag: "flagpack:gq" },
  { name: "Eritrea", code: "+291", iso: "er", flag: "flagpack:er" },
  { name: "Estonia", code: "+372", iso: "ee", flag: "flagpack:ee" },
  { name: "Ethiopia", code: "+251", iso: "et", flag: "flagpack:et" },
  { name: "Falkland Islands", code: "+500", iso: "fk", flag: "flagpack:fk" },
  { name: "Faroe Islands", code: "+298", iso: "fo", flag: "flagpack:fo" },
  { name: "Fiji", code: "+679", iso: "fj", flag: "flagpack:fj" },
  { name: "Finland", code: "+358", iso: "fi", flag: "flagpack:fi" },
  { name: "France", code: "+33", iso: "fr", flag: "flagpack:fr" },
  { name: "French Polynesia", code: "+689", iso: "pf", flag: "flagpack:pf" },
  { name: "Gabon", code: "+241", iso: "ga", flag: "flagpack:ga" },
  { name: "Gambia", code: "+220", iso: "gm", flag: "flagpack:gm" },
  { name: "Georgia", code: "+995", iso: "ge", flag: "flagpack:ge" },
  { name: "Germany", code: "+49", iso: "de", flag: "flagpack:de" },
  { name: "Ghana", code: "+233", iso: "gh", flag: "flagpack:gh" },
  { name: "Gibraltar", code: "+350", iso: "gi", flag: "flagpack:gi" },
  { name: "Greece", code: "+30", iso: "gr", flag: "flagpack:gr" },
  { name: "Greenland", code: "+299", iso: "gl", flag: "flagpack:gl" },
  { name: "Grenada", code: "+1473", iso: "gd", flag: "flagpack:gd" },
  { name: "Guam", code: "+1671", iso: "gu", flag: "flagpack:gu" },
  { name: "Guatemala", code: "+502", iso: "gt", flag: "flagpack:gt" },
  { name: "Guernsey", code: "+441481", iso: "gg", flag: "flagpack:gg" },
  { name: "Guinea", code: "+224", iso: "gn", flag: "flagpack:gn" },
  { name: "GuineaBissau", code: "+245", iso: "gw", flag: "flagpack:gw" },
  { name: "Guyana", code: "+592", iso: "gy", flag: "flagpack:gy" },
  { name: "Haiti", code: "+509", iso: "ht", flag: "flagpack:ht" },
  { name: "Honduras", code: "+504", iso: "hn", flag: "flagpack:hn" },
  { name: "Hong Kong", code: "+852", iso: "hk", flag: "flagpack:hk" },
  { name: "Hungary", code: "+36", iso: "hu", flag: "flagpack:hu" },
  { name: "Iceland", code: "+354", iso: "is", flag: "flagpack:is" },
  { name: "India", code: "+91", iso: "in", flag: "flagpack:in" },
  { name: "Indonesia", code: "+62", iso: "id", flag: "flagpack:id" },
  { name: "Iran", code: "+98", iso: "ir", flag: "flagpack:ir" },
  { name: "Iraq", code: "+964", iso: "iq", flag: "flagpack:iq" },
  { name: "Ireland", code: "+353", iso: "ie", flag: "flagpack:ie" },
  { name: "Isle of Man", code: "+441624", iso: "im", flag: "flagpack:im" },
  { name: "Israel", code: "+972", iso: "il", flag: "flagpack:il" },
  { name: "Italy", code: "+39", iso: "it", flag: "flagpack:it" },
  { name: "Ivory Coast", code: "+225", iso: "ci", flag: "flagpack:ci" },
  { name: "Jamaica", code: "+1876", iso: "jm", flag: "flagpack:jm" },
  { name: "Japan", code: "+81", iso: "jp", flag: "flagpack:jp" },
  { name: "Jersey", code: "+441534", iso: "je", flag: "flagpack:je" },
  { name: "Jordan", code: "+962", iso: "jo", flag: "flagpack:jo" },
  { name: "Kazakhstan", code: "+7", iso: "kz", flag: "flagpack:kz" },
  { name: "Kenya", code: "+254", iso: "ke", flag: "flagpack:ke" },
  { name: "Kiribati", code: "+686", iso: "ki", flag: "flagpack:ki" },
  { name: "Kosovo", code: "+383", iso: "xk", flag: "flagpack:xk" },
  { name: "Kuwait", code: "+965", iso: "kw", flag: "flagpack:kw" },
  { name: "Kyrgyzstan", code: "+996", iso: "kg", flag: "flagpack:kg" },
  { name: "Laos", code: "+856", iso: "la", flag: "flagpack:la" },
  { name: "Latvia", code: "+371", iso: "lv", flag: "flagpack:lv" },
  { name: "Lebanon", code: "+961", iso: "lb", flag: "flagpack:lb" },
  { name: "Lesotho", code: "+266", iso: "ls", flag: "flagpack:ls" },
  { name: "Liberia", code: "+231", iso: "lr", flag: "flagpack:lr" },
  { name: "Libya", code: "+218", iso: "ly", flag: "flagpack:ly" },
  { name: "Liechtenstein", code: "+423", iso: "li", flag: "flagpack:li" },
  { name: "Lithuania", code: "+370", iso: "lv", flag: "flagpack:lv" },
  { name: "Luxembourg", code: "+352", iso: "lu", flag: "flagpack:lu" },
  { name: "Macao", code: "+853", iso: "mo", flag: "flagpack:mo" },
  { name: "Macedonia", code: "+389", iso: "mk", flag: "flagpack:mk" },
  { name: "Madagascar", code: "+261", iso: "mg", flag: "flagpack:mg" },
  { name: "Malawi", code: "+265", iso: "mw", flag: "flagpack:mw" },
  { name: "Malaysia", code: "+60", iso: "my", flag: "flagpack:my" },
  { name: "Maldives", code: "+960", iso: "mv", flag: "flagpack:mv" },
  { name: "Mali", code: "+223", iso: "ml", flag: "flagpack:ml" },
  { name: "Malta", code: "+356", iso: "mt", flag: "flagpack:mt" },
  { name: "Marshall Islands", code: "+692", iso: "mh", flag: "flagpack:mh" },
  { name: "Mauritania", code: "+222", iso: "mr", flag: "flagpack:mr" },
  { name: "Mauritius", code: "+230", iso: "mu", flag: "flagpack:mu" },
  { name: "Mayotte", code: "+262", iso: "yt", flag: "flagpack:yt" },
  { name: "Mexico", code: "+52", iso: "mx", flag: "flagpack:mx" },
  { name: "Micronesia", code: "+691", iso: "fm", flag: "flagpack:fm" },
  { name: "Moldova", code: "+373", iso: "md", flag: "flagpack:md" },
  { name: "Monaco", code: "+377", iso: "mc", flag: "flagpack:mc" },
  { name: "Mongolia", code: "+976", iso: "mn", flag: "flagpack:mn" },
  { name: "Montenegro", code: "+382", iso: "me", flag: "flagpack:me" },
  { name: "Montserrat", code: "+1664", iso: "ms", flag: "flagpack:ms" },
  { name: "Morocco", code: "+212", iso: "ma", flag: "flagpack:ma" },
  { name: "Mozambique", code: "+258", iso: "mz", flag: "flagpack:mz" },
  { name: "Myanmar", code: "+95", iso: "mm", flag: "flagpack:mm" },
  { name: "Namibia", code: "+264", iso: "na", flag: "flagpack:na" },
  { name: "Nauru", code: "+674", iso: "nr", flag: "flagpack:nr" },
  { name: "Nepal", code: "+977", iso: "np", flag: "flagpack:np" },
  { name: "Netherlands", code: "+31", iso: "nl", flag: "flagpack:nl" },
  { name: "Netherlands Antilles", code: "+599", iso: "an", flag: "flagpack:an" },
  { name: "New Caledonia", code: "+687", iso: "nc", flag: "flagpack:nc" },
  { name: "New Zealand", code: "+64", iso: "nz", flag: "flagpack:nz" },
  { name: "Nicaragua", code: "+505", iso: "ni", flag: "flagpack:ni" },
  { name: "Niger", code: "+227", iso: "ne", flag: "flagpack:ne" },
  { name: "Nigeria", code: "+234", iso: "ng", flag: "flagpack:ng" },
  { name: "Niue", code: "+683", iso: "nu", flag: "flagpack:nu" },
  { name: "North Korea", code: "+850", iso: "kp", flag: "flagpack:kp" },
  { name: "Northern Mariana Islands", code: "+1670", iso: "mp", flag: "flagpack:mp" },
  { name: "Norway", code: "+47", iso: "no", flag: "flagpack:no" },
  { name: "Oman", code: "+968", iso: "om", flag: "flagpack:om" },
  { name: "Pakistan", code: "+92", iso: "pk", flag: "flagpack:pk" },
  { name: "Palau", code: "+680", iso: "pw", flag: "flagpack:pw" },
  { name: "Palestine", code: "+970", iso: "ps", flag: "flagpack:ps" },
  { name: "Panama", code: "+507", iso: "pa", flag: "flagpack:pa" },
  { name: "Papua New Guinea", code: "+675", iso: "pg", flag: "flagpack:pg" },
  { name: "Paraguay", code: "+595", iso: "py", flag: "flagpack:py" },
  { name: "Peru", code: "+51", iso: "pe", flag: "flagpack:pe" },
  { name: "Philippines", code: "+63", iso: "ph", flag: "flagpack:ph" },
  { name: "Pitcairn", code: "+64", iso: "pn", flag: "flagpack:pn" },
  { name: "Poland", code: "+48", iso: "pl", flag: "flagpack:pl" },
  { name: "Portugal", code: "+351", iso: "pt", flag: "flagpack:pt" },
  { name: "Puerto Rico", code: "+1787, +1939", iso: "pr", flag: "flagpack:pr" },
  { name: "Qatar", code: "+974", iso: "qa", flag: "flagpack:qa" },
  { name: "Republic of the Congo", code: "+242", iso: "cg", flag: "flagpack:cg" },
  { name: "Reunion", code: "+262", iso: "re", flag: "flagpack:re" },
  { name: "Romania", code: "+40", iso: "ro", flag: "flagpack:ro" },
  { name: "Russia", code: "+7", iso: "ru", flag: "flagpack:ru" },
  { name: "Rwanda", code: "+250", iso: "rw", flag: "flagpack:rw" },
  { name: "Saint Barthelemy", code: "+590", iso: "bl", flag: "flagpack:bl" },
  { name: "Saint Helena", code: "+290", iso: "sh", flag: "flagpack:sh" },
  { name: "Saint Kitts and Nevis", code: "+1869", iso: "kn", flag: "flagpack:kn" },
  { name: "Saint Lucia", code: "+1758", iso: "lc", flag: "flagpack:lc" },
  { name: "Saint Martin", code: "+590", iso: "mf", flag: "flagpack:mf" },
  { name: "Saint Pierre and Miquelon", code: "+508", iso: "pm", flag: "flagpack:pm" },
  { name: "Saint Vincent and the Grenadines", code: "+1784", iso: "vc", flag: "flagpack:vc" },
  { name: "Samoa", code: "+685", iso: "ws", flag: "flagpack:ws" },
  { name: "San Marino", code: "+378", iso: "sm", flag: "flagpack:sm" },
  { name: "Sao Tome and Principe", code: "+239", iso: "st", flag: "flagpack:st" },
  { name: "Saudi Arabia", code: "+966", iso: "sa", flag: "flagpack:sa" },
  { name: "Senegal", code: "+221", iso: "sn", flag: "flagpack:sn" },
  { name: "Serbia", code: "+381", iso: "rs", flag: "flagpack:rs" },
  { name: "Seychelles", code: "+248", iso: "sc", flag: "flagpack:sc" },
  { name: "Sierra Leone", code: "+232", iso: "sl", flag: "flagpack:sl" },
  { name: "Singapore", code: "+65", iso: "sg", flag: "flagpack:sg" },
  { name: "Sint Maarten", code: "+1721", iso: "sx", flag: "flagpack:sx" },
  { name: "Slovakia", code: "+421", iso: "sk", flag: "flagpack:sk" },
  { name: "Slovenia", code: "+386", iso: "si", flag: "flagpack:si" },
  { name: "Solomon Islands", code: "+677", iso: "sb", flag: "flagpack:sb" },
  { name: "Somalia", code: "+252", iso: "so", flag: "flagpack:so" },
  { name: "South Africa", code: "+27", iso: "za", flag: "flagpack:za" },
  { name: "South Korea", code: "+82", iso: "kr", flag: "flagpack:kr" },
  { name: "South Sudan", code: "+211", iso: "ss", flag: "flagpack:ss" },
  { name: "Spain", code: "+34", iso: "es", flag: "flagpack:es" },
  { name: "Sri Lanka", code: "+94", iso: "lk", flag: "flagpack:lk" },
  { name: "Sudan", code: "+249", iso: "sd", flag: "flagpack:sd" },
  { name: "Suriname", code: "+597", iso: "sr", flag: "flagpack:sr" },
  { name: "Svalbard and Jan Mayen", code: "+47", iso: "sj", flag: "flagpack:sj" },
  { name: "Swaziland", code: "+268", iso: "sz", flag: "flagpack:sz" },
  { name: "Sweden", code: "+46", iso: "se", flag: "flagpack:se" },
  { name: "Switzerland", code: "+41", iso: "ch", flag: "flagpack:ch" },
  { name: "Syria", code: "+963", iso: "sy", flag: "flagpack:sy" },
  { name: "Taiwan", code: "+886", iso: "tw", flag: "flagpack:tw" },
  { name: "Tajikistan", code: "+992", iso: "tj", flag: "flagpack:tj" },
  { name: "Tanzania", code: "+255", iso: "tz", flag: "flagpack:tz" },
  { name: "Thailand", code: "+66", iso: "th", flag: "flagpack:th" },
  { name: "Togo", code: "+228", iso: "tg", flag: "flagpack:tg" },
  { name: "Tokelau", code: "+690", iso: "tk", flag: "flagpack:tk" },
  { name: "Tonga", code: "+676", iso: "to", flag: "flagpack:to" },
  { name: "Trinidad and Tobago", code: "+1868", iso: "tt", flag: "flagpack:tt" },
  { name: "Tunisia", code: "+216", iso: "tn", flag: "flagpack:tn" },
  { name: "Turkey", code: "+90", iso: "tr", flag: "flagpack:tr" },
  { name: "Turkmenistan", code: "+993", iso: "tm", flag: "flagpack:tm" },
  { name: "Turks and Caicos Islands", code: "+1649", iso: "tc", flag: "flagpack:tc" },
  { name: "Tuvalu", code: "+688", iso: "tv", flag: "flagpack:tv" },
  { name: "U.S. Virgin Islands", code: "+1340", iso: "vi", flag: "flagpack:vi" },
  { name: "Uganda", code: "+256", iso: "ug", flag: "flagpack:ug" },
  { name: "Ukraine", code: "+380", iso: "ua", flag: "flagpack:ua" },
  { name: "United Arab Emirates", code: "+971", iso: "ae", flag: "flagpack:ae" },
  { name: "United Kingdom", code: "+44", iso: "gb", flag: "flagpack:gb" },
  { name: "United States", code: "+1", iso: "us", flag: "flagpack:us" },
  { name: "Canada", code: "+1", iso: "ca", flag: "flagpack:ca" },
  { name: "Uruguay", code: "+598", iso: "uy", flag: "flagpack:uy" },
  { name: "Uzbekistan", code: "+998", iso: "uz", flag: "flagpack:uz" },
  { name: "Vanuatu", code: "+678", iso: "vu", flag: "flagpack:vu" },
  { name: "Vatican", code: "+379", iso: "va", flag: "flagpack:va" },
  { name: "Venezuela", code: "+58", iso: "ve", flag: "flagpack:ve" },
  { name: "Vietnam", code: "+84", iso: "vn", flag: "flagpack:vn" },
  { name: "Wallis and Futuna", code: "+681", iso: "wf", flag: "flagpack:wf" },
  { name: "Western Sahara", code: "+212", iso: "eh", flag: "flagpack:eh" },
  { name: "Yemen", code: "+967", iso: "ye", flag: "flagpack:ye" },
  { name: "Zambia", code: "+260", iso: "zm", flag: "flagpack:zm" },
  { name: "Zimbabwe", code: "+263", iso: "zw", flag: "flagpack:zw" }
], X$ = { version: 4, country_calling_codes: { 1: ["US", "AG", "AI", "AS", "BB", "BM", "BS", "CA", "DM", "DO", "GD", "GU", "JM", "KN", "KY", "LC", "MP", "MS", "PR", "SX", "TC", "TT", "VC", "VG", "VI"], 7: ["RU", "KZ"], 20: ["EG"], 27: ["ZA"], 30: ["GR"], 31: ["NL"], 32: ["BE"], 33: ["FR"], 34: ["ES"], 36: ["HU"], 39: ["IT", "VA"], 40: ["RO"], 41: ["CH"], 43: ["AT"], 44: ["GB", "GG", "IM", "JE"], 45: ["DK"], 46: ["SE"], 47: ["NO", "SJ"], 48: ["PL"], 49: ["DE"], 51: ["PE"], 52: ["MX"], 53: ["CU"], 54: ["AR"], 55: ["BR"], 56: ["CL"], 57: ["CO"], 58: ["VE"], 60: ["MY"], 61: ["AU", "CC", "CX"], 62: ["ID"], 63: ["PH"], 64: ["NZ"], 65: ["SG"], 66: ["TH"], 81: ["JP"], 82: ["KR"], 84: ["VN"], 86: ["CN"], 90: ["TR"], 91: ["IN"], 92: ["PK"], 93: ["AF"], 94: ["LK"], 95: ["MM"], 98: ["IR"], 211: ["SS"], 212: ["MA", "EH"], 213: ["DZ"], 216: ["TN"], 218: ["LY"], 220: ["GM"], 221: ["SN"], 222: ["MR"], 223: ["ML"], 224: ["GN"], 225: ["CI"], 226: ["BF"], 227: ["NE"], 228: ["TG"], 229: ["BJ"], 230: ["MU"], 231: ["LR"], 232: ["SL"], 233: ["GH"], 234: ["NG"], 235: ["TD"], 236: ["CF"], 237: ["CM"], 238: ["CV"], 239: ["ST"], 240: ["GQ"], 241: ["GA"], 242: ["CG"], 243: ["CD"], 244: ["AO"], 245: ["GW"], 246: ["IO"], 247: ["AC"], 248: ["SC"], 249: ["SD"], 250: ["RW"], 251: ["ET"], 252: ["SO"], 253: ["DJ"], 254: ["KE"], 255: ["TZ"], 256: ["UG"], 257: ["BI"], 258: ["MZ"], 260: ["ZM"], 261: ["MG"], 262: ["RE", "YT"], 263: ["ZW"], 264: ["NA"], 265: ["MW"], 266: ["LS"], 267: ["BW"], 268: ["SZ"], 269: ["KM"], 290: ["SH", "TA"], 291: ["ER"], 297: ["AW"], 298: ["FO"], 299: ["GL"], 350: ["GI"], 351: ["PT"], 352: ["LU"], 353: ["IE"], 354: ["IS"], 355: ["AL"], 356: ["MT"], 357: ["CY"], 358: ["FI", "AX"], 359: ["BG"], 370: ["LT"], 371: ["LV"], 372: ["EE"], 373: ["MD"], 374: ["AM"], 375: ["BY"], 376: ["AD"], 377: ["MC"], 378: ["SM"], 380: ["UA"], 381: ["RS"], 382: ["ME"], 383: ["XK"], 385: ["HR"], 386: ["SI"], 387: ["BA"], 389: ["MK"], 420: ["CZ"], 421: ["SK"], 423: ["LI"], 500: ["FK"], 501: ["BZ"], 502: ["GT"], 503: ["SV"], 504: ["HN"], 505: ["NI"], 506: ["CR"], 507: ["PA"], 508: ["PM"], 509: ["HT"], 590: ["GP", "BL", "MF"], 591: ["BO"], 592: ["GY"], 593: ["EC"], 594: ["GF"], 595: ["PY"], 596: ["MQ"], 597: ["SR"], 598: ["UY"], 599: ["CW", "BQ"], 670: ["TL"], 672: ["NF"], 673: ["BN"], 674: ["NR"], 675: ["PG"], 676: ["TO"], 677: ["SB"], 678: ["VU"], 679: ["FJ"], 680: ["PW"], 681: ["WF"], 682: ["CK"], 683: ["NU"], 685: ["WS"], 686: ["KI"], 687: ["NC"], 688: ["TV"], 689: ["PF"], 690: ["TK"], 691: ["FM"], 692: ["MH"], 850: ["KP"], 852: ["HK"], 853: ["MO"], 855: ["KH"], 856: ["LA"], 880: ["BD"], 886: ["TW"], 960: ["MV"], 961: ["LB"], 962: ["JO"], 963: ["SY"], 964: ["IQ"], 965: ["KW"], 966: ["SA"], 967: ["YE"], 968: ["OM"], 970: ["PS"], 971: ["AE"], 972: ["IL"], 973: ["BH"], 974: ["QA"], 975: ["BT"], 976: ["MN"], 977: ["NP"], 992: ["TJ"], 993: ["TM"], 994: ["AZ"], 995: ["GE"], 996: ["KG"], 998: ["UZ"] }, countries: { AC: ["247", "00", "(?:[01589]\\d|[46])\\d{4}", [5, 6]], AD: ["376", "00", "(?:1|6\\d)\\d{7}|[135-9]\\d{5}", [6, 8, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["[135-9]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["1"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]]], AE: ["971", "00", "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{2,9})", "$1 $2", ["60|8"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[236]|[479][2-8]"], "0$1"], ["(\\d{3})(\\d)(\\d{5})", "$1 $2 $3", ["[479]"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"]], "0"], AF: ["93", "00", "[2-7]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"]], "0"], AG: ["1", "011", "(?:268|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([457]\\d{6})$|1", "268$1", 0, "268"], AI: ["1", "011", "(?:264|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2457]\\d{6})$|1", "264$1", 0, "264"], AL: ["355", "00", "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}", [6, 7, 8, 9], [["(\\d{3})(\\d{3,4})", "$1 $2", ["80|9"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["4[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2358][2-5]|4"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["[23578]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["6"], "0$1"]], "0"], AM: ["374", "00", "(?:[1-489]\\d|55|60|77)\\d{6}", [8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[89]0"], "0 $1"], ["(\\d{3})(\\d{5})", "$1 $2", ["2|3[12]"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["1|47"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[3-9]"], "0$1"]], "0"], AO: ["244", "00", "[29]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[29]"]]]], AR: ["54", "00", "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}", [10, 11], [["(\\d{4})(\\d{2})(\\d{4})", "$1 $2-$3", ["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])", "2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["1"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[68]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2-$3", ["[23]"], "0$1", 1], ["(\\d)(\\d{4})(\\d{2})(\\d{4})", "$2 15-$3-$4", ["9(?:2[2-469]|3[3-578])", "9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))", "9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]", "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d)(\\d{2})(\\d{4})(\\d{4})", "$2 15-$3-$4", ["91"], "0$1", 0, "$1 $2 $3-$4"], ["(\\d{3})(\\d{3})(\\d{5})", "$1-$2-$3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{4})", "$2 15-$3-$4", ["9"], "0$1", 0, "$1 $2 $3-$4"]], "0", 0, "0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?", "9$1"], AS: ["1", "011", "(?:[58]\\d\\d|684|900)\\d{7}", [10], 0, "1", 0, "([267]\\d{6})$|1", "684$1", 0, "684"], AT: ["43", "00", "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{3,12})", "$1 $2", ["1(?:11|[2-9])"], "0$1"], ["(\\d{3})(\\d{2})", "$1 $2", ["517"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["5[079]"], "0$1"], ["(\\d{3})(\\d{3,10})", "$1 $2", ["(?:31|4)6|51|6(?:48|5[0-3579]|[6-9])|7(?:20|32|8)|[89]", "(?:31|4)6|51|6(?:485|5[0-3579]|[6-9])|7(?:20|32|8)|[89]"], "0$1"], ["(\\d{4})(\\d{3,9})", "$1 $2", ["[2-467]|5[2-6]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,7})", "$1 $2 $3", ["5"], "0$1"]], "0"], AU: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}", [5, 6, 7, 8, 9, 10, 12], [["(\\d{2})(\\d{3,4})", "$1 $2", ["16"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["16"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["14|4"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[2378]"], "(0$1)"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:30|[89])"]]], "0", 0, "(183[12])|0", 0, 0, 0, [["(?:(?:241|349)0\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|[34]\\d\\d)|91(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79]))))\\d{3}|(?:2(?:[0-26-9]\\d|3[0-8]|4[02-9]|5[0135-9])|3(?:[0-3589]\\d|4[0-578]|6[1-9]|7[0-35-9])|7(?:[013-57-9]\\d|2[0-8])|8(?:55|6[0-8]|[78]\\d|9[02-9]))\\d{6}", [9]], ["4(?:79[01]|83[0-36-9]|95[0-3])\\d{5}|4(?:[0-36]\\d|4[047-9]|[58][0-24-9]|7[02-8]|9[0-47-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, ["163\\d{2,6}", [5, 6, 7, 8, 9]], ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], AW: ["297", "00", "(?:[25-79]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[25-9]"]]]], AX: ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}", [5, 6, 7, 8, 9, 10, 11, 12], 0, "0", 0, 0, 0, 0, "18", 0, "00"], AZ: ["994", "00", "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[28]|2|365|46", "1[28]|2|365[45]|46", "1[28]|2|365(?:4|5[02])|46"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[13-9]"], "0$1"]], "0"], BA: ["387", "00", "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[1-3]|[7-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2-$3", ["[3-5]|6[56]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["6"], "0$1"]], "0"], BB: ["1", "011", "(?:246|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "246$1", 0, "246"], BD: ["880", "00", "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{2})(\\d{4,6})", "$1-$2", ["31[5-8]|[459]1"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1-$2", ["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"], "0$1"], ["(\\d{4})(\\d{3,6})", "$1-$2", ["[13-9]|2[23]"], "0$1"], ["(\\d)(\\d{7,8})", "$1-$2", ["2"], "0$1"]], "0"], BE: ["32", "00", "4\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:80|9)0"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[239]|4[23]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[15-8]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4"], "0$1"]], "0"], BF: ["226", "00", "(?:[025-7]\\d|44)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[024-7]"]]]], BG: ["359", "00", "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}", [6, 7, 8, 9, 12], [["(\\d)(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["43[1-6]|70[1-9]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:70|8)0"], "0$1"], ["(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3", ["43[1-7]|7"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[48]|9[08]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"]], "0"], BH: ["973", "00", "[136-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[13679]|8[02-4679]"]]]], BI: ["257", "00", "(?:[267]\\d|31)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2367]"]]]], BJ: ["229", "00", "(?:01\\d|8)\\d{7}", [8, 10], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["0"]]]], BL: ["590", "00", "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"], ["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]], BM: ["1", "011", "(?:441|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "441$1", 0, "441"], BN: ["673", "00", "[2-578]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-578]"]]]], BO: ["591", "00(?:1\\d)?", "8001\\d{5}|(?:[2-467]\\d|50)\\d{6}", [8, 9], [["(\\d)(\\d{7})", "$1 $2", ["[235]|4[46]"]], ["(\\d{8})", "$1", ["[67]"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["8"]]], "0", 0, "0(1\\d)?"], BQ: ["599", "00", "(?:[34]1|7\\d)\\d{5}", [7], 0, 0, 0, 0, 0, 0, "[347]"], BR: ["55", "00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)", "[1-467]\\d{9,10}|55[0-46-9]\\d{8}|[34]\\d{7}|55\\d{7,8}|(?:5[0-46-9]|[89]\\d)\\d{7,9}", [8, 9, 10, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["300|4(?:0[02]|37|86)", "300|4(?:0(?:0|20)|370|864)"]], ["(\\d{3})(\\d{2,3})(\\d{4})", "$1 $2 $3", ["(?:[358]|90)0"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2-$3", ["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"], "($1)"], ["(\\d{2})(\\d{5})(\\d{4})", "$1 $2-$3", ["[16][1-9]|[2-57-9]"], "($1)"]], "0", 0, "(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?", "$2"], BS: ["1", "011", "(?:242|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([3-8]\\d{6})$|1", "242$1", 0, "242"], BT: ["975", "00", "[178]\\d{7}|[2-8]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-6]|7[246]|8[2-4]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[67]|[78]"]]]], BW: ["267", "00", "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["90"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[24-6]|3[15-9]"]], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37]"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["8"]]]], BY: ["375", "810", "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3})", "$1 $2", ["800"], "8 $1"], ["(\\d{3})(\\d{2})(\\d{2,4})", "$1 $2 $3", ["800"], "8 $1"], ["(\\d{4})(\\d{2})(\\d{3})", "$1 $2-$3", ["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])", "1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"], "8 0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["1(?:[56]|7[467])|2[1-3]"], "8 0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-4]"], "8 0$1"], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[89]"], "8 $1"]], "8", 0, "0|80?", 0, 0, 0, 0, "8~10"], BZ: ["501", "00", "(?:0800\\d|[2-8])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-8]"]], ["(\\d)(\\d{3})(\\d{4})(\\d{3})", "$1-$2-$3-$4", ["0"]]]], CA: ["1", "011", "[2-9]\\d{9}|3\\d{6}", [7, 10], 0, "1", 0, 0, 0, 0, 0, [["(?:2(?:04|[23]6|[48]9|5[07]|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|9(?:0[25]|42))[2-9]\\d{6}", [10]], ["", [10]], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}", [10]], ["900[2-9]\\d{6}", [10]], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:2[125-9]|33|44|66|77|88)|6(?:22|33))[2-9]\\d{6}", [10]], 0, ["310\\d{4}", [7]], 0, ["600[2-9]\\d{6}", [10]]]], CC: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}", [9]], ["4(?:79[01]|83[0-36-9]|95[0-3])\\d{5}|4(?:[0-36]\\d|4[047-9]|[58][0-24-9]|7[02-8]|9[0-47-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], CD: ["243", "00", "(?:(?:[189]|5\\d)\\d|2)\\d{7}|[1-68]\\d{6}", [7, 8, 9, 10], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[1-6]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["5"], "0$1"]], "0"], CF: ["236", "00", "(?:[27]\\d{3}|8776)\\d{4}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[278]"]]]], CG: ["242", "00", "222\\d{6}|(?:0\\d|80)\\d{7}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[02]"]]]], CH: ["41", "00", "8\\d{11}|[2-9]\\d{8}", [9, 12], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8[047]|90"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]|81"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["8"], "0$1"]], "0"], CI: ["225", "00", "[02]\\d{9}", [10], [["(\\d{2})(\\d{2})(\\d)(\\d{5})", "$1 $2 $3 $4", ["2"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3 $4", ["0"]]]], CK: ["682", "00", "[2-578]\\d{4}", [5], [["(\\d{2})(\\d{3})", "$1 $2", ["[2-578]"]]]], CL: ["56", "(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0", "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}", [9, 10, 11], [["(\\d{5})(\\d{4})", "$1 $2", ["219", "2196"], "($1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["60|809"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["44"]], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2[1-36]"], "($1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["9(?:10|[2-9])"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-8]|[1-9])"], "($1)"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["60|8"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{3})(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["60"]]]], CM: ["237", "00", "[26]\\d{8}|88\\d{6,7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["88"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[26]|88"]]]], CN: ["86", "00|1(?:[12]\\d|79)\\d\\d00", "(?:(?:1[03-689]|2\\d)\\d\\d|6)\\d{8}|1\\d{10}|[126]\\d{6}(?:\\d(?:\\d{2})?)?|86\\d{5,6}|(?:[3-579]\\d|8[0-57-9])\\d{5,9}", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5,6})", "$1 $2", ["(?:10|2[0-57-9])[19]|3(?:[157]|35|49|9[1-68])|4(?:1[124-9]|2[179]|6[47-9]|7|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:07|1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3|4[13]|5[1-5]|7[0-79]|9[0-35-9])|(?:4[35]|59|85)[1-9]", "(?:10|2[0-57-9])(?:1[02]|9[56])|8078|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))1", "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|80781|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))12", "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|807812|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123", "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:078|1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123"], "0$1"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]", "(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]", "85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])", "85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["(?:4|80)0"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|2(?:[02-57-9]|1[1-9])", "10|2(?:[02-57-9]|1[1-9])", "10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"], "0$1", 1], ["(\\d{3})(\\d{7,8})", "$1 $2", ["9"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["80"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[3-578]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["1[3-9]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["[12]"], "0$1", 1]], "0", 0, "(1(?:[12]\\d|79)\\d\\d)|0", 0, 0, 0, 0, "00"], CO: ["57", "00(?:4(?:[14]4|56)|[579])", "(?:46|60\\d\\d)\\d{6}|(?:1\\d|[39])\\d{9}", [8, 10, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["46"]], ["(\\d{3})(\\d{7})", "$1 $2", ["6|90"], "($1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3[0-357]|9[14]"]], ["(\\d)(\\d{3})(\\d{7})", "$1-$2-$3", ["1"], "0$1", 0, "$1 $2 $3"]], "0", 0, "0([3579]|4(?:[14]4|56))?"], CR: ["506", "00", "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}", [8, 10], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[3-9]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["[89]"]]], 0, 0, "(19(?:0[0-2468]|1[09]|20|66|77|99))"], CU: ["53", "119", "(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}", [6, 7, 8, 10], [["(\\d{2})(\\d{4,6})", "$1 $2", ["2[1-4]|[34]"], "(0$1)"], ["(\\d)(\\d{6,7})", "$1 $2", ["7"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["[56]"], "0$1"], ["(\\d{3})(\\d{7})", "$1 $2", ["8"], "0$1"]], "0"], CV: ["238", "0", "(?:[2-59]\\d\\d|800)\\d{4}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2-589]"]]]], CW: ["599", "00", "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[3467]"]], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["9[4-8]"]]], 0, 0, 0, 0, 0, "[69]"], CX: ["61", "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011", "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}", [6, 7, 8, 9, 10, 12], 0, "0", 0, "([59]\\d{7})$|0", "8$1", 0, 0, [["8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}", [9]], ["4(?:79[01]|83[0-36-9]|95[0-3])\\d{5}|4(?:[0-36]\\d|4[047-9]|[58][0-24-9]|7[02-8]|9[0-47-9])\\d{6}", [9]], ["180(?:0\\d{3}|2)\\d{3}", [7, 10]], ["190[0-26]\\d{6}", [10]], 0, 0, 0, 0, ["14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}", [9]], ["13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}", [6, 8, 10, 12]]], "0011"], CY: ["357", "00", "(?:[279]\\d|[58]0)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[257-9]"]]]], CZ: ["420", "00", "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}", [9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]|9[015-7]"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["96"]], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]]], DE: ["49", "00", "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [["(\\d{2})(\\d{3,13})", "$1 $2", ["3[02]|40|[68]9"], "0$1"], ["(\\d{3})(\\d{3,12})", "$1 $2", ["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1", "2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"], "0$1"], ["(\\d{4})(\\d{2,11})", "$1 $2", ["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]", "[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["138"], "0$1"], ["(\\d{5})(\\d{2,10})", "$1 $2", ["3"], "0$1"], ["(\\d{3})(\\d{5,11})", "$1 $2", ["181"], "0$1"], ["(\\d{3})(\\d)(\\d{4,10})", "$1 $2 $3", ["1(?:3|80)|9"], "0$1"], ["(\\d{3})(\\d{7,8})", "$1 $2", ["1[67]"], "0$1"], ["(\\d{3})(\\d{7,12})", "$1 $2", ["8"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["185", "1850", "18500"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["18[68]"], "0$1"], ["(\\d{4})(\\d{7})", "$1 $2", ["15[1279]"], "0$1"], ["(\\d{5})(\\d{6})", "$1 $2", ["15[03568]", "15(?:[0568]|3[13])"], "0$1"], ["(\\d{3})(\\d{8})", "$1 $2", ["18"], "0$1"], ["(\\d{3})(\\d{2})(\\d{7,8})", "$1 $2 $3", ["1(?:6[023]|7)"], "0$1"], ["(\\d{4})(\\d{2})(\\d{7})", "$1 $2 $3", ["15[279]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{8})", "$1 $2 $3", ["15"], "0$1"]], "0"], DJ: ["253", "00", "(?:2\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[27]"]]]], DK: ["45", "00", "[2-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-9]"]]]], DM: ["1", "011", "(?:[58]\\d\\d|767|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "767$1", 0, "767"], DO: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "8001|8[024]9"], DZ: ["213", "00", "(?:[1-4]|[5-79]\\d|80)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["9"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-8]"], "0$1"]], "0"], EC: ["593", "00", "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}", [8, 9, 10, 11], [["(\\d)(\\d{3})(\\d{4})", "$1 $2-$3", ["[2-7]"], "(0$1)", 0, "$1-$2-$3"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1"]]], "0"], EE: ["372", "00", "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88", "[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]], ["(\\d{4})(\\d{3,4})", "$1 $2", ["[45]|8(?:00|[1-49])", "[45]|8(?:00[1-9]|[1-49])"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]]], EG: ["20", "00", "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}", [8, 9, 10], [["(\\d)(\\d{7,8})", "$1 $2", ["[23]"], "0$1"], ["(\\d{2})(\\d{6,7})", "$1 $2", ["1[35]|[4-6]|8[2468]|9[235-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{8})", "$1 $2", ["1"], "0$1"]], "0"], EH: ["212", "00", "[5-8]\\d{8}", [9], 0, "0", 0, 0, 0, 0, "528[89]"], ER: ["291", "00", "[178]\\d{6}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[178]"], "0$1"]], "0"], ES: ["34", "00", "[5-9]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[89]00"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-9]"]]]], ET: ["251", "00", "(?:11|[2-579]\\d)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-579]"], "0$1"]], "0"], FI: ["358", "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))", "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}", [5, 6, 7, 8, 9, 10, 11, 12], [["(\\d{5})", "$1", ["20[2-59]"], "0$1"], ["(\\d{3})(\\d{3,7})", "$1 $2", ["(?:[1-3]0|[68])0|70[07-9]"], "0$1"], ["(\\d{2})(\\d{4,8})", "$1 $2", ["[14]|2[09]|50|7[135]"], "0$1"], ["(\\d{2})(\\d{6,10})", "$1 $2", ["7"], "0$1"], ["(\\d)(\\d{4,9})", "$1 $2", ["(?:19|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"], "0$1"]], "0", 0, 0, 0, 0, "1[03-79]|[2-9]", 0, "00"], FJ: ["679", "0(?:0|52)", "45\\d{5}|(?:0800\\d|[235-9])\\d{6}", [7, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[235-9]|45"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]]], 0, 0, 0, 0, 0, 0, 0, "00"], FK: ["500", "00", "[2-7]\\d{4}", [5]], FM: ["691", "00", "(?:[39]\\d\\d|820)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[389]"]]]], FO: ["298", "00", "[2-9]\\d{5}", [6], [["(\\d{6})", "$1", ["[2-9]"]]], 0, 0, "(10(?:01|[12]0|88))"], FR: ["33", "00", "[1-9]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0 $1"], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[1-79]"], "0$1"]], "0"], GA: ["241", "00", "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}", [7, 8], [["(\\d)(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-7]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["11|[67]"], "0$1"]], 0, 0, "0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})", "$1"], GB: ["44", "00", "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}", [7, 9, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["800", "8001", "80011", "800111", "8001111"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["845", "8454", "84546", "845464"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["800"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["1(?:38|5[23]|69|76|94)", "1(?:(?:38|69)7|5(?:24|39)|768|946)", "1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["1(?:[2-69][02-9]|[78])"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[25]|7(?:0|6[02-9])", "[25]|7(?:0|6(?:[03-9]|2[356]))"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1389]"], "0$1"]], "0", 0, "0|180020", 0, 0, 0, [["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0-5])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|5[01]))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-3]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}", [9, 10]], ["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]], 0, " x"], GD: ["1", "011", "(?:473|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "473$1", 0, "473"], GE: ["995", "00", "(?:[3-57]\\d\\d|800)\\d{6}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["32"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[57]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[348]"], "0$1"]], "0"], GF: ["594", "00", "(?:[56]94\\d|7093)\\d{5}|(?:80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]|9[47]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[89]"], "0$1"]], "0"], GG: ["44", "00", "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?", [7, 9, 10], 0, "0", 0, "([25-9]\\d{5})$|0|180020", "1481$1", 0, 0, [["1481[25-9]\\d{5}", [10]], ["7(?:(?:781|839)\\d|911[17])\\d{5}", [10]], ["80[08]\\d{7}|800\\d{6}|8001111"], ["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d", [7, 10]], ["70\\d{8}", [10]], 0, ["(?:3[0347]|55)\\d{8}", [10]], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}", [10]], ["56\\d{8}", [10]]]], GH: ["233", "00", "(?:[235]\\d{3}|800)\\d{5}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[235]"], "0$1"]], "0"], GI: ["350", "00", "(?:[25]\\d|60)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["2"]]]], GL: ["299", "00", "(?:19|[2-689]\\d|70)\\d{4}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["19|[2-9]"]]]], GM: ["220", "00", "[2-9]\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], GN: ["224", "00", "722\\d{6}|(?:3|6\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["3"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[67]"]]]], GP: ["590", "00", "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-79]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0", 0, 0, 0, 0, 0, [["590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"], ["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]], GQ: ["240", "00", "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235]"]], ["(\\d{3})(\\d{6})", "$1 $2", ["[89]"]]]], GR: ["30", "00", "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}", [10, 11, 12], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["21|7"]], ["(\\d{4})(\\d{6})", "$1 $2", ["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2689]"]], ["(\\d{3})(\\d{3,4})(\\d{5})", "$1 $2 $3", ["8"]]]], GT: ["502", "00", "80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[2-8]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]]], GU: ["1", "011", "(?:[58]\\d\\d|671|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "671$1", 0, "671"], GW: ["245", "00", "[49]\\d{8}|4\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["40"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"]]]], GY: ["592", "001", "(?:[2-8]\\d{3}|9008)\\d{3}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], HK: ["852", "00(?:30|5[09]|[126-9]?)", "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}", [5, 6, 7, 8, 9, 11], [["(\\d{3})(\\d{2,5})", "$1 $2", ["900", "9003"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{3})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["9"]]], 0, 0, 0, 0, 0, 0, 0, "00"], HN: ["504", "00", "8\\d{10}|[237-9]\\d{7}", [8, 11], [["(\\d{4})(\\d{4})", "$1-$2", ["[237-9]"]]]], HR: ["385", "00", "[2-69]\\d{8}|80\\d{5,7}|[1-79]\\d{7}|6\\d{6}", [7, 8, 9], [["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["6[01]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{4})(\\d{3})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6|7[245]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-57]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"]], "0"], HT: ["509", "00", "[2-589]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[2-589]"]]]], HU: ["36", "00", "[235-7]\\d{8}|[1-9]\\d{7}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"], "(06 $1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "06 $1"]], "06"], ID: ["62", "00[89]", "00[1-9]\\d{9,14}|(?:[1-36]|8\\d{5})\\d{6}|00\\d{9}|[1-9]\\d{8,10}|[2-9]\\d{7}", [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["15"]], ["(\\d{2})(\\d{5,9})", "$1 $2", ["2[124]|[36]1"], "(0$1)"], ["(\\d{3})(\\d{5,7})", "$1 $2", ["800"], "0$1"], ["(\\d{3})(\\d{5,8})", "$1 $2", ["[2-79]"], "(0$1)"], ["(\\d{3})(\\d{3,4})(\\d{3})", "$1-$2-$3", ["8[1-35-9]"], "0$1"], ["(\\d{3})(\\d{6,8})", "$1 $2", ["1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["804"], "0$1"], ["(\\d{3})(\\d)(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["80"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1-$2-$3", ["8"], "0$1"]], "0"], IE: ["353", "00", "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["2[24-9]|47|58|6[237-9]|9[35-9]"], "(0$1)"], ["(\\d{3})(\\d{5})", "$1 $2", ["[45]0"], "(0$1)"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2569]|4[1-69]|7[14]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["70"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["81"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["4"], "(0$1)"], ["(\\d{2})(\\d)(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], IL: ["972", "0(?:0|1[2-9])", "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}", [7, 8, 9, 10, 11, 12], [["(\\d{4})(\\d{3})", "$1-$2", ["125"]], ["(\\d{4})(\\d{2})(\\d{2})", "$1-$2-$3", ["121"]], ["(\\d)(\\d{3})(\\d{4})", "$1-$2-$3", ["[2-489]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1-$2-$3", ["12"]], ["(\\d{4})(\\d{6})", "$1-$2", ["159"]], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3-$4", ["1[7-9]"]], ["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})", "$1-$2 $3-$4", ["15"]]], "0"], IM: ["44", "00", "1624\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([25-8]\\d{5})$|0|180020", "1624$1", 0, "74576|(?:16|7[56])24"], IN: ["91", "00", "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}", [8, 9, 10, 11, 12, 13], [["(\\d{8})", "$1", ["5(?:0|2[23]|3[03]|[67]1|88)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)", "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"], 0, 1], ["(\\d{4})(\\d{4,5})", "$1 $2", ["180", "1800"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["140"], 0, 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["11|2[02]|33|4[04]|79[1-7]|80[2-46]", "11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])", "11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]", "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"], "0$1", 1], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807", "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]", "1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|8(?:28[235-7]|3))|73179|807(?:1|9[1-3])|(?:1552|6(?:(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689])\\d|8(?:[14-6]\\d|2[0-79]))|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"], "0$1", 1], ["(\\d{5})(\\d{5})", "$1 $2", ["[6-9]"], "0$1", 1], ["(\\d{4})(\\d{2,4})(\\d{4})", "$1 $2 $3", ["1(?:6|8[06])", "1(?:6|8[06]0)"], 0, 1], ["(\\d{4})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["18"], 0, 1]], "0"], IO: ["246", "00", "3\\d{6}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["3"]]]], IQ: ["964", "00", "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-6]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"]], "0"], IR: ["98", "00", "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}", [4, 5, 6, 7, 10], [["(\\d{4,5})", "$1", ["96"], "0$1"], ["(\\d{2})(\\d{4,5})", "$1 $2", ["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["[1-8]"], "0$1"]], "0"], IS: ["354", "00|1(?:0(?:01|[12]0)|100)", "(?:38\\d|[4-9])\\d{6}", [7, 9], [["(\\d{3})(\\d{4})", "$1 $2", ["[4-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["3"]]], 0, 0, 0, 0, 0, 0, 0, "00"], IT: ["39", "00", "0\\d{5,11}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?", [6, 7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{4,6})", "$1 $2", ["0[26]"]], ["(\\d{3})(\\d{3,6})", "$1 $2", ["0[13-57-9][0159]|8(?:03|4[17]|9[2-5])", "0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"]], ["(\\d{4})(\\d{2,6})", "$1 $2", ["0(?:[13-579][2-46-8]|8[236-8])"]], ["(\\d{4})(\\d{4})", "$1 $2", ["894"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[26]|5"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["1(?:44|[679])|[378]|43"]], ["(\\d{3})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["0[13-57-9][0159]|14"]], ["(\\d{2})(\\d{4})(\\d{5})", "$1 $2 $3", ["0[26]"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["[03]"]]], 0, 0, 0, 0, 0, 0, [["0(?:669[0-79]\\d{1,6}|831\\d{2,8})|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[2356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"], ["3[2-9]\\d{7,8}|(?:31|43)\\d{8}", [9, 10]], ["80(?:0\\d{3}|3)\\d{3}", [6, 9]], ["(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}", [6, 8, 9, 10]], ["1(?:78\\d|99)\\d{6}", [9, 10]], ["3[2-8]\\d{9,10}", [11, 12]], 0, 0, ["55\\d{8}", [10]], ["84(?:[08]\\d{3}|[17])\\d{3}", [6, 9]]]], JE: ["44", "00", "1534\\d{6}|(?:[3578]\\d|90)\\d{8}", [10], 0, "0", 0, "([0-24-8]\\d{5})$|0|180020", "1534$1", 0, 0, [["1534[0-24-8]\\d{5}"], ["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"], ["80(?:07(?:35|81)|8901)\\d{4}"], ["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"], ["701511\\d{4}"], 0, ["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"], ["76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"], ["56\\d{8}"]]], JM: ["1", "011", "(?:[58]\\d\\d|658|900)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "658|876"], JO: ["962", "00", "(?:(?:[2689]|7\\d)\\d|32|427|53)\\d{6}", [8, 9], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2356]|87"], "(0$1)"], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["70"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[47]"], "0$1"]], "0"], JP: ["81", "010", "00[1-9]\\d{6,14}|[25-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}", [8, 9, 10, 11, 12, 13, 14, 15, 16, 17], [["(\\d{3})(\\d{3})(\\d{3})", "$1-$2-$3", ["(?:12|57|99)0"], "0$1"], ["(\\d{4})(\\d)(\\d{4})", "$1-$2-$3", ["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]", "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["60"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2-$3", ["3|4(?:2[09]|7[01])|6[1-9]", "3|4(?:2(?:0|9[02-69])|7(?:0[019]|1))|6[1-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]", "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3", ["[14]|[289][2-9]|5[3-9]|7[2-4679]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2-$3", ["800"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[25-9]"], "0$1"]], "0", 0, "(000[2569]\\d{4,6})$|(?:(?:003768)0?)|0", "$1"], KE: ["254", "000", "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}", [7, 8, 9, 10], [["(\\d{2})(\\d{5,7})", "$1 $2", ["[24-6]"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[17]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0"], KG: ["996", "00", "8\\d{9}|[235-9]\\d{8}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["3(?:1[346]|[24-79])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-79]|88"], "0$1"], ["(\\d{3})(\\d{3})(\\d)(\\d{2,3})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], KH: ["855", "00[14-9]", "1\\d{9}|[1-9]\\d{7,8}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], KI: ["686", "00", "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}", [5, 8], 0, "0"], KM: ["269", "00", "[3478]\\d{6}", [7], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[3478]"]]]], KN: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "869$1", 0, "869"], KP: ["850", "00|99", "85\\d{6}|(?:19\\d|[2-7])\\d{7}", [8, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-7]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"]], "0"], KR: ["82", "00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))", "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}", [5, 6, 8, 9, 10, 11, 12, 13, 14], [["(\\d{2})(\\d{3,4})", "$1-$2", ["(?:3[1-3]|[46][1-4]|5[1-5])1"], "0$1"], ["(\\d{4})(\\d{4})", "$1-$2", ["1"]], ["(\\d)(\\d{3,4})(\\d{4})", "$1-$2-$3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1-$2-$3", ["[36]0|8"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1-$2-$3", ["[1346]|5[1-5]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2-$3", ["[57]"], "0$1"], ["(\\d{2})(\\d{5})(\\d{4})", "$1-$2-$3", ["5"], "0$1"]], "0", 0, "0(8(?:[1-46-8]|5\\d\\d))?"], KW: ["965", "00", "18\\d{5}|(?:[2569]\\d|41)\\d{6}", [7, 8], [["(\\d{4})(\\d{3,4})", "$1 $2", ["[169]|2(?:[235]|4[1-35-9])|52"]], ["(\\d{3})(\\d{5})", "$1 $2", ["[245]"]]]], KY: ["1", "011", "(?:345|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "345$1", 0, "345"], KZ: ["7", "810", "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}", [10, 14], 0, "8", 0, 0, 0, 0, "33622|7", 0, "8~10"], LA: ["856", "00", "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}", [8, 9, 10], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2[13]|3[14]|[4-8]"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["3"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0"], LB: ["961", "00", "[27-9]\\d{7}|[13-9]\\d{6}", [7, 8], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[13-69]|7(?:[2-57]|62|8[0-6]|9[04-9])|8[02-9]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[27-9]"]]], "0"], LC: ["1", "011", "(?:[58]\\d\\d|758|900)\\d{7}", [10], 0, "1", 0, "([2-8]\\d{6})$|1", "758$1", 0, "758"], LI: ["423", "00", "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}", [7, 9], [["(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3", ["[2379]|8(?:0[09]|7)", "[2379]|8(?:0(?:02|9)|7)"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["69"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]]], "0", 0, "(1001)|0"], LK: ["94", "00", "[1-9]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[1-689]"], "0$1"]], "0"], LR: ["231", "00", "(?:[2457]\\d|33|88)\\d{7}|(?:2\\d|[4-6])\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["4[67]|[56]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-578]"], "0$1"]], "0"], LS: ["266", "00", "(?:[256]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2568]"]]]], LT: ["370", "00", "(?:[3469]\\d|52|[78]0)\\d{6}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["52[0-7]"], "(0-$1)", 1], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0 $1", 1], ["(\\d{2})(\\d{6})", "$1 $2", ["37|4(?:[15]|6[1-8])"], "(0-$1)", 1], ["(\\d{3})(\\d{5})", "$1 $2", ["[3-6]"], "(0-$1)", 1]], "0", 0, "[08]"], LU: ["352", "00", "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}", [4, 5, 6, 7, 8, 9, 10, 11], [["(\\d{2})(\\d{3})", "$1 $2", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["20[2-689]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4", ["2(?:[0367]|4[3-8])"]], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["80[01]|90[015]"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3 $4", ["20"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})", "$1 $2 $3 $4 $5", ["2(?:[0367]|4[3-8])"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})", "$1 $2 $3 $4", ["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]], 0, 0, "(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"], LV: ["371", "00", "(?:[268]\\d|78|90)\\d{6}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2679]|8[01]"]]]], LY: ["218", "00", "[2-9]\\d{8}", [9], [["(\\d{2})(\\d{7})", "$1-$2", ["[2-9]"], "0$1"]], "0"], MA: ["212", "00", "[5-8]\\d{8}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5[45]"], "0$1"], ["(\\d{4})(\\d{5})", "$1-$2", ["5(?:[19]|2[2-46-9]|3[3-9])|8(?:0[89]|92)"], "0$1"], ["(\\d{2})(\\d{7})", "$1-$2", ["8"], "0$1"], ["(\\d{3})(\\d{6})", "$1-$2", ["[5-7]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["5(?:(?:18|4[0679]|5[03])\\d|2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9]))\\d{5}"], ["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[016-8]\\d|2[0-8]|5[0-5]))\\d{6}"], ["80[0-7]\\d{6}"], ["89\\d{7}"], 0, 0, 0, 0, ["(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"]]], MC: ["377", "00", "(?:[3489]|[67]\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["4"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[389]"]], ["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4 $5", ["[67]"], "0$1"]], "0"], MD: ["373", "00", "(?:[235-7]\\d|[89]0)\\d{6}", [8], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["22|3"], "0$1"], ["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["[25-7]"], "0$1"]], "0"], ME: ["382", "00", "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[2-9]"], "0$1"]], "0"], MF: ["590", "00", "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}", [9], 0, "0", 0, 0, 0, 0, 0, [["590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"], ["(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"], ["80[0-5]\\d{6}"], 0, 0, 0, 0, 0, ["9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"]]], MG: ["261", "00", "[23]\\d{8}", [9], [["(\\d{2})(\\d{2})(\\d{3})(\\d{2})", "$1 $2 $3 $4", ["[23]"], "0$1"]], "0", 0, "([24-9]\\d{6})$|0", "20$1"], MH: ["692", "011", "329\\d{4}|(?:[256]\\d|45)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1-$2", ["[2-6]"]]], "1"], MK: ["389", "00", "[2-578]\\d{7}", [8], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2|34[47]|4(?:[37]7|5[47]|64)"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[347]"], "0$1"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[58]"], "0$1"]], "0"], ML: ["223", "00", "[24-9]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24-9]"]]]], MM: ["95", "00", "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}", [6, 7, 8, 9, 10], [["(\\d)(\\d{2})(\\d{3})", "$1 $2 $3", ["16|2"], "0$1"], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["4(?:[2-46]|5[3-5])|5|6(?:[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-5]|(?:60|86)[23]"], "0$1"], ["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[12]|452|678|86", "[12]|452|6788|86"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[4-7]|8[1-35]"], "0$1"], ["(\\d)(\\d{3})(\\d{4,6})", "$1 $2 $3", ["9(?:2[0-4]|[35-9]|4[137-9])"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["92"], "0$1"], ["(\\d)(\\d{5})(\\d{4})", "$1 $2 $3", ["9"], "0$1"]], "0"], MN: ["976", "001", "[12]\\d{7,9}|[5-9]\\d{7}", [8, 9, 10], [["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["[12]1"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[5-9]"]], ["(\\d{3})(\\d{5,6})", "$1 $2", ["[12]2[1-3]"], "0$1"], ["(\\d{4})(\\d{5,6})", "$1 $2", ["[12](?:27|3[2-8]|4[2-68]|5[1-4689])", "[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"], "0$1"], ["(\\d{5})(\\d{4,5})", "$1 $2", ["[12]"], "0$1"]], "0"], MO: ["853", "00", "0800\\d{3}|(?:28|[68]\\d)\\d{6}", [7, 8], [["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[268]"]]]], MP: ["1", "011", "[58]\\d{9}|(?:67|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "670$1", 0, "670"], MQ: ["596", "00", "(?:596\\d|7091)\\d{5}|(?:69|[89]\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-79]|8(?:0[6-9]|[36])"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], MR: ["222", "00", "(?:[2-4]\\d\\d|800)\\d{5}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-48]"]]]], MS: ["1", "011", "(?:[58]\\d\\d|664|900)\\d{7}", [10], 0, "1", 0, "([34]\\d{6})$|1", "664$1", 0, "664"], MT: ["356", "00", "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[2357-9]"]]]], MU: ["230", "0(?:0|[24-7]0|3[03])", "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}", [7, 8, 10], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-46]|8[013]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[57]"]], ["(\\d{5})(\\d{5})", "$1 $2", ["8"]]], 0, 0, 0, 0, 0, 0, 0, "020"], MV: ["960", "0(?:0|19)", "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}", [7, 10], [["(\\d{3})(\\d{4})", "$1-$2", ["[34679]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], MW: ["265", "00", "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}", [7, 9], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["1[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[137-9]"], "0$1"]], "0"], MX: ["52", "0[09]", "[2-9]\\d{9}", [10], [["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["33|5[56]|81"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[2-9]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], MY: ["60", "00", "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1-$2 $3", ["[4-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1-$2 $3", ["1(?:[02469]|[378][1-9]|53)|8", "1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"], "0$1"], ["(\\d)(\\d{4})(\\d{4})", "$1-$2 $3", ["3"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{4})", "$1-$2-$3-$4", ["1(?:[367]|80)"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1-$2 $3", ["15"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4})", "$1-$2 $3", ["1"], "0$1"]], "0"], MZ: ["258", "00", "(?:2|8\\d)\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2|8[2-79]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["8"]]]], NA: ["264", "00", "[68]\\d{7,8}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["88"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["87"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0"], NC: ["687", "00", "(?:050|[2-57-9]\\d\\d)\\d{3}", [6], [["(\\d{2})(\\d{2})(\\d{2})", "$1.$2.$3", ["[02-57-9]"]]]], NE: ["227", "00", "[027-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["08"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[089]|2[013]|7[0467]"]]]], NF: ["672", "00", "[13]\\d{5}", [6], [["(\\d{2})(\\d{4})", "$1 $2", ["1[0-3]"]], ["(\\d)(\\d{5})", "$1 $2", ["[13]"]]], 0, 0, "([0-258]\\d{4})$", "3$1"], NG: ["234", "009", "(?:20|9\\d)\\d{8}|[78]\\d{9,13}", [10, 11, 12, 13, 14], [["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[7-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["20[129]"], "0$1"], ["(\\d{4})(\\d{2})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{3})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["[78]"], "0$1"], ["(\\d{3})(\\d{5})(\\d{5,6})", "$1 $2 $3", ["[78]"], "0$1"]], "0"], NI: ["505", "00", "(?:1800|[25-8]\\d{3})\\d{4}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[125-8]"]]]], NL: ["31", "00", "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}", [5, 6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{4,7})", "$1 $2", ["[89]0"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["66"], "0$1"], ["(\\d)(\\d{8})", "$1 $2", ["6"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-578]|91"], "0$1"], ["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3", ["9"], "0$1"]], "0"], NO: ["47", "00", "(?:0|[2-9]\\d{3})\\d{4}", [5, 8], [["(\\d{3})(\\d{2})(\\d{3})", "$1 $2 $3", ["8"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[2-79]"]]], 0, 0, 0, 0, 0, "[02-689]|7[0-8]"], NP: ["977", "00", "(?:1\\d|9)\\d{9}|[1-9]\\d{7}", [8, 10, 11], [["(\\d)(\\d{7})", "$1-$2", ["1[2-6]"], "0$1"], ["(\\d{2})(\\d{6})", "$1-$2", ["1[01]|[2-8]|9(?:[1-59]|[67][2-6])"], "0$1"], ["(\\d{3})(\\d{7})", "$1-$2", ["9"]]], "0"], NR: ["674", "00", "(?:222|444|(?:55|8\\d)\\d|666|777|999)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[24-9]"]]]], NU: ["683", "00", "(?:[4-7]|888\\d)\\d{3}", [4, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["8"]]]], NZ: ["64", "0(?:0|161)", "[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,8})", "$1 $2", ["8[1-79]"], "0$1"], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["50[036-8]|8|90", "50(?:[0367]|88)|8|90"], "0$1"], ["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["24|[346]|7[2-57-9]|9[2-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:10|74)|[589]"], "0$1"], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["1|2[028]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,5})", "$1 $2 $3", ["2(?:[169]|7[0-35-9])|7"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, "00"], OM: ["968", "00", "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}", [7, 8, 9], [["(\\d{3})(\\d{4,6})", "$1 $2", ["[58]"]], ["(\\d{2})(\\d{6})", "$1 $2", ["2"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[179]"]]]], PA: ["507", "00", "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}", [7, 8, 10, 11], [["(\\d{3})(\\d{4})", "$1-$2", ["[1-57-9]"]], ["(\\d{4})(\\d{4})", "$1-$2", ["[68]"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]]], PE: ["51", "00|19(?:1[124]|77|90)00", "(?:[14-8]|9\\d)\\d{7}", [8, 9], [["(\\d{3})(\\d{5})", "$1 $2", ["80"], "(0$1)"], ["(\\d)(\\d{7})", "$1 $2", ["1"], "(0$1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[4-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"]]], "0", 0, 0, 0, 0, 0, 0, "00", " Anexo "], PF: ["689", "00", "4\\d{5}(?:\\d{2})?|8\\d{7,8}", [6, 8, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["44"]], ["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["4|8[7-9]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]]], PG: ["675", "00|140[1-3]", "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["18|[2-69]|85"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[78]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], PH: ["63", "00", "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}", [6, 8, 9, 10, 11, 12, 13], [["(\\d)(\\d{5})", "$1 $2", ["2"], "(0$1)"], ["(\\d{4})(\\d{4,6})", "$1 $2", ["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2", "3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"], "(0$1)"], ["(\\d{5})(\\d{4})", "$1 $2", ["346|4(?:27|9[35])|883", "3469|4(?:279|9(?:30|56))|8834"], "(0$1)"], ["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["2"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|8[2-8]"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]], ["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})", "$1 $2 $3 $4", ["1"]]], "0"], PK: ["92", "00", "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,7})", "$1 $2 $3", ["[89]0"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["1"]], ["(\\d{3})(\\d{6,7})", "$1 $2", ["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])", "9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"], "(0$1)"], ["(\\d{2})(\\d{7,8})", "$1 $2", ["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"], "(0$1)"], ["(\\d{5})(\\d{5})", "$1 $2", ["58"], "(0$1)"], ["(\\d{3})(\\d{7})", "$1 $2", ["3"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"], "(0$1)"], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[24-9]"], "(0$1)"]], "0"], PL: ["48", "00", "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}", [6, 7, 8, 9, 10], [["(\\d{5})", "$1", ["19"]], ["(\\d{3})(\\d{3})", "$1 $2", ["11|20|64"]], ["(\\d{2})(\\d{2})(\\d{3})", "$1 $2 $3", ["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1", "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]], ["(\\d{3})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["64"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["1[2-8]|[2-7]|8[1-79]|9[145]"]], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["8"]]]], PM: ["508", "00", "[45]\\d{5}|(?:708|8\\d\\d)\\d{6}", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[45]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"], "0$1"]], "0"], PR: ["1", "011", "(?:[589]\\d\\d|787)\\d{7}", [10], 0, "1", 0, 0, 0, 0, "787|939"], PS: ["970", "00", "[2489]2\\d{6}|(?:1\\d|5)\\d{8}", [8, 9, 10], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["[2489]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], PT: ["351", "00", "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["2[12]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["16|[236-9]"]]]], PW: ["680", "01[12]", "(?:[24-8]\\d\\d|345|900)\\d{4}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-9]"]]]], PY: ["595", "00", "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}", [6, 7, 8, 9, 10, 11], [["(\\d{3})(\\d{3,6})", "$1 $2", ["[2-9]0"], "0$1"], ["(\\d{2})(\\d{5})", "$1 $2", ["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"], "(0$1)"], ["(\\d{3})(\\d{4,5})", "$1 $2", ["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["87"]], ["(\\d{3})(\\d{6})", "$1 $2", ["9(?:[5-79]|8[1-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-8]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["9"]]], "0"], QA: ["974", "00", "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}", [7, 8, 9, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["2[136]|8"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[3-7]"]]]], RE: ["262", "00", "709\\d{6}|(?:26|[689]\\d)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[26-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, [["26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"], ["(?:69(?:2\\d\\d|3(?:[06][0-6]|1[0-3]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))|7092[0-3])\\d{4}"], ["80\\d{7}"], ["89[1-37-9]\\d{6}"], 0, 0, 0, 0, ["9(?:399[0-3]|479[0-6]|76(?:2[278]|3[0-37]))\\d{4}"], ["8(?:1[019]|2[0156]|84|90)\\d{6}"]]], RO: ["40", "00", "(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}", [6, 9], [["(\\d{3})(\\d{3})", "$1 $2", ["2[3-6]", "2[3-6]\\d9"], "0$1"], ["(\\d{2})(\\d{4})", "$1 $2", ["219|31"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[23]1"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[236-9]"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, 0, " int "], RS: ["381", "00", "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}", [6, 7, 8, 9, 10, 11, 12], [["(\\d{3})(\\d{3,9})", "$1 $2", ["(?:2[389]|39)0|[7-9]"], "0$1"], ["(\\d{2})(\\d{5,10})", "$1 $2", ["[1-36]"], "0$1"]], "0"], RU: ["7", "810", "8\\d{13}|[347-9]\\d{9}", [10, 14], [["(\\d{4})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-8]|2[1-9])", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))", "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"], "8 ($1)", 1], ["(\\d{5})(\\d)(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["7(?:1[0-68]|2[1-9])", "7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))", "7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "8 ($1)", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[349]|8(?:[02-7]|1[1-8])"], "8 ($1)", 1], ["(\\d{4})(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["8"], "8 ($1)"]], "8", 0, 0, 0, 0, 0, [["336(?:[013-9]\\d|2[013-9])\\d{5}|(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15-7]|6[0-35-79]|7[1-37-9]))\\d{7}", [10]], ["9\\d{9}", [10]], ["8(?:0[04]|108\\d{3})\\d{7}"], ["80[39]\\d{7}", [10]], ["808\\d{7}", [10]]], "8~10"], RW: ["250", "00", "(?:06|[27]\\d\\d|[89]00)\\d{6}", [8, 9], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[7-9]"], "0$1"]], "0"], SA: ["966", "00", "(?:[15]\\d|800|92)\\d{7}", [9, 10], [["(\\d{4})(\\d{5})", "$1 $2", ["9"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["5"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]]], "0"], SB: ["677", "0[01]", "[6-9]\\d{6}|[1-6]\\d{4}", [5, 7], [["(\\d{2})(\\d{5})", "$1 $2", ["6[89]|7|8[4-9]|9(?:[1-8]|9[0-8])"]]]], SC: ["248", "010|0[0-2]", "(?:[2489]\\d|64)\\d{5}", [7], [["(\\d)(\\d{3})(\\d{3})", "$1 $2 $3", ["[246]|9[57]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], SD: ["249", "00", "[19]\\d{8}", [9], [["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[19]"], "0$1"]], "0"], SE: ["46", "00", "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}", [6, 7, 8, 9, 10, 12], [["(\\d{2})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["20"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{4})", "$1-$2", ["9(?:00|39|44|9)"], "0$1", 0, "$1 $2"], ["(\\d{2})(\\d{3})(\\d{2})", "$1-$2 $3", ["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3"], ["(\\d)(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2,3})(\\d{2})", "$1-$2 $3", ["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3"], ["(\\d{3})(\\d{2,3})(\\d{3})", "$1-$2 $3", ["9(?:00|39|44)"], "0$1", 0, "$1 $2 $3"], ["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["10|7"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1-$2 $3 $4", ["8"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1-$2 $3 $4", ["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{2})(\\d{3})", "$1-$2 $3 $4", ["9"], "0$1", 0, "$1 $2 $3 $4"], ["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1-$2 $3 $4 $5", ["[26]"], "0$1", 0, "$1 $2 $3 $4 $5"]], "0"], SG: ["65", "0[0-3]\\d", "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}", [8, 10, 11], [["(\\d{4})(\\d{4})", "$1 $2", ["[369]|8(?:0[1-9]|[1-9])"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"]], ["(\\d{4})(\\d{4})(\\d{3})", "$1 $2 $3", ["7"]], ["(\\d{4})(\\d{3})(\\d{4})", "$1 $2 $3", ["1"]]]], SH: ["290", "00", "(?:[256]\\d|8)\\d{3}", [4, 5], 0, 0, 0, 0, 0, 0, "[256]"], SI: ["386", "00|10(?:22|66|88|99)", "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}", [5, 6, 7, 8], [["(\\d{2})(\\d{3,6})", "$1 $2", ["8[09]|9"], "0$1"], ["(\\d{3})(\\d{5})", "$1 $2", ["59|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[37][01]|4[0139]|51|6"], "0$1"], ["(\\d)(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[1-57]"], "(0$1)"]], "0", 0, 0, 0, 0, 0, 0, "00"], SJ: ["47", "00", "0\\d{4}|(?:[489]\\d|79)\\d{6}", [5, 8], 0, 0, 0, 0, 0, 0, "79"], SK: ["421", "00", "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}", [6, 7, 9], [["(\\d)(\\d{2})(\\d{3,4})", "$1 $2 $3", ["21"], "0$1"], ["(\\d{2})(\\d{2})(\\d{2,3})", "$1 $2 $3", ["[3-5][1-8]1", "[3-5][1-8]1[67]"], "0$1"], ["(\\d)(\\d{3})(\\d{3})(\\d{2})", "$1/$2 $3 $4", ["2"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[689]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1/$2 $3 $4", ["[3-5]"], "0$1"]], "0"], SL: ["232", "00", "(?:[237-9]\\d|66)\\d{6}", [8], [["(\\d{2})(\\d{6})", "$1 $2", ["[236-9]"], "(0$1)"]], "0"], SM: ["378", "00", "(?:0549|[5-7]\\d)\\d{6}", [8, 10], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[5-7]"]], ["(\\d{4})(\\d{6})", "$1 $2", ["0"]]], 0, 0, "([89]\\d{5})$", "0549$1"], SN: ["221", "00", "(?:[378]\\d|93)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[379]"]]]], SO: ["252", "00", "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}", [6, 7, 8, 9], [["(\\d{2})(\\d{4})", "$1 $2", ["8[125]"]], ["(\\d{6})", "$1", ["[134]"]], ["(\\d)(\\d{6})", "$1 $2", ["[15]|2[0-79]|3[0-46-8]|4[0-7]"]], ["(\\d)(\\d{7})", "$1 $2", ["(?:2|90)4|[67]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[348]|64|79|90"]], ["(\\d{2})(\\d{5,7})", "$1 $2", ["1|28|6[0-35-9]|7[67]|9[2-9]"]]], "0"], SR: ["597", "00", "(?:[2-5]|[6-8]\\d|90)\\d{5}", [6, 7], [["(\\d{2})(\\d{2})(\\d{2})", "$1-$2-$3", ["56"]], ["(\\d{3})(\\d{3})", "$1-$2", ["[2-5]"]], ["(\\d{3})(\\d{4})", "$1-$2", ["[6-9]"]]]], SS: ["211", "00", "[19]\\d{8}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[19]"], "0$1"]], "0"], ST: ["239", "00", "(?:22|9\\d)\\d{5}", [7], [["(\\d{3})(\\d{4})", "$1 $2", ["[29]"]]]], SV: ["503", "00", "[25-7]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?", [7, 8, 11], [["(\\d{3})(\\d{4})", "$1 $2", ["[89]"]], ["(\\d{4})(\\d{4})", "$1 $2", ["[25-7]"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["[89]"]]]], SX: ["1", "011", "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "(5\\d{6})$|1", "721$1", 0, "721"], SY: ["963", "00", "[1-359]\\d{8}|[1-5]\\d{7}", [8, 9], [["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-4]|5[1-3]"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[59]"], "0$1", 1]], "0"], SZ: ["268", "00", "0800\\d{4}|(?:[237]\\d|900)\\d{6}", [8, 9], [["(\\d{4})(\\d{4})", "$1 $2", ["[0237]"]], ["(\\d{5})(\\d{4})", "$1 $2", ["9"]]]], TA: ["290", "00", "8\\d{3}", [4], 0, 0, 0, 0, 0, 0, "8"], TC: ["1", "011", "(?:[58]\\d\\d|649|900)\\d{7}", [10], 0, "1", 0, "([2-479]\\d{6})$|1", "649$1", 0, "649"], TD: ["235", "00|16", "(?:22|30|[689]\\d|77)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[236-9]"]]], 0, 0, 0, 0, 0, 0, 0, "00"], TG: ["228", "00", "[279]\\d{7}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[279]"]]]], TH: ["66", "00[1-9]", "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}", [8, 9, 10, 13], [["(\\d)(\\d{3})(\\d{4})", "$1 $2 $3", ["2"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[13-9]"], "0$1"], ["(\\d{4})(\\d{3})(\\d{3})", "$1 $2 $3", ["1"]]], "0"], TJ: ["992", "810", "(?:[0-57-9]\\d|66)\\d{7}", [9], [["(\\d{6})(\\d)(\\d{2})", "$1 $2 $3", ["331", "3317"]], ["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["44[02-479]|[34]7"]], ["(\\d{4})(\\d)(\\d{4})", "$1 $2 $3", ["3(?:[1245]|3[12])"]], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["\\d"]]], 0, 0, 0, 0, 0, 0, 0, "8~10"], TK: ["690", "00", "[2-47]\\d{3,6}", [4, 5, 6, 7]], TL: ["670", "00", "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}", [7, 8], [["(\\d{3})(\\d{4})", "$1 $2", ["[2-489]|70"]], ["(\\d{4})(\\d{4})", "$1 $2", ["7"]]]], TM: ["993", "810", "(?:[1-6]\\d|71)\\d{6}", [8], [["(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["12"], "(8 $1)"], ["(\\d{3})(\\d)(\\d{2})(\\d{2})", "$1 $2-$3-$4", ["[1-5]"], "(8 $1)"], ["(\\d{2})(\\d{6})", "$1 $2", ["[67]"], "8 $1"]], "8", 0, 0, 0, 0, 0, 0, "8~10"], TN: ["216", "00", "[2-57-9]\\d{7}", [8], [["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-57-9]"]]]], TO: ["676", "00", "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}", [5, 7], [["(\\d{2})(\\d{3})", "$1-$2", ["[2-4]|50|6[09]|7[0-24-69]|8[05]"]], ["(\\d{4})(\\d{3})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[5-9]"]]]], TR: ["90", "00", "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}", [7, 10, 12, 13], [["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["512|8[01589]|90"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["5(?:[0-59]|61)", "5(?:[0-59]|61[06])", "5(?:[0-59]|61[06]1)"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[24][1-8]|3[1-9]"], "(0$1)", 1], ["(\\d{3})(\\d{3})(\\d{6,7})", "$1 $2 $3", ["80"], "0$1", 1]], "0"], TT: ["1", "011", "(?:[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-46-8]\\d{6})$|1", "868$1", 0, "868"], TV: ["688", "00", "(?:2|7\\d\\d|90)\\d{4}", [5, 6, 7], [["(\\d{2})(\\d{3})", "$1 $2", ["2"]], ["(\\d{2})(\\d{4})", "$1 $2", ["90"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]]], TW: ["886", "0(?:0[25-79]|19)", "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}", [7, 8, 9, 10, 11], [["(\\d{2})(\\d)(\\d{4})", "$1 $2 $3", ["202"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[258]0"], "0$1"], ["(\\d)(\\d{3,4})(\\d{4})", "$1 $2 $3", ["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]", "[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{2})(\\d{4})(\\d{4,5})", "$1 $2 $3", ["7"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, 0, "#"], TZ: ["255", "00[056]", "(?:[25-8]\\d|41|90)\\d{7}", [9], [["(\\d{3})(\\d{2})(\\d{4})", "$1 $2 $3", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[24]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["5"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[67]"], "0$1"]], "0"], UA: ["380", "00", "[89]\\d{9}|[3-9]\\d{8}", [9, 10], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]", "6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"], "0$1"], ["(\\d{4})(\\d{5})", "$1 $2", ["3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])", "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[3-7]|89|9[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[89]"], "0$1"]], "0", 0, 0, 0, 0, 0, 0, "0~0"], UG: ["256", "00[057]", "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}", [9], [["(\\d{4})(\\d{5})", "$1 $2", ["202", "2024"], "0$1"], ["(\\d{3})(\\d{6})", "$1 $2", ["[27-9]|4(?:6[45]|[7-9])"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[34]"], "0$1"]], "0"], US: ["1", "011", "[2-9]\\d{9}|3\\d{6}", [10], [["(\\d{3})(\\d{4})", "$1-$2", ["310"], 0, 1], ["(\\d{3})(\\d{3})(\\d{4})", "($1) $2-$3", ["[2-9]"], 0, 1, "$1-$2-$3"]], "1", 0, 0, 0, 0, 0, [["3052(?:0[0-8]|[1-9]\\d)\\d{4}|(?:2742|305[3-9])\\d{6}|(?:472|983)[2-47-9]\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-47-9]|1[02-9]|2[013-79]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-269])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[0-247]|4[0378]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[0168]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-3589]|8[04-69]))[2-9]\\d{6}"], [""], ["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"], ["900[2-9]\\d{6}"], ["52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"], 0, 0, 0, ["305209\\d{4}"]]], UY: ["598", "0(?:0|1[3-9]\\d)", "0004\\d{2,9}|[1249]\\d{7}|2\\d{3,4}|(?:[49]\\d|80)\\d{5}", [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [["(\\d{4,5})", "$1", ["21"]], ["(\\d{3})(\\d{3,4})", "$1 $2", ["0"]], ["(\\d{3})(\\d{4})", "$1 $2", ["[49]0|8"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["9"], "0$1"], ["(\\d{4})(\\d{4})", "$1 $2", ["[124]"]], ["(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3", ["0"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})", "$1 $2 $3 $4", ["0"]]], "0", 0, 0, 0, 0, 0, 0, "00", " int. "], UZ: ["998", "00", "(?:20|33|[5-9]\\d)\\d{7}", [9], [["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["[235-9]"]]]], VA: ["39", "00", "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}", [6, 7, 8, 9, 10, 11, 12], 0, 0, 0, 0, 0, 0, "06698"], VC: ["1", "011", "(?:[58]\\d\\d|784|900)\\d{7}", [10], 0, "1", 0, "([2-7]\\d{6})$|1", "784$1", 0, "784"], VE: ["58", "00", "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}", [10], [["(\\d{3})(\\d{7})", "$1-$2", ["[24-689]"], "0$1"]], "0"], VG: ["1", "011", "(?:284|[58]\\d\\d|900)\\d{7}", [10], 0, "1", 0, "([2-578]\\d{6})$|1", "284$1", 0, "284"], VI: ["1", "011", "[58]\\d{9}|(?:34|90)0\\d{7}", [10], 0, "1", 0, "([2-9]\\d{6})$|1", "340$1", 0, "340"], VN: ["84", "00", "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}", [7, 8, 9, 10], [["(\\d{2})(\\d{5})", "$1 $2", ["80"], "0$1", 1], ["(\\d{4})(\\d{4,6})", "$1 $2", ["1"], 0, 1], ["(\\d{2})(\\d{3})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["6"], "0$1", 1], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[357-9]"], "0$1", 1], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["2[48]"], "0$1", 1], ["(\\d{3})(\\d{4})(\\d{3})", "$1 $2 $3", ["2"], "0$1", 1]], "0"], VU: ["678", "00", "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}", [5, 7], [["(\\d{3})(\\d{4})", "$1 $2", ["[57-9]"]]]], WF: ["681", "00", "(?:40|72|8\\d{4})\\d{4}|[89]\\d{5}", [6, 9], [["(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3", ["[47-9]"]], ["(\\d{3})(\\d{2})(\\d{2})(\\d{2})", "$1 $2 $3 $4", ["8"]]]], WS: ["685", "0", "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}", [5, 6, 7, 10], [["(\\d{5})", "$1", ["[2-5]|6[1-9]"]], ["(\\d{3})(\\d{3,7})", "$1 $2", ["[68]"]], ["(\\d{2})(\\d{5})", "$1 $2", ["7"]]]], XK: ["383", "00", "2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{5})", "$1 $2", ["[89]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3})", "$1 $2 $3", ["[2-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["2|39"], "0$1"], ["(\\d{2})(\\d{7,10})", "$1 $2", ["3"], "0$1"]], "0"], YE: ["967", "00", "(?:1|7\\d)\\d{7}|[1-7]\\d{6}", [7, 8, 9], [["(\\d)(\\d{3})(\\d{3,4})", "$1 $2 $3", ["[1-6]|7(?:[24-6]|8[0-7])"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["7"], "0$1"]], "0"], YT: ["262", "00", "7093\\d{5}|(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}", [9], 0, "0", 0, 0, 0, 0, 0, [["269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"], ["(?:639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])|7093[5-7])\\d{4}"], ["80\\d{7}"], 0, 0, 0, 0, 0, ["9(?:(?:39|47)8[01]|769\\d)\\d{4}"]]], ZA: ["27", "00", "[1-79]\\d{8}|8\\d{4,9}", [5, 6, 7, 8, 9, 10], [["(\\d{2})(\\d{3,4})", "$1 $2", ["8[1-4]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{2,3})", "$1 $2 $3", ["8[1-4]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["860"], "0$1"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["[1-9]"], "0$1"], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["8"], "0$1"]], "0"], ZM: ["260", "00", "800\\d{6}|(?:21|[579]\\d|63)\\d{7}", [9], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[28]"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["[579]"], "0$1"]], "0"], ZW: ["263", "00", "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}", [5, 6, 7, 8, 9, 10], [["(\\d{3})(\\d{3,5})", "$1 $2", ["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"], "0$1"], ["(\\d)(\\d{3})(\\d{2,4})", "$1 $2 $3", ["[49]"], "0$1"], ["(\\d{3})(\\d{4})", "$1 $2", ["80"], "0$1"], ["(\\d{2})(\\d{7})", "$1 $2", ["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2", "2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"], "(0$1)"], ["(\\d{2})(\\d{3})(\\d{4})", "$1 $2 $3", ["7"], "0$1"], ["(\\d{3})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)", "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"], "0$1"], ["(\\d{4})(\\d{6})", "$1 $2", ["8"], "0$1"], ["(\\d{2})(\\d{3,5})", "$1 $2", ["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"], "0$1"], ["(\\d{2})(\\d{3})(\\d{3,4})", "$1 $2 $3", ["29[013-9]|39|54"], "0$1"], ["(\\d{4})(\\d{3,5})", "$1 $2", ["(?:25|54)8", "258|5483"], "0$1"]], "0"] }, nonGeographic: { 800: ["800", 0, "(?:00|[1-9]\\d)\\d{6}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["\\d"]]], 0, 0, 0, 0, 0, 0, [0, 0, ["(?:00|[1-9]\\d)\\d{6}"]]], 808: ["808", 0, "[1-9]\\d{7}", [8], [["(\\d{4})(\\d{4})", "$1 $2", ["[1-9]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, ["[1-9]\\d{7}"]]], 870: ["870", 0, "7\\d{11}|[235-7]\\d{8}", [9, 12], [["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["[235-7]"]]], 0, 0, 0, 0, 0, 0, [0, ["(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"], 0, 0, 0, 0, 0, 0, ["2\\d{8}", [9]]]], 878: ["878", 0, "10\\d{10}", [12], [["(\\d{2})(\\d{5})(\\d{5})", "$1 $2 $3", ["1"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["10\\d{10}"]]], 881: ["881", 0, "6\\d{9}|[0-36-9]\\d{8}", [9, 10], [["(\\d)(\\d{3})(\\d{5})", "$1 $2 $3", ["[0-37-9]"]], ["(\\d)(\\d{3})(\\d{5,6})", "$1 $2 $3", ["6"]]], 0, 0, 0, 0, 0, 0, [0, ["6\\d{9}|[0-36-9]\\d{8}"]]], 882: ["882", 0, "[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?", [7, 8, 9, 10, 11, 12], [["(\\d{2})(\\d{5})", "$1 $2", ["16|342"]], ["(\\d{2})(\\d{6})", "$1 $2", ["49"]], ["(\\d{2})(\\d{2})(\\d{4})", "$1 $2 $3", ["1[36]|9"]], ["(\\d{2})(\\d{4})(\\d{3})", "$1 $2 $3", ["3[23]"]], ["(\\d{2})(\\d{3,4})(\\d{4})", "$1 $2 $3", ["16"]], ["(\\d{2})(\\d{4})(\\d{4})", "$1 $2 $3", ["10|23|3(?:[15]|4[57])|4|51"]], ["(\\d{3})(\\d{4})(\\d{4})", "$1 $2 $3", ["34"]], ["(\\d{2})(\\d{4,5})(\\d{5})", "$1 $2 $3", ["[1-35]"]]], 0, 0, 0, 0, 0, 0, [0, ["342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}", [7, 8, 9, 10, 12]], 0, 0, 0, ["348[57]\\d{7}", [11]], 0, 0, ["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"]]], 883: ["883", 0, "(?:[1-4]\\d|51)\\d{6,10}", [8, 9, 10, 11, 12], [["(\\d{3})(\\d{3})(\\d{2,8})", "$1 $2 $3", ["[14]|2[24-689]|3[02-689]|51[24-9]"]], ["(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3", ["510"]], ["(\\d{3})(\\d{3})(\\d{4})", "$1 $2 $3", ["21"]], ["(\\d{4})(\\d{4})(\\d{4})", "$1 $2 $3", ["51[13]"]], ["(\\d{3})(\\d{3})(\\d{3})(\\d{3})", "$1 $2 $3 $4", ["[235]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, 0, 0, ["(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"]]], 888: ["888", 0, "\\d{11}", [11], [["(\\d{3})(\\d{3})(\\d{5})", "$1 $2 $3"]], 0, 0, 0, 0, 0, 0, [0, 0, 0, 0, 0, 0, ["\\d{11}"]]], 979: ["979", 0, "[1359]\\d{8}", [9], [["(\\d)(\\d{4})(\\d{4})", "$1 $2 $3", ["[1359]"]]], 0, 0, 0, 0, 0, 0, [0, 0, 0, ["[1359]\\d{8}"]]] } };
function Z$(t, e) {
  var r = Array.prototype.slice.call(e);
  return r.push(X$), t.apply(this, r);
}
function zu(t, e) {
  t = t.split("-"), e = e.split("-");
  for (var r = t[0].split("."), n = e[0].split("."), o = 0; o < 3; o++) {
    var s = Number(r[o]), i = Number(n[o]);
    if (s > i) return 1;
    if (i > s) return -1;
    if (!isNaN(s) && isNaN(i)) return 1;
    if (isNaN(s) && !isNaN(i)) return -1;
  }
  return t[1] && e[1] ? t[1] > e[1] ? 1 : t[1] < e[1] ? -1 : 0 : !t[1] && e[1] ? 1 : t[1] && !e[1] ? -1 : 0;
}
var Q$ = {}.constructor;
function Zn(t) {
  return t != null && t.constructor === Q$;
}
function oo(t) {
  "@babel/helpers - typeof";
  return oo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, oo(t);
}
function sa(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function e3(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, t3(n.key), n);
  }
}
function ia(t, e, r) {
  return e && e3(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function t3(t) {
  var e = r3(t, "string");
  return oo(e) == "symbol" ? e : e + "";
}
function r3(t, e) {
  if (oo(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (oo(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var n3 = "1.2.0", o3 = "1.7.35", Hu = " ext. ", s3 = /^\d+$/, St = /* @__PURE__ */ function() {
  function t(e) {
    sa(this, t), Rm(e), this.metadata = e, Om.call(this, e);
  }
  return ia(t, [{
    key: "getCountries",
    value: function() {
      return Object.keys(this.metadata.countries).filter(function(r) {
        return r !== "001";
      });
    }
  }, {
    key: "getCountryMetadata",
    value: function(r) {
      return this.metadata.countries[r];
    }
  }, {
    key: "nonGeographic",
    value: function() {
      if (!(this.v1 || this.v2 || this.v3))
        return this.metadata.nonGeographic || this.metadata.nonGeographical;
    }
  }, {
    key: "hasCountry",
    value: function(r) {
      return this.getCountryMetadata(r) !== void 0;
    }
  }, {
    key: "hasCallingCode",
    value: function(r) {
      if (this.getCountryCodesForCallingCode(r))
        return !0;
      if (this.nonGeographic()) {
        if (this.nonGeographic()[r])
          return !0;
      } else {
        var n = this.countryCallingCodes()[r];
        if (n && n.length === 1 && n[0] === "001")
          return !0;
      }
    }
  }, {
    key: "isNonGeographicCallingCode",
    value: function(r) {
      return this.nonGeographic() ? !!this.nonGeographic()[r] : !this.getCountryCodesForCallingCode(r);
    }
    // Deprecated.
  }, {
    key: "country",
    value: function(r) {
      return this.selectNumberingPlan(r);
    }
  }, {
    key: "selectNumberingPlan",
    value: function(r, n) {
      if (r && s3.test(r) && (n = r, r = null), r && r !== "001") {
        if (!this.hasCountry(r))
          throw new Error("Unknown country: ".concat(r));
        this.numberingPlan = new Bu(this.getCountryMetadata(r), this);
      } else if (n) {
        if (!this.hasCallingCode(n))
          throw new Error("Unknown calling code: ".concat(n));
        this.numberingPlan = new Bu(this.getNumberingPlanMetadata(n), this);
      } else
        this.numberingPlan = void 0;
      return this;
    }
  }, {
    key: "getCountryCodesForCallingCode",
    value: function(r) {
      var n = this.countryCallingCodes()[r];
      if (n)
        return n.length === 1 && n[0].length === 3 ? void 0 : n;
    }
  }, {
    key: "getCountryCodeForCallingCode",
    value: function(r) {
      var n = this.getCountryCodesForCallingCode(r);
      if (n)
        return n[0];
    }
  }, {
    key: "getNumberingPlanMetadata",
    value: function(r) {
      var n = this.getCountryCodeForCallingCode(r);
      if (n)
        return this.getCountryMetadata(n);
      if (this.nonGeographic()) {
        var o = this.nonGeographic()[r];
        if (o)
          return o;
      } else {
        var s = this.countryCallingCodes()[r];
        if (s && s.length === 1 && s[0] === "001")
          return this.metadata.countries["001"];
      }
    }
    // Deprecated.
  }, {
    key: "countryCallingCode",
    value: function() {
      return this.numberingPlan.callingCode();
    }
    // Deprecated.
  }, {
    key: "IDDPrefix",
    value: function() {
      return this.numberingPlan.IDDPrefix();
    }
    // Deprecated.
  }, {
    key: "defaultIDDPrefix",
    value: function() {
      return this.numberingPlan.defaultIDDPrefix();
    }
    // Deprecated.
  }, {
    key: "nationalNumberPattern",
    value: function() {
      return this.numberingPlan.nationalNumberPattern();
    }
    // Deprecated.
  }, {
    key: "possibleLengths",
    value: function() {
      return this.numberingPlan.possibleLengths();
    }
    // Deprecated.
  }, {
    key: "formats",
    value: function() {
      return this.numberingPlan.formats();
    }
    // Deprecated.
  }, {
    key: "nationalPrefixForParsing",
    value: function() {
      return this.numberingPlan.nationalPrefixForParsing();
    }
    // Deprecated.
  }, {
    key: "nationalPrefixTransformRule",
    value: function() {
      return this.numberingPlan.nationalPrefixTransformRule();
    }
    // Deprecated.
  }, {
    key: "leadingDigits",
    value: function() {
      return this.numberingPlan.leadingDigits();
    }
    // Deprecated.
  }, {
    key: "hasTypes",
    value: function() {
      return this.numberingPlan.hasTypes();
    }
    // Deprecated.
  }, {
    key: "type",
    value: function(r) {
      return this.numberingPlan.type(r);
    }
    // Deprecated.
  }, {
    key: "ext",
    value: function() {
      return this.numberingPlan.ext();
    }
  }, {
    key: "countryCallingCodes",
    value: function() {
      return this.v1 ? this.metadata.country_phone_code_to_countries : this.metadata.country_calling_codes;
    }
    // Deprecated.
  }, {
    key: "chooseCountryByCountryCallingCode",
    value: function(r) {
      return this.selectNumberingPlan(r);
    }
  }, {
    key: "hasSelectedNumberingPlan",
    value: function() {
      return this.numberingPlan !== void 0;
    }
  }]);
}(), Bu = /* @__PURE__ */ function() {
  function t(e, r) {
    sa(this, t), this.globalMetadataObject = r, this.metadata = e, Om.call(this, r.metadata);
  }
  return ia(t, [{
    key: "callingCode",
    value: function() {
      return this.metadata[0];
    }
    // Formatting information for regions which share
    // a country calling code is contained by only one region
    // for performance reasons. For example, for NANPA region
    // ("North American Numbering Plan Administration",
    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
    // it will be contained in the metadata for `US`.
  }, {
    key: "getDefaultCountryMetadataForRegion",
    value: function() {
      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
    }
    // Is always present.
  }, {
    key: "IDDPrefix",
    value: function() {
      if (!(this.v1 || this.v2))
        return this.metadata[1];
    }
    // Is only present when a country supports multiple IDD prefixes.
  }, {
    key: "defaultIDDPrefix",
    value: function() {
      if (!(this.v1 || this.v2))
        return this.metadata[12];
    }
  }, {
    key: "nationalNumberPattern",
    value: function() {
      return this.v1 || this.v2 ? this.metadata[1] : this.metadata[2];
    }
    // "possible length" data is always present in Google's metadata.
  }, {
    key: "possibleLengths",
    value: function() {
      if (!this.v1)
        return this.metadata[this.v2 ? 2 : 3];
    }
  }, {
    key: "_getFormats",
    value: function(r) {
      return r[this.v1 ? 2 : this.v2 ? 3 : 4];
    }
    // For countries of the same region (e.g. NANPA)
    // formats are all stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "formats",
    value: function() {
      var r = this, n = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
      return n.map(function(o) {
        return new i3(o, r);
      });
    }
  }, {
    key: "nationalPrefix",
    value: function() {
      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
    }
  }, {
    key: "_getNationalPrefixFormattingRule",
    value: function(r) {
      return r[this.v1 ? 4 : this.v2 ? 5 : 6];
    }
    // For countries of the same region (e.g. NANPA)
    // national prefix formatting rule is stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "nationalPrefixFormattingRule",
    value: function() {
      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "_nationalPrefixForParsing",
    value: function() {
      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
    }
  }, {
    key: "nationalPrefixForParsing",
    value: function() {
      return this._nationalPrefixForParsing() || this.nationalPrefix();
    }
  }, {
    key: "nationalPrefixTransformRule",
    value: function() {
      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
    }
  }, {
    key: "_getNationalPrefixIsOptionalWhenFormatting",
    value: function() {
      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
    }
    // For countries of the same region (e.g. NANPA)
    // "national prefix is optional when formatting" flag is
    // stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function() {
      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "leadingDigits",
    value: function() {
      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
    }
  }, {
    key: "types",
    value: function() {
      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
    }
  }, {
    key: "hasTypes",
    value: function() {
      return this.types() && this.types().length === 0 ? !1 : !!this.types();
    }
  }, {
    key: "type",
    value: function(r) {
      if (this.hasTypes() && Vu(this.types(), r))
        return new l3(Vu(this.types(), r), this);
    }
  }, {
    key: "ext",
    value: function() {
      return this.v1 || this.v2 ? Hu : this.metadata[13] || Hu;
    }
  }]);
}(), i3 = /* @__PURE__ */ function() {
  function t(e, r) {
    sa(this, t), this._format = e, this.metadata = r;
  }
  return ia(t, [{
    key: "pattern",
    value: function() {
      return this._format[0];
    }
  }, {
    key: "format",
    value: function() {
      return this._format[1];
    }
  }, {
    key: "leadingDigitsPatterns",
    value: function() {
      return this._format[2] || [];
    }
  }, {
    key: "nationalPrefixFormattingRule",
    value: function() {
      return this._format[3] || this.metadata.nationalPrefixFormattingRule();
    }
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function() {
      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
  }, {
    key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
    value: function() {
      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
    // Checks whether national prefix formatting rule contains national prefix.
  }, {
    key: "usesNationalPrefix",
    value: function() {
      return !!(this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
      !a3.test(this.nationalPrefixFormattingRule()));
    }
  }, {
    key: "internationalFormat",
    value: function() {
      return this._format[5] || this.format();
    }
  }]);
}(), a3 = /^\(?\$1\)?$/, l3 = /* @__PURE__ */ function() {
  function t(e, r) {
    sa(this, t), this.type = e, this.metadata = r;
  }
  return ia(t, [{
    key: "pattern",
    value: function() {
      return this.metadata.v1 ? this.type : this.type[0];
    }
  }, {
    key: "possibleLengths",
    value: function() {
      if (!this.metadata.v1)
        return this.type[1] || this.metadata.possibleLengths();
    }
  }]);
}();
function Vu(t, e) {
  switch (e) {
    case "FIXED_LINE":
      return t[0];
    case "MOBILE":
      return t[1];
    case "TOLL_FREE":
      return t[2];
    case "PREMIUM_RATE":
      return t[3];
    case "PERSONAL_NUMBER":
      return t[4];
    case "VOICEMAIL":
      return t[5];
    case "UAN":
      return t[6];
    case "PAGER":
      return t[7];
    case "VOIP":
      return t[8];
    case "SHARED_COST":
      return t[9];
  }
}
function Rm(t) {
  if (!t)
    throw new Error("[libphonenumber-js] `metadata` argument not passed. Check your arguments.");
  if (!Zn(t) || !Zn(t.countries))
    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(Zn(t) ? "an object of shape: { " + Object.keys(t).join(", ") + " }" : "a " + d3(t) + ": " + t, "."));
}
var d3 = function(e) {
  return oo(e);
};
function Fd(t, e) {
  if (e = new St(e), e.hasCountry(t))
    return e.selectNumberingPlan(t).countryCallingCode();
  throw new Error("Unknown country: ".concat(t));
}
function c3(t, e) {
  return e.countries.hasOwnProperty(t);
}
function Om(t) {
  var e = t.version;
  typeof e == "number" ? (this.v1 = e === 1, this.v2 = e === 2, this.v3 = e === 3, this.v4 = e === 4) : e ? zu(e, n3) === -1 ? this.v2 = !0 : zu(e, o3) === -1 ? this.v3 = !0 : this.v4 = !0 : this.v1 = !0;
}
function zd(t, e, r) {
  return u3(t, e, void 0, r);
}
function u3(t, e, r, n) {
  e && (n = new St(n.metadata), n.selectNumberingPlan(e));
  var o = n.type(r), s = o && o.possibleLengths() || n.possibleLengths();
  if (!s)
    return "IS_POSSIBLE";
  var i = t.length, a = s[0];
  return a === i ? "IS_POSSIBLE" : a > i ? "TOO_SHORT" : s[s.length - 1] < i ? "TOO_LONG" : s.indexOf(i, 1) >= 0 ? "IS_POSSIBLE" : "INVALID_LENGTH";
}
function f3(t, e, r) {
  if (e === void 0 && (e = {}), r = new St(r), e.v2) {
    if (!t.countryCallingCode)
      throw new Error("Invalid phone number object passed");
    r.selectNumberingPlan(t.countryCallingCode);
  } else {
    if (!t.phone)
      return !1;
    if (t.country) {
      if (!r.hasCountry(t.country))
        throw new Error("Unknown country: ".concat(t.country));
      r.selectNumberingPlan(t.country);
    } else {
      if (!t.countryCallingCode)
        throw new Error("Invalid phone number object passed");
      r.selectNumberingPlan(t.countryCallingCode);
    }
  }
  if (r.possibleLengths())
    return Lm(t.phone || t.nationalNumber, t.country, r);
  if (t.countryCallingCode && r.isNonGeographicCallingCode(t.countryCallingCode))
    return !0;
  throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
}
function Lm(t, e, r) {
  switch (zd(t, e, r)) {
    case "IS_POSSIBLE":
      return !0;
    default:
      return !1;
  }
}
function Or(t, e) {
  return t = t || "", new RegExp("^(?:" + e + ")$").test(t);
}
function p3(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r) return (r = r.call(t)).next.bind(r);
  if (Array.isArray(t) || (r = h3(t)) || e) {
    r && (t = r);
    var n = 0;
    return function() {
      return n >= t.length ? { done: !0 } : { done: !1, value: t[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function h3(t, e) {
  if (t) {
    if (typeof t == "string") return Wu(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Wu(t, e) : void 0;
  }
}
function Wu(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
var m3 = ["MOBILE", "PREMIUM_RATE", "TOLL_FREE", "SHARED_COST", "VOIP", "PERSONAL_NUMBER", "PAGER", "UAN", "VOICEMAIL"];
function Hd(t, e, r) {
  if (e = e || {}, !(!t.country && !t.countryCallingCode)) {
    r = new St(r), r.selectNumberingPlan(t.country, t.countryCallingCode);
    var n = e.v2 ? t.nationalNumber : t.phone;
    if (Or(n, r.nationalNumberPattern())) {
      if (Da(n, "FIXED_LINE", r))
        return r.type("MOBILE") && r.type("MOBILE").pattern() === "" || !r.type("MOBILE") || Da(n, "MOBILE", r) ? "FIXED_LINE_OR_MOBILE" : "FIXED_LINE";
      for (var o = p3(m3), s; !(s = o()).done; ) {
        var i = s.value;
        if (Da(n, i, r))
          return i;
      }
    }
  }
}
function Da(t, e, r) {
  return e = r.type(e), !e || !e.pattern() || e.possibleLengths() && e.possibleLengths().indexOf(t.length) < 0 ? !1 : Or(t, e.pattern());
}
function g3(t, e, r) {
  if (e = e || {}, r = new St(r), r.selectNumberingPlan(t.country, t.countryCallingCode), r.hasTypes())
    return Hd(t, e, r.metadata) !== void 0;
  var n = e.v2 ? t.nationalNumber : t.phone;
  return Or(n, r.nationalNumberPattern());
}
function b3(t, e, r) {
  var n = new St(r), o = n.getCountryCodesForCallingCode(t);
  return o ? o.filter(function(s) {
    return y3(e, s, r);
  }) : [];
}
function y3(t, e, r) {
  var n = new St(r);
  return n.selectNumberingPlan(e), n.numberingPlan.possibleLengths().indexOf(t.length) >= 0;
}
var Bd = 2, v3 = 17, $3 = 3, rr = "0-9---", x3 = "--", w3 = "/", k3 = ".", E3 = " ", C3 = "()\\[\\]", S3 = "~", oi = "".concat(x3).concat(w3).concat(k3).concat(E3).concat(C3).concat(S3), Vd = "+", N3 = new RegExp("([" + rr + "])");
function T3(t, e, r, n) {
  if (e) {
    var o = new St(n);
    o.selectNumberingPlan(e, r);
    var s = new RegExp(o.IDDPrefix());
    if (t.search(s) === 0) {
      t = t.slice(t.match(s)[0].length);
      var i = t.match(N3);
      if (!(i && i[1] != null && i[1].length > 0 && i[1] === "0"))
        return t;
    }
  }
}
function A3(t, e) {
  if (t && e.numberingPlan.nationalPrefixForParsing()) {
    var r = new RegExp("^(?:" + e.numberingPlan.nationalPrefixForParsing() + ")"), n = r.exec(t);
    if (n) {
      var o, s, i = n.length - 1, a = i > 0 && n[i];
      if (e.nationalPrefixTransformRule() && a)
        o = t.replace(r, e.nationalPrefixTransformRule()), i > 1 && (s = n[1]);
      else {
        var l = n[0];
        o = t.slice(l.length), a && (s = n[1]);
      }
      var d;
      if (a) {
        var c = t.indexOf(n[1]), u = t.slice(0, c);
        u === e.numberingPlan.nationalPrefix() && (d = e.numberingPlan.nationalPrefix());
      } else
        d = n[0];
      return {
        nationalNumber: o,
        nationalPrefix: d,
        carrierCode: s
      };
    }
  }
  return {
    nationalNumber: t
  };
}
function M3(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r) return (r = r.call(t)).next.bind(r);
  if (Array.isArray(t) || (r = P3(t)) || e) {
    r && (t = r);
    var n = 0;
    return function() {
      return n >= t.length ? { done: !0 } : { done: !1, value: t[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function P3(t, e) {
  if (t) {
    if (typeof t == "string") return Uu(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Uu(t, e) : void 0;
  }
}
function Uu(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function I3(t, e) {
  var r = e.countries, n = e.metadata;
  n = new St(n);
  for (var o = M3(r), s; !(s = o()).done; ) {
    var i = s.value;
    if (n.selectNumberingPlan(i), n.leadingDigits()) {
      if (t && t.search(n.leadingDigits()) === 0)
        return i;
    } else if (Hd({
      phone: t,
      country: i
    }, void 0, n.metadata))
      return i;
  }
}
function jm(t, e) {
  var r = e.nationalNumber, n = e.metadata, o = n.getCountryCodesForCallingCode(t);
  if (o)
    return o.length === 1 ? o[0] : I3(r, {
      countries: o,
      metadata: n.metadata
    });
}
function Ol(t, e, r) {
  var n = A3(t, r), o = n.carrierCode, s = n.nationalNumber;
  if (s !== t) {
    if (!R3(t, s, r))
      return {
        nationalNumber: t
      };
    if (r.numberingPlan.possibleLengths() && (e || (e = jm(r.numberingPlan.callingCode(), {
      nationalNumber: s,
      metadata: r
    })), !O3(s, e, r)))
      return {
        nationalNumber: t
      };
  }
  return {
    nationalNumber: s,
    carrierCode: o
  };
}
function R3(t, e, r) {
  return !(Or(t, r.nationalNumberPattern()) && !Or(e, r.nationalNumberPattern()));
}
function O3(t, e, r) {
  switch (zd(t, e, r)) {
    case "TOO_SHORT":
    case "INVALID_LENGTH":
      return !1;
    default:
      return !0;
  }
}
function L3(t, e, r, n, o) {
  var s = r ? Fd(r, o) : n;
  if (t.indexOf(s) === 0) {
    o = new St(o), o.selectNumberingPlan(r, s);
    var i = t.slice(s.length), a = Ol(i, e, o), l = a.nationalNumber, d = Ol(t, e, o), c = d.nationalNumber;
    if (!Or(c, o.nationalNumberPattern()) && Or(l, o.nationalNumberPattern()) || zd(c, e, o) === "TOO_LONG")
      return {
        countryCallingCode: s,
        number: i
      };
  }
  return {
    number: t
  };
}
function Dm(t, e, r, n, o) {
  if (!t)
    return {};
  var s;
  if (t[0] !== "+") {
    var i = T3(t, r, n, o);
    if (i && i !== t)
      s = !0, t = "+" + i;
    else {
      if (r || n) {
        var a = L3(t, e, r, n, o), l = a.countryCallingCode, d = a.number;
        if (l)
          return {
            countryCallingCodeSource: "FROM_NUMBER_WITHOUT_PLUS_SIGN",
            countryCallingCode: l,
            number: d
          };
      }
      return {
        // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
        // countryCallingCodeSource: 'UNSPECIFIED',
        number: t
      };
    }
  }
  if (t[1] === "0")
    return {};
  o = new St(o);
  for (var c = 2; c - 1 <= $3 && c <= t.length; ) {
    var u = t.slice(1, c);
    if (o.hasCallingCode(u))
      return o.selectNumberingPlan(u), {
        countryCallingCodeSource: s ? "FROM_NUMBER_WITH_IDD" : "FROM_NUMBER_WITH_PLUS_SIGN",
        countryCallingCode: u,
        number: t.slice(c)
      };
    c++;
  }
  return {};
}
function j3(t) {
  return t.replace(new RegExp("[".concat(oi, "]+"), "g"), " ").trim();
}
var D3 = /(\$\d)/;
function _3(t, e, r) {
  var n = r.useInternationalFormat, o = r.withNationalPrefix, s = t.replace(new RegExp(e.pattern()), n ? e.internationalFormat() : (
    // This library doesn't use `domestic_carrier_code_formatting_rule`,
    // because that one is only used when formatting phone numbers
    // for dialing from a mobile phone, and this is not a dialing library.
    // carrierCode && format.domesticCarrierCodeFormattingRule()
    // 	// First, replace the $CC in the formatting rule with the desired carrier code.
    // 	// Then, replace the $FG in the formatting rule with the first group
    // 	// and the carrier code combined in the appropriate way.
    // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
    // 	: (
    // 		withNationalPrefix && format.nationalPrefixFormattingRule()
    // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
    // 			: format.format()
    // 	)
    o && e.nationalPrefixFormattingRule() ? e.format().replace(D3, e.nationalPrefixFormattingRule()) : e.format()
  ));
  return n ? j3(s) : s;
}
var F3 = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;
function z3(t, e, r) {
  var n = new St(r);
  if (n.selectNumberingPlan(t, e), n.defaultIDDPrefix())
    return n.defaultIDDPrefix();
  if (F3.test(n.IDDPrefix()))
    return n.IDDPrefix();
}
var H3 = ";ext=", Bn = function(e) {
  return "([".concat(rr, "]{1,").concat(e, "})");
};
function _m(t) {
  var e = "20", r = "15", n = "9", o = "6", s = "[ \\t,]*", i = "[:\\.]?[ \\t,-]*", a = "#?", l = "(?:e?xt(?:ensi(?:o?|))?n?|??||anexo)", d = "(?:[x#~]|int|)", c = "[- ]+", u = "[ \\t]*", f = "(?:,{2}|;)", p = H3 + Bn(e), h = s + l + i + Bn(e) + a, g = s + d + i + Bn(n) + a, b = c + Bn(o) + "#", y = u + f + i + Bn(r) + a, $ = u + "(?:,)+" + i + Bn(n) + a;
  return p + "|" + h + "|" + g + "|" + b + "|" + y + "|" + $;
}
var B3 = "[" + rr + "]{" + Bd + "}", V3 = "[" + Vd + "]{0,1}(?:[" + oi + "]*[" + rr + "]){3,}[" + oi + rr + "]*", W3 = new RegExp("^[" + Vd + "]{0,1}(?:[" + oi + "]*[" + rr + "]){1,2}$", "i"), U3 = V3 + // Phone number extensions
"(?:" + _m() + ")?", G3 = new RegExp(
  // Either a short two-digit-only phone number
  "^" + B3 + "$|^" + U3 + "$",
  "i"
);
function K3(t) {
  return t.length >= Bd && G3.test(t);
}
function Y3(t) {
  return W3.test(t);
}
function J3(t) {
  var e = t.number, r = t.ext;
  if (!e)
    return "";
  if (e[0] !== "+")
    throw new Error('"formatRFC3966()" expects "number" to be in E.164 format.');
  return "tel:".concat(e).concat(r ? ";ext=" + r : "");
}
var Gu = {
  formatExtension: function(e, r, n) {
    return "".concat(e).concat(n.ext()).concat(r);
  }
};
function q3(t, e, r, n) {
  if (r ? r = Q3({}, Gu, r) : r = Gu, n = new St(n), t.country && t.country !== "001") {
    if (!n.hasCountry(t.country))
      throw new Error("Unknown country: ".concat(t.country));
    n.selectNumberingPlan(t.country);
  } else if (t.countryCallingCode)
    n.selectNumberingPlan(t.countryCallingCode);
  else return t.phone || "";
  var o = n.countryCallingCode(), s = r.v2 ? t.nationalNumber : t.phone, i;
  switch (e) {
    case "NATIONAL":
      return s ? (i = si(s, t.carrierCode, "NATIONAL", n, r), _a(i, t.ext, n, r.formatExtension)) : "";
    case "INTERNATIONAL":
      return s ? (i = si(s, null, "INTERNATIONAL", n, r), i = "+".concat(o, " ").concat(i), _a(i, t.ext, n, r.formatExtension)) : "+".concat(o);
    case "E.164":
      return "+".concat(o).concat(s);
    case "RFC3966":
      return J3({
        number: "+".concat(o).concat(s),
        ext: t.ext
      });
    case "IDD":
      if (!r.fromCountry)
        return;
      var a = Z3(s, t.carrierCode, o, r.fromCountry, n);
      return _a(a, t.ext, n, r.formatExtension);
    default:
      throw new Error('Unknown "format" argument passed to "formatNumber()": "'.concat(e, '"'));
  }
}
function si(t, e, r, n, o) {
  var s = X3(n.formats(), t);
  return s ? _3(t, s, {
    useInternationalFormat: r === "INTERNATIONAL",
    withNationalPrefix: !(s.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && o && o.nationalPrefix === !1)
  }) : t;
}
function X3(t, e) {
  return ex(t, function(r) {
    if (r.leadingDigitsPatterns().length > 0) {
      var n = r.leadingDigitsPatterns()[r.leadingDigitsPatterns().length - 1];
      if (e.search(n) !== 0)
        return !1;
    }
    return Or(e, r.pattern());
  });
}
function _a(t, e, r, n) {
  return e ? n(t, e, r) : t;
}
function Z3(t, e, r, n, o) {
  var s = Fd(n, o.metadata);
  if (s === r) {
    var i = si(t, e, "NATIONAL", o);
    return r === "1" ? r + " " + i : i;
  }
  var a = z3(n, void 0, o.metadata);
  if (a)
    return "".concat(a, " ").concat(r, " ").concat(si(t, null, "INTERNATIONAL", o));
}
function Q3() {
  for (var t = 1, e = arguments.length, r = new Array(e), n = 0; n < e; n++)
    r[n] = arguments[n];
  for (; t < r.length; ) {
    if (r[t])
      for (var o in r[t])
        r[0][o] = r[t][o];
    t++;
  }
  return r[0];
}
function ex(t, e) {
  for (var r = 0; r < t.length; ) {
    if (e(t[r]))
      return t[r];
    r++;
  }
}
function Vo(t) {
  "@babel/helpers - typeof";
  return Vo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Vo(t);
}
function Ku(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Yu(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ku(Object(r), !0).forEach(function(n) {
      tx(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Ku(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function tx(t, e, r) {
  return (e = Fm(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function rx(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function nx(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, Fm(n.key), n);
  }
}
function ox(t, e, r) {
  return e && nx(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function Fm(t) {
  var e = sx(t, "string");
  return Vo(e) == "symbol" ? e : e + "";
}
function sx(t, e) {
  if (Vo(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (Vo(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var ix = /* @__PURE__ */ function() {
  function t(e, r, n) {
    if (rx(this, t), !e)
      throw new TypeError("First argument is required");
    if (typeof e != "string")
      throw new TypeError("First argument must be a string");
    if (e[0] === "+" && !r)
      throw new TypeError("`metadata` argument not passed");
    if (Zn(r) && Zn(r.countries)) {
      n = r;
      var o = e;
      if (!dx.test(o))
        throw new Error('Invalid `number` argument passed: must consist of a "+" followed by digits');
      var s = Dm(o, void 0, void 0, void 0, n), i = s.countryCallingCode, a = s.number;
      if (r = a, e = i, !r)
        throw new Error("Invalid `number` argument passed: too short");
    }
    if (!r)
      throw new TypeError("`nationalNumber` argument is required");
    if (typeof r != "string")
      throw new TypeError("`nationalNumber` argument must be a string");
    Rm(n);
    var l = lx(e, n), d = l.country, c = l.countryCallingCode;
    this.country = d, this.countryCallingCode = c, this.nationalNumber = r, this.number = "+" + this.countryCallingCode + this.nationalNumber, this.getMetadata = function() {
      return n;
    };
  }
  return ox(t, [{
    key: "setExt",
    value: function(r) {
      this.ext = r;
    }
  }, {
    key: "getPossibleCountries",
    value: function() {
      return this.country ? [this.country] : b3(this.countryCallingCode, this.nationalNumber, this.getMetadata());
    }
  }, {
    key: "isPossible",
    value: function() {
      return f3(this, {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "isValid",
    value: function() {
      return g3(this, {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "isNonGeographic",
    value: function() {
      var r = new St(this.getMetadata());
      return r.isNonGeographicCallingCode(this.countryCallingCode);
    }
  }, {
    key: "isEqual",
    value: function(r) {
      return this.number === r.number && this.ext === r.ext;
    }
    // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
    // but later it was found out that it doesn't include the possible `TOO_SHORT` result
    // returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,
    // so eventually I simply commented out this method from the `PhoneNumber` class
    // and just left the `validatePhoneNumberLength()` function, even though that one would require
    // and additional step to also validate the actual country / calling code of the phone number.
    // validateLength() {
    // 	const metadata = new Metadata(this.getMetadata())
    // 	metadata.selectNumberingPlan(this.countryCallingCode)
    // 	const result = checkNumberLength(this.nationalNumber, metadata)
    // 	if (result !== 'IS_POSSIBLE') {
    // 		return result
    // 	}
    // }
  }, {
    key: "getType",
    value: function() {
      return Hd(this, {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "format",
    value: function(r, n) {
      return q3(this, r, n ? Yu(Yu({}, n), {}, {
        v2: !0
      }) : {
        v2: !0
      }, this.getMetadata());
    }
  }, {
    key: "formatNational",
    value: function(r) {
      return this.format("NATIONAL", r);
    }
  }, {
    key: "formatInternational",
    value: function(r) {
      return this.format("INTERNATIONAL", r);
    }
  }, {
    key: "getURI",
    value: function(r) {
      return this.format("RFC3966", r);
    }
  }]);
}(), ax = function(e) {
  return /^[A-Z]{2}$/.test(e);
};
function lx(t, e) {
  var r, n, o = new St(e);
  return ax(t) ? (r = t, o.selectNumberingPlan(r), n = o.countryCallingCode()) : n = t, {
    country: r,
    countryCallingCode: n
  };
}
var dx = /^\+\d+$/;
function Ll(t) {
  "@babel/helpers - typeof";
  return Ll = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ll(t);
}
function cx(t, e, r) {
  return Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function ux(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function fx(t, e, r) {
  return e = Uo(e), px(t, Wd() ? Reflect.construct(e, r || [], Uo(t).constructor) : e.apply(t, r));
}
function px(t, e) {
  if (e && (Ll(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return hx(t);
}
function hx(t) {
  if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function mx(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && Wo(t, e);
}
function jl(t) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return jl = function(n) {
    if (n === null || !bx(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(n)) return e.get(n);
      e.set(n, o);
    }
    function o() {
      return gx(n, arguments, Uo(this).constructor);
    }
    return o.prototype = Object.create(n.prototype, { constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 } }), Wo(o, n);
  }, jl(t);
}
function gx(t, e, r) {
  if (Wd()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var o = new (t.bind.apply(t, n))();
  return r && Wo(o, r.prototype), o;
}
function Wd() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Wd = function() {
    return !!t;
  })();
}
function bx(t) {
  try {
    return Function.toString.call(t).indexOf("[native code]") !== -1;
  } catch {
    return typeof t == "function";
  }
}
function Wo(t, e) {
  return Wo = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Wo(t, e);
}
function Uo(t) {
  return Uo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Uo(t);
}
var Ar = /* @__PURE__ */ function(t) {
  function e(r) {
    var n;
    return ux(this, e), n = fx(this, e, [r]), Object.setPrototypeOf(n, e.prototype), n.name = n.constructor.name, n;
  }
  return mx(e, t), cx(e);
}(/* @__PURE__ */ jl(Error)), Ju = new RegExp("(?:" + _m() + ")$", "i");
function yx(t) {
  var e = t.search(Ju);
  if (e < 0)
    return {};
  for (var r = t.slice(0, e), n = t.match(Ju), o = 1; o < n.length; ) {
    if (n[o])
      return {
        number: r,
        ext: n[o]
      };
    o++;
  }
}
var vx = {
  0: "0",
  1: "1",
  2: "2",
  3: "3",
  4: "4",
  5: "5",
  6: "6",
  7: "7",
  8: "8",
  9: "9",
  "": "0",
  // Fullwidth digit 0
  "": "1",
  // Fullwidth digit 1
  "": "2",
  // Fullwidth digit 2
  "": "3",
  // Fullwidth digit 3
  "": "4",
  // Fullwidth digit 4
  "": "5",
  // Fullwidth digit 5
  "": "6",
  // Fullwidth digit 6
  "": "7",
  // Fullwidth digit 7
  "": "8",
  // Fullwidth digit 8
  "": "9",
  // Fullwidth digit 9
  "": "0",
  // Arabic-indic digit 0
  "": "1",
  // Arabic-indic digit 1
  "": "2",
  // Arabic-indic digit 2
  "": "3",
  // Arabic-indic digit 3
  "": "4",
  // Arabic-indic digit 4
  "": "5",
  // Arabic-indic digit 5
  "": "6",
  // Arabic-indic digit 6
  "": "7",
  // Arabic-indic digit 7
  "": "8",
  // Arabic-indic digit 8
  "": "9",
  // Arabic-indic digit 9
  "": "0",
  // Eastern-Arabic digit 0
  "": "1",
  // Eastern-Arabic digit 1
  "": "2",
  // Eastern-Arabic digit 2
  "": "3",
  // Eastern-Arabic digit 3
  "": "4",
  // Eastern-Arabic digit 4
  "": "5",
  // Eastern-Arabic digit 5
  "": "6",
  // Eastern-Arabic digit 6
  "": "7",
  // Eastern-Arabic digit 7
  "": "8",
  // Eastern-Arabic digit 8
  "": "9"
  // Eastern-Arabic digit 9
};
function $x(t) {
  return vx[t];
}
function xx(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r) return (r = r.call(t)).next.bind(r);
  if (Array.isArray(t) || (r = wx(t)) || e) {
    r && (t = r);
    var n = 0;
    return function() {
      return n >= t.length ? { done: !0 } : { done: !1, value: t[n++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function wx(t, e) {
  if (t) {
    if (typeof t == "string") return qu(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? qu(t, e) : void 0;
  }
}
function qu(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function Xu(t) {
  for (var e = "", r = xx(t.split("")), n; !(n = r()).done; ) {
    var o = n.value;
    e += kx(o, e) || "";
  }
  return e;
}
function kx(t, e, r) {
  return t === "+" ? e ? void 0 : "+" : $x(t);
}
var zm = "+", Ex = "[\\-\\.\\(\\)]?", Zu = "([" + rr + "]|" + Ex + ")", Cx = "^\\" + zm + Zu + "*[" + rr + "]" + Zu + "*$", Sx = new RegExp(Cx, "g"), Dl = rr, Nx = "[" + Dl + "]+((\\-)*[" + Dl + "])*", Tx = "a-zA-Z", Ax = "[" + Tx + "]+((\\-)*[" + Dl + "])*", Mx = "^(" + Nx + "\\.)*" + Ax + "\\.?$", Px = new RegExp(Mx, "g"), Qu = "tel:", _l = ";phone-context=", Ix = ";isub=";
function Rx(t) {
  var e = t.indexOf(_l);
  if (e < 0)
    return null;
  var r = e + _l.length;
  if (r >= t.length)
    return "";
  var n = t.indexOf(";", r);
  return n >= 0 ? t.substring(r, n) : t.substring(r);
}
function Ox(t) {
  return t === null ? !0 : t.length === 0 ? !1 : Sx.test(t) || Px.test(t);
}
function Lx(t, e) {
  var r = e.extractFormattedPhoneNumber, n = Rx(t);
  if (!Ox(n))
    throw new Ar("NOT_A_NUMBER");
  var o;
  if (n === null)
    o = r(t) || "";
  else {
    o = "", n.charAt(0) === zm && (o += n);
    var s = t.indexOf(Qu), i;
    s >= 0 ? i = s + Qu.length : i = 0;
    var a = t.indexOf(_l);
    o += t.substring(i, a);
  }
  var l = o.indexOf(Ix);
  if (l > 0 && (o = o.substring(0, l)), o !== "")
    return o;
}
var jx = 250, Dx = new RegExp("[" + Vd + rr + "]"), _x = new RegExp("[^" + rr + "#]+$");
function Fx(t, e, r) {
  if (e = e || {}, r = new St(r), e.defaultCountry && !r.hasCountry(e.defaultCountry))
    throw e.v2 ? new Ar("INVALID_COUNTRY") : new Error("Unknown country: ".concat(e.defaultCountry));
  var n = Hx(t, e.v2, e.extract), o = n.number, s = n.ext, i = n.error;
  if (!o) {
    if (e.v2)
      throw i === "TOO_SHORT" ? new Ar("TOO_SHORT") : new Ar("NOT_A_NUMBER");
    return {};
  }
  var a = Vx(o, e.defaultCountry, e.defaultCallingCode, r), l = a.country, d = a.nationalNumber, c = a.countryCallingCode, u = a.countryCallingCodeSource, f = a.carrierCode;
  if (!r.hasSelectedNumberingPlan()) {
    if (e.v2)
      throw new Ar("INVALID_COUNTRY");
    return {};
  }
  if (!d || d.length < Bd) {
    if (e.v2)
      throw new Ar("TOO_SHORT");
    return {};
  }
  if (d.length > v3) {
    if (e.v2)
      throw new Ar("TOO_LONG");
    return {};
  }
  if (e.v2) {
    var p = new ix(c, d, r.metadata);
    return l && (p.country = l), f && (p.carrierCode = f), s && (p.ext = s), p.__countryCallingCodeSource = u, p;
  }
  var h = (e.extended ? r.hasSelectedNumberingPlan() : l) ? Or(d, r.nationalNumberPattern()) : !1;
  return e.extended ? {
    country: l,
    countryCallingCode: c,
    carrierCode: f,
    valid: h,
    possible: h ? !0 : !!(e.extended === !0 && r.possibleLengths() && Lm(d, l, r)),
    phone: d,
    ext: s
  } : h ? Bx(l, d, s) : {};
}
function zx(t, e, r) {
  if (t) {
    if (t.length > jx) {
      if (r)
        throw new Ar("TOO_LONG");
      return;
    }
    if (e === !1)
      return t;
    var n = t.search(Dx);
    if (!(n < 0))
      return t.slice(n).replace(_x, "");
  }
}
function Hx(t, e, r) {
  var n = Lx(t, {
    extractFormattedPhoneNumber: function(i) {
      return zx(i, r, e);
    }
  });
  if (!n)
    return {};
  if (!K3(n))
    return Y3(n) ? {
      error: "TOO_SHORT"
    } : {};
  var o = yx(n);
  return o.ext ? o : {
    number: n
  };
}
function Bx(t, e, r) {
  var n = {
    country: t,
    phone: e
  };
  return r && (n.ext = r), n;
}
function Vx(t, e, r, n) {
  var o = Dm(Xu(t), void 0, e, r, n.metadata), s = o.countryCallingCodeSource, i = o.countryCallingCode, a = o.number, l;
  if (i)
    n.selectNumberingPlan(i);
  else if (a && (e || r))
    n.selectNumberingPlan(e, r), e && (l = e), i = r || Fd(e, n.metadata);
  else return {};
  if (!a)
    return {
      countryCallingCodeSource: s,
      countryCallingCode: i
    };
  var d = Ol(Xu(a), l, n), c = d.nationalNumber, u = d.carrierCode, f = jm(i, {
    nationalNumber: c,
    metadata: n
  });
  return f && (l = f, f === "001" || n.selectNumberingPlan(l)), {
    country: l,
    countryCallingCode: i,
    countryCallingCodeSource: s,
    nationalNumber: c,
    carrierCode: u
  };
}
function Go(t) {
  "@babel/helpers - typeof";
  return Go = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Go(t);
}
function ef(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function tf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ef(Object(r), !0).forEach(function(n) {
      Wx(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : ef(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function Wx(t, e, r) {
  return (e = Ux(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function Ux(t) {
  var e = Gx(t, "string");
  return Go(e) == "symbol" ? e : e + "";
}
function Gx(t, e) {
  if (Go(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (Go(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Kx(t, e, r) {
  return Fx(t, tf(tf({}, e), {}, {
    v2: !0
  }), r);
}
function Ko(t) {
  "@babel/helpers - typeof";
  return Ko = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ko(t);
}
function rf(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Yx(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? rf(Object(r), !0).forEach(function(n) {
      Jx(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : rf(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function Jx(t, e, r) {
  return (e = qx(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function qx(t) {
  var e = Xx(t, "string");
  return Ko(e) == "symbol" ? e : e + "";
}
function Xx(t, e) {
  if (Ko(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (Ko(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Zx(t, e) {
  return rw(t) || tw(t, e) || ew(t, e) || Qx();
}
function Qx() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ew(t, e) {
  if (t) {
    if (typeof t == "string") return nf(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? nf(t, e) : void 0;
  }
}
function nf(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function tw(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n, o, s, i, a = [], l = !0, d = !1;
    try {
      if (s = (r = r.call(t)).next, e !== 0) for (; !(l = (n = s.call(r)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      d = !0, o = c;
    } finally {
      try {
        if (!l && r.return != null && (i = r.return(), Object(i) !== i)) return;
      } finally {
        if (d) throw o;
      }
    }
    return a;
  }
}
function rw(t) {
  if (Array.isArray(t)) return t;
}
function nw(t) {
  var e = Array.prototype.slice.call(t), r = Zx(e, 4), n = r[0], o = r[1], s = r[2], i = r[3], a, l, d;
  if (typeof n == "string")
    a = n;
  else throw new TypeError("A text for parsing must be a string.");
  if (!o || typeof o == "string")
    i ? (l = s, d = i) : (l = void 0, d = s), o && (l = Yx({
      defaultCountry: o
    }, l));
  else if (Zn(o))
    s ? (l = o, d = s) : d = o;
  else throw new Error("Invalid second argument: ".concat(o));
  return {
    text: a,
    options: l,
    metadata: d
  };
}
function Yo(t) {
  "@babel/helpers - typeof";
  return Yo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Yo(t);
}
function of(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function sf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? of(Object(r), !0).forEach(function(n) {
      ow(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : of(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function ow(t, e, r) {
  return (e = sw(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function sw(t) {
  var e = iw(t, "string");
  return Yo(e) == "symbol" ? e : e + "";
}
function iw(t, e) {
  if (Yo(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (Yo(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function aw(t, e, r) {
  e && e.defaultCountry && !c3(e.defaultCountry, r) && (e = sf(sf({}, e), {}, {
    defaultCountry: void 0
  }));
  try {
    return Kx(t, e, r);
  } catch (n) {
    if (!(n instanceof Ar)) throw n;
  }
}
function lw() {
  var t = nw(arguments), e = t.text, r = t.options, n = t.metadata;
  return aw(e, r, n);
}
function Hm() {
  return Z$(lw, arguments);
}
function dw(t) {
  var o;
  const e = Hm(t);
  if (!e) return null;
  const r = (o = e.country) == null ? void 0 : o.toLowerCase(), n = Nr.find((s) => s.iso === r);
  return n ? {
    ...n,
    formatted: e.formatInternational(),
    isValid: e.isValid()
  } : null;
}
function cw(t) {
  var n;
  const e = Hm(t);
  if (!e) return null;
  const r = (n = e.country) == null ? void 0 : n.toLowerCase();
  return Nr.find((o) => o.iso === r) || null;
}
const uw = ct(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        "2xl": "rounded-2xl",
        "3xl": "rounded-3xl",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "xl",
      fullWidth: !0
    }
  }
), ws = (t) => {
  if (!t) return null;
  const e = t.startsWith("+") ? t : `+${t}`;
  return cw(e);
}, fw = (t) => t.startsWith("0") && t.length >= 9 && t.length <= 12 ? "+62" + t.slice(1) : t, pw = (t) => t.startsWith("0") && t.length >= 3, Bm = Oe(
  ({
    className: t,
    variant: e = "default",
    size: r = "md",
    rounded: n = "xl",
    error: o = !1,
    errorText: s,
    helperText: i,
    label: a,
    required: l = !1,
    fullWidth: d = !1,
    value: c = "",
    onChange: u,
    disabled: f = !1,
    defaultCountry: p = "id",
    placeholder: h = "Enter phone number",
    autoDetect: g = !0,
    name: b,
    ...y
  }, $) => {
    const [k, w] = de(!1), [C, T] = de(
      () => Nr.find((B) => B.iso === p) || Nr[0]
    ), [H, O] = de(""), [j, F] = de(() => {
      if (g && c) {
        const _ = ws(c);
        return _ && T(_), c;
      }
      const B = C.code;
      return c.startsWith(B) ? c.slice(B.length) : c;
    });
    me(() => {
      if (c && u)
        if (g) {
          const B = ws(c);
          if (B) {
            const _ = B.code, W = c.startsWith(_) ? c.slice(_.length) : c, ie = {
              iso: B.iso,
              code: B.code.replace("+", ""),
              value: W
            };
            u(c, ie);
          } else
            u(c);
        } else {
          const B = C.code, _ = c.startsWith(B) ? c.slice(B.length) : c, W = {
            iso: C.iso,
            code: C.code.replace("+", ""),
            value: _
          };
          u(c, W);
        }
    }, []);
    const [v, M] = de(() => g && c ? !!ws(c) : !1), E = te(null), N = te(null), R = te(null), x = le.useId(), P = `${x}-helper`, I = `${x}-error`;
    In($, () => R.current || L.current, []);
    const D = Nr.filter(
      (B) => B.name.toLowerCase().includes(H.toLowerCase()) || B.code.includes(H)
    ), L = te(null), A = () => {
      if (k && E.current && N.current) {
        const B = E.current.getBoundingClientRect(), _ = N.current, W = typeof window < "u" ? window : { innerHeight: 0 }, ie = W.innerHeight - B.bottom, pe = B.top, Ce = B.bottom + (_.offsetHeight || 0) + 4 >= W.innerHeight, Be = pe > ie, je = Ce && Be;
        _.style.position = "fixed", _.style.left = `${B.left}px`, _.style.minWidth = `${B.width}px`, _.style.maxWidth = "340px", _.style.width = "auto", je ? (_.style.bottom = `${W.innerHeight - B.top + 4}px`, _.style.top = "auto", _.style.maxHeight = `${pe - 8}px`) : (_.style.top = `${B.bottom + 4}px`, _.style.bottom = "auto", _.style.maxHeight = `${ie - 8}px`);
      }
    };
    me(() => {
      const B = typeof window < "u" ? window : void 0, _ = () => {
        k && A();
      }, W = () => {
        k && A();
      };
      return k && (A(), B == null || B.addEventListener("scroll", _, !0), B == null || B.addEventListener("resize", W)), () => {
        B == null || B.removeEventListener("scroll", _, !0), B == null || B.removeEventListener("resize", W);
      };
    }, [k]), me(() => {
      if (!k) return;
      const B = (_) => {
        const W = _.target;
        E.current && N.current && !E.current.contains(W) && !N.current.contains(W) && w(!1);
      };
      return document.addEventListener("click", B), () => document.removeEventListener("click", B);
    }, [k]);
    const z = (B) => {
      if (T(B), w(!1), O(""), g) {
        const _ = B.code + j.replace(/^\+?\d*/, "");
        F(_);
        const W = _.replace(/[^\d]/g, ""), ie = j.replace(/^\+?\d*/, ""), pe = {
          iso: B.iso,
          code: B.code.replace("+", ""),
          value: ie
        };
        u == null || u(W, pe);
      } else {
        const W = (B.code + j).replace(/[^\d]/g, ""), ie = {
          iso: B.iso,
          code: B.code.replace("+", ""),
          value: j
        };
        u == null || u(W, ie);
      }
    }, Y = (B) => {
      const _ = B.target.value;
      if (/^[+\d]*$/.test(_))
        if (g && _.startsWith("+")) {
          const ie = ws(_);
          if (ie) {
            T(ie), M(!0), F(_);
            const pe = _.replace(/[^\d]/g, ""), ye = ie.code, Ce = _.startsWith(ye) ? _.slice(ye.length) : _, Be = {
              iso: ie.iso,
              code: ie.code.replace("+", ""),
              value: Ce
            };
            u == null || u(pe, Be);
          } else {
            F(_), M(!1);
            const pe = _.replace(/[^\d]/g, "");
            u == null || u(pe);
          }
        } else if (g && !_.startsWith("+") && _.length > 0) {
          const ie = fw(_);
          if (ie !== _) {
            F(ie), T(
              Nr.find((Be) => Be.iso === "id") || Nr[0]
            ), M(!0);
            const pe = ie.replace(/[^\d]/g, ""), Ce = {
              iso: "id",
              code: "62",
              value: _.slice(1)
            };
            u == null || u(pe, Ce);
          } else if (pw(_)) {
            const pe = "+62" + _.slice(1);
            F(pe), T(
              Nr.find((je) => je.iso === "id") || Nr[0]
            ), M(!0);
            const ye = pe.replace(/[^\d]/g, ""), Be = {
              iso: "id",
              code: "62",
              value: _.slice(1)
            };
            u == null || u(ye, Be);
          } else if (_.startsWith("0"))
            F(_), M(!1);
          else {
            const pe = "+" + _;
            F(pe);
            const ye = pe.replace(/[^\d]/g, "");
            u == null || u(ye);
          }
        } else {
          const ie = _.replace(/[^\d]/g, "");
          F(ie);
          const ye = (C.code + ie).replace(/[^\d]/g, ""), Ce = {
            iso: C.iso,
            code: C.code.replace("+", ""),
            value: ie
          };
          u == null || u(ye, Ce);
        }
    }, q = V(
      uw({
        variant: o ? "error" : e,
        size: r,
        rounded: n,
        fullWidth: d
      }),
      "!w-full"
    ), ee = !g || g && v;
    return me(() => {
      if (R.current) {
        const B = j || "";
        R.current.value = B;
        const _ = new Event("input", { bubbles: !0 });
        R.current.dispatchEvent(_);
      }
    }, [j]), /* @__PURE__ */ m.jsxs(
      "div",
      {
        ref: L,
        className: V(d ? "w-full" : "inline-block", t),
        ...y,
        children: [
          /* @__PURE__ */ m.jsx(
            "input",
            {
              type: "hidden",
              ref: R,
              name: b,
              value: j || "",
              onChange: () => {
              }
            }
          ),
          a && /* @__PURE__ */ m.jsxs("label", { htmlFor: x, className: "mb-1.5 block text-sm text-neutral-900", children: [
            a,
            l && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
          ] }),
          /* @__PURE__ */ m.jsxs("div", { className: V("relative", !d && "inline-block"), children: [
            /* @__PURE__ */ m.jsxs("div", { className: "flex", children: [
              ee && /* @__PURE__ */ m.jsxs(
                "button",
                {
                  type: "button",
                  ref: E,
                  onClick: () => !f && w(!k),
                  className: V(
                    q,
                    "flex items-center gap-2 rounded-r-none justify-between",
                    g ? "max-w-[60px]" : "max-w-[100px]",
                    f && "cursor-not-allowed opacity-50"
                  ),
                  children: [
                    /* @__PURE__ */ m.jsxs("span", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ m.jsx($e, { icon: C.flag, className: "w-5 h-5" }),
                      !g && /* @__PURE__ */ m.jsx("span", { className: "text-sm", children: C.code })
                    ] }),
                    /* @__PURE__ */ m.jsx(
                      $e,
                      {
                        icon: "mdi:chevron-down",
                        className: V("transition-transform", k && "rotate-180")
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ m.jsx(
                "input",
                {
                  type: "tel",
                  id: x,
                  value: j,
                  onChange: Y,
                  disabled: f,
                  className: V(
                    q,
                    ee ? "rounded-l-none" : `rounded-l-${n}`,
                    "flex-1 min-w-0 w-full"
                  ),
                  placeholder: g ? "e.g. +6281234567890" : h
                }
              )
            ] }),
            k && Rn(
              /* @__PURE__ */ m.jsxs(
                "div",
                {
                  ref: N,
                  className: "border border-neutral-200 bg-white shadow-lg overflow-y-auto rounded-md",
                  children: [
                    /* @__PURE__ */ m.jsx("div", { className: "p-2 border-b border-neutral-200", children: /* @__PURE__ */ m.jsx(
                      "input",
                      {
                        type: "text",
                        value: H,
                        onChange: (B) => {
                          const _ = B.target.value;
                          /^[a-zA-Z0-9\s]*$/.test(_) && O(_);
                        },
                        placeholder: "Search countries...",
                        className: "w-full px-3 py-2 text-sm border border-neutral-200 rounded-md focus:outline-none focus:border-primary-300"
                      }
                    ) }),
                    /* @__PURE__ */ m.jsx("div", { className: "max-h-[300px] overflow-y-auto", children: D.map((B) => /* @__PURE__ */ m.jsx(
                      "button",
                      {
                        type: "button",
                        onClick: () => z(B),
                        className: V(
                          "w-full px-3 py-2 text-sm text-left hover:bg-primary-50 cursor-pointer",
                          C.iso === B.iso && "bg-primary-50"
                        ),
                        children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2", children: [
                          /* @__PURE__ */ m.jsx($e, { icon: B.flag, className: "w-5 h-5" }),
                          /* @__PURE__ */ m.jsx("span", { className: "text-sm font-medium", children: B.code }),
                          /* @__PURE__ */ m.jsx("span", { className: "text-sm text-neutral-600", children: B.name })
                        ] })
                      },
                      B.iso + B.code
                    )) })
                  ]
                }
              ),
              typeof document < "u" ? document.body : document
            )
          ] }),
          o && s && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger", id: I, children: s }),
          !o && i && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral", id: P, children: i })
        ]
      }
    );
  }
);
Bm.displayName = "PhoneInput";
const X7 = () => {
  const [t, e] = de(""), [r, n] = de(null), o = (s) => {
    e(s);
    const i = dw(`+${s}`);
    n(i);
  };
  return /* @__PURE__ */ m.jsxs("div", { className: "p-6 max-w-md mx-auto", children: [
    /* @__PURE__ */ m.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Phone Input with libphonenumber-js Integration" }),
    /* @__PURE__ */ m.jsx(
      Bm,
      {
        label: "Phone Number",
        placeholder: "Enter phone number",
        value: t,
        onChange: o,
        autoDetect: !0,
        helperText: "Try typing: +12025551234 (US), +14165551234 (Canada), +18765551234 (Jamaica)"
      }
    ),
    r && /* @__PURE__ */ m.jsxs("div", { className: "mt-4 p-4 bg-gray-50 rounded-lg", children: [
      /* @__PURE__ */ m.jsx("h3", { className: "font-medium mb-2", children: "Detected Country Info:" }),
      /* @__PURE__ */ m.jsxs("div", { className: "space-y-1 text-sm", children: [
        /* @__PURE__ */ m.jsxs("p", { children: [
          /* @__PURE__ */ m.jsx("strong", { children: "Country:" }),
          " ",
          r.name
        ] }),
        /* @__PURE__ */ m.jsxs("p", { children: [
          /* @__PURE__ */ m.jsx("strong", { children: "ISO Code:" }),
          " ",
          r.iso
        ] }),
        /* @__PURE__ */ m.jsxs("p", { children: [
          /* @__PURE__ */ m.jsx("strong", { children: "Dial Code:" }),
          " ",
          r.code
        ] }),
        /* @__PURE__ */ m.jsxs("p", { children: [
          /* @__PURE__ */ m.jsx("strong", { children: "Formatted:" }),
          " ",
          r.formatted
        ] }),
        /* @__PURE__ */ m.jsxs("p", { children: [
          /* @__PURE__ */ m.jsx("strong", { children: "Valid:" }),
          " ",
          r.isValid ? "Yes" : "No"
        ] })
      ] })
    ] })
  ] });
}, hw = ct("border bg-popover text-popover-foreground", {
  variants: {
    variant: {
      default: "border-border shadow-sm",
      elevated: "border-border shadow-lg",
      outline: "border-border bg-transparent",
      ghost: "border-transparent bg-transparent"
    },
    color: {
      primary: "border-primary bg-primary text-primary-foreground",
      secondary: "border-secondary bg-secondary text-secondary-foreground",
      success: "border-success bg-success text-success-foreground",
      warning: "border-warning bg-warning text-warning-foreground",
      danger: "border-danger bg-danger text-danger-foreground",
      info: "border-info bg-info text-info-foreground",
      neutral: "border-neutral bg-neutral text-neutral-foreground",
      light: "border-gray-200 bg-white text-gray-900",
      custom: ""
    },
    shadow: {
      none: "",
      sm: "shadow-sm",
      md: "shadow-md",
      lg: "shadow-lg",
      xl: "shadow-xl"
    },
    rounded: {
      none: "rounded-none",
      sm: "rounded-sm",
      md: "rounded-md",
      lg: "rounded-lg",
      xl: "rounded-xl",
      "2xl": "rounded-2xl",
      "3xl": "rounded-3xl",
      full: "rounded-full"
    }
  },
  defaultVariants: {
    variant: "default",
    color: "light",
    shadow: "md",
    rounded: "lg"
  }
}), Z7 = ({
  content: t,
  children: e,
  placement: r = "bottom",
  showArrow: n = !1,
  variant: o = "default",
  color: s = "light",
  customColor: i,
  rounded: a = "lg",
  shadow: l = "md",
  className: d,
  isOpen: c,
  onOpenChange: u,
  backdrop: f = "transparent",
  disableAnimation: p = !1,
  offset: h = 7,
  isDismissable: g = !0,
  shouldCloseOnScroll: b = !0,
  shouldCloseOnBlur: y = !1,
  shouldBlockScroll: $ = !1,
  containerPadding: k = 12,
  crossOffset: w = 0,
  portalContainer: C = typeof document < "u" ? document.body : void 0,
  triggerType: T = "dialog",
  shouldFlip: H = !0,
  triggerScaleOnOpen: O = !0,
  zIndex: j = 50,
  // Default z-index for popover
  contentZIndex: F
  // Specific z-index for content, falls back to zIndex
}) => {
  const v = () => {
    switch (s) {
      case "primary":
        return "primary";
      case "secondary":
        return "secondary";
      case "success":
        return "success";
      case "warning":
        return "warning";
      case "danger":
        return "danger";
      case "info":
      case "neutral":
        return "default";
      case "light":
        return "default";
      case "custom":
        return "default";
      default:
        return "default";
    }
  }, M = () => s === "custom" && i ? { backgroundColor: i, color: "#ffffff" } : {
    info: "bg-blue-500 text-white border-blue-500",
    neutral: "bg-gray-500 text-white border-gray-500",
    light: "bg-white text-gray-900 border-gray-200"
  }[s] || "", E = () => {
    switch (f) {
      case "blur":
        return "blur";
      case "dark":
        return "opaque";
      case "transparent":
      default:
        return "transparent";
    }
  }, N = M(), R = v(), x = E(), P = F !== void 0 ? F : j, I = {
    placement: r,
    showArrow: n,
    color: R,
    radius: a,
    shadow: l,
    isOpen: c,
    onOpenChange: u,
    backdrop: x,
    disableAnimation: p,
    offset: h,
    isDismissable: g,
    shouldCloseOnScroll: b,
    shouldCloseOnBlur: y,
    shouldBlockScroll: $,
    containerPadding: k,
    crossOffset: w,
    portalContainer: C,
    triggerType: T,
    shouldFlip: H,
    triggerScaleOnOpen: O,
    // Ensure proper positioning
    isKeyboardDismissDisabled: !1,
    // Apply z-index to the popover container
    style: {
      zIndex: j
    }
  };
  return Object.keys(I).forEach((D) => {
    I[D] === void 0 && delete I[D];
  }), /* @__PURE__ */ m.jsxs(W$, { ...I, children: [
    /* @__PURE__ */ m.jsx(V$, { children: e }),
    /* @__PURE__ */ m.jsx(
      B$,
      {
        className: V(
          hw({ variant: o, color: s, shadow: l, rounded: a }),
          d,
          N,
          // Apply custom color styles when needed
          s === "custom" && i ? "border-0" : ""
        ),
        style: {
          ...s === "custom" && i ? { backgroundColor: i, color: "#ffffff" } : {},
          // Apply z-index to content container
          zIndex: P
        },
        children: t
      }
    )
  ] });
}, mw = ct("flex items-center text-sm", {
  variants: {
    variant: {
      default: "text-neutral-600",
      light: "text-neutral-400",
      dark: "text-neutral-800"
    },
    size: {
      sm: "text-xs",
      md: "text-sm",
      lg: "text-base"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "md"
  }
}), gw = Oe(
  ({
    className: t,
    variant: e = "default",
    size: r = "md",
    items: n,
    separator: o = /* @__PURE__ */ m.jsx($e, { icon: "mdi:slash-forward", className: "h-4 w-4 flex-shrink-0" }),
    activeLastItem: s = !0,
    ...i
  }, a) => /* @__PURE__ */ m.jsx(
    "nav",
    {
      ref: a,
      className: V(mw({ variant: e, size: r }), t),
      "aria-label": "Breadcrumb",
      ...i,
      children: /* @__PURE__ */ m.jsx("ol", { className: "flex flex-wrap items-center gap-1.5", children: n.map((l, d) => {
        const c = d === n.length - 1, u = c && s;
        return /* @__PURE__ */ m.jsxs(
          "li",
          {
            className: V(
              "flex items-center gap-1.5",
              u && "text-primary font-medium"
            ),
            children: [
              l.icon && /* @__PURE__ */ m.jsx(
                $e,
                {
                  icon: l.icon,
                  className: V(
                    "flex-shrink-0",
                    r === "sm" && "h-3.5 w-3.5",
                    r === "md" && "h-4 w-4",
                    r === "lg" && "h-5 w-5"
                  )
                }
              ),
              l.href && !u ? /* @__PURE__ */ m.jsx(
                "a",
                {
                  href: l.href,
                  className: V(
                    "transition-colors duration-200",
                    "hover:text-primary hover:underline focus:outline-none",
                    "focus-visible:text-primary focus-visible:underline",
                    "active:text-primary-600"
                  ),
                  children: /* @__PURE__ */ m.jsx("span", { className: "truncate max-w-[200px] inline-block align-bottom", children: l.label })
                }
              ) : /* @__PURE__ */ m.jsx("span", { className: V(
                "truncate max-w-[200px] inline-block",
                u && "text-primary"
              ), children: l.label }),
              !c && /* @__PURE__ */ m.jsx("span", { className: V(
                "text-neutral-400 flex-shrink-0",
                r === "sm" && "scale-90",
                r === "lg" && "scale-110"
              ), children: o })
            ]
          },
          l.label
        );
      }) })
    }
  )
);
gw.displayName = "Breadcrumbs";
const Vm = (t) => {
  const e = {
    header: {
      primary: "bg-primary text-white",
      default: "bg-primary text-white",
      secondary: "bg-secondary text-white",
      warning: "bg-warning text-white",
      danger: "bg-danger text-white",
      ghost: "bg-gray-100 text-gray-700",
      success: "bg-success text-white"
    },
    row: {
      primary: "hover:bg-primary-50",
      default: "hover:bg-primary-50",
      secondary: "hover:bg-secondary-50",
      warning: "hover:bg-warning-50",
      danger: "hover:bg-danger-50",
      ghost: "hover:bg-gray-50",
      success: "hover:bg-success-50"
    },
    border: {
      primary: "border-primary",
      default: "border-primary",
      secondary: "border-secondary",
      warning: "border-warning",
      danger: "border-danger",
      ghost: "border-gray-200",
      success: "border-success"
    },
    stripe: {
      primary: "bg-primary-50",
      default: "bg-none",
      secondary: "bg-secondary-50",
      warning: "bg-warning-50",
      danger: "bg-danger-50",
      ghost: "bg-gray-50",
      success: "bg-success-50"
    },
    hoverStripe: {
      primary: "group-hover:bg-primary-50",
      default: "group-hover:bg-primary-50",
      secondary: "group-hover:bg-secondary-50",
      warning: "group-hover:bg-warning-50",
      danger: "group-hover:bg-danger-50",
      ghost: "group-hover:bg-gray-50",
      success: "group-hover:bg-success-50"
    }
  };
  return {
    header: e.header[t],
    row: e.row[t],
    border: e.border[t],
    stripe: e.stripe[t],
    hoverStripe: e.hoverStripe[t]
  };
}, bw = ({
  schema: t,
  variant: e = "default",
  showIndexSticky: r = !1,
  isMobile: n = !1
}) => {
  const o = [
    {
      name: "no",
      label: "No.",
      accessorKey: "no",
      type: "number",
      width: 80,
      sticky: r,
      stickyPosition: "left"
    },
    ...t
  ], s = Vm(e);
  return /* @__PURE__ */ m.jsx("div", { className: "bg-white rounded-md flex flex-col h-full max-h-[600px]", children: /* @__PURE__ */ m.jsx("div", { className: "p-0 w-full overflow-auto rounded-t-md [&::-webkit-scrollbar]:w-2 [&::-webkit-scrollbar]:h-2 [&::-webkit-scrollbar-track]:bg-gray-100 [&::-webkit-scrollbar-thumb]:bg-gray-300 [&::-webkit-scrollbar-thumb]:rounded-full flex-1", children: /* @__PURE__ */ m.jsxs("table", { className: "w-full border-spacing-0 border-separate min-w-full", children: [
    /* @__PURE__ */ m.jsx(
      "thead",
      {
        className: V(
          "border-2 sticky top-0 z-20 rounded-t-md",
          s.border
        ),
        children: /* @__PURE__ */ m.jsx("tr", { children: o.map((i, a) => {
          const l = () => {
            var c;
            if (n || !i.sticky || i.stickyPosition !== "left")
              return 0;
            let d = 0;
            for (let u = 0; u < a; u++) {
              const f = o[u];
              if (f.sticky && f.stickyPosition === "left") {
                const p = typeof f.width == "number" ? f.width : parseInt(((c = f.width) == null ? void 0 : c.toString()) || "0") || 0;
                d += p;
              }
            }
            return d;
          };
          return /* @__PURE__ */ m.jsx(
            "th",
            {
              className: V(
                "text-sm text-wrap border-y p-4 text-left",
                s.header,
                {
                  "rounded-tl-md": a === 0,
                  "rounded-tr-md": a === o.length - 1,
                  "sticky z-30": !n && i.sticky,
                  "left-0": !n && i.sticky && i.stickyPosition === "left",
                  "right-0": !n && i.sticky && i.stickyPosition === "right"
                }
              ),
              style: {
                width: typeof i.width == "number" ? `${i.width}px` : i.width,
                minWidth: typeof i.width == "number" ? `${i.width}px` : i.width,
                left: !n && i.sticky && i.stickyPosition === "left" ? `${l()}px` : void 0
              },
              children: i.label
            },
            a
          );
        }) })
      }
    ),
    /* @__PURE__ */ m.jsx("tbody", { children: [...Array(5)].map((i, a) => /* @__PURE__ */ m.jsx(
      "tr",
      {
        className: V("p-3", {
          [s.stripe]: a % 2 !== 0,
          "bg-white": a % 2 === 0
        }),
        children: o.map((l, d) => {
          const c = () => {
            var f;
            if (!l.sticky || l.stickyPosition !== "left")
              return 0;
            let u = 0;
            for (let p = 0; p < d; p++) {
              const h = o[p];
              if (h.sticky && h.stickyPosition === "left") {
                const g = typeof h.width == "number" ? h.width : parseInt(((f = h.width) == null ? void 0 : f.toString()) || "0") || 0;
                u += g;
              }
            }
            return u;
          };
          return /* @__PURE__ */ m.jsx(
            "td",
            {
              className: V("text-left text-nowrap text-sm p-4", {
                "sticky z-10": l.sticky,
                "left-0": l.sticky && l.stickyPosition === "left",
                "right-0": l.sticky && l.stickyPosition === "right",
                // Ensure sticky columns have solid background that matches row
                "bg-white": l.sticky && (a % 2 === 0 || e === "default"),
                [s.stripe]: l.sticky && a % 2 !== 0 && e !== "default",
                [s.hoverStripe]: l.sticky,
                "border-b border-gray-200": e === "default"
              }),
              style: {
                width: typeof l.width == "number" ? `${l.width}px` : l.width,
                minWidth: typeof l.width == "number" ? `${l.width}px` : l.width,
                left: l.sticky && l.stickyPosition === "left" ? `${c()}px` : void 0
              },
              children: /* @__PURE__ */ m.jsx(jb, { className: "h-10 w-full rounded-md" })
            },
            `${a}-${d}`
          );
        })
      },
      a
    )) })
  ] }) }) });
}, Q7 = ({
  schema: t,
  data: e,
  className: r,
  headerClassName: n,
  rowClassName: o,
  cellClassName: s,
  emptyState: i,
  isLoading: a,
  loadingState: l,
  showIndex: d = !1,
  showIndexSticky: c = !1,
  onPageChange: u,
  onPageSizeChange: f,
  onSortChange: p,
  onRowClick: h,
  showPagination: g = !1,
  variant: b = "default",
  meta: y = {
    current_page: 1,
    total_page: 1,
    total_data: 0,
    limit_number: 10
  }
}) => {
  const [$, k] = de(() => {
    const F = t.find((v) => v.sortable && v.sort);
    return F ? [
      {
        id: F.accessorKey.toString(),
        desc: F.sort === "desc"
      }
    ] : [];
  }), [w, C] = de(!1);
  me(() => {
    const F = () => C(window.innerWidth < 768);
    return F(), window.addEventListener("resize", F), () => window.removeEventListener("resize", F);
  }, []);
  const T = le.useMemo(() => {
    const F = t.map((v) => ({
      accessorKey: v.accessorKey,
      header: v.label,
      enableSorting: !!v.sortable,
      cell: v.render ? ({ row: M }) => {
        var E;
        return (E = v.render) == null ? void 0 : E.call(v, M.original[v.accessorKey], M.original, M.index);
      } : ({ row: M }) => M.original[v.accessorKey] || "-",
      meta: {
        align: v.align || "left",
        width: v.width,
        sticky: v.sticky,
        stickyPosition: v.stickyPosition || "left"
      }
    }));
    return d ? [
      {
        accessorKey: "no",
        header: "No.",
        enableSorting: !1,
        cell: ({ row: v }) => (y.current_page - 1) * y.limit_number + v.index + 1,
        meta: {
          align: "left",
          width: 80,
          sticky: c,
          stickyPosition: "left"
        }
      },
      ...F
    ] : F;
  }, [t, d, c, y]), H = w1({
    data: e,
    columns: T,
    state: {
      sorting: $
    },
    onSortingChange: (F) => {
      const v = typeof F == "function" ? F($) : F;
      k(v), v.length > 0 ? p == null || p(v[0].desc ? "desc" : "asc", v[0].id) : p == null || p("", "");
    },
    getCoreRowModel: C1(),
    getSortedRowModel: E1(),
    getPaginationRowModel: k1(),
    manualPagination: !0,
    pageCount: y.total_page
  }), O = Vm(b);
  if (a)
    return l || /* @__PURE__ */ m.jsx(
      bw,
      {
        schema: t,
        variant: b,
        showIndexSticky: c,
        isMobile: w
      }
    );
  const j = (F, v, M) => {
    const E = F.target;
    E.tagName === "BUTTON" || E.tagName === "A" || E.tagName === "INPUT" || E.tagName === "SELECT" || E.closest("button") !== null || E.closest("a") !== null || E.closest("input") !== null || E.closest("select") !== null || h == null || h(v, M);
  };
  return /* @__PURE__ */ m.jsxs("div", { className: "bg-white rounded-md flex flex-col h-full max-h-[600px]", children: [
    /* @__PURE__ */ m.jsx("div", { className: "p-0 w-full overflow-auto rounded-t-md [&::-webkit-scrollbar]:w-2 [&::-webkit-scrollbar]:h-2 [&::-webkit-scrollbar-track]:bg-gray-100 [&::-webkit-scrollbar-thumb]:bg-gray-300 [&::-webkit-scrollbar-thumb]:rounded-full flex-1", children: /* @__PURE__ */ m.jsxs(
      "table",
      {
        className: V(
          "w-full border-spacing-0 border-separate min-w-full",
          r
        ),
        children: [
          /* @__PURE__ */ m.jsx(
            "thead",
            {
              className: V(
                "border-2 sticky top-0 z-20 rounded-t-md",
                O.border
              ),
              children: H.getHeaderGroups().map((F) => /* @__PURE__ */ m.jsx("tr", { children: F.headers.map(
                (v, M) => {
                  const E = v.column.columnDef.meta, N = () => {
                    var x;
                    if (w || !(E != null && E.sticky) || E.stickyPosition !== "left")
                      return 0;
                    let R = 0;
                    for (let P = 0; P < M; P++) {
                      const D = F.headers[P].column.columnDef.meta;
                      if (D != null && D.sticky && D.stickyPosition === "left") {
                        const L = typeof D.width == "number" ? D.width : parseInt(((x = D.width) == null ? void 0 : x.toString()) || "0") || 0;
                        R += L;
                      }
                    }
                    return R;
                  };
                  return /* @__PURE__ */ m.jsx(
                    "th",
                    {
                      className: V(
                        "text-sm text-wrap border-y p-4",
                        O.header,
                        {
                          "cursor-pointer": v.column.getCanSort(),
                          "rounded-tl-md": M === 0,
                          "rounded-tr-md": M === F.headers.length - 1,
                          "text-left": (E == null ? void 0 : E.align) === "left",
                          "text-center": (E == null ? void 0 : E.align) === "center",
                          "text-right": (E == null ? void 0 : E.align) === "right",
                          "sticky z-30": !w && (E == null ? void 0 : E.sticky),
                          "left-0": !w && (E == null ? void 0 : E.sticky) && E.stickyPosition === "left",
                          "right-0": !w && (E == null ? void 0 : E.sticky) && E.stickyPosition === "right"
                        },
                        n
                      ),
                      style: {
                        width: typeof (E == null ? void 0 : E.width) == "number" ? `${E.width}px` : E == null ? void 0 : E.width,
                        minWidth: typeof (E == null ? void 0 : E.width) == "number" ? `${E.width}px` : E == null ? void 0 : E.width,
                        left: !w && (E != null && E.sticky) && E.stickyPosition === "left" ? `${N()}px` : void 0
                      },
                      onClick: v.column.getCanSort() ? v.column.getToggleSortingHandler() : void 0,
                      children: /* @__PURE__ */ m.jsxs("div", { className: "flex items-center gap-2 relative z-10", children: [
                        /* @__PURE__ */ m.jsx(
                          "span",
                          {
                            className: V({
                              "font-semibold": M === 0
                            }),
                            children: jc(
                              v.column.columnDef.header,
                              v.getContext()
                            )
                          }
                        ),
                        v.column.getCanSort() && /* @__PURE__ */ m.jsx(
                          $e,
                          {
                            icon: v.column.getIsSorted() ? v.column.getIsSorted() === "desc" ? "mdi:keyboard-arrow-up" : "mdi:keyboard-arrow-down" : "mdi:unfold-more-horizontal",
                            className: V("h-4 w-4 flex-shrink-0", {
                              "text-white": b !== "ghost",
                              "text-gray-700": b === "ghost"
                            })
                          }
                        )
                      ] })
                    },
                    v.id
                  );
                }
              ) }, F.id))
            }
          ),
          /* @__PURE__ */ m.jsx("tbody", { children: H.getRowModel().rows.length === 0 ? /* @__PURE__ */ m.jsx("tr", { children: /* @__PURE__ */ m.jsx(
            "td",
            {
              colSpan: H.getAllColumns().length,
              className: V(
                "text-center border h-full w-full rounded-b-md"
              ),
              children: i || /* @__PURE__ */ m.jsxs("div", { className: "flex mx-auto w-full text-center justify-center gap-3 items-center", children: [
                /* @__PURE__ */ m.jsx("p", { children: "Data Not Found" }),
                /* @__PURE__ */ m.jsx($e, { icon: "mdi:face-frown-open", size: 34 })
              ] })
            }
          ) }) : H.getRowModel().rows.map((F, v) => /* @__PURE__ */ m.jsx(
            "tr",
            {
              className: V(
                "p-3 group",
                O.row,
                {
                  [O.stripe]: v % 2 !== 0,
                  "bg-white": v % 2 === 0,
                  "cursor-pointer": h
                },
                o
              ),
              onClick: (M) => j(M, F.original, v),
              children: F.getVisibleCells().map((M) => {
                const E = M.column.columnDef.meta, N = () => {
                  var I;
                  if (w || !(E != null && E.sticky) || E.stickyPosition !== "left")
                    return 0;
                  let R = 0;
                  const x = H.getAllColumns(), P = x.findIndex(
                    (D) => D.id === M.column.id
                  );
                  for (let D = 0; D < P; D++) {
                    const A = x[D].columnDef.meta;
                    if (A != null && A.sticky && A.stickyPosition === "left") {
                      const z = typeof A.width == "number" ? A.width : parseInt(((I = A.width) == null ? void 0 : I.toString()) || "0") || 0;
                      R += z;
                    }
                  }
                  return R;
                };
                return /* @__PURE__ */ m.jsx(
                  "td",
                  {
                    className: V(
                      "px-4 py-3 text-sm text-gray-900",
                      {
                        "text-left": (E == null ? void 0 : E.align) === "left",
                        "text-center": (E == null ? void 0 : E.align) === "center",
                        "text-right": (E == null ? void 0 : E.align) === "right",
                        "sticky z-10": !w && (E == null ? void 0 : E.sticky),
                        "left-0": !w && (E == null ? void 0 : E.sticky) && E.stickyPosition === "left",
                        "right-0": !w && (E == null ? void 0 : E.sticky) && E.stickyPosition === "right",
                        // Ensure sticky columns have solid background that matches row
                        "bg-white": !w && (E == null ? void 0 : E.sticky) && (v % 2 === 0 || b === "default"),
                        [O.stripe]: !w && (E == null ? void 0 : E.sticky) && v % 2 !== 0 && b !== "default",
                        [O.hoverStripe]: !w && (E == null ? void 0 : E.sticky),
                        "border-b border-gray-200": b === "default"
                      },
                      s
                    ),
                    style: {
                      width: typeof (E == null ? void 0 : E.width) == "number" ? `${E.width}px` : E == null ? void 0 : E.width,
                      minWidth: typeof (E == null ? void 0 : E.width) == "number" ? `${E.width}px` : E == null ? void 0 : E.width,
                      left: !w && (E != null && E.sticky) && E.stickyPosition === "left" ? `${N()}px` : void 0
                    },
                    children: jc(
                      M.column.columnDef.cell,
                      M.getContext()
                    )
                  },
                  M.id
                );
              })
            },
            F.id
          )) })
        ]
      }
    ) }),
    !!e.length && g && /* @__PURE__ */ m.jsx("div", { className: "p-4 bg-white rounded-b-md border-t border-gray-200 sticky bottom-0 z-10 flex-shrink-0", children: /* @__PURE__ */ m.jsx(
      Rb,
      {
        currentPage: y.current_page,
        totalPages: y.total_page,
        totalData: y.total_data,
        onPageChange: u || (() => {
        }),
        perPage: y.limit_number,
        onPerPageChange: f || (() => {
        }),
        perPageOptions: [5, 10, 20, 50, 100],
        siblingCount: 1
      }
    ) })
  ] });
}, yw = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  full: "rounded-full"
}, Wm = Oe(
  ({
    className: t,
    variant: e = "default",
    rounded: r = "lg",
    title: n,
    description: o,
    onClose: s,
    icon: i,
    showIcon: a = !0,
    showClose: l = !0,
    ...d
  }, c) => {
    const f = i || (a ? {
      default: "mdi:information",
      success: "mdi:check-circle",
      error: "mdi:alert-circle",
      warning: "mdi:alert",
      info: "mdi:information"
    }[e] : void 0), p = n || o;
    return /* @__PURE__ */ m.jsxs(
      "div",
      {
        ref: c,
        className: V(
          "flex",
          o ? "items-start gap-3 p-4" : "items-center gap-2 py-2.5 px-3",
          "border border-gray-200",
          yw[r],
          {
            "bg-white": e === "default",
            "bg-success-50": e === "success",
            "bg-danger-50": e === "error",
            "bg-warning-50": e === "warning",
            "bg-info-50": e === "info"
          },
          t
        ),
        ...d,
        children: [
          f && /* @__PURE__ */ m.jsx(
            $e,
            {
              icon: f,
              className: V(
                "flex-shrink-0",
                o ? "h-5 w-5 mt-0.5" : "h-4 w-4",
                {
                  "text-gray": e === "default",
                  "text-success": e === "success",
                  "text-danger": e === "error",
                  "text-warning": e === "warning",
                  "text-info": e === "info"
                }
              )
            }
          ),
          /* @__PURE__ */ m.jsxs("div", { className: "flex-1", children: [
            n && /* @__PURE__ */ m.jsx(
              "h3",
              {
                className: V("text-sm font-medium leading-5", {
                  "text-gray-900": e === "default",
                  "text-success-900": e === "success",
                  "text-danger-900": e === "error",
                  "text-warning-900": e === "warning",
                  "text-info-900": e === "info"
                }),
                children: n
              }
            ),
            o && /* @__PURE__ */ m.jsx(
              "p",
              {
                className: V(n ? "mt-1" : "", "text-sm leading-5", {
                  "text-gray": e === "default",
                  "text-success-700": e === "success",
                  "text-danger-700": e === "error",
                  "text-warning-700": e === "warning",
                  "text-info-700": e === "info"
                }),
                children: o
              }
            ),
            !p && /* @__PURE__ */ m.jsx("span", { className: "text-sm leading-5", children: d.children })
          ] }),
          l && s && /* @__PURE__ */ m.jsx(
            kt,
            {
              variant: "ghost",
              size: "sm",
              onClick: s,
              className: V(
                "flex-shrink-0 !p-1",
                o ? "ml-4" : "ml-2",
                {
                  "text-gray-400 hover:text-gray": e === "default",
                  "text-success-400 hover:text-success": e === "success",
                  "text-danger-400 hover:text-danger": e === "error",
                  "text-warning-400 hover:text-warning": e === "warning",
                  "text-info-400 hover:text-info": e === "info"
                }
              ),
              children: /* @__PURE__ */ m.jsx($e, { icon: "mdi:close", className: V(o ? "h-5 w-5" : "h-4 w-4") })
            }
          )
        ]
      }
    );
  }
);
Wm.displayName = "Toast";
const Fl = Ep(void 0), vw = {
  "top-left": "top-4 left-4",
  "top-right": "top-4 right-4",
  "bottom-left": "bottom-4 left-4",
  "bottom-right": "bottom-4 right-4",
  "top-center": "top-4 left-1/2 -translate-x-1/2",
  "bottom-center": "bottom-4 left-1/2 -translate-x-1/2"
}, eE = ({ children: t }) => {
  const [e, r] = de([]), n = we((a) => {
    r((l) => l.filter((d) => d.id !== a));
  }, []), o = we((a) => {
    const l = Math.random().toString(36).substr(2, 9), d = a.position || "top-right", c = a.duration || 5e3, u = {
      ...a,
      id: l,
      position: d
    };
    return r((f) => [...f, u]), c > 0 && setTimeout(() => {
      n(l);
    }, c), l;
  }, [n]), s = e.reduce((a, l) => (a[l.position] || (a[l.position] = []), a[l.position].push(l), a), {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": [],
    "top-center": [],
    "bottom-center": []
  }), i = wt();
  return "body" in i ? /* @__PURE__ */ m.jsxs(Fl.Provider, { value: { showToast: o, removeToast: n }, children: [
    t,
    Rn(
      /* @__PURE__ */ m.jsx(m.Fragment, { children: Object.entries(s).map(([a, l]) => /* @__PURE__ */ m.jsx(
        "div",
        {
          className: V(
            "fixed z-[100] flex flex-col gap-2 min-w-[320px] max-w-[420px]",
            vw[a],
            a.includes("bottom") ? "flex-col-reverse" : "flex-col"
          ),
          children: l.map((d) => /* @__PURE__ */ m.jsx(
            Wm,
            {
              ...d,
              onClose: () => n(d.id),
              className: "animate-slide-in"
            },
            d.id
          ))
        },
        a
      )) }),
      i.body
    )
  ] }) : /* @__PURE__ */ m.jsx(Fl.Provider, { value: { showToast: o, removeToast: n }, children: t });
}, tE = () => {
  const t = Qt(Fl);
  if (!t)
    throw new Error("useToast must be used within a ToastProvider");
  return t;
}, $w = {
  400: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "Bad request. Please check your input and try again."
  },
  401: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "Please sign in to access this resource."
  },
  403: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "You do not have permission to access this resource."
  },
  404: {
    image: "https://design-system-eaip.onrender.com/img/page-not-found.svg",
    message: "The page you are looking for does not exist."
  },
  500: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "Something went wrong on our end. Please try again later."
  },
  502: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "Bad gateway. Our servers are having trouble connecting."
  },
  503: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "Service unavailable. We are currently performing maintenance."
  },
  504: {
    image: "https://design-system-eaip.onrender.com/img/error.svg",
    message: "Gateway timeout. The server took too long to respond."
  }
}, Um = {
  PAGE_NOT_FOUND: {
    image: "https://design-system-eaip.onrender.com/img/page-not-found.svg",
    message: "The page you are looking for does not exist."
  },
  NO_INTERNET: {
    image: "https://design-system-eaip.onrender.com/img/no-internet.svg",
    message: "Please check your internet connection and try again."
  },
  DATA_NOT_FOUND: {
    image: "https://design-system-eaip.onrender.com/img/search-not-found.svg",
    message: "No data available for your request."
  },
  UNDER_DEVELOPMENT: {
    image: "https://design-system-eaip.onrender.com/img/under-development.svg",
    message: "This feature is currently under development."
  },
  INFORMATION_UNAVAILABLE: {
    image: "https://design-system-eaip.onrender.com/img/search-not-found.svg",
    message: "The requested information is currently unavailable."
  },
  PAYMENT_SUCCESS: {
    image: "https://design-system-eaip.onrender.com/img/payment-success.svg",
    message: "Operation completed successfully."
  },
  PAYMENT_FAILED: {
    image: "https://design-system-eaip.onrender.com/img/payment-failed.svg",
    message: "Payment failed. Please try again."
  },
  NO_ORDER: {
    image: "https://design-system-eaip.onrender.com/img/no-order.svg",
    message: "No order found."
  },
  TIMEOUT: {
    image: "https://design-system-eaip.onrender.com/img/timeout.svg",
    message: "Request timed out. Please try again."
  },
  ON_PROCESS: {
    image: "https://design-system-eaip.onrender.com/img/on-process.svg",
    message: "Your request is being processed. Please wait for a moment."
  }
}, xw = {
  "no-internet": "NO_INTERNET",
  "data-not-found": "DATA_NOT_FOUND",
  "under-development": "UNDER_DEVELOPMENT",
  "information-unavailable": "INFORMATION_UNAVAILABLE",
  "payment-success": "PAYMENT_SUCCESS",
  "payment-failed": "PAYMENT_FAILED",
  "no-order": "NO_ORDER",
  timeout: "TIMEOUT",
  "on-process": "ON_PROCESS",
  "page-not-found": "PAGE_NOT_FOUND"
}, af = {
  ...$w,
  ...Um
}, lf = {
  image: "https://design-system-eaip.onrender.com/img/error.svg",
  message: "An unexpected error occurred. Our team is currently investigating the issue."
}, df = (t) => typeof t == "object" && t !== null && ("code" in t || "message" in t), rE = ({
  error: t,
  reload: e,
  children: r,
  className: n = "",
  variant: o,
  customImage: s,
  customMessage: i
}) => {
  if (!t && !o)
    return r ? /* @__PURE__ */ m.jsx(m.Fragment, { children: r }) : null;
  const l = (() => {
    if (o) {
      const u = xw[o];
      return Um[u];
    }
    return df(t) && t.code && af[t.code] ? af[t.code] : lf;
  })(), d = s || l.image, c = i || (df(t) ? t.message : null) || l.message;
  return /* @__PURE__ */ m.jsxs("div", { className: `flex flex-col items-center justify-center p-8 text-center gap-4 ${n}`, children: [
    /* @__PURE__ */ m.jsx(
      "img",
      {
        src: d,
        alt: "Error illustration",
        className: "max-w-[300px] h-auto"
      }
    ),
    typeof c == "string" ? /* @__PURE__ */ m.jsx(Ho, { variant: "body1", className: "m-0", children: c }) : /* @__PURE__ */ m.jsx("div", { className: "m-0", children: c }),
    e && /* @__PURE__ */ m.jsx(
      kt,
      {
        onClick: e,
        rounded: "full",
        variant: "primary",
        size: "md",
        children: "Try Again"
      }
    )
  ] });
}, ww = ct(
  "border bg-white flex items-center justify-center aspect-square transition-colors placeholder:text-neutral placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 text-center",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 w-8 text-sm",
        md: "h-12 w-12 text-lg",
        lg: "h-16 w-16 text-xl"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "md"
    }
  }
), kw = Oe(
  ({
    className: t,
    variant: e = "default",
    size: r = "md",
    rounded: n = "md",
    error: o = !1,
    errorText: s,
    helperText: i,
    label: a,
    bottomLabel: l,
    required: d = !1,
    showSubmitButton: c = !1,
    submitButtonLabel: u = "Submit",
    submitButtonVariant: f = "primary",
    length: p = 6,
    numericOnly: h = !0,
    onComplete: g,
    onChange: b,
    onSubmit: y,
    value: $,
    defaultValue: k = "",
    disabled: w = !1,
    autoFocus: C = !1,
    ...T
  }, H) => {
    const [O, j] = de(k || ""), F = te([]);
    me(() => {
      $ !== void 0 && j($);
    }, [$]);
    const v = $ !== void 0, M = v ? $ : O, E = (A) => {
      v || j(A), b == null || b(A), A.length === p && (g == null || g(A), c || y == null || y(A));
    }, N = (A) => (z) => {
      F.current[A] = z;
    }, R = (A) => {
      A.target.select();
    }, x = (A, z) => {
      var _;
      const Y = A.target.value;
      let q = "";
      if (Y.length >= 1)
        q = Y.slice(-1);
      else if (Y.length === 0) {
        const W = M.split("");
        W[z] = "", E(W.join(""));
        return;
      }
      if (h && !/^\d$/.test(q))
        return;
      const ee = M.split("");
      for (; ee.length <= z; )
        ee.push("");
      ee[z] = q;
      const B = ee.join("");
      E(B), z < p - 1 && q && ((_ = F.current[z + 1]) == null || _.focus());
    }, P = (A, z) => {
      var Y, q, ee;
      if (A.key === "Backspace") {
        const B = M.split("");
        M[z] ? (A.preventDefault(), B[z] = "", E(B.join(""))) : z > 0 && (A.preventDefault(), B[z - 1] = "", E(B.join("")), (Y = F.current[z - 1]) == null || Y.focus());
      } else if (A.key === "Delete") {
        if (M[z]) {
          A.preventDefault();
          const B = M.split("");
          B[z] = "", E(B.join(""));
        }
      } else if (A.key === "ArrowLeft" && z > 0)
        A.preventDefault(), (q = F.current[z - 1]) == null || q.focus();
      else if (A.key === "ArrowRight" && z < p - 1)
        A.preventDefault(), (ee = F.current[z + 1]) == null || ee.focus();
      else if (!A.ctrlKey && !A.altKey && !A.metaKey && A.key.length === 1 && h && !/^\d$/.test(A.key)) {
        A.preventDefault();
        return;
      }
    }, I = (A) => {
      var B;
      A.preventDefault();
      const z = A.clipboardData.getData("text/plain").trim();
      if (h && !/^\d+$/.test(z))
        return;
      const q = z.slice(0, p).padEnd(M.length, "").slice(0, p);
      E(q);
      const ee = q.length < p ? q.length : p - 1;
      (B = F.current[ee]) == null || B.focus();
    }, D = () => {
      M.length === p && (y == null || y(M));
    }, L = M.split("").concat(Array(p - M.length).fill(""));
    return /* @__PURE__ */ m.jsxs("div", { ref: H, className: V("w-full", t), ...T, children: [
      a && /* @__PURE__ */ m.jsxs("label", { className: "mb-1.5 block text-sm text-neutral-900", children: [
        a,
        d && /* @__PURE__ */ m.jsx("span", { className: "text-danger ml-0.5", children: "*" })
      ] }),
      /* @__PURE__ */ m.jsxs("div", { className: "flex flex-col items-center space-y-4", children: [
        /* @__PURE__ */ m.jsx("div", { className: "flex items-center justify-center gap-2", children: Array.from({ length: p }).map((A, z) => /* @__PURE__ */ m.jsx(
          "input",
          {
            ref: N(z),
            type: h ? "tel" : "text",
            inputMode: h ? "numeric" : "text",
            maxLength: 1,
            value: L[z] || "",
            onChange: (Y) => x(Y, z),
            onKeyDown: (Y) => P(Y, z),
            onPaste: z === 0 ? I : void 0,
            onFocus: R,
            disabled: w,
            autoFocus: C && z === 0,
            className: V(
              ww({
                variant: o ? "error" : e,
                size: r,
                rounded: n
              })
            ),
            "aria-invalid": o
          },
          z
        )) }),
        o && s && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-danger self-start", children: s }),
        !o && i && /* @__PURE__ */ m.jsx("p", { className: "mt-1 text-xs text-neutral self-start", children: i }),
        l && /* @__PURE__ */ m.jsx("p", { className: "text-sm text-neutral-600", children: l }),
        c && /* @__PURE__ */ m.jsx(
          kt,
          {
            variant: f,
            disabled: M.length !== p || w,
            onClick: D,
            className: "mt-4",
            children: u
          }
        )
      ] })
    ] });
  }
);
kw.displayName = "InputOTP";
const cf = {
  primary: "#007C99",
  // tailwind primary.DEFAULT
  secondary: "#CEEAE7",
  // tailwind secondary.DEFAULT
  danger: "#CA0000",
  // tailwind danger.DEFAULT
  warning: "#FF9319",
  // tailwind warning.DEFAULT
  info: "#0073E6",
  // tailwind info.DEFAULT
  success: "#00B37D",
  // tailwind success.DEFAULT
  disabled: "#959595"
  // tailwind disabled.DEFAULT
}, nE = ({
  icon: t,
  className: e,
  color: r = "primary",
  value: n,
  maxValue: o = 99,
  children: s,
  ...i
}) => {
  const a = "top-0 right-0", l = typeof n == "number" && !isNaN(n);
  let d = "";
  l && (n > o ? d = `${o}+` : d = String(n));
  const c = l ? "px-2" : "", u = l ? "min-w-[20px]" : "w-2.5 h-2.5", f = l ? "h-5" : "h-2.5", p = typeof r == "string" && r in cf ? cf[r] : r;
  return /* @__PURE__ */ m.jsxs("div", { className: V("relative inline-block", e), children: [
    s || (t ? /* @__PURE__ */ m.jsx($e, { icon: t, color: p, size: 32, ...i }) : null),
    /* @__PURE__ */ m.jsx(
      "span",
      {
        className: V(
          "absolute flex items-center justify-center rounded-xl bg-[#FF4C4C] text-white text-[10px] font-semibold",
          a,
          c,
          u,
          f,
          !l && "p-0",
          !l && "rounded-full"
        ),
        style: {
          transform: "translate(50%,-50%)"
        },
        children: l ? d : ""
      }
    )
  ] });
}, Ew = {
  FLIGHT_LIGHT: {
    image: "https://design-system-eaip.onrender.com/img/flight-loader-light.gif",
    message: "Loading, please wait..."
  },
  FLIGHT_DARK: {
    image: "https://design-system-eaip.onrender.com/img/flight-loader-dark.gif",
    message: "Loading, please wait..."
  },
  "TIXIA-CIRCULAR": {
    image: "https://design-system-eaip.onrender.com/img/tixia-circular.gif",
    message: "Loading, please wait..."
  },
  "TIXIA-LINEAR": {
    image: "https://design-system-eaip.onrender.com/img/tixia-linear.gif",
    message: "Loading, please wait..."
  },
  "HOTEL-LOADER": {
    image: "https://design-system-eaip.onrender.com/img/hotel-loader.gif",
    message: "Loading, please wait..."
  }
}, Cw = {
  "flight-light": "FLIGHT_LIGHT",
  "flight-dark": "FLIGHT_DARK",
  "tixia-circular": "TIXIA-CIRCULAR",
  "tixia-linear": "TIXIA-LINEAR",
  "hotel-loader": "HOTEL-LOADER"
}, ks = (t, e) => t === void 0 ? { className: e } : typeof t == "number" ? {
  className: "",
  style: { width: `${t}px`, height: `${t}px` }
} : { className: t }, oE = ({
  variant: t,
  customImage: e,
  customMessage: r,
  width: n = "w-full",
  height: o = "h-full",
  widthImg: s = "w-auto",
  heightImg: i = "h-auto",
  className: a = ""
}) => {
  const l = Cw[t], d = Ew[l], c = ks(n, "w-full"), u = ks(o, "h-full"), f = ks(s, "w-auto"), p = ks(i, "h-auto");
  return /* @__PURE__ */ m.jsxs(
    "div",
    {
      className: `flex flex-col items-center justify-center p-8 text-center gap-4 ${c.className} ${u.className} ${a}`,
      style: { ...c.style, ...u.style },
      children: [
        /* @__PURE__ */ m.jsx(
          "img",
          {
            src: e || d.image,
            alt: "Loading animation",
            className: `${f.className} ${p.className}`,
            style: { ...f.style, ...p.style }
          }
        ),
        r ? typeof r == "string" ? /* @__PURE__ */ m.jsx(Ho, { variant: "body1", className: "m-0", children: r }) : /* @__PURE__ */ m.jsx("div", { className: "m-0", children: r }) : /* @__PURE__ */ m.jsx(Ho, { variant: "body1", className: "m-0", children: d.message })
      ]
    }
  );
}, Sw = {
  PAGE_NOT_FOUND: {
    image: "https://design-system-eaip.onrender.com/img/page-not-found.svg",
    message: "The page you are looking for does not exist."
  },
  PAGE_NOT_FOUND_V2: {
    image: "https://design-system-eaip.onrender.com/img/page-not-found-v2.svg",
    message: "The page you are looking for does not exist."
  },
  NO_INTERNET: {
    image: "https://design-system-eaip.onrender.com/img/no-internet.svg",
    message: "Please check your internet connection and try again."
  },
  DATA_NOT_FOUND: {
    image: "https://design-system-eaip.onrender.com/img/search-not-found.svg",
    message: "No data available for your request."
  },
  UNDER_DEVELOPMENT: {
    image: "https://design-system-eaip.onrender.com/img/under-development.svg",
    message: "This feature is currently under development."
  },
  INFORMATION_UNAVAILABLE: {
    image: "https://design-system-eaip.onrender.com/img/search-not-found.svg",
    message: "The requested information is currently unavailable."
  },
  PAYMENT_SUCCESS: {
    image: "https://design-system-eaip.onrender.com/img/payment-success.svg",
    message: "Operation completed successfully."
  },
  PAYMENT_FAILED: {
    image: "https://design-system-eaip.onrender.com/img/payment-failed.svg",
    message: "Payment failed. Please try again."
  },
  NO_ORDER: {
    image: "https://design-system-eaip.onrender.com/img/no-order.svg",
    message: "No order found."
  },
  TIMEOUT: {
    image: "https://design-system-eaip.onrender.com/img/timeout.svg",
    message: "Request timed out. Please try again."
  },
  ON_PROCESS: {
    image: "https://design-system-eaip.onrender.com/img/on-process.svg",
    message: "Your request is being processed. Please wait for a moment."
  },
  NO_SEAT_AVAILABLE: {
    image: "https://design-system-eaip.onrender.com/img/seat-not-available.svg",
    message: "No seat available. Please try again later."
  },
  CHANGE_PRICE: {
    image: "https://design-system-eaip.onrender.com/img/change-price.svg",
    message: "The price has been changed. Please try again."
  },
  HELP_DESK: {
    image: "https://design-system-eaip.onrender.com/img/help-desk.svg",
    message: "Please contact our help desk for assistance."
  },
  APPROVED: {
    image: "https://design-system-eaip.onrender.com/img/approved.svg",
    message: "Your request has been approved."
  },
  REJECTED: {
    image: "https://design-system-eaip.onrender.com/img/rejected.svg",
    message: "Your request has been rejected."
  }
}, Nw = {
  "no-internet": "NO_INTERNET",
  "data-not-found": "DATA_NOT_FOUND",
  "under-development": "UNDER_DEVELOPMENT",
  "information-unavailable": "INFORMATION_UNAVAILABLE",
  "payment-success": "PAYMENT_SUCCESS",
  "payment-failed": "PAYMENT_FAILED",
  "no-order": "NO_ORDER",
  timeout: "TIMEOUT",
  "on-process": "ON_PROCESS",
  "page-not-found": "PAGE_NOT_FOUND",
  "page-not-found-v2": "PAGE_NOT_FOUND_V2",
  "no-seat-available": "NO_SEAT_AVAILABLE",
  "change-price": "CHANGE_PRICE",
  "help-desk": "HELP_DESK",
  approved: "APPROVED",
  rejected: "REJECTED"
}, sE = ({
  variant: t,
  customMessage: e,
  reload: r,
  reloadText: n = "Try Again",
  customImage: o,
  width: s,
  height: i,
  className: a = ""
}) => {
  const l = Nw[t], d = Sw[l];
  return /* @__PURE__ */ m.jsxs(
    "div",
    {
      className: `flex flex-col items-center justify-center p-8 text-center gap-4 ${a}`,
      children: [
        /* @__PURE__ */ m.jsx(
          "img",
          {
            src: o || d.image,
            alt: "Negative case illustration",
            className: "max-w-[300px] h-auto",
            style: { width: s, height: i }
          }
        ),
        e ? typeof e == "string" ? /* @__PURE__ */ m.jsx(Ho, { variant: "body1", className: "m-0", children: e }) : /* @__PURE__ */ m.jsx("div", { className: "m-0", children: e }) : /* @__PURE__ */ m.jsx(Ho, { variant: "body1", className: "m-0", children: d.message }),
        r && /* @__PURE__ */ m.jsx(kt, { onClick: r, rounded: "full", variant: "primary", size: "md", children: n })
      ]
    }
  );
}, Tw = ({
  children: t,
  delay: e = 0,
  index: r,
  onMouseEnter: n,
  onClick: o
}) => {
  const s = te(null), i = $1(s, { amount: 0.5 });
  return /* @__PURE__ */ m.jsx(
    x1.div,
    {
      ref: s,
      "data-index": r,
      onMouseEnter: n,
      onClick: o,
      initial: { scale: 0.7, opacity: 0 },
      animate: i ? { scale: 1, opacity: 1 } : { scale: 0.7, opacity: 0 },
      transition: { duration: 0.2, delay: e },
      style: { marginBottom: "1rem", cursor: "pointer" },
      children: t
    }
  );
}, iE = ({
  items: t,
  children: e,
  onItemSelect: r,
  showGradients: n = !1,
  enableArrowNavigation: o = !1,
  className: s = "",
  itemClassName: i = "",
  displayScrollbar: a = !0,
  initialSelectedIndex: l = -1
}) => {
  const d = te(null), [c, u] = de(l), [f, p] = de(!1), [h, g] = de(0), [b, y] = de(1), $ = Ye(() => e ? le.Children.toArray(e) : t || [], [e, t]), k = Ye(() => !!e, [e]), w = (C) => {
    const { scrollTop: T, scrollHeight: H, clientHeight: O } = C.currentTarget;
    g(Math.min(T / 50, 1));
    const j = H - (T + O);
    y(
      H <= O ? 0 : Math.min(j / 50, 1)
    );
  };
  return me(() => {
    if (!o) return;
    const C = (T) => {
      T.key === "ArrowDown" || T.key === "Tab" && !T.shiftKey ? (T.preventDefault(), p(!0), u((H) => Math.min(H + 1, $.length - 1))) : T.key === "ArrowUp" || T.key === "Tab" && T.shiftKey ? (T.preventDefault(), p(!0), u((H) => Math.max(H - 1, 0))) : T.key === "Enter" && c >= 0 && c < $.length && (T.preventDefault(), r && r($[c], c));
    };
    return window.addEventListener("keydown", C), () => window.removeEventListener("keydown", C);
  }, [$, c, r, o]), me(() => {
    if (!f || c < 0 || !d.current) return;
    const C = d.current, T = C.querySelector(
      `[data-index="${c}"]`
    );
    if (T) {
      const O = C.scrollTop, j = C.clientHeight, F = T.offsetTop, v = F + T.offsetHeight;
      F < O + 50 ? C.scrollTo({ top: F - 50, behavior: "smooth" }) : v > O + j - 50 && C.scrollTo({
        top: v - j + 50,
        behavior: "smooth"
      });
    }
    p(!1);
  }, [c, f]), /* @__PURE__ */ m.jsxs("div", { className: `scroll-list-container ${s}`, children: [
    /* @__PURE__ */ m.jsx(
      "div",
      {
        ref: d,
        className: `scroll-list ${a ? "" : "no-scrollbar"}`,
        onScroll: w,
        children: $.map((C, T) => /* @__PURE__ */ m.jsx(
          Tw,
          {
            delay: 0.1,
            index: T,
            onMouseEnter: () => u(T),
            onClick: () => {
              u(T), r && r(C, T);
            },
            children: k ? /* @__PURE__ */ m.jsx(
              "div",
              {
                className: `${c === T ? "selected" : ""} ${i}`,
                children: C
              }
            ) : /* @__PURE__ */ m.jsx(
              "div",
              {
                className: `border border-gray-200 rounded-md p-2 w-full hover:bg-gray-300 ${c === T ? "selected" : ""} ${i}`,
                children: /* @__PURE__ */ m.jsx("p", { className: "item-text", children: C })
              }
            )
          },
          T
        ))
      }
    ),
    n && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "div",
        {
          className: "top-gradient",
          style: { opacity: h }
        }
      ),
      /* @__PURE__ */ m.jsx(
        "div",
        {
          className: "bottom-gradient",
          style: { opacity: b }
        }
      )
    ] })
  ] });
};
function $t(t) {
  this.content = t;
}
$t.prototype = {
  constructor: $t,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, r) {
    var n = r && r != t ? this.remove(r) : this, o = n.find(t), s = n.content.slice();
    return o == -1 ? s.push(r || t, e) : (s[o + 1] = e, r && (s[o] = r)), new $t(s);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var r = this.content.slice();
    return r.splice(e, 2), new $t(r);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new $t([t, e].concat(this.remove(t).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var r = this.remove(t).content.slice();
    return r.push(t, e), new $t(r);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, r) {
    var n = this.remove(e), o = n.content.slice(), s = n.find(t);
    return o.splice(s == -1 ? o.length : s, 0, e, r), new $t(o);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = $t.from(t), t.size ? new $t(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = $t.from(t), t.size ? new $t(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = $t.from(t);
    for (var r = 0; r < t.content.length; r += 2)
      e = e.remove(t.content[r]);
    return e;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, r) {
      t[e] = r;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
$t.from = function(t) {
  if (t instanceof $t) return t;
  var e = [];
  if (t) for (var r in t) e.push(r, t[r]);
  return new $t(e);
};
function Gm(t, e, r) {
  for (let n = 0; ; n++) {
    if (n == t.childCount || n == e.childCount)
      return t.childCount == e.childCount ? null : r;
    let o = t.child(n), s = e.child(n);
    if (o == s) {
      r += o.nodeSize;
      continue;
    }
    if (!o.sameMarkup(s))
      return r;
    if (o.isText && o.text != s.text) {
      for (let i = 0; o.text[i] == s.text[i]; i++)
        r++;
      return r;
    }
    if (o.content.size || s.content.size) {
      let i = Gm(o.content, s.content, r + 1);
      if (i != null)
        return i;
    }
    r += o.nodeSize;
  }
}
function Km(t, e, r, n) {
  for (let o = t.childCount, s = e.childCount; ; ) {
    if (o == 0 || s == 0)
      return o == s ? null : { a: r, b: n };
    let i = t.child(--o), a = e.child(--s), l = i.nodeSize;
    if (i == a) {
      r -= l, n -= l;
      continue;
    }
    if (!i.sameMarkup(a))
      return { a: r, b: n };
    if (i.isText && i.text != a.text) {
      let d = 0, c = Math.min(i.text.length, a.text.length);
      for (; d < c && i.text[i.text.length - d - 1] == a.text[a.text.length - d - 1]; )
        d++, r--, n--;
      return { a: r, b: n };
    }
    if (i.content.size || a.content.size) {
      let d = Km(i.content, a.content, r - 1, n - 1);
      if (d)
        return d;
    }
    r -= l, n -= l;
  }
}
class U {
  /**
  @internal
  */
  constructor(e, r) {
    if (this.content = e, this.size = r || 0, r == null)
      for (let n = 0; n < e.length; n++)
        this.size += e[n].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, r, n, o = 0, s) {
    for (let i = 0, a = 0; a < r; i++) {
      let l = this.content[i], d = a + l.nodeSize;
      if (d > e && n(l, o + a, s || null, i) !== !1 && l.content.size) {
        let c = a + 1;
        l.nodesBetween(Math.max(0, e - c), Math.min(l.content.size, r - c), n, o + c);
      }
      a = d;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, r, n, o) {
    let s = "", i = !0;
    return this.nodesBetween(e, r, (a, l) => {
      let d = a.isText ? a.text.slice(Math.max(e, l) - l, r - l) : a.isLeaf ? o ? typeof o == "function" ? o(a) : o : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && d || a.isTextblock) && n && (i ? i = !1 : s += n), s += d;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let r = this.lastChild, n = e.firstChild, o = this.content.slice(), s = 0;
    for (r.isText && r.sameMarkup(n) && (o[o.length - 1] = r.withText(r.text + n.text), s = 1); s < e.content.length; s++)
      o.push(e.content[s]);
    return new U(o, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, r = this.size) {
    if (e == 0 && r == this.size)
      return this;
    let n = [], o = 0;
    if (r > e)
      for (let s = 0, i = 0; i < r; s++) {
        let a = this.content[s], l = i + a.nodeSize;
        l > e && ((i < e || l > r) && (a.isText ? a = a.cut(Math.max(0, e - i), Math.min(a.text.length, r - i)) : a = a.cut(Math.max(0, e - i - 1), Math.min(a.content.size, r - i - 1))), n.push(a), o += a.nodeSize), i = l;
      }
    return new U(n, o);
  }
  /**
  @internal
  */
  cutByIndex(e, r) {
    return e == r ? U.empty : e == 0 && r == this.content.length ? this : new U(this.content.slice(e, r));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, r) {
    let n = this.content[e];
    if (n == r)
      return this;
    let o = this.content.slice(), s = this.size + r.nodeSize - n.nodeSize;
    return o[e] = r, new U(o, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new U([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new U(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let r = 0; r < this.content.length; r++)
      if (!this.content[r].eq(e.content[r]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let r = this.content[e];
    if (!r)
      throw new RangeError("Index " + e + " out of range for " + this);
    return r;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let r = 0, n = 0; r < this.content.length; r++) {
      let o = this.content[r];
      e(o, n, r), n += o.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, r = 0) {
    return Gm(this, e, r);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, r = this.size, n = e.size) {
    return Km(this, e, r, n);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return Es(0, e);
    if (e == this.size)
      return Es(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, n = 0; ; r++) {
      let o = this.child(r), s = n + o.nodeSize;
      if (s >= e)
        return s == e ? Es(r + 1, s) : Es(r, n);
      n = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, r) {
    if (!r)
      return U.empty;
    if (!Array.isArray(r))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new U(r.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return U.empty;
    let r, n = 0;
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      n += s.nodeSize, o && s.isText && e[o - 1].sameMarkup(s) ? (r || (r = e.slice(0, o)), r[r.length - 1] = s.withText(r[r.length - 1].text + s.text)) : r && r.push(s);
    }
    return new U(r || e, n);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return U.empty;
    if (e instanceof U)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new U([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
U.empty = new U([], 0);
const Fa = { index: 0, offset: 0 };
function Es(t, e) {
  return Fa.index = t, Fa.offset = e, Fa;
}
function ii(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let r = Array.isArray(t);
  if (Array.isArray(e) != r)
    return !1;
  if (r) {
    if (t.length != e.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (!ii(t[n], e[n]))
        return !1;
  } else {
    for (let n in t)
      if (!(n in e) || !ii(t[n], e[n]))
        return !1;
    for (let n in e)
      if (!(n in t))
        return !1;
  }
  return !0;
}
let Ke = class zl {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.attrs = r;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let r, n = !1;
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        r || (r = e.slice(0, o));
      else {
        if (s.type.excludes(this.type))
          return e;
        !n && s.type.rank > this.type.rank && (r || (r = e.slice(0, o)), r.push(this), n = !0), r && r.push(s);
      }
    }
    return r || (r = e.slice()), n || r.push(this), r;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let r = 0; r < e.length; r++)
      if (this.eq(e[r]))
        return e.slice(0, r).concat(e.slice(r + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let r = 0; r < e.length; r++)
      if (this.eq(e[r]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && ii(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let r in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, r) {
    if (!r)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let n = e.marks[r.type];
    if (!n)
      throw new RangeError(`There is no mark type ${r.type} in this schema`);
    let o = n.create(r.attrs);
    return n.checkAttrs(o.attrs), o;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, r) {
    if (e == r)
      return !0;
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++)
      if (!e[n].eq(r[n]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return zl.none;
    if (e instanceof zl)
      return [e];
    let r = e.slice();
    return r.sort((n, o) => n.type.rank - o.type.rank), r;
  }
};
Ke.none = [];
class ai extends Error {
}
class X {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, r, n) {
    this.content = e, this.openStart = r, this.openEnd = n;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, r) {
    let n = Jm(this.content, e + this.openStart, r);
    return n && new X(n, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, r) {
    return new X(Ym(this.content, e + this.openStart, r + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, r) {
    if (!r)
      return X.empty;
    let n = r.openStart || 0, o = r.openEnd || 0;
    if (typeof n != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new X(U.fromJSON(e, r.content), n, o);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, r = !0) {
    let n = 0, o = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (r || !s.type.spec.isolating); s = s.firstChild)
      n++;
    for (let s = e.lastChild; s && !s.isLeaf && (r || !s.type.spec.isolating); s = s.lastChild)
      o++;
    return new X(e, n, o);
  }
}
X.empty = new X(U.empty, 0, 0);
function Ym(t, e, r) {
  let { index: n, offset: o } = t.findIndex(e), s = t.maybeChild(n), { index: i, offset: a } = t.findIndex(r);
  if (o == e || s.isText) {
    if (a != r && !t.child(i).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(r));
  }
  if (n != i)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(n, s.copy(Ym(s.content, e - o - 1, r - o - 1)));
}
function Jm(t, e, r, n) {
  let { index: o, offset: s } = t.findIndex(e), i = t.maybeChild(o);
  if (s == e || i.isText)
    return n && !n.canReplace(o, o, r) ? null : t.cut(0, e).append(r).append(t.cut(e));
  let a = Jm(i.content, e - s - 1, r, i);
  return a && t.replaceChild(o, i.copy(a));
}
function Aw(t, e, r) {
  if (r.openStart > t.depth)
    throw new ai("Inserted content deeper than insertion position");
  if (t.depth - r.openStart != e.depth - r.openEnd)
    throw new ai("Inconsistent open depths");
  return qm(t, e, r, 0);
}
function qm(t, e, r, n) {
  let o = t.index(n), s = t.node(n);
  if (o == e.index(n) && n < t.depth - r.openStart) {
    let i = qm(t, e, r, n + 1);
    return s.copy(s.content.replaceChild(o, i));
  } else if (r.content.size)
    if (!r.openStart && !r.openEnd && t.depth == n && e.depth == n) {
      let i = t.parent, a = i.content;
      return vn(i, a.cut(0, t.parentOffset).append(r.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: i, end: a } = Mw(r, t);
      return vn(s, Zm(t, i, a, e, n));
    }
  else return vn(s, li(t, e, n));
}
function Xm(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new ai("Cannot join " + e.type.name + " onto " + t.type.name);
}
function Hl(t, e, r) {
  let n = t.node(r);
  return Xm(n, e.node(r)), n;
}
function yn(t, e) {
  let r = e.length - 1;
  r >= 0 && t.isText && t.sameMarkup(e[r]) ? e[r] = t.withText(e[r].text + t.text) : e.push(t);
}
function Io(t, e, r, n) {
  let o = (e || t).node(r), s = 0, i = e ? e.index(r) : o.childCount;
  t && (s = t.index(r), t.depth > r ? s++ : t.textOffset && (yn(t.nodeAfter, n), s++));
  for (let a = s; a < i; a++)
    yn(o.child(a), n);
  e && e.depth == r && e.textOffset && yn(e.nodeBefore, n);
}
function vn(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function Zm(t, e, r, n, o) {
  let s = t.depth > o && Hl(t, e, o + 1), i = n.depth > o && Hl(r, n, o + 1), a = [];
  return Io(null, t, o, a), s && i && e.index(o) == r.index(o) ? (Xm(s, i), yn(vn(s, Zm(t, e, r, n, o + 1)), a)) : (s && yn(vn(s, li(t, e, o + 1)), a), Io(e, r, o, a), i && yn(vn(i, li(r, n, o + 1)), a)), Io(n, null, o, a), new U(a);
}
function li(t, e, r) {
  let n = [];
  if (Io(null, t, r, n), t.depth > r) {
    let o = Hl(t, e, r + 1);
    yn(vn(o, li(t, e, r + 1)), n);
  }
  return Io(e, null, r, n), new U(n);
}
function Mw(t, e) {
  let r = e.depth - t.openStart, o = e.node(r).copy(t.content);
  for (let s = r - 1; s >= 0; s--)
    o = e.node(s).copy(U.from(o));
  return {
    start: o.resolveNoCache(t.openStart + r),
    end: o.resolveNoCache(o.content.size - t.openEnd - r)
  };
}
class Jo {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.pos = e, this.path = r, this.parentOffset = n, this.depth = r.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, r = this.index(this.depth);
    if (r == e.childCount)
      return null;
    let n = this.pos - this.path[this.path.length - 1], o = e.child(r);
    return n ? e.child(r).cut(n) : o;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), r = this.pos - this.path[this.path.length - 1];
    return r ? this.parent.child(e).cut(0, r) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, r) {
    r = this.resolveDepth(r);
    let n = this.path[r * 3], o = r == 0 ? 0 : this.path[r * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      o += n.child(s).nodeSize;
    return o;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, r = this.index();
    if (e.content.size == 0)
      return Ke.none;
    if (this.textOffset)
      return e.child(r).marks;
    let n = e.maybeChild(r - 1), o = e.maybeChild(r);
    if (!n) {
      let a = n;
      n = o, o = a;
    }
    let s = n.marks;
    for (var i = 0; i < s.length; i++)
      s[i].type.spec.inclusive === !1 && (!o || !s[i].isInSet(o.marks)) && (s = s[i--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let r = this.parent.maybeChild(this.index());
    if (!r || !r.isInline)
      return null;
    let n = r.marks, o = e.parent.maybeChild(e.index());
    for (var s = 0; s < n.length; s++)
      n[s].type.spec.inclusive === !1 && (!o || !n[s].isInSet(o.marks)) && (n = n[s--].removeFromSet(n));
    return n;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let r = this.depth; r > 0; r--)
      if (this.start(r) <= e && this.end(r) >= e)
        return r;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, r) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)
      if (e.pos <= this.end(n) && (!r || r(this.node(n))))
        return new di(this, e, n);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 1; r <= this.depth; r++)
      e += (e ? "/" : "") + this.node(r).type.name + "_" + this.index(r - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, r) {
    if (!(r >= 0 && r <= e.content.size))
      throw new RangeError("Position " + r + " out of range");
    let n = [], o = 0, s = r;
    for (let i = e; ; ) {
      let { index: a, offset: l } = i.content.findIndex(s), d = s - l;
      if (n.push(i, a, o + l), !d || (i = i.child(a), i.isText))
        break;
      s = d - 1, o += l + 1;
    }
    return new Jo(r, n, s);
  }
  /**
  @internal
  */
  static resolveCached(e, r) {
    let n = uf.get(e);
    if (n)
      for (let s = 0; s < n.elts.length; s++) {
        let i = n.elts[s];
        if (i.pos == r)
          return i;
      }
    else
      uf.set(e, n = new Pw());
    let o = n.elts[n.i] = Jo.resolve(e, r);
    return n.i = (n.i + 1) % Iw, o;
  }
}
class Pw {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const Iw = 12, uf = /* @__PURE__ */ new WeakMap();
class di {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, r, n) {
    this.$from = e, this.$to = r, this.depth = n;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const Rw = /* @__PURE__ */ Object.create(null);
let $n = class Bl {
  /**
  @internal
  */
  constructor(e, r, n, o = Ke.none) {
    this.type = e, this.attrs = r, this.marks = o, this.content = n || U.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, r, n, o = 0) {
    this.content.nodesBetween(e, r, n, o, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, r, n, o) {
    return this.content.textBetween(e, r, n, o);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, r, n) {
    return this.type == e && ii(this.attrs, r || e.defaultAttrs || Rw) && Ke.sameSet(this.marks, n || Ke.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Bl(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Bl(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, r = this.content.size) {
    return e == 0 && r == this.content.size ? this : this.copy(this.content.cut(e, r));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, r = this.content.size, n = !1) {
    if (e == r)
      return X.empty;
    let o = this.resolve(e), s = this.resolve(r), i = n ? 0 : o.sharedDepth(r), a = o.start(i), d = o.node(i).content.cut(o.pos - a, s.pos - a);
    return new X(d, o.depth - i, s.depth - i);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, r, n) {
    return Aw(this.resolve(e), this.resolve(r), n);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let r = this; ; ) {
      let { index: n, offset: o } = r.content.findIndex(e);
      if (r = r.maybeChild(n), !r)
        return null;
      if (o == e || r.isText)
        return r;
      e -= o + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: r, offset: n } = this.content.findIndex(e);
    return { node: this.content.maybeChild(r), index: r, offset: n };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: r, offset: n } = this.content.findIndex(e);
    if (n < e)
      return { node: this.content.child(r), index: r, offset: n };
    let o = this.content.child(r - 1);
    return { node: o, index: r - 1, offset: n - o.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Jo.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Jo.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, r, n) {
    let o = !1;
    return r > e && this.nodesBetween(e, r, (s) => (n.isInSet(s.marks) && (o = !0), !o)), o;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Qm(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let r = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!r)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return r;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, r, n = U.empty, o = 0, s = n.childCount) {
    let i = this.contentMatchAt(e).matchFragment(n, o, s), a = i && i.matchFragment(this.content, r);
    if (!a || !a.validEnd)
      return !1;
    for (let l = o; l < s; l++)
      if (!this.type.allowsMarks(n.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, r, n, o) {
    if (o && !this.type.allowsMarks(o))
      return !1;
    let s = this.contentMatchAt(e).matchType(n), i = s && s.matchFragment(this.content, r);
    return i ? i.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Ke.none;
    for (let r = 0; r < this.marks.length; r++) {
      let n = this.marks[r];
      n.type.checkAttrs(n.attrs), e = n.addToSet(e);
    }
    if (!Ke.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((r) => r.type.name)}`);
    this.content.forEach((r) => r.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let r in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((r) => r.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, r) {
    if (!r)
      throw new RangeError("Invalid input for Node.fromJSON");
    let n;
    if (r.marks) {
      if (!Array.isArray(r.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      n = r.marks.map(e.markFromJSON);
    }
    if (r.type == "text") {
      if (typeof r.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(r.text, n);
    }
    let o = U.fromJSON(e, r.content), s = e.nodeType(r.type).create(r.attrs, o, n);
    return s.type.checkAttrs(s.attrs), s;
  }
};
$n.prototype.text = void 0;
class ci extends $n {
  /**
  @internal
  */
  constructor(e, r, n, o) {
    if (super(e, r, null, o), !n)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = n;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Qm(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, r) {
    return this.text.slice(e, r);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new ci(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new ci(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, r = this.text.length) {
    return e == 0 && r == this.text.length ? this : this.withText(this.text.slice(e, r));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function Qm(t, e) {
  for (let r = t.length - 1; r >= 0; r--)
    e = t[r].type.name + "(" + e + ")";
  return e;
}
class Sn {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, r) {
    let n = new Ow(e, r);
    if (n.next == null)
      return Sn.empty;
    let o = e0(n);
    n.next && n.err("Unexpected trailing text");
    let s = Hw(zw(o));
    return Bw(s, n), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let r = 0; r < this.next.length; r++)
      if (this.next[r].type == e)
        return this.next[r].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, r = 0, n = e.childCount) {
    let o = this;
    for (let s = r; o && s < n; s++)
      o = o.matchType(e.child(s).type);
    return o;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: r } = this.next[e];
      if (!(r.isText || r.hasRequiredAttrs()))
        return r;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let r = 0; r < this.next.length; r++)
      for (let n = 0; n < e.next.length; n++)
        if (this.next[r].type == e.next[n].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, r = !1, n = 0) {
    let o = [this];
    function s(i, a) {
      let l = i.matchFragment(e, n);
      if (l && (!r || l.validEnd))
        return U.from(a.map((d) => d.createAndFill()));
      for (let d = 0; d < i.next.length; d++) {
        let { type: c, next: u } = i.next[d];
        if (!(c.isText || c.hasRequiredAttrs()) && o.indexOf(u) == -1) {
          o.push(u);
          let f = s(u, a.concat(c));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let n = 0; n < this.wrapCache.length; n += 2)
      if (this.wrapCache[n] == e)
        return this.wrapCache[n + 1];
    let r = this.computeWrapping(e);
    return this.wrapCache.push(e, r), r;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let r = /* @__PURE__ */ Object.create(null), n = [{ match: this, type: null, via: null }];
    for (; n.length; ) {
      let o = n.shift(), s = o.match;
      if (s.matchType(e)) {
        let i = [];
        for (let a = o; a.type; a = a.via)
          i.push(a.type);
        return i.reverse();
      }
      for (let i = 0; i < s.next.length; i++) {
        let { type: a, next: l } = s.next[i];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in r) && (!o.type || l.validEnd) && (n.push({ match: a.contentMatch, type: a, via: o }), r[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function r(n) {
      e.push(n);
      for (let o = 0; o < n.next.length; o++)
        e.indexOf(n.next[o].next) == -1 && r(n.next[o].next);
    }
    return r(this), e.map((n, o) => {
      let s = o + (n.validEnd ? "*" : " ") + " ";
      for (let i = 0; i < n.next.length; i++)
        s += (i ? ", " : "") + n.next[i].type.name + "->" + e.indexOf(n.next[i].next);
      return s;
    }).join(`
`);
  }
}
Sn.empty = new Sn(!0);
class Ow {
  constructor(e, r) {
    this.string = e, this.nodeTypes = r, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function e0(t) {
  let e = [];
  do
    e.push(Lw(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function Lw(t) {
  let e = [];
  do
    e.push(jw(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function jw(t) {
  let e = Fw(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = Dw(t, e);
    else
      break;
  return e;
}
function ff(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function Dw(t, e) {
  let r = ff(t), n = r;
  return t.eat(",") && (t.next != "}" ? n = ff(t) : n = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: r, max: n, expr: e };
}
function _w(t, e) {
  let r = t.nodeTypes, n = r[e];
  if (n)
    return [n];
  let o = [];
  for (let s in r) {
    let i = r[s];
    i.isInGroup(e) && o.push(i);
  }
  return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function Fw(t) {
  if (t.eat("(")) {
    let e = e0(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = _w(t, t.next).map((r) => (t.inline == null ? t.inline = r.isInline : t.inline != r.isInline && t.err("Mixing inline and block content"), { type: "name", value: r }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function zw(t) {
  let e = [[]];
  return o(s(t, 0), r()), e;
  function r() {
    return e.push([]) - 1;
  }
  function n(i, a, l) {
    let d = { term: l, to: a };
    return e[i].push(d), d;
  }
  function o(i, a) {
    i.forEach((l) => l.to = a);
  }
  function s(i, a) {
    if (i.type == "choice")
      return i.exprs.reduce((l, d) => l.concat(s(d, a)), []);
    if (i.type == "seq")
      for (let l = 0; ; l++) {
        let d = s(i.exprs[l], a);
        if (l == i.exprs.length - 1)
          return d;
        o(d, a = r());
      }
    else if (i.type == "star") {
      let l = r();
      return n(a, l), o(s(i.expr, l), l), [n(l)];
    } else if (i.type == "plus") {
      let l = r();
      return o(s(i.expr, a), l), o(s(i.expr, l), l), [n(l)];
    } else {
      if (i.type == "opt")
        return [n(a)].concat(s(i.expr, a));
      if (i.type == "range") {
        let l = a;
        for (let d = 0; d < i.min; d++) {
          let c = r();
          o(s(i.expr, l), c), l = c;
        }
        if (i.max == -1)
          o(s(i.expr, l), l);
        else
          for (let d = i.min; d < i.max; d++) {
            let c = r();
            n(l, c), o(s(i.expr, l), c), l = c;
          }
        return [n(l)];
      } else {
        if (i.type == "name")
          return [n(a, void 0, i.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function t0(t, e) {
  return e - t;
}
function pf(t, e) {
  let r = [];
  return n(e), r.sort(t0);
  function n(o) {
    let s = t[o];
    if (s.length == 1 && !s[0].term)
      return n(s[0].to);
    r.push(o);
    for (let i = 0; i < s.length; i++) {
      let { term: a, to: l } = s[i];
      !a && r.indexOf(l) == -1 && n(l);
    }
  }
}
function Hw(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return r(pf(t, 0));
  function r(n) {
    let o = [];
    n.forEach((i) => {
      t[i].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let d;
        for (let c = 0; c < o.length; c++)
          o[c][0] == a && (d = o[c][1]);
        pf(t, l).forEach((c) => {
          d || o.push([a, d = []]), d.indexOf(c) == -1 && d.push(c);
        });
      });
    });
    let s = e[n.join(",")] = new Sn(n.indexOf(t.length - 1) > -1);
    for (let i = 0; i < o.length; i++) {
      let a = o[i][1].sort(t0);
      s.next.push({ type: o[i][0], next: e[a.join(",")] || r(a) });
    }
    return s;
  }
}
function Bw(t, e) {
  for (let r = 0, n = [t]; r < n.length; r++) {
    let o = n[r], s = !o.validEnd, i = [];
    for (let a = 0; a < o.next.length; a++) {
      let { type: l, next: d } = o.next[a];
      i.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), n.indexOf(d) == -1 && n.push(d);
    }
    s && e.err("Only non-generatable nodes (" + i.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function r0(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    if (!n.hasDefault)
      return null;
    e[r] = n.default;
  }
  return e;
}
function n0(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let o = e && e[n];
    if (o === void 0) {
      let s = t[n];
      if (s.hasDefault)
        o = s.default;
      else
        throw new RangeError("No value supplied for attribute " + n);
    }
    r[n] = o;
  }
  return r;
}
function o0(t, e, r, n) {
  for (let o in e)
    if (!(o in t))
      throw new RangeError(`Unsupported attribute ${o} for ${r} of type ${o}`);
  for (let o in t) {
    let s = t[o];
    s.validate && s.validate(e[o]);
  }
}
function s0(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let n in e)
      r[n] = new Ww(t, n, e[n]);
  return r;
}
let hf = class i0 {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.name = e, this.schema = r, this.spec = n, this.markSet = null, this.groups = n.group ? n.group.split(" ") : [], this.attrs = s0(e, n.attrs), this.defaultAttrs = r0(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(n.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Sn.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : n0(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, r, n) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new $n(this, this.computeAttrs(e), U.from(r), Ke.setFrom(n));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, r, n) {
    return r = U.from(r), this.checkContent(r), new $n(this, this.computeAttrs(e), r, Ke.setFrom(n));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, r, n) {
    if (e = this.computeAttrs(e), r = U.from(r), r.size) {
      let i = this.contentMatch.fillBefore(r);
      if (!i)
        return null;
      r = i.append(r);
    }
    let o = this.contentMatch.matchFragment(r), s = o && o.fillBefore(U.empty, !0);
    return s ? new $n(this, e, r.append(s), Ke.setFrom(n)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let r = this.contentMatch.matchFragment(e);
    if (!r || !r.validEnd)
      return !1;
    for (let n = 0; n < e.childCount; n++)
      if (!this.allowsMarks(e.child(n).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    o0(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let r = 0; r < e.length; r++)
      if (!this.allowsMarkType(e[r].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let r;
    for (let n = 0; n < e.length; n++)
      this.allowsMarkType(e[n].type) ? r && r.push(e[n]) : r || (r = e.slice(0, n));
    return r ? r.length ? r : Ke.none : e;
  }
  /**
  @internal
  */
  static compile(e, r) {
    let n = /* @__PURE__ */ Object.create(null);
    e.forEach((s, i) => n[s] = new i0(s, r, i));
    let o = r.spec.topNode || "doc";
    if (!n[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!n.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in n.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return n;
  }
};
function Vw(t, e, r) {
  let n = r.split("|");
  return (o) => {
    let s = o === null ? "null" : typeof o;
    if (n.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${n} for attribute ${e} on type ${t}, got ${s}`);
  };
}
class Ww {
  constructor(e, r, n) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default"), this.default = n.default, this.validate = typeof n.validate == "string" ? Vw(e, r, n.validate) : n.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class aa {
  /**
  @internal
  */
  constructor(e, r, n, o) {
    this.name = e, this.rank = r, this.schema = n, this.spec = o, this.attrs = s0(e, o.attrs), this.excluded = null;
    let s = r0(this.attrs);
    this.instance = s ? new Ke(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Ke(this, n0(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, r) {
    let n = /* @__PURE__ */ Object.create(null), o = 0;
    return e.forEach((s, i) => n[s] = new aa(s, o++, r, i)), n;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var r = 0; r < e.length; r++)
      e[r].type == this && (e = e.slice(0, r).concat(e.slice(r + 1)), r--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let r = 0; r < e.length; r++)
      if (e[r].type == this)
        return e[r];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    o0(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Uw {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let r = this.spec = {};
    for (let o in e)
      r[o] = e[o];
    r.nodes = $t.from(e.nodes), r.marks = $t.from(e.marks || {}), this.nodes = hf.compile(this.spec.nodes, this), this.marks = aa.compile(this.spec.marks, this);
    let n = /* @__PURE__ */ Object.create(null);
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark");
      let s = this.nodes[o], i = s.spec.content || "", a = s.spec.marks;
      if (s.contentMatch = n[i] || (n[i] = Sn.parse(i, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = a == "_" ? null : a ? mf(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let o in this.marks) {
      let s = this.marks[o], i = s.spec.excludes;
      s.excluded = i == null ? [s] : i == "" ? [] : mf(this, i.split(" "));
    }
    this.nodeFromJSON = (o) => $n.fromJSON(this, o), this.markFromJSON = (o) => Ke.fromJSON(this, o), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, r = null, n, o) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof hf) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(r, n, o);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, r) {
    let n = this.nodes.text;
    return new ci(n, n.defaultAttrs, e, Ke.setFrom(r));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, r) {
    return typeof e == "string" && (e = this.marks[e]), e.create(r);
  }
  /**
  @internal
  */
  nodeType(e) {
    let r = this.nodes[e];
    if (!r)
      throw new RangeError("Unknown node type: " + e);
    return r;
  }
}
function mf(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++) {
    let o = e[n], s = t.marks[o], i = s;
    if (s)
      r.push(s);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (o == "_" || l.spec.group && l.spec.group.split(" ").indexOf(o) > -1) && r.push(i = l);
      }
    if (!i)
      throw new SyntaxError("Unknown mark type: '" + e[n] + "'");
  }
  return r;
}
function Gw(t) {
  return t.tag != null;
}
function Kw(t) {
  return t.style != null;
}
class xn {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, r) {
    this.schema = e, this.rules = r, this.tags = [], this.styles = [];
    let n = this.matchedStyles = [];
    r.forEach((o) => {
      if (Gw(o))
        this.tags.push(o);
      else if (Kw(o)) {
        let s = /[^=]*/.exec(o.style)[0];
        n.indexOf(s) < 0 && n.push(s), this.styles.push(o);
      }
    }), this.normalizeLists = !this.tags.some((o) => {
      if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
        return !1;
      let s = e.nodes[o.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, r = {}) {
    let n = new bf(this, r, !1);
    return n.addAll(e, Ke.none, r.from, r.to), n.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, r = {}) {
    let n = new bf(this, r, !0);
    return n.addAll(e, Ke.none, r.from, r.to), X.maxOpen(n.finish());
  }
  /**
  @internal
  */
  matchTag(e, r, n) {
    for (let o = n ? this.tags.indexOf(n) + 1 : 0; o < this.tags.length; o++) {
      let s = this.tags[o];
      if (qw(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || r.matchesContext(s.context))) {
        if (s.getAttrs) {
          let i = s.getAttrs(e);
          if (i === !1)
            continue;
          s.attrs = i || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, r, n, o) {
    for (let s = o ? this.styles.indexOf(o) + 1 : 0; s < this.styles.length; s++) {
      let i = this.styles[s], a = i.style;
      if (!(a.indexOf(e) != 0 || i.context && !n.matchesContext(i.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != r))) {
        if (i.getAttrs) {
          let l = i.getAttrs(r);
          if (l === !1)
            continue;
          i.attrs = l || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let r = [];
    function n(o) {
      let s = o.priority == null ? 50 : o.priority, i = 0;
      for (; i < r.length; i++) {
        let a = r[i];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      r.splice(i, 0, o);
    }
    for (let o in e.marks) {
      let s = e.marks[o].spec.parseDOM;
      s && s.forEach((i) => {
        n(i = yf(i)), i.mark || i.ignore || i.clearMark || (i.mark = o);
      });
    }
    for (let o in e.nodes) {
      let s = e.nodes[o].spec.parseDOM;
      s && s.forEach((i) => {
        n(i = yf(i)), i.node || i.ignore || i.mark || (i.node = o);
      });
    }
    return r;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new xn(e, xn.schemaRules(e)));
  }
}
const a0 = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, Yw = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, l0 = { ol: !0, ul: !0 }, qo = 1, Vl = 2, Ro = 4;
function gf(t, e, r) {
  return e != null ? (e ? qo : 0) | (e === "full" ? Vl : 0) : t && t.whitespace == "pre" ? qo | Vl : r & ~Ro;
}
class Cs {
  constructor(e, r, n, o, s, i) {
    this.type = e, this.attrs = r, this.marks = n, this.solid = o, this.options = i, this.content = [], this.activeMarks = Ke.none, this.match = s || (i & Ro ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let r = this.type.contentMatch.fillBefore(U.from(e));
      if (r)
        this.match = this.type.contentMatch.matchFragment(r);
      else {
        let n = this.type.contentMatch, o;
        return (o = n.findWrapping(e.type)) ? (this.match = n, o) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & qo)) {
      let n = this.content[this.content.length - 1], o;
      if (n && n.isText && (o = /[ \t\r\n\u000c]+$/.exec(n.text))) {
        let s = n;
        n.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - o[0].length));
      }
    }
    let r = U.from(this.content);
    return !e && this.match && (r = r.append(this.match.fillBefore(U.empty, !0))), this.type ? this.type.create(this.attrs, r, this.marks) : r;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !a0.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class bf {
  constructor(e, r, n) {
    this.parser = e, this.options = r, this.isOpen = n, this.open = 0, this.localPreserveWS = !1;
    let o = r.topNode, s, i = gf(null, r.preserveWhitespace, 0) | (n ? Ro : 0);
    o ? s = new Cs(o.type, o.attrs, Ke.none, !0, r.topMatch || o.type.contentMatch, i) : n ? s = new Cs(null, null, Ke.none, !0, null, i) : s = new Cs(e.schema.topNodeType, null, Ke.none, !0, null, i), this.nodes = [s], this.find = r.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, r) {
    e.nodeType == 3 ? this.addTextNode(e, r) : e.nodeType == 1 && this.addElement(e, r);
  }
  addTextNode(e, r) {
    let n = e.nodeValue, o = this.top, s = o.options & Vl ? "full" : this.localPreserveWS || (o.options & qo) > 0, { schema: i } = this.parser;
    if (s === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
      if (s)
        if (s === "full")
          n = n.replace(/\r\n?/g, `
`);
        else if (i.linebreakReplacement && /[\r\n]/.test(n) && this.top.findWrapping(i.linebreakReplacement.create())) {
          let a = n.split(/\r?\n|\r/);
          for (let l = 0; l < a.length; l++)
            l && this.insertNode(i.linebreakReplacement.create(), r, !0), a[l] && this.insertNode(i.text(a[l]), r, !/\S/.test(a[l]));
          n = "";
        } else
          n = n.replace(/\r?\n|\r/g, " ");
      else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
        let a = o.content[o.content.length - 1], l = e.previousSibling;
        (!a || l && l.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (n = n.slice(1));
      }
      n && this.insertNode(i.text(n), r, !/\S/.test(n)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, r, n) {
    let o = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let i = e.nodeName.toLowerCase(), a;
    l0.hasOwnProperty(i) && this.parser.normalizeLists && Jw(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, n));
    e: if (l ? l.ignore : Yw.hasOwnProperty(i))
      this.findInside(e), this.ignoreFallback(e, r);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let d, c = this.needsBlock;
      if (a0.hasOwnProperty(i))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), d = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, r);
        break e;
      }
      let u = l && l.skip ? r : this.readStyles(e, r);
      u && this.addAll(e, u), d && this.sync(s), this.needsBlock = c;
    } else {
      let d = this.readStyles(e, r);
      d && this.addElementByRule(e, l, d, l.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = o;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, r) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), r);
  }
  // Called for ignored nodes
  ignoreFallback(e, r) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), r, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, r) {
    let n = e.style;
    if (n && n.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let s = this.parser.matchedStyles[o], i = n.getPropertyValue(s);
        if (i)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(s, i, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? r = r.filter((d) => !l.clearMark(d)) : r = r.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return r;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, r, n, o) {
    let s, i;
    if (r.node)
      if (i = this.parser.schema.nodes[r.node], i.isLeaf)
        this.insertNode(i.create(r.attrs), n, e.nodeName == "BR") || this.leafFallback(e, n);
      else {
        let l = this.enter(i, r.attrs || null, n, r.preserveWhitespace);
        l && (s = !0, n = l);
      }
    else {
      let l = this.parser.schema.marks[r.mark];
      n = n.concat(l.create(r.attrs));
    }
    let a = this.top;
    if (i && i.isLeaf)
      this.findInside(e);
    else if (o)
      this.addElement(e, n, o);
    else if (r.getContent)
      this.findInside(e), r.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, n, !1));
    else {
      let l = e;
      typeof r.contentElement == "string" ? l = e.querySelector(r.contentElement) : typeof r.contentElement == "function" ? l = r.contentElement(e) : r.contentElement && (l = r.contentElement), this.findAround(e, l, !0), this.addAll(l, n), this.findAround(e, l, !1);
    }
    s && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, r, n, o) {
    let s = n || 0;
    for (let i = n ? e.childNodes[n] : e.firstChild, a = o == null ? null : e.childNodes[o]; i != a; i = i.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(i, r);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, r, n) {
    let o, s;
    for (let i = this.open, a = 0; i >= 0; i--) {
      let l = this.nodes[i], d = l.findWrapping(e);
      if (d && (!o || o.length > d.length + a) && (o = d, s = l, !d.length))
        break;
      if (l.solid) {
        if (n)
          break;
        a += 2;
      }
    }
    if (!o)
      return null;
    this.sync(s);
    for (let i = 0; i < o.length; i++)
      r = this.enterInner(o[i], null, r, !1);
    return r;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, r, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (r = this.enterInner(s, null, r));
    }
    let o = this.findPlace(e, r, n);
    if (o) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let i = Ke.none;
      for (let a of o.concat(e.marks))
        (s.type ? s.type.allowsMarkType(a.type) : vf(a.type, e.type)) && (i = a.addToSet(i));
      return s.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, r, n, o) {
    let s = this.findPlace(e.create(r), n, !1);
    return s && (s = this.enterInner(e, r, n, !0, o)), s;
  }
  // Open a node of the given type
  enterInner(e, r, n, o = !1, s) {
    this.closeExtra();
    let i = this.top;
    i.match = i.match && i.match.matchType(e);
    let a = gf(e, s, i.options);
    i.options & Ro && i.content.length == 0 && (a |= Ro);
    let l = Ke.none;
    return n = n.filter((d) => (i.type ? i.type.allowsMarkType(d.type) : vf(d.type, e)) ? (l = d.addToSet(l), !1) : !0), this.nodes.push(new Cs(e, r, l, o, null, a)), this.open++, n;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let r = this.nodes.length - 1;
    if (r > this.open) {
      for (; r > this.open; r--)
        this.nodes[r - 1].content.push(this.nodes[r].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let r = this.open; r >= 0; r--) {
      if (this.nodes[r] == e)
        return this.open = r, !0;
      this.localPreserveWS && (this.nodes[r].options |= qo);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let r = this.open; r >= 0; r--) {
      let n = this.nodes[r].content;
      for (let o = n.length - 1; o >= 0; o--)
        e += n[o].nodeSize;
      r && e++;
    }
    return e;
  }
  findAtPoint(e, r) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && this.find[n].offset == r && (this.find[n].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && (this.find[r].pos = this.currentPos);
  }
  findAround(e, r, n) {
    if (e != r && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && r.compareDocumentPosition(this.find[o].node) & (n ? 2 : 4) && (this.find[o].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && (this.find[r].pos = this.currentPos - (e.nodeValue.length - this.find[r].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let r = e.split("/"), n = this.options.context, o = !this.isOpen && (!n || n.parent.type == this.nodes[0].type), s = -(n ? n.depth + 1 : 0) + (o ? 0 : 1), i = (a, l) => {
      for (; a >= 0; a--) {
        let d = r[a];
        if (d == "") {
          if (a == r.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (i(a - 1, l))
              return !0;
          return !1;
        } else {
          let c = l > 0 || l == 0 && o ? this.nodes[l].type : n && l >= s ? n.node(l - s).type : null;
          if (!c || c.name != d && !c.isInGroup(d))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return i(r.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let r = e.depth; r >= 0; r--) {
        let n = e.node(r).contentMatchAt(e.indexAfter(r)).defaultType;
        if (n && n.isTextblock && n.defaultAttrs)
          return n;
      }
    for (let r in this.parser.schema.nodes) {
      let n = this.parser.schema.nodes[r];
      if (n.isTextblock && n.defaultAttrs)
        return n;
    }
  }
}
function Jw(t) {
  for (let e = t.firstChild, r = null; e; e = e.nextSibling) {
    let n = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    n && l0.hasOwnProperty(n) && r ? (r.appendChild(e), e = r) : n == "li" ? r = e : n && (r = null);
  }
}
function qw(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function yf(t) {
  let e = {};
  for (let r in t)
    e[r] = t[r];
  return e;
}
function vf(t, e) {
  let r = e.schema.nodes;
  for (let n in r) {
    let o = r[n];
    if (!o.allowsMarkType(t))
      continue;
    let s = [], i = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: d, next: c } = a.edge(l);
        if (d == e || s.indexOf(c) < 0 && i(c))
          return !0;
      }
    };
    if (i(o.contentMatch))
      return !0;
  }
}
class la {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, r) {
    this.nodes = e, this.marks = r;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, r = {}, n) {
    n || (n = za(r).createDocumentFragment());
    let o = n, s = [];
    return e.forEach((i) => {
      if (s.length || i.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < i.marks.length; ) {
          let d = i.marks[l];
          if (!this.marks[d.type.name]) {
            l++;
            continue;
          }
          if (!d.eq(s[a][0]) || d.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          o = s.pop()[1];
        for (; l < i.marks.length; ) {
          let d = i.marks[l++], c = this.serializeMark(d, i.isInline, r);
          c && (s.push([d, o]), o.appendChild(c.dom), o = c.contentDOM || c.dom);
        }
      }
      o.appendChild(this.serializeNodeInner(i, r));
    }), n;
  }
  /**
  @internal
  */
  serializeNodeInner(e, r) {
    let { dom: n, contentDOM: o } = Fs(za(r), this.nodes[e.type.name](e), null, e.attrs);
    if (o) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, r, o);
    }
    return n;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, r = {}) {
    let n = this.serializeNodeInner(e, r);
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let s = this.serializeMark(e.marks[o], e.isInline, r);
      s && ((s.contentDOM || s.dom).appendChild(n), n = s.dom);
    }
    return n;
  }
  /**
  @internal
  */
  serializeMark(e, r, n = {}) {
    let o = this.marks[e.type.name];
    return o && Fs(za(n), o(e, r), null, e.attrs);
  }
  static renderSpec(e, r, n = null, o) {
    return Fs(e, r, n, o);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new la(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let r = $f(e.nodes);
    return r.text || (r.text = (n) => n.text), r;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return $f(e.marks);
  }
}
function $f(t) {
  let e = {};
  for (let r in t) {
    let n = t[r].spec.toDOM;
    n && (e[r] = n);
  }
  return e;
}
function za(t) {
  return t.document || window.document;
}
const xf = /* @__PURE__ */ new WeakMap();
function Xw(t) {
  let e = xf.get(t);
  return e === void 0 && xf.set(t, e = Zw(t)), e;
}
function Zw(t) {
  let e = null;
  function r(n) {
    if (n && typeof n == "object")
      if (Array.isArray(n))
        if (typeof n[0] == "string")
          e || (e = []), e.push(n);
        else
          for (let o = 0; o < n.length; o++)
            r(n[o]);
      else
        for (let o in n)
          r(n[o]);
  }
  return r(t), e;
}
function Fs(t, e, r, n) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let o = e[0], s;
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (n && (s = Xw(n)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let i = o.indexOf(" ");
  i > 0 && (r = o.slice(0, i), o = o.slice(i + 1));
  let a, l = r ? t.createElementNS(r, o) : t.createElement(o), d = e[1], c = 1;
  if (d && typeof d == "object" && d.nodeType == null && !Array.isArray(d)) {
    c = 2;
    for (let u in d)
      if (d[u] != null) {
        let f = u.indexOf(" ");
        f > 0 ? l.setAttributeNS(u.slice(0, f), u.slice(f + 1), d[u]) : u == "style" && l.style ? l.style.cssText = d[u] : l.setAttribute(u, d[u]);
      }
  }
  for (let u = c; u < e.length; u++) {
    let f = e[u];
    if (f === 0) {
      if (u < e.length - 1 || u > c)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: h } = Fs(t, f, r, n);
      if (l.appendChild(p), h) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = h;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const d0 = 65535, c0 = Math.pow(2, 16);
function Qw(t, e) {
  return t + e * c0;
}
function wf(t) {
  return t & d0;
}
function e4(t) {
  return (t - (t & d0)) / c0;
}
const u0 = 1, f0 = 2, zs = 4, p0 = 8;
class Wl {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.pos = e, this.delInfo = r, this.recover = n;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & p0) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (u0 | zs)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (f0 | zs)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & zs) > 0;
  }
}
class _t {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, r = !1) {
    if (this.ranges = e, this.inverted = r, !e.length && _t.empty)
      return _t.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let r = 0, n = wf(e);
    if (!this.inverted)
      for (let o = 0; o < n; o++)
        r += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
    return this.ranges[n * 3] + r + e4(e);
  }
  mapResult(e, r = 1) {
    return this._map(e, r, !1);
  }
  map(e, r = 1) {
    return this._map(e, r, !0);
  }
  /**
  @internal
  */
  _map(e, r, n) {
    let o = 0, s = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? o : 0);
      if (l > e)
        break;
      let d = this.ranges[a + s], c = this.ranges[a + i], u = l + d;
      if (e <= u) {
        let f = d ? e == l ? -1 : e == u ? 1 : r : r, p = l + o + (f < 0 ? 0 : c);
        if (n)
          return p;
        let h = e == (r < 0 ? l : u) ? null : Qw(a / 3, e - l), g = e == l ? f0 : e == u ? u0 : zs;
        return (r < 0 ? e != l : e != u) && (g |= p0), new Wl(p, g, h);
      }
      o += c - d;
    }
    return n ? e + o : new Wl(e + o, 0, null);
  }
  /**
  @internal
  */
  touches(e, r) {
    let n = 0, o = wf(r), s = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? n : 0);
      if (l > e)
        break;
      let d = this.ranges[a + s], c = l + d;
      if (e <= c && a == o * 3)
        return !0;
      n += this.ranges[a + i] - d;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let r = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2;
    for (let o = 0, s = 0; o < this.ranges.length; o += 3) {
      let i = this.ranges[o], a = i - (this.inverted ? s : 0), l = i + (this.inverted ? 0 : s), d = this.ranges[o + r], c = this.ranges[o + n];
      e(a, a + d, l, l + c), s += c - d;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _t(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? _t.empty : new _t(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
_t.empty = new _t([]);
class Xo {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, r, n = 0, o = e ? e.length : 0) {
    this.mirror = r, this.from = n, this.to = o, this._maps = e || [], this.ownData = !(e || r);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, r = this.maps.length) {
    return new Xo(this._maps, this.mirror, e, r);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, r) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), r != null && this.setMirror(this._maps.length - 1, r);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let r = 0, n = this._maps.length; r < e._maps.length; r++) {
      let o = e.getMirror(r);
      this.appendMap(e._maps[r], o != null && o < r ? n + o : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let r = 0; r < this.mirror.length; r++)
        if (this.mirror[r] == e)
          return this.mirror[r + (r % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, r) {
    this.mirror || (this.mirror = []), this.mirror.push(e, r);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let r = e.maps.length - 1, n = this._maps.length + e._maps.length; r >= 0; r--) {
      let o = e.getMirror(r);
      this.appendMap(e._maps[r].invert(), o != null && o > r ? n - o - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Xo();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, r = 1) {
    if (this.mirror)
      return this._map(e, r, !0);
    for (let n = this.from; n < this.to; n++)
      e = this._maps[n].map(e, r);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, r = 1) {
    return this._map(e, r, !1);
  }
  /**
  @internal
  */
  _map(e, r, n) {
    let o = 0;
    for (let s = this.from; s < this.to; s++) {
      let i = this._maps[s], a = i.mapResult(e, r);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this._maps[l].recover(a.recover);
          continue;
        }
      }
      o |= a.delInfo, e = a.pos;
    }
    return n ? e : new Wl(e, o, null);
  }
}
const Ha = /* @__PURE__ */ Object.create(null);
class Nt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return _t.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, r) {
    if (!r || !r.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let n = Ha[r.stepType];
    if (!n)
      throw new RangeError(`No step type ${r.stepType} defined`);
    return n.fromJSON(e, r);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, r) {
    if (e in Ha)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Ha[e] = r, r.prototype.jsonID = e, r;
  }
}
class it {
  /**
  @internal
  */
  constructor(e, r) {
    this.doc = e, this.failed = r;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new it(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new it(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, r, n, o) {
    try {
      return it.ok(e.replace(r, n, o));
    } catch (s) {
      if (s instanceof ai)
        return it.fail(s.message);
      throw s;
    }
  }
}
function Ud(t, e, r) {
  let n = [];
  for (let o = 0; o < t.childCount; o++) {
    let s = t.child(o);
    s.content.size && (s = s.copy(Ud(s.content, e, s))), s.isInline && (s = e(s, r, o)), n.push(s);
  }
  return U.fromArray(n);
}
class qr extends Nt {
  /**
  Create a mark step.
  */
  constructor(e, r, n) {
    super(), this.from = e, this.to = r, this.mark = n;
  }
  apply(e) {
    let r = e.slice(this.from, this.to), n = e.resolve(this.from), o = n.node(n.sharedDepth(this.to)), s = new X(Ud(r.content, (i, a) => !i.isAtom || !a.type.allowsMarkType(this.mark.type) ? i : i.mark(this.mark.addToSet(i.marks)), o), r.openStart, r.openEnd);
    return it.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new tr(this.from, this.to, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
    return r.deleted && n.deleted || r.pos >= n.pos ? null : new qr(r.pos, n.pos, this.mark);
  }
  merge(e) {
    return e instanceof qr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new qr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new qr(r.from, r.to, e.markFromJSON(r.mark));
  }
}
Nt.jsonID("addMark", qr);
class tr extends Nt {
  /**
  Create a mark-removing step.
  */
  constructor(e, r, n) {
    super(), this.from = e, this.to = r, this.mark = n;
  }
  apply(e) {
    let r = e.slice(this.from, this.to), n = new X(Ud(r.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), r.openStart, r.openEnd);
    return it.fromReplace(e, this.from, this.to, n);
  }
  invert() {
    return new qr(this.from, this.to, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
    return r.deleted && n.deleted || r.pos >= n.pos ? null : new tr(r.pos, n.pos, this.mark);
  }
  merge(e) {
    return e instanceof tr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new tr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new tr(r.from, r.to, e.markFromJSON(r.mark));
  }
}
Nt.jsonID("removeMark", tr);
class Xr extends Nt {
  /**
  Create a node mark step.
  */
  constructor(e, r) {
    super(), this.pos = e, this.mark = r;
  }
  apply(e) {
    let r = e.nodeAt(this.pos);
    if (!r)
      return it.fail("No node at mark step's position");
    let n = r.type.create(r.attrs, null, this.mark.addToSet(r.marks));
    return it.fromReplace(e, this.pos, this.pos + 1, new X(U.from(n), 0, r.isLeaf ? 0 : 1));
  }
  invert(e) {
    let r = e.nodeAt(this.pos);
    if (r) {
      let n = this.mark.addToSet(r.marks);
      if (n.length == r.marks.length) {
        for (let o = 0; o < r.marks.length; o++)
          if (!r.marks[o].isInSet(n))
            return new Xr(this.pos, r.marks[o]);
        return new Xr(this.pos, this.mark);
      }
    }
    return new Nn(this.pos, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.pos, 1);
    return r.deletedAfter ? null : new Xr(r.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Xr(r.pos, e.markFromJSON(r.mark));
  }
}
Nt.jsonID("addNodeMark", Xr);
class Nn extends Nt {
  /**
  Create a mark-removing step.
  */
  constructor(e, r) {
    super(), this.pos = e, this.mark = r;
  }
  apply(e) {
    let r = e.nodeAt(this.pos);
    if (!r)
      return it.fail("No node at mark step's position");
    let n = r.type.create(r.attrs, null, this.mark.removeFromSet(r.marks));
    return it.fromReplace(e, this.pos, this.pos + 1, new X(U.from(n), 0, r.isLeaf ? 0 : 1));
  }
  invert(e) {
    let r = e.nodeAt(this.pos);
    return !r || !this.mark.isInSet(r.marks) ? this : new Xr(this.pos, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.pos, 1);
    return r.deletedAfter ? null : new Nn(r.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Nn(r.pos, e.markFromJSON(r.mark));
  }
}
Nt.jsonID("removeNodeMark", Nn);
class mt extends Nt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, r, n, o = !1) {
    super(), this.from = e, this.to = r, this.slice = n, this.structure = o;
  }
  apply(e) {
    return this.structure && Ul(e, this.from, this.to) ? it.fail("Structure replace would overwrite content") : it.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new _t([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new mt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let r = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
    return r.deletedAcross && n.deletedAcross ? null : new mt(r.pos, Math.max(r.pos, n.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof mt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let r = this.slice.size + e.slice.size == 0 ? X.empty : new X(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new mt(this.from, this.to + (e.to - e.from), r, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let r = this.slice.size + e.slice.size == 0 ? X.empty : new X(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new mt(e.from, this.to, r, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new mt(r.from, r.to, X.fromJSON(e, r.slice), !!r.structure);
  }
}
Nt.jsonID("replace", mt);
class gt extends Nt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, r, n, o, s, i, a = !1) {
    super(), this.from = e, this.to = r, this.gapFrom = n, this.gapTo = o, this.slice = s, this.insert = i, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Ul(e, this.from, this.gapFrom) || Ul(e, this.gapTo, this.to)))
      return it.fail("Structure gap-replace would overwrite content");
    let r = e.slice(this.gapFrom, this.gapTo);
    if (r.openStart || r.openEnd)
      return it.fail("Gap is not a flat range");
    let n = this.slice.insertAt(this.insert, r.content);
    return n ? it.fromReplace(e, this.from, this.to, n) : it.fail("Content does not fit in gap");
  }
  getMap() {
    return new _t([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let r = this.gapTo - this.gapFrom;
    return new gt(this.from, this.from + this.slice.size + r, this.from + this.insert, this.from + this.insert + r, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let r = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1), o = this.from == this.gapFrom ? r.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1);
    return r.deletedAcross && n.deletedAcross || o < r.pos || s > n.pos ? null : new gt(r.pos, n.pos, o, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number" || typeof r.gapFrom != "number" || typeof r.gapTo != "number" || typeof r.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new gt(r.from, r.to, r.gapFrom, r.gapTo, X.fromJSON(e, r.slice), r.insert, !!r.structure);
  }
}
Nt.jsonID("replaceAround", gt);
function Ul(t, e, r) {
  let n = t.resolve(e), o = r - e, s = n.depth;
  for (; o > 0 && s > 0 && n.indexAfter(s) == n.node(s).childCount; )
    s--, o--;
  if (o > 0) {
    let i = n.node(s).maybeChild(n.indexAfter(s));
    for (; o > 0; ) {
      if (!i || i.isLeaf)
        return !0;
      i = i.firstChild, o--;
    }
  }
  return !1;
}
function t4(t, e, r, n) {
  let o = [], s = [], i, a;
  t.doc.nodesBetween(e, r, (l, d, c) => {
    if (!l.isInline)
      return;
    let u = l.marks;
    if (!n.isInSet(u) && c.type.allowsMarkType(n.type)) {
      let f = Math.max(d, e), p = Math.min(d + l.nodeSize, r), h = n.addToSet(u);
      for (let g = 0; g < u.length; g++)
        u[g].isInSet(h) || (i && i.to == f && i.mark.eq(u[g]) ? i.to = p : o.push(i = new tr(f, p, u[g])));
      a && a.to == f ? a.to = p : s.push(a = new qr(f, p, n));
    }
  }), o.forEach((l) => t.step(l)), s.forEach((l) => t.step(l));
}
function r4(t, e, r, n) {
  let o = [], s = 0;
  t.doc.nodesBetween(e, r, (i, a) => {
    if (!i.isInline)
      return;
    s++;
    let l = null;
    if (n instanceof aa) {
      let d = i.marks, c;
      for (; c = n.isInSet(d); )
        (l || (l = [])).push(c), d = c.removeFromSet(d);
    } else n ? n.isInSet(i.marks) && (l = [n]) : l = i.marks;
    if (l && l.length) {
      let d = Math.min(a + i.nodeSize, r);
      for (let c = 0; c < l.length; c++) {
        let u = l[c], f;
        for (let p = 0; p < o.length; p++) {
          let h = o[p];
          h.step == s - 1 && u.eq(o[p].style) && (f = h);
        }
        f ? (f.to = d, f.step = s) : o.push({ style: u, from: Math.max(a, e), to: d, step: s });
      }
    }
  }), o.forEach((i) => t.step(new tr(i.from, i.to, i.style)));
}
function Gd(t, e, r, n = r.contentMatch, o = !0) {
  let s = t.doc.nodeAt(e), i = [], a = e + 1;
  for (let l = 0; l < s.childCount; l++) {
    let d = s.child(l), c = a + d.nodeSize, u = n.matchType(d.type);
    if (!u)
      i.push(new mt(a, c, X.empty));
    else {
      n = u;
      for (let f = 0; f < d.marks.length; f++)
        r.allowsMarkType(d.marks[f].type) || t.step(new tr(a, c, d.marks[f]));
      if (o && d.isText && r.whitespace != "pre") {
        let f, p = /\r?\n|\r/g, h;
        for (; f = p.exec(d.text); )
          h || (h = new X(U.from(r.schema.text(" ", r.allowedMarks(d.marks))), 0, 0)), i.push(new mt(a + f.index, a + f.index + f[0].length, h));
      }
    }
    a = c;
  }
  if (!n.validEnd) {
    let l = n.fillBefore(U.empty, !0);
    t.replace(a, a, new X(l, 0, 0));
  }
  for (let l = i.length - 1; l >= 0; l--)
    t.step(i[l]);
}
function n4(t, e, r) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (r == t.childCount || t.canReplace(0, r));
}
function ho(t) {
  let r = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let n = t.depth, o = 0, s = 0; ; --n) {
    let i = t.$from.node(n), a = t.$from.index(n) + o, l = t.$to.indexAfter(n) - s;
    if (n < t.depth && i.canReplace(a, l, r))
      return n;
    if (n == 0 || i.type.spec.isolating || !n4(i, a, l))
      break;
    a && (o = 1), l < i.childCount && (s = 1);
  }
  return null;
}
function o4(t, e, r) {
  let { $from: n, $to: o, depth: s } = e, i = n.before(s + 1), a = o.after(s + 1), l = i, d = a, c = U.empty, u = 0;
  for (let h = s, g = !1; h > r; h--)
    g || n.index(h) > 0 ? (g = !0, c = U.from(n.node(h).copy(c)), u++) : l--;
  let f = U.empty, p = 0;
  for (let h = s, g = !1; h > r; h--)
    g || o.after(h + 1) < o.end(h) ? (g = !0, f = U.from(o.node(h).copy(f)), p++) : d++;
  t.step(new gt(l, d, i, a, new X(c.append(f), u, p), c.size - u, !0));
}
function Kd(t, e, r = null, n = t) {
  let o = s4(t, e), s = o && i4(n, e);
  return s ? o.map(kf).concat({ type: e, attrs: r }).concat(s.map(kf)) : null;
}
function kf(t) {
  return { type: t, attrs: null };
}
function s4(t, e) {
  let { parent: r, startIndex: n, endIndex: o } = t, s = r.contentMatchAt(n).findWrapping(e);
  if (!s)
    return null;
  let i = s.length ? s[0] : e;
  return r.canReplaceWith(n, o, i) ? s : null;
}
function i4(t, e) {
  let { parent: r, startIndex: n, endIndex: o } = t, s = r.child(n), i = e.contentMatch.findWrapping(s.type);
  if (!i)
    return null;
  let l = (i.length ? i[i.length - 1] : e).contentMatch;
  for (let d = n; l && d < o; d++)
    l = l.matchType(r.child(d).type);
  return !l || !l.validEnd ? null : i;
}
function a4(t, e, r) {
  let n = U.empty;
  for (let i = r.length - 1; i >= 0; i--) {
    if (n.size) {
      let a = r[i].type.contentMatch.matchFragment(n);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    n = U.from(r[i].type.create(r[i].attrs, n));
  }
  let o = e.start, s = e.end;
  t.step(new gt(o, s, o, s, new X(n, 0, 0), r.length, !0));
}
function l4(t, e, r, n, o) {
  if (!n.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = t.steps.length;
  t.doc.nodesBetween(e, r, (i, a) => {
    let l = typeof o == "function" ? o(i) : o;
    if (i.isTextblock && !i.hasMarkup(n, l) && d4(t.doc, t.mapping.slice(s).map(a), n)) {
      let d = null;
      if (n.schema.linebreakReplacement) {
        let p = n.whitespace == "pre", h = !!n.contentMatch.matchType(n.schema.linebreakReplacement);
        p && !h ? d = !1 : !p && h && (d = !0);
      }
      d === !1 && m0(t, i, a, s), Gd(t, t.mapping.slice(s).map(a, 1), n, void 0, d === null);
      let c = t.mapping.slice(s), u = c.map(a, 1), f = c.map(a + i.nodeSize, 1);
      return t.step(new gt(u, f, u + 1, f - 1, new X(U.from(n.create(l, null, i.marks)), 0, 0), 1, !0)), d === !0 && h0(t, i, a, s), !1;
    }
  });
}
function h0(t, e, r, n) {
  e.forEach((o, s) => {
    if (o.isText) {
      let i, a = /\r?\n|\r/g;
      for (; i = a.exec(o.text); ) {
        let l = t.mapping.slice(n).map(r + 1 + s + i.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function m0(t, e, r, n) {
  e.forEach((o, s) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let i = t.mapping.slice(n).map(r + 1 + s);
      t.replaceWith(i, i + 1, e.type.schema.text(`
`));
    }
  });
}
function d4(t, e, r) {
  let n = t.resolve(e), o = n.index();
  return n.parent.canReplaceWith(o, o + 1, r);
}
function c4(t, e, r, n, o) {
  let s = t.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  r || (r = s.type);
  let i = r.create(n, null, o || s.marks);
  if (s.isLeaf)
    return t.replaceWith(e, e + s.nodeSize, i);
  if (!r.validContent(s.content))
    throw new RangeError("Invalid content for node type " + r.name);
  t.step(new gt(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new X(U.from(i), 0, 0), 1, !0));
}
function Pr(t, e, r = 1, n) {
  let o = t.resolve(e), s = o.depth - r, i = n && n[n.length - 1] || o.parent;
  if (s < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !i.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
    return !1;
  for (let d = o.depth - 1, c = r - 2; d > s; d--, c--) {
    let u = o.node(d), f = o.index(d);
    if (u.type.spec.isolating)
      return !1;
    let p = u.content.cutByIndex(f, u.childCount), h = n && n[c + 1];
    h && (p = p.replaceChild(0, h.type.create(h.attrs)));
    let g = n && n[c] || u;
    if (!u.canReplace(f + 1, u.childCount) || !g.type.validContent(p))
      return !1;
  }
  let a = o.indexAfter(s), l = n && n[0];
  return o.node(s).canReplaceWith(a, a, l ? l.type : o.node(s + 1).type);
}
function u4(t, e, r = 1, n) {
  let o = t.doc.resolve(e), s = U.empty, i = U.empty;
  for (let a = o.depth, l = o.depth - r, d = r - 1; a > l; a--, d--) {
    s = U.from(o.node(a).copy(s));
    let c = n && n[d];
    i = U.from(c ? c.type.create(c.attrs, i) : o.node(a).copy(i));
  }
  t.step(new mt(e, e, new X(s.append(i), r, r), !0));
}
function rn(t, e) {
  let r = t.resolve(e), n = r.index();
  return g0(r.nodeBefore, r.nodeAfter) && r.parent.canReplace(n, n + 1);
}
function f4(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let r = t.contentMatchAt(t.childCount), { linebreakReplacement: n } = t.type.schema;
  for (let o = 0; o < e.childCount; o++) {
    let s = e.child(o), i = s.type == n ? t.type.schema.nodes.text : s.type;
    if (r = r.matchType(i), !r || !t.type.allowsMarks(s.marks))
      return !1;
  }
  return r.validEnd;
}
function g0(t, e) {
  return !!(t && e && !t.isLeaf && f4(t, e));
}
function da(t, e, r = -1) {
  let n = t.resolve(e);
  for (let o = n.depth; ; o--) {
    let s, i, a = n.index(o);
    if (o == n.depth ? (s = n.nodeBefore, i = n.nodeAfter) : r > 0 ? (s = n.node(o + 1), a++, i = n.node(o).maybeChild(a)) : (s = n.node(o).maybeChild(a - 1), i = n.node(o + 1)), s && !s.isTextblock && g0(s, i) && n.node(o).canReplace(a, a + 1))
      return e;
    if (o == 0)
      break;
    e = r < 0 ? n.before(o) : n.after(o);
  }
}
function p4(t, e, r) {
  let n = null, { linebreakReplacement: o } = t.doc.type.schema, s = t.doc.resolve(e - r), i = s.node().type;
  if (o && i.inlineContent) {
    let c = i.whitespace == "pre", u = !!i.contentMatch.matchType(o);
    c && !u ? n = !1 : !c && u && (n = !0);
  }
  let a = t.steps.length;
  if (n === !1) {
    let c = t.doc.resolve(e + r);
    m0(t, c.node(), c.before(), a);
  }
  i.inlineContent && Gd(t, e + r - 1, i, s.node().contentMatchAt(s.index()), n == null);
  let l = t.mapping.slice(a), d = l.map(e - r);
  if (t.step(new mt(d, l.map(e + r, -1), X.empty, !0)), n === !0) {
    let c = t.doc.resolve(d);
    h0(t, c.node(), c.before(), t.steps.length);
  }
  return t;
}
function h4(t, e, r) {
  let n = t.resolve(e);
  if (n.parent.canReplaceWith(n.index(), n.index(), r))
    return e;
  if (n.parentOffset == 0)
    for (let o = n.depth - 1; o >= 0; o--) {
      let s = n.index(o);
      if (n.node(o).canReplaceWith(s, s, r))
        return n.before(o + 1);
      if (s > 0)
        return null;
    }
  if (n.parentOffset == n.parent.content.size)
    for (let o = n.depth - 1; o >= 0; o--) {
      let s = n.indexAfter(o);
      if (n.node(o).canReplaceWith(s, s, r))
        return n.after(o + 1);
      if (s < n.node(o).childCount)
        return null;
    }
  return null;
}
function b0(t, e, r) {
  let n = t.resolve(e);
  if (!r.content.size)
    return e;
  let o = r.content;
  for (let s = 0; s < r.openStart; s++)
    o = o.firstChild.content;
  for (let s = 1; s <= (r.openStart == 0 && r.size ? 2 : 1); s++)
    for (let i = n.depth; i >= 0; i--) {
      let a = i == n.depth ? 0 : n.pos <= (n.start(i + 1) + n.end(i + 1)) / 2 ? -1 : 1, l = n.index(i) + (a > 0 ? 1 : 0), d = n.node(i), c = !1;
      if (s == 1)
        c = d.canReplace(l, l, o);
      else {
        let u = d.contentMatchAt(l).findWrapping(o.firstChild.type);
        c = u && d.canReplaceWith(l, l, u[0]);
      }
      if (c)
        return a == 0 ? n.pos : a < 0 ? n.before(i + 1) : n.after(i + 1);
    }
  return null;
}
function ca(t, e, r = e, n = X.empty) {
  if (e == r && !n.size)
    return null;
  let o = t.resolve(e), s = t.resolve(r);
  return y0(o, s, n) ? new mt(e, r, n) : new m4(o, s, n).fit();
}
function y0(t, e, r) {
  return !r.openStart && !r.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), r.content);
}
class m4 {
  constructor(e, r, n) {
    this.$from = e, this.$to = r, this.unplaced = n, this.frontier = [], this.placed = U.empty;
    for (let o = 0; o <= e.depth; o++) {
      let s = e.node(o);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(o))
      });
    }
    for (let o = e.depth; o > 0; o--)
      this.placed = U.from(e.node(o).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let d = this.findFittable();
      d ? this.placeNodes(d) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), r = this.placed.size - this.depth - this.$from.depth, n = this.$from, o = this.close(e < 0 ? this.$to : n.doc.resolve(e));
    if (!o)
      return null;
    let s = this.placed, i = n.depth, a = o.depth;
    for (; i && a && s.childCount == 1; )
      s = s.firstChild.content, i--, a--;
    let l = new X(s, i, a);
    return e > -1 ? new gt(n.pos, e, this.$to.pos, this.$to.end(), l, r) : l.size || n.pos != this.$to.pos ? new mt(n.pos, o.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let r = this.unplaced.content, n = 0, o = this.unplaced.openEnd; n < e; n++) {
      let s = r.firstChild;
      if (r.childCount > 1 && (o = 0), s.type.spec.isolating && o <= n) {
        e = n;
        break;
      }
      r = s.content;
    }
    for (let r = 1; r <= 2; r++)
      for (let n = r == 1 ? e : this.unplaced.openStart; n >= 0; n--) {
        let o, s = null;
        n ? (s = Ba(this.unplaced.content, n - 1).firstChild, o = s.content) : o = this.unplaced.content;
        let i = o.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: d } = this.frontier[a], c, u = null;
          if (r == 1 && (i ? d.matchType(i.type) || (u = d.fillBefore(U.from(i), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: n, frontierDepth: a, parent: s, inject: u };
          if (r == 2 && i && (c = d.findWrapping(i.type)))
            return { sliceDepth: n, frontierDepth: a, parent: s, wrap: c };
          if (s && d.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: r, openEnd: n } = this.unplaced, o = Ba(e, r);
    return !o.childCount || o.firstChild.isLeaf ? !1 : (this.unplaced = new X(e, r + 1, Math.max(n, o.size + r >= e.size - n ? r + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: r, openEnd: n } = this.unplaced, o = Ba(e, r);
    if (o.childCount <= 1 && r > 0) {
      let s = e.size - r <= r + o.size;
      this.unplaced = new X(No(e, r - 1, 1), r - 1, s ? r - 1 : n);
    } else
      this.unplaced = new X(No(e, r, 1), r, n);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: r, parent: n, inject: o, wrap: s }) {
    for (; this.depth > r; )
      this.closeFrontierNode();
    if (s)
      for (let g = 0; g < s.length; g++)
        this.openFrontierNode(s[g]);
    let i = this.unplaced, a = n ? n.content : i.content, l = i.openStart - e, d = 0, c = [], { match: u, type: f } = this.frontier[r];
    if (o) {
      for (let g = 0; g < o.childCount; g++)
        c.push(o.child(g));
      u = u.matchFragment(o);
    }
    let p = a.size + e - (i.content.size - i.openEnd);
    for (; d < a.childCount; ) {
      let g = a.child(d), b = u.matchType(g.type);
      if (!b)
        break;
      d++, (d > 1 || l == 0 || g.content.size) && (u = b, c.push(v0(g.mark(f.allowedMarks(g.marks)), d == 1 ? l : 0, d == a.childCount ? p : -1)));
    }
    let h = d == a.childCount;
    h || (p = -1), this.placed = To(this.placed, r, U.from(c)), this.frontier[r].match = u, h && p < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, b = a; g < p; g++) {
      let y = b.lastChild;
      this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), b = y.content;
    }
    this.unplaced = h ? e == 0 ? X.empty : new X(No(i.content, e - 1, 1), e - 1, p < 0 ? i.openEnd : e - 1) : new X(No(i.content, e, d), i.openStart, i.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], r;
    if (!e.type.isTextblock || !Va(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (r = this.findCloseLevel(this.$to)) && r.depth == this.depth)
      return -1;
    let { depth: n } = this.$to, o = this.$to.after(n);
    for (; n > 1 && o == this.$to.end(--n); )
      ++o;
    return o;
  }
  findCloseLevel(e) {
    e: for (let r = Math.min(this.depth, e.depth); r >= 0; r--) {
      let { match: n, type: o } = this.frontier[r], s = r < e.depth && e.end(r + 1) == e.pos + (e.depth - (r + 1)), i = Va(e, r, o, n, s);
      if (i) {
        for (let a = r - 1; a >= 0; a--) {
          let { match: l, type: d } = this.frontier[a], c = Va(e, a, d, l, !0);
          if (!c || c.childCount)
            continue e;
        }
        return { depth: r, fit: i, move: s ? e.doc.resolve(e.after(r + 1)) : e };
      }
    }
  }
  close(e) {
    let r = this.findCloseLevel(e);
    if (!r)
      return null;
    for (; this.depth > r.depth; )
      this.closeFrontierNode();
    r.fit.childCount && (this.placed = To(this.placed, r.depth, r.fit)), e = r.move;
    for (let n = r.depth + 1; n <= e.depth; n++) {
      let o = e.node(n), s = o.type.contentMatch.fillBefore(o.content, !0, e.index(n));
      this.openFrontierNode(o.type, o.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, r = null, n) {
    let o = this.frontier[this.depth];
    o.match = o.match.matchType(e), this.placed = To(this.placed, this.depth, U.from(e.create(r, n))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let r = this.frontier.pop().match.fillBefore(U.empty, !0);
    r.childCount && (this.placed = To(this.placed, this.frontier.length, r));
  }
}
function No(t, e, r) {
  return e == 0 ? t.cutByIndex(r, t.childCount) : t.replaceChild(0, t.firstChild.copy(No(t.firstChild.content, e - 1, r)));
}
function To(t, e, r) {
  return e == 0 ? t.append(r) : t.replaceChild(t.childCount - 1, t.lastChild.copy(To(t.lastChild.content, e - 1, r)));
}
function Ba(t, e) {
  for (let r = 0; r < e; r++)
    t = t.firstChild.content;
  return t;
}
function v0(t, e, r) {
  if (e <= 0)
    return t;
  let n = t.content;
  return e > 1 && (n = n.replaceChild(0, v0(n.firstChild, e - 1, n.childCount == 1 ? r - 1 : 0))), e > 0 && (n = t.type.contentMatch.fillBefore(n).append(n), r <= 0 && (n = n.append(t.type.contentMatch.matchFragment(n).fillBefore(U.empty, !0)))), t.copy(n);
}
function Va(t, e, r, n, o) {
  let s = t.node(e), i = o ? t.indexAfter(e) : t.index(e);
  if (i == s.childCount && !r.compatibleContent(s.type))
    return null;
  let a = n.fillBefore(s.content, !0, i);
  return a && !g4(r, s.content, i) ? a : null;
}
function g4(t, e, r) {
  for (let n = r; n < e.childCount; n++)
    if (!t.allowsMarks(e.child(n).marks))
      return !0;
  return !1;
}
function b4(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function y4(t, e, r, n) {
  if (!n.size)
    return t.deleteRange(e, r);
  let o = t.doc.resolve(e), s = t.doc.resolve(r);
  if (y0(o, s, n))
    return t.step(new mt(e, r, n));
  let i = x0(o, s);
  i[i.length - 1] == 0 && i.pop();
  let a = -(o.depth + 1);
  i.unshift(a);
  for (let f = o.depth, p = o.pos - 1; f > 0; f--, p--) {
    let h = o.node(f).type.spec;
    if (h.defining || h.definingAsContext || h.isolating)
      break;
    i.indexOf(f) > -1 ? a = f : o.before(f) == p && i.splice(1, 0, -f);
  }
  let l = i.indexOf(a), d = [], c = n.openStart;
  for (let f = n.content, p = 0; ; p++) {
    let h = f.firstChild;
    if (d.push(h), p == n.openStart)
      break;
    f = h.content;
  }
  for (let f = c - 1; f >= 0; f--) {
    let p = d[f], h = b4(p.type);
    if (h && !p.sameMarkup(o.node(Math.abs(a) - 1)))
      c = f;
    else if (h || !p.type.isTextblock)
      break;
  }
  for (let f = n.openStart; f >= 0; f--) {
    let p = (f + c + 1) % (n.openStart + 1), h = d[p];
    if (h)
      for (let g = 0; g < i.length; g++) {
        let b = i[(g + l) % i.length], y = !0;
        b < 0 && (y = !1, b = -b);
        let $ = o.node(b - 1), k = o.index(b - 1);
        if ($.canReplaceWith(k, k, h.type, h.marks))
          return t.replace(o.before(b), y ? s.after(b) : r, new X($0(n.content, 0, n.openStart, p), p, n.openEnd));
      }
  }
  let u = t.steps.length;
  for (let f = i.length - 1; f >= 0 && (t.replace(e, r, n), !(t.steps.length > u)); f--) {
    let p = i[f];
    p < 0 || (e = o.before(p), r = s.after(p));
  }
}
function $0(t, e, r, n, o) {
  if (e < r) {
    let s = t.firstChild;
    t = t.replaceChild(0, s.copy($0(s.content, e + 1, r, n, s)));
  }
  if (e > n) {
    let s = o.contentMatchAt(0), i = s.fillBefore(t).append(t);
    t = i.append(s.matchFragment(i).fillBefore(U.empty, !0));
  }
  return t;
}
function v4(t, e, r, n) {
  if (!n.isInline && e == r && t.doc.resolve(e).parent.content.size) {
    let o = h4(t.doc, e, n.type);
    o != null && (e = r = o);
  }
  t.replaceRange(e, r, new X(U.from(n), 0, 0));
}
function $4(t, e, r) {
  let n = t.doc.resolve(e), o = t.doc.resolve(r), s = x0(n, o);
  for (let i = 0; i < s.length; i++) {
    let a = s[i], l = i == s.length - 1;
    if (l && a == 0 || n.node(a).type.contentMatch.validEnd)
      return t.delete(n.start(a), o.end(a));
    if (a > 0 && (l || n.node(a - 1).canReplace(n.index(a - 1), o.indexAfter(a - 1))))
      return t.delete(n.before(a), o.after(a));
  }
  for (let i = 1; i <= n.depth && i <= o.depth; i++)
    if (e - n.start(i) == n.depth - i && r > n.end(i) && o.end(i) - r != o.depth - i && n.start(i - 1) == o.start(i - 1) && n.node(i - 1).canReplace(n.index(i - 1), o.index(i - 1)))
      return t.delete(n.before(i), r);
  t.delete(e, r);
}
function x0(t, e) {
  let r = [], n = Math.min(t.depth, e.depth);
  for (let o = n; o >= 0; o--) {
    let s = t.start(o);
    if (s < t.pos - (t.depth - o) || e.end(o) > e.pos + (e.depth - o) || t.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
      break;
    (s == e.start(o) || o == t.depth && o == e.depth && t.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == s - 1) && r.push(o);
  }
  return r;
}
class Qn extends Nt {
  /**
  Construct an attribute step.
  */
  constructor(e, r, n) {
    super(), this.pos = e, this.attr = r, this.value = n;
  }
  apply(e) {
    let r = e.nodeAt(this.pos);
    if (!r)
      return it.fail("No node at attribute step's position");
    let n = /* @__PURE__ */ Object.create(null);
    for (let s in r.attrs)
      n[s] = r.attrs[s];
    n[this.attr] = this.value;
    let o = r.type.create(n, null, r.marks);
    return it.fromReplace(e, this.pos, this.pos + 1, new X(U.from(o), 0, r.isLeaf ? 0 : 1));
  }
  getMap() {
    return _t.empty;
  }
  invert(e) {
    return new Qn(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let r = e.mapResult(this.pos, 1);
    return r.deletedAfter ? null : new Qn(r.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, r) {
    if (typeof r.pos != "number" || typeof r.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Qn(r.pos, r.attr, r.value);
  }
}
Nt.jsonID("attr", Qn);
class Zo extends Nt {
  /**
  Construct an attribute step.
  */
  constructor(e, r) {
    super(), this.attr = e, this.value = r;
  }
  apply(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in e.attrs)
      r[o] = e.attrs[o];
    r[this.attr] = this.value;
    let n = e.type.create(r, e.content, e.marks);
    return it.ok(n);
  }
  getMap() {
    return _t.empty;
  }
  invert(e) {
    return new Zo(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, r) {
    if (typeof r.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Zo(r.attr, r.value);
  }
}
Nt.jsonID("docAttr", Zo);
let so = class extends Error {
};
so = function t(e) {
  let r = Error.call(this, e);
  return r.__proto__ = t.prototype, r;
};
so.prototype = Object.create(Error.prototype);
so.prototype.constructor = so;
so.prototype.name = "TransformError";
class w0 {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Xo();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let r = this.maybeStep(e);
    if (r.failed)
      throw new so(r.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let r = e.apply(this.doc);
    return r.failed || this.addStep(e, r.doc), r;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, r) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = r;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, r = e, n = X.empty) {
    let o = ca(this.doc, e, r, n);
    return o && this.step(o), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, r, n) {
    return this.replace(e, r, new X(U.from(n), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, r) {
    return this.replace(e, r, X.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, r) {
    return this.replaceWith(e, e, r);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, r, n) {
    return y4(this, e, r, n), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, r, n) {
    return v4(this, e, r, n), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, r) {
    return $4(this, e, r), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, r) {
    return o4(this, e, r), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, r = 1) {
    return p4(this, e, r), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, r) {
    return a4(this, e, r), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, r = e, n, o = null) {
    return l4(this, e, r, n, o), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, r, n = null, o) {
    return c4(this, e, r, n, o), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, r, n) {
    return this.step(new Qn(e, r, n)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, r) {
    return this.step(new Zo(e, r)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, r) {
    return this.step(new Xr(e, r)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, r) {
    let n = this.doc.nodeAt(e);
    if (!n)
      throw new RangeError("No node at position " + e);
    if (r instanceof Ke)
      r.isInSet(n.marks) && this.step(new Nn(e, r));
    else {
      let o = n.marks, s, i = [];
      for (; s = r.isInSet(o); )
        i.push(new Nn(e, s)), o = s.removeFromSet(o);
      for (let a = i.length - 1; a >= 0; a--)
        this.step(i[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, r = 1, n) {
    return u4(this, e, r, n), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, r, n) {
    return t4(this, e, r, n), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, r, n) {
    return r4(this, e, r, n), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, r, n) {
    return Gd(this, e, r, n), this;
  }
}
const Wa = /* @__PURE__ */ Object.create(null);
class be {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, r, n) {
    this.$anchor = e, this.$head = r, this.ranges = n || [new k0(e.min(r), e.max(r))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let r = 0; r < e.length; r++)
      if (e[r].$from.pos != e[r].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, r = X.empty) {
    let n = r.content.lastChild, o = null;
    for (let a = 0; a < r.openEnd; a++)
      o = n, n = n.lastChild;
    let s = e.steps.length, i = this.ranges;
    for (let a = 0; a < i.length; a++) {
      let { $from: l, $to: d } = i[a], c = e.mapping.slice(s);
      e.replaceRange(c.map(l.pos), c.map(d.pos), a ? X.empty : r), a == 0 && Sf(e, s, (n ? n.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, r) {
    let n = e.steps.length, o = this.ranges;
    for (let s = 0; s < o.length; s++) {
      let { $from: i, $to: a } = o[s], l = e.mapping.slice(n), d = l.map(i.pos), c = l.map(a.pos);
      s ? e.deleteRange(d, c) : (e.replaceRangeWith(d, c, r), Sf(e, n, r.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, r, n = !1) {
    let o = e.parent.inlineContent ? new fe(e) : Wn(e.node(0), e.parent, e.pos, e.index(), r, n);
    if (o)
      return o;
    for (let s = e.depth - 1; s >= 0; s--) {
      let i = r < 0 ? Wn(e.node(0), e.node(s), e.before(s + 1), e.index(s), r, n) : Wn(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, r, n);
      if (i)
        return i;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, r = 1) {
    return this.findFrom(e, r) || this.findFrom(e, -r) || new Ht(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Wn(e, e, 0, 0, 1) || new Ht(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Wn(e, e, e.content.size, e.childCount, -1) || new Ht(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, r) {
    if (!r || !r.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let n = Wa[r.type];
    if (!n)
      throw new RangeError(`No selection type ${r.type} defined`);
    return n.fromJSON(e, r);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, r) {
    if (e in Wa)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Wa[e] = r, r.prototype.jsonID = e, r;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return fe.between(this.$anchor, this.$head).getBookmark();
  }
}
be.prototype.visible = !0;
class k0 {
  /**
  Create a range.
  */
  constructor(e, r) {
    this.$from = e, this.$to = r;
  }
}
let Ef = !1;
function Cf(t) {
  !Ef && !t.parent.inlineContent && (Ef = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class fe extends be {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, r = e) {
    Cf(e), Cf(r), super(e, r);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, r) {
    let n = e.resolve(r.map(this.head));
    if (!n.parent.inlineContent)
      return be.near(n);
    let o = e.resolve(r.map(this.anchor));
    return new fe(o.parent.inlineContent ? o : n, n);
  }
  replace(e, r = X.empty) {
    if (super.replace(e, r), r == X.empty) {
      let n = this.$from.marksAcross(this.$to);
      n && e.ensureMarks(n);
    }
  }
  eq(e) {
    return e instanceof fe && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new ua(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.anchor != "number" || typeof r.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new fe(e.resolve(r.anchor), e.resolve(r.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, r, n = r) {
    let o = e.resolve(r);
    return new this(o, n == r ? o : e.resolve(n));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, r, n) {
    let o = e.pos - r.pos;
    if ((!n || o) && (n = o >= 0 ? 1 : -1), !r.parent.inlineContent) {
      let s = be.findFrom(r, n, !0) || be.findFrom(r, -n, !0);
      if (s)
        r = s.$head;
      else
        return be.near(r, n);
    }
    return e.parent.inlineContent || (o == 0 ? e = r : (e = (be.findFrom(e, -n, !0) || be.findFrom(e, n, !0)).$anchor, e.pos < r.pos != o < 0 && (e = r))), new fe(e, r);
  }
}
be.jsonID("text", fe);
class ua {
  constructor(e, r) {
    this.anchor = e, this.head = r;
  }
  map(e) {
    return new ua(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return fe.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ue extends be {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let r = e.nodeAfter, n = e.node(0).resolve(e.pos + r.nodeSize);
    super(e, n), this.node = r;
  }
  map(e, r) {
    let { deleted: n, pos: o } = r.mapResult(this.anchor), s = e.resolve(o);
    return n ? be.near(s) : new ue(s);
  }
  content() {
    return new X(U.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ue && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Yd(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ue(e.resolve(r.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, r) {
    return new ue(e.resolve(r));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ue.prototype.visible = !1;
be.jsonID("node", ue);
class Yd {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: r, pos: n } = e.mapResult(this.anchor);
    return r ? new ua(n, n) : new Yd(n);
  }
  resolve(e) {
    let r = e.resolve(this.anchor), n = r.nodeAfter;
    return n && ue.isSelectable(n) ? new ue(r) : be.near(r);
  }
}
class Ht extends be {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, r = X.empty) {
    if (r == X.empty) {
      e.delete(0, e.doc.content.size);
      let n = be.atStart(e.doc);
      n.eq(e.selection) || e.setSelection(n);
    } else
      super.replace(e, r);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Ht(e);
  }
  map(e) {
    return new Ht(e);
  }
  eq(e) {
    return e instanceof Ht;
  }
  getBookmark() {
    return x4;
  }
}
be.jsonID("all", Ht);
const x4 = {
  map() {
    return this;
  },
  resolve(t) {
    return new Ht(t);
  }
};
function Wn(t, e, r, n, o, s = !1) {
  if (e.inlineContent)
    return fe.create(t, r);
  for (let i = n - (o > 0 ? 0 : 1); o > 0 ? i < e.childCount : i >= 0; i += o) {
    let a = e.child(i);
    if (a.isAtom) {
      if (!s && ue.isSelectable(a))
        return ue.create(t, r - (o < 0 ? a.nodeSize : 0));
    } else {
      let l = Wn(t, a, r + o, o < 0 ? a.childCount : 0, o, s);
      if (l)
        return l;
    }
    r += a.nodeSize * o;
  }
  return null;
}
function Sf(t, e, r) {
  let n = t.steps.length - 1;
  if (n < e)
    return;
  let o = t.steps[n];
  if (!(o instanceof mt || o instanceof gt))
    return;
  let s = t.mapping.maps[n], i;
  s.forEach((a, l, d, c) => {
    i == null && (i = c);
  }), t.setSelection(be.near(t.doc.resolve(i), r));
}
function Nf(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Ss {
  constructor(e, r, n) {
    this.name = e, this.init = Nf(r.init, n), this.apply = Nf(r.apply, n);
  }
}
new Ss("doc", {
  init(t) {
    return t.doc || t.schema.topNodeType.createAndFill();
  },
  apply(t) {
    return t.doc;
  }
}), new Ss("selection", {
  init(t, e) {
    return t.selection || be.atStart(e.doc);
  },
  apply(t) {
    return t.selection;
  }
}), new Ss("storedMarks", {
  init(t) {
    return t.storedMarks || null;
  },
  apply(t, e, r, n) {
    return n.selection.$cursor ? t.storedMarks : null;
  }
}), new Ss("scrollToSelection", {
  init() {
    return 0;
  },
  apply(t, e) {
    return t.scrolledIntoView ? e + 1 : e;
  }
});
function E0(t, e, r) {
  for (let n in t) {
    let o = t[n];
    o instanceof Function ? o = o.bind(e) : n == "handleDOMEvents" && (o = E0(o, e, {})), r[n] = o;
  }
  return r;
}
class Ze {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && E0(e.props, this, this.props), this.key = e.key ? e.key.key : C0("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Ua = /* @__PURE__ */ Object.create(null);
function C0(t) {
  return t in Ua ? t + "$" + ++Ua[t] : (Ua[t] = 0, t + "$");
}
class Qe {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = C0(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Jd = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function S0(t, e) {
  let { $cursor: r } = t.selection;
  return !r || (e ? !e.endOfTextblock("backward", t) : r.parentOffset > 0) ? null : r;
}
const N0 = (t, e, r) => {
  let n = S0(t, r);
  if (!n)
    return !1;
  let o = qd(n);
  if (!o) {
    let i = n.blockRange(), a = i && ho(i);
    return a == null ? !1 : (e && e(t.tr.lift(i, a).scrollIntoView()), !0);
  }
  let s = o.nodeBefore;
  if (j0(t, o, e, -1))
    return !0;
  if (n.parent.content.size == 0 && (io(s, "end") || ue.isSelectable(s)))
    for (let i = n.depth; ; i--) {
      let a = ca(t.doc, n.before(i), n.after(i), X.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(io(s, "end") ? be.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1) : ue.create(l.doc, o.pos - s.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (i == 1 || n.node(i - 1).childCount > 1)
        break;
    }
  return s.isAtom && o.depth == n.depth - 1 ? (e && e(t.tr.delete(o.pos - s.nodeSize, o.pos).scrollIntoView()), !0) : !1;
}, w4 = (t, e, r) => {
  let n = S0(t, r);
  if (!n)
    return !1;
  let o = qd(n);
  return o ? T0(t, o, e) : !1;
}, k4 = (t, e, r) => {
  let n = M0(t, r);
  if (!n)
    return !1;
  let o = Xd(n);
  return o ? T0(t, o, e) : !1;
};
function T0(t, e, r) {
  let n = e.nodeBefore, o = n, s = e.pos - 1;
  for (; !o.isTextblock; s--) {
    if (o.type.spec.isolating)
      return !1;
    let c = o.lastChild;
    if (!c)
      return !1;
    o = c;
  }
  let i = e.nodeAfter, a = i, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let c = a.firstChild;
    if (!c)
      return !1;
    a = c;
  }
  let d = ca(t.doc, s, l, X.empty);
  if (!d || d.from != s || d instanceof mt && d.slice.size >= l - s)
    return !1;
  if (r) {
    let c = t.tr.step(d);
    c.setSelection(fe.create(c.doc, s)), r(c.scrollIntoView());
  }
  return !0;
}
function io(t, e, r = !1) {
  for (let n = t; n; n = e == "start" ? n.firstChild : n.lastChild) {
    if (n.isTextblock)
      return !0;
    if (r && n.childCount != 1)
      return !1;
  }
  return !1;
}
const A0 = (t, e, r) => {
  let { $head: n, empty: o } = t.selection, s = n;
  if (!o)
    return !1;
  if (n.parent.isTextblock) {
    if (r ? !r.endOfTextblock("backward", t) : n.parentOffset > 0)
      return !1;
    s = qd(n);
  }
  let i = s && s.nodeBefore;
  return !i || !ue.isSelectable(i) ? !1 : (e && e(t.tr.setSelection(ue.create(t.doc, s.pos - i.nodeSize)).scrollIntoView()), !0);
};
function qd(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function M0(t, e) {
  let { $cursor: r } = t.selection;
  return !r || (e ? !e.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size) ? null : r;
}
const P0 = (t, e, r) => {
  let n = M0(t, r);
  if (!n)
    return !1;
  let o = Xd(n);
  if (!o)
    return !1;
  let s = o.nodeAfter;
  if (j0(t, o, e, 1))
    return !0;
  if (n.parent.content.size == 0 && (io(s, "start") || ue.isSelectable(s))) {
    let i = ca(t.doc, n.before(), n.after(), X.empty);
    if (i && i.slice.size < i.to - i.from) {
      if (e) {
        let a = t.tr.step(i);
        a.setSelection(io(s, "start") ? be.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1) : ue.create(a.doc, a.mapping.map(o.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && o.depth == n.depth - 1 ? (e && e(t.tr.delete(o.pos, o.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, I0 = (t, e, r) => {
  let { $head: n, empty: o } = t.selection, s = n;
  if (!o)
    return !1;
  if (n.parent.isTextblock) {
    if (r ? !r.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size)
      return !1;
    s = Xd(n);
  }
  let i = s && s.nodeAfter;
  return !i || !ue.isSelectable(i) ? !1 : (e && e(t.tr.setSelection(ue.create(t.doc, s.pos)).scrollIntoView()), !0);
};
function Xd(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let r = t.node(e);
      if (t.index(e) + 1 < r.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (r.type.spec.isolating)
        break;
    }
  return null;
}
const E4 = (t, e) => {
  let r = t.selection, n = r instanceof ue, o;
  if (n) {
    if (r.node.isTextblock || !rn(t.doc, r.from))
      return !1;
    o = r.from;
  } else if (o = da(t.doc, r.from, -1), o == null)
    return !1;
  if (e) {
    let s = t.tr.join(o);
    n && s.setSelection(ue.create(s.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)), e(s.scrollIntoView());
  }
  return !0;
}, C4 = (t, e) => {
  let r = t.selection, n;
  if (r instanceof ue) {
    if (r.node.isTextblock || !rn(t.doc, r.to))
      return !1;
    n = r.to;
  } else if (n = da(t.doc, r.to, 1), n == null)
    return !1;
  return e && e(t.tr.join(n).scrollIntoView()), !0;
}, S4 = (t, e) => {
  let { $from: r, $to: n } = t.selection, o = r.blockRange(n), s = o && ho(o);
  return s == null ? !1 : (e && e(t.tr.lift(o, s).scrollIntoView()), !0);
}, R0 = (t, e) => {
  let { $head: r, $anchor: n } = t.selection;
  return !r.parent.type.spec.code || !r.sameParent(n) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Zd(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: r } = t.edge(e);
    if (r.isTextblock && !r.hasRequiredAttrs())
      return r;
  }
  return null;
}
const N4 = (t, e) => {
  let { $head: r, $anchor: n } = t.selection;
  if (!r.parent.type.spec.code || !r.sameParent(n))
    return !1;
  let o = r.node(-1), s = r.indexAfter(-1), i = Zd(o.contentMatchAt(s));
  if (!i || !o.canReplaceWith(s, s, i))
    return !1;
  if (e) {
    let a = r.after(), l = t.tr.replaceWith(a, a, i.createAndFill());
    l.setSelection(be.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, O0 = (t, e) => {
  let r = t.selection, { $from: n, $to: o } = r;
  if (r instanceof Ht || n.parent.inlineContent || o.parent.inlineContent)
    return !1;
  let s = Zd(o.parent.contentMatchAt(o.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let i = (!n.parentOffset && o.index() < o.parent.childCount ? n : o).pos, a = t.tr.insert(i, s.createAndFill());
    a.setSelection(fe.create(a.doc, i + 1)), e(a.scrollIntoView());
  }
  return !0;
}, L0 = (t, e) => {
  let { $cursor: r } = t.selection;
  if (!r || r.parent.content.size)
    return !1;
  if (r.depth > 1 && r.after() != r.end(-1)) {
    let s = r.before();
    if (Pr(t.doc, s))
      return e && e(t.tr.split(s).scrollIntoView()), !0;
  }
  let n = r.blockRange(), o = n && ho(n);
  return o == null ? !1 : (e && e(t.tr.lift(n, o).scrollIntoView()), !0);
};
function T4(t) {
  return (e, r) => {
    let { $from: n, $to: o } = e.selection;
    if (e.selection instanceof ue && e.selection.node.isBlock)
      return !n.parentOffset || !Pr(e.doc, n.pos) ? !1 : (r && r(e.tr.split(n.pos).scrollIntoView()), !0);
    if (!n.depth)
      return !1;
    let s = [], i, a, l = !1, d = !1;
    for (let p = n.depth; ; p--)
      if (n.node(p).isBlock) {
        l = n.end(p) == n.pos + (n.depth - p), d = n.start(p) == n.pos - (n.depth - p), a = Zd(n.node(p - 1).contentMatchAt(n.indexAfter(p - 1))), s.unshift(l && a ? { type: a } : null), i = p;
        break;
      } else {
        if (p == 1)
          return !1;
        s.unshift(null);
      }
    let c = e.tr;
    (e.selection instanceof fe || e.selection instanceof Ht) && c.deleteSelection();
    let u = c.mapping.map(n.pos), f = Pr(c.doc, u, s.length, s);
    if (f || (s[0] = a ? { type: a } : null, f = Pr(c.doc, u, s.length, s)), !f)
      return !1;
    if (c.split(u, s.length, s), !l && d && n.node(i).type != a) {
      let p = c.mapping.map(n.before(i)), h = c.doc.resolve(p);
      a && n.node(i - 1).canReplaceWith(h.index(), h.index() + 1, a) && c.setNodeMarkup(c.mapping.map(n.before(i)), a);
    }
    return r && r(c.scrollIntoView()), !0;
  };
}
const A4 = T4(), M4 = (t, e) => {
  let { $from: r, to: n } = t.selection, o, s = r.sharedDepth(n);
  return s == 0 ? !1 : (o = r.before(s), e && e(t.tr.setSelection(ue.create(t.doc, o))), !0);
};
function P4(t, e, r) {
  let n = e.nodeBefore, o = e.nodeAfter, s = e.index();
  return !n || !o || !n.type.compatibleContent(o.type) ? !1 : !n.content.size && e.parent.canReplace(s - 1, s) ? (r && r(t.tr.delete(e.pos - n.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(o.isTextblock || rn(t.doc, e.pos)) ? !1 : (r && r(t.tr.join(e.pos).scrollIntoView()), !0);
}
function j0(t, e, r, n) {
  let o = e.nodeBefore, s = e.nodeAfter, i, a, l = o.type.spec.isolating || s.type.spec.isolating;
  if (!l && P4(t, e, r))
    return !0;
  let d = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (d && (i = (a = o.contentMatchAt(o.childCount)).findWrapping(s.type)) && a.matchType(i[0] || s.type).validEnd) {
    if (r) {
      let p = e.pos + s.nodeSize, h = U.empty;
      for (let y = i.length - 1; y >= 0; y--)
        h = U.from(i[y].create(null, h));
      h = U.from(o.copy(h));
      let g = t.tr.step(new gt(e.pos - 1, p, e.pos, p, new X(h, 1, 0), i.length, !0)), b = g.doc.resolve(p + 2 * i.length);
      b.nodeAfter && b.nodeAfter.type == o.type && rn(g.doc, b.pos) && g.join(b.pos), r(g.scrollIntoView());
    }
    return !0;
  }
  let c = s.type.spec.isolating || n > 0 && l ? null : be.findFrom(e, 1), u = c && c.$from.blockRange(c.$to), f = u && ho(u);
  if (f != null && f >= e.depth)
    return r && r(t.tr.lift(u, f).scrollIntoView()), !0;
  if (d && io(s, "start", !0) && io(o, "end")) {
    let p = o, h = [];
    for (; h.push(p), !p.isTextblock; )
      p = p.lastChild;
    let g = s, b = 1;
    for (; !g.isTextblock; g = g.firstChild)
      b++;
    if (p.canReplace(p.childCount, p.childCount, g.content)) {
      if (r) {
        let y = U.empty;
        for (let k = h.length - 1; k >= 0; k--)
          y = U.from(h[k].copy(y));
        let $ = t.tr.step(new gt(e.pos - h.length, e.pos + s.nodeSize, e.pos + b, e.pos + s.nodeSize - b, new X(y, h.length, 0), 0, !0));
        r($.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function D0(t) {
  return function(e, r) {
    let n = e.selection, o = t < 0 ? n.$from : n.$to, s = o.depth;
    for (; o.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return o.node(s).isTextblock ? (r && r(e.tr.setSelection(fe.create(e.doc, t < 0 ? o.start(s) : o.end(s)))), !0) : !1;
  };
}
const I4 = D0(-1), R4 = D0(1);
function O4(t, e = null) {
  return function(r, n) {
    let { $from: o, $to: s } = r.selection, i = o.blockRange(s), a = i && Kd(i, t, e);
    return a ? (n && n(r.tr.wrap(i, a).scrollIntoView()), !0) : !1;
  };
}
function Tf(t, e = null) {
  return function(r, n) {
    let o = !1;
    for (let s = 0; s < r.selection.ranges.length && !o; s++) {
      let { $from: { pos: i }, $to: { pos: a } } = r.selection.ranges[s];
      r.doc.nodesBetween(i, a, (l, d) => {
        if (o)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            o = !0;
          else {
            let c = r.doc.resolve(d), u = c.index();
            o = c.parent.canReplaceWith(u, u + 1, t);
          }
      });
    }
    if (!o)
      return !1;
    if (n) {
      let s = r.tr;
      for (let i = 0; i < r.selection.ranges.length; i++) {
        let { $from: { pos: a }, $to: { pos: l } } = r.selection.ranges[i];
        s.setBlockType(a, l, t, e);
      }
      n(s.scrollIntoView());
    }
    return !0;
  };
}
function Qd(...t) {
  return function(e, r, n) {
    for (let o = 0; o < t.length; o++)
      if (t[o](e, r, n))
        return !0;
    return !1;
  };
}
Qd(Jd, N0, A0);
Qd(Jd, P0, I0);
Qd(R0, O0, L0, A4);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function L4(t, e = null) {
  return function(r, n) {
    let { $from: o, $to: s } = r.selection, i = o.blockRange(s);
    if (!i)
      return !1;
    let a = n ? r.tr : null;
    return j4(a, i, t, e) ? (n && n(a.scrollIntoView()), !0) : !1;
  };
}
function j4(t, e, r, n = null) {
  let o = !1, s = e, i = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(r) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = i.resolve(e.start - 2);
    s = new di(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new di(e.$from, i.resolve(e.$to.end(e.depth)), e.depth)), o = !0;
  }
  let a = Kd(s, r, n, e);
  return a ? (t && D4(t, e, a, o, r), !0) : !1;
}
function D4(t, e, r, n, o) {
  let s = U.empty;
  for (let c = r.length - 1; c >= 0; c--)
    s = U.from(r[c].type.create(r[c].attrs, s));
  t.step(new gt(e.start - (n ? 2 : 0), e.end, e.start, e.end, new X(s, 0, 0), r.length, !0));
  let i = 0;
  for (let c = 0; c < r.length; c++)
    r[c].type == o && (i = c + 1);
  let a = r.length - i, l = e.start + r.length - (n ? 2 : 0), d = e.parent;
  for (let c = e.startIndex, u = e.endIndex, f = !0; c < u; c++, f = !1)
    !f && Pr(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += d.child(c).nodeSize;
  return t;
}
function _4(t) {
  return function(e, r) {
    let { $from: n, $to: o } = e.selection, s = n.blockRange(o, (i) => i.childCount > 0 && i.firstChild.type == t);
    return s ? r ? n.node(s.depth - 1).type == t ? F4(e, r, t, s) : z4(e, r, s) : !0 : !1;
  };
}
function F4(t, e, r, n) {
  let o = t.tr, s = n.end, i = n.$to.end(n.depth);
  s < i && (o.step(new gt(s - 1, i, s, i, new X(U.from(r.create(null, n.parent.copy())), 1, 0), 1, !0)), n = new di(o.doc.resolve(n.$from.pos), o.doc.resolve(i), n.depth));
  const a = ho(n);
  if (a == null)
    return !1;
  o.lift(n, a);
  let l = o.doc.resolve(o.mapping.map(s, -1) - 1);
  return rn(o.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && o.join(l.pos), e(o.scrollIntoView()), !0;
}
function z4(t, e, r) {
  let n = t.tr, o = r.parent;
  for (let p = r.end, h = r.endIndex - 1, g = r.startIndex; h > g; h--)
    p -= o.child(h).nodeSize, n.delete(p - 1, p + 1);
  let s = n.doc.resolve(r.start), i = s.nodeAfter;
  if (n.mapping.map(r.end) != r.start + s.nodeAfter.nodeSize)
    return !1;
  let a = r.startIndex == 0, l = r.endIndex == o.childCount, d = s.node(-1), c = s.index(-1);
  if (!d.canReplace(c + (a ? 0 : 1), c + 1, i.content.append(l ? U.empty : U.from(o))))
    return !1;
  let u = s.pos, f = u + i.nodeSize;
  return n.step(new gt(u - (a ? 1 : 0), f + (l ? 1 : 0), u + 1, f - 1, new X((a ? U.empty : U.from(o.copy(U.empty))).append(l ? U.empty : U.from(o.copy(U.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(n.scrollIntoView()), !0;
}
function H4(t) {
  return function(e, r) {
    let { $from: n, $to: o } = e.selection, s = n.blockRange(o, (d) => d.childCount > 0 && d.firstChild.type == t);
    if (!s)
      return !1;
    let i = s.startIndex;
    if (i == 0)
      return !1;
    let a = s.parent, l = a.child(i - 1);
    if (l.type != t)
      return !1;
    if (r) {
      let d = l.lastChild && l.lastChild.type == a.type, c = U.from(d ? t.create() : null), u = new X(U.from(t.create(null, U.from(a.type.create(null, c)))), d ? 3 : 1, 0), f = s.start, p = s.end;
      r(e.tr.step(new gt(f - (d ? 3 : 1), p, f, p, u, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
const On = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, _0 = function(t, e, r, n) {
  return r && (Af(t, e, r, n, -1) || Af(t, e, r, n, 1));
}, B4 = /^(img|br|input|textarea|hr)$/i;
function Af(t, e, r, n, o) {
  for (var s; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (o < 0 ? 0 : ui(t))) {
      let i = t.parentNode;
      if (!i || i.nodeType != 1 || ec(t) || B4.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = On(t) + (o < 0 ? 0 : 1), t = i;
    } else if (t.nodeType == 1) {
      let i = t.childNodes[e + (o < 0 ? -1 : 0)];
      if (i.nodeType == 1 && i.contentEditable == "false")
        if (!((s = i.pmViewDesc) === null || s === void 0) && s.ignoreForSelection)
          e += o;
        else
          return !1;
      else
        t = i, e = o < 0 ? ui(t) : 0;
    } else
      return !1;
  }
}
function ui(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function V4(t, e, r) {
  for (let n = e == 0, o = e == ui(t); n || o; ) {
    if (t == r)
      return !0;
    let s = On(t);
    if (t = t.parentNode, !t)
      return !1;
    n = n && s == 0, o = o && s == ui(t);
  }
}
function ec(t) {
  let e;
  for (let r = t; r && !(e = r.pmViewDesc); r = r.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const F0 = function(t) {
  return t.focusNode && _0(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function z0(t, e) {
  let r = document.createEvent("Event");
  return r.initEvent("keydown", !0, !0), r.keyCode = t, r.key = r.code = e, r;
}
const pr = typeof navigator < "u" ? navigator : null, Mf = typeof document < "u" ? document : null, nn = pr && pr.userAgent || "", Gl = /Edge\/(\d+)/.exec(nn), H0 = /MSIE \d/.exec(nn), Kl = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nn), is = !!(H0 || Kl || Gl), B0 = H0 ? document.documentMode : Kl ? +Kl[1] : Gl ? +Gl[1] : 0, fa = !is && /gecko\/(\d+)/i.test(nn);
fa && +(/Firefox\/(\d+)/.exec(nn) || [0, 0])[1];
const Yl = !is && /Chrome\/(\d+)/.exec(nn), jr = !!Yl, V0 = Yl ? +Yl[1] : 0, Ln = !is && !!pr && /Apple Computer/.test(pr.vendor), tc = Ln && (/Mobile\/\w+/.test(nn) || !!pr && pr.maxTouchPoints > 2), Jt = tc || (pr ? /Mac/.test(pr.platform) : !1), W0 = pr ? /Win/.test(pr.platform) : !1, as = /Android \d/.test(nn), rc = !!Mf && "webkitFontSmoothing" in Mf.documentElement.style, W4 = rc ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function U4(t, e = null) {
  let r = t.domSelectionRange(), n = t.state.doc;
  if (!r.focusNode)
    return null;
  let o = t.docView.nearestDesc(r.focusNode), s = o && o.size == 0, i = t.docView.posFromDOM(r.focusNode, r.focusOffset, 1);
  if (i < 0)
    return null;
  let a = n.resolve(i), l, d;
  if (F0(r)) {
    for (l = i; o && !o.node; )
      o = o.parent;
    let u = o.node;
    if (o && u.isAtom && ue.isSelectable(u) && o.parent && !(u.isInline && V4(r.focusNode, r.focusOffset, o.dom))) {
      let f = o.posBefore;
      d = new ue(i == f ? a : n.resolve(f));
    }
  } else {
    if (r instanceof t.dom.ownerDocument.defaultView.Selection && r.rangeCount > 1) {
      let u = i, f = i;
      for (let p = 0; p < r.rangeCount; p++) {
        let h = r.getRangeAt(p);
        u = Math.min(u, t.docView.posFromDOM(h.startContainer, h.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(h.endContainer, h.endOffset, -1));
      }
      if (u < 0)
        return null;
      [l, i] = f == t.state.selection.anchor ? [f, u] : [u, f], a = n.resolve(i);
    } else
      l = t.docView.posFromDOM(r.anchorNode, r.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let c = n.resolve(l);
  if (!d) {
    let u = e == "pointer" || t.state.selection.head < a.pos && !s ? 1 : -1;
    d = G0(t, c, a, u);
  }
  return d;
}
function U0(t) {
  return t.editable ? t.hasFocus() : J4(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function nc(t, e = !1) {
  let r = t.state.selection;
  if (Y4(t, r), !!U0(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && jr) {
      let n = t.domSelectionRange(), o = t.domObserver.currentSelection;
      if (n.anchorNode && o.anchorNode && _0(n.anchorNode, n.anchorOffset, o.anchorNode, o.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      K4(t);
    else {
      let { anchor: n, head: o } = r, s, i;
      Pf && !(r instanceof fe) && (r.$from.parent.inlineContent || (s = If(t, r.from)), !r.empty && !r.$from.parent.inlineContent && (i = If(t, r.to))), t.docView.setSelection(n, o, t, e), Pf && (s && Rf(s), i && Rf(i)), r.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && G4(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const Pf = Ln || jr && V0 < 63;
function If(t, e) {
  let { node: r, offset: n } = t.docView.domFromPos(e, 0), o = n < r.childNodes.length ? r.childNodes[n] : null, s = n ? r.childNodes[n - 1] : null;
  if (Ln && o && o.contentEditable == "false")
    return Ga(o);
  if ((!o || o.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (o)
      return Ga(o);
    if (s)
      return Ga(s);
  }
}
function Ga(t) {
  return t.contentEditable = "true", Ln && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Rf(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function G4(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let r = t.domSelectionRange(), n = r.anchorNode, o = r.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (r.anchorNode != n || r.anchorOffset != o) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!U0(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function K4(t) {
  let e = t.domSelection();
  if (!e)
    return;
  let r = t.cursorWrapper.dom, n = r.nodeName == "IMG";
  n ? e.collapse(r.parentNode, On(r) + 1) : e.collapse(r, 0), !n && !t.state.selection.visible && is && B0 <= 11 && (r.disabled = !0, r.disabled = !1);
}
function Y4(t, e) {
  if (e instanceof ue) {
    let r = t.docView.descAt(e.from);
    r != t.lastSelectedViewDesc && (Of(t), r && r.selectNode(), t.lastSelectedViewDesc = r);
  } else
    Of(t);
}
function Of(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function G0(t, e, r, n) {
  return t.someProp("createSelectionBetween", (o) => o(t, e, r)) || fe.between(e, r, n);
}
function J4(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Jl(t, e) {
  let { $anchor: r, $head: n } = t.selection, o = e > 0 ? r.max(n) : r.min(n), s = o.parent.inlineContent ? o.depth ? t.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
  return s && be.findFrom(s, e);
}
function Br(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Lf(t, e, r) {
  let n = t.state.selection;
  if (n instanceof fe)
    if (r.indexOf("s") > -1) {
      let { $head: o } = n, s = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let i = t.state.doc.resolve(o.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Br(t, new fe(n.$anchor, i));
    } else if (n.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let o = Jl(t.state, e);
        return o && o instanceof ue ? Br(t, o) : !1;
      } else if (!(Jt && r.indexOf("m") > -1)) {
        let o = n.$head, s = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, i;
        if (!s || s.isText)
          return !1;
        let a = e < 0 ? o.pos - s.nodeSize : o.pos;
        return s.isAtom || (i = t.docView.descAt(a)) && !i.contentDOM ? ue.isSelectable(s) ? Br(t, new ue(e < 0 ? t.state.doc.resolve(o.pos - s.nodeSize) : o)) : rc ? Br(t, new fe(t.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (n instanceof ue && n.node.isInline)
      return Br(t, new fe(e > 0 ? n.$to : n.$from));
    {
      let o = Jl(t.state, e);
      return o ? Br(t, o) : !1;
    }
  }
}
function fi(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Oo(t, e) {
  let r = t.pmViewDesc;
  return r && r.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Vn(t, e) {
  return e < 0 ? q4(t) : X4(t);
}
function q4(t) {
  let e = t.domSelectionRange(), r = e.focusNode, n = e.focusOffset;
  if (!r)
    return;
  let o, s, i = !1;
  for (fa && r.nodeType == 1 && n < fi(r) && Oo(r.childNodes[n], -1) && (i = !0); ; )
    if (n > 0) {
      if (r.nodeType != 1)
        break;
      {
        let a = r.childNodes[n - 1];
        if (Oo(a, -1))
          o = r, s = --n;
        else if (a.nodeType == 3)
          r = a, n = r.nodeValue.length;
        else
          break;
      }
    } else {
      if (K0(r))
        break;
      {
        let a = r.previousSibling;
        for (; a && Oo(a, -1); )
          o = r.parentNode, s = On(a), a = a.previousSibling;
        if (a)
          r = a, n = fi(r);
        else {
          if (r = r.parentNode, r == t.dom)
            break;
          n = 0;
        }
      }
    }
  i ? ql(t, r, n) : o && ql(t, o, s);
}
function X4(t) {
  let e = t.domSelectionRange(), r = e.focusNode, n = e.focusOffset;
  if (!r)
    return;
  let o = fi(r), s, i;
  for (; ; )
    if (n < o) {
      if (r.nodeType != 1)
        break;
      let a = r.childNodes[n];
      if (Oo(a, 1))
        s = r, i = ++n;
      else
        break;
    } else {
      if (K0(r))
        break;
      {
        let a = r.nextSibling;
        for (; a && Oo(a, 1); )
          s = a.parentNode, i = On(a) + 1, a = a.nextSibling;
        if (a)
          r = a, n = 0, o = fi(r);
        else {
          if (r = r.parentNode, r == t.dom)
            break;
          n = o = 0;
        }
      }
    }
  s && ql(t, s, i);
}
function K0(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function Z4(t, e) {
  for (; t && e == t.childNodes.length && !ec(t); )
    e = On(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let r = t.childNodes[e];
    if (r.nodeType == 3)
      return r;
    if (r.nodeType == 1 && r.contentEditable == "false")
      break;
    t = r, e = 0;
  }
}
function Q4(t, e) {
  for (; t && !e && !ec(t); )
    e = On(t), t = t.parentNode;
  for (; t && e; ) {
    let r = t.childNodes[e - 1];
    if (r.nodeType == 3)
      return r;
    if (r.nodeType == 1 && r.contentEditable == "false")
      break;
    t = r, e = t.childNodes.length;
  }
}
function ql(t, e, r) {
  if (e.nodeType != 3) {
    let s, i;
    (i = Z4(e, r)) ? (e = i, r = 0) : (s = Q4(e, r)) && (e = s, r = s.nodeValue.length);
  }
  let n = t.domSelection();
  if (!n)
    return;
  if (F0(n)) {
    let s = document.createRange();
    s.setEnd(e, r), s.setStart(e, r), n.removeAllRanges(), n.addRange(s);
  } else n.extend && n.extend(e, r);
  t.domObserver.setCurSelection();
  let { state: o } = t;
  setTimeout(() => {
    t.state == o && nc(t);
  }, 50);
}
function jf(t, e) {
  let r = t.state.doc.resolve(e);
  if (!(jr || W0) && r.parent.inlineContent) {
    let o = t.coordsAtPos(e);
    if (e > r.start()) {
      let s = t.coordsAtPos(e - 1), i = (s.top + s.bottom) / 2;
      if (i > o.top && i < o.bottom && Math.abs(s.left - o.left) > 1)
        return s.left < o.left ? "ltr" : "rtl";
    }
    if (e < r.end()) {
      let s = t.coordsAtPos(e + 1), i = (s.top + s.bottom) / 2;
      if (i > o.top && i < o.bottom && Math.abs(s.left - o.left) > 1)
        return s.left > o.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Df(t, e, r) {
  let n = t.state.selection;
  if (n instanceof fe && !n.empty || r.indexOf("s") > -1 || Jt && r.indexOf("m") > -1)
    return !1;
  let { $from: o, $to: s } = n;
  if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let i = Jl(t.state, e);
    if (i && i instanceof ue)
      return Br(t, i);
  }
  if (!o.parent.inlineContent) {
    let i = e < 0 ? o : s, a = n instanceof Ht ? be.near(i, e) : be.findFrom(i, e);
    return a ? Br(t, a) : !1;
  }
  return !1;
}
function _f(t, e) {
  if (!(t.state.selection instanceof fe))
    return !0;
  let { $head: r, $anchor: n, empty: o } = t.state.selection;
  if (!r.sameParent(n))
    return !0;
  if (!o)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !r.textOffset && (e < 0 ? r.nodeBefore : r.nodeAfter);
  if (s && !s.isText) {
    let i = t.state.tr;
    return e < 0 ? i.delete(r.pos - s.nodeSize, r.pos) : i.delete(r.pos, r.pos + s.nodeSize), t.dispatch(i), !0;
  }
  return !1;
}
function Ff(t, e, r) {
  t.domObserver.stop(), e.contentEditable = r, t.domObserver.start();
}
function e5(t) {
  if (!Ln || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: r } = t.domSelectionRange();
  if (e && e.nodeType == 1 && r == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let n = e.firstChild;
    Ff(t, n, "true"), setTimeout(() => Ff(t, n, "false"), 20);
  }
  return !1;
}
function t5(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function r5(t, e) {
  let r = e.keyCode, n = t5(e);
  if (r == 8 || Jt && r == 72 && n == "c")
    return _f(t, -1) || Vn(t, -1);
  if (r == 46 && !e.shiftKey || Jt && r == 68 && n == "c")
    return _f(t, 1) || Vn(t, 1);
  if (r == 13 || r == 27)
    return !0;
  if (r == 37 || Jt && r == 66 && n == "c") {
    let o = r == 37 ? jf(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Lf(t, o, n) || Vn(t, o);
  } else if (r == 39 || Jt && r == 70 && n == "c") {
    let o = r == 39 ? jf(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Lf(t, o, n) || Vn(t, o);
  } else {
    if (r == 38 || Jt && r == 80 && n == "c")
      return Df(t, -1, n) || Vn(t, -1);
    if (r == 40 || Jt && r == 78 && n == "c")
      return e5(t) || Df(t, 1, n) || Vn(t, 1);
    if (n == (Jt ? "m" : "c") && (r == 66 || r == 73 || r == 89 || r == 90))
      return !0;
  }
  return !1;
}
function Y0(t, e) {
  t.someProp("transformCopied", (p) => {
    e = p(e, t);
  });
  let r = [], { content: n, openStart: o, openEnd: s } = e;
  for (; o > 1 && s > 1 && n.childCount == 1 && n.firstChild.childCount == 1; ) {
    o--, s--;
    let p = n.firstChild;
    r.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), n = p.content;
  }
  let i = t.someProp("clipboardSerializer") || la.fromSchema(t.state.schema), a = eg(), l = a.createElement("div");
  l.appendChild(i.serializeFragment(n, { document: a }));
  let d = l.firstChild, c, u = 0;
  for (; d && d.nodeType == 1 && (c = Q0[d.nodeName.toLowerCase()]); ) {
    for (let p = c.length - 1; p >= 0; p--) {
      let h = a.createElement(c[p]);
      for (; l.firstChild; )
        h.appendChild(l.firstChild);
      l.appendChild(h), u++;
    }
    d = l.firstChild;
  }
  d && d.nodeType == 1 && d.setAttribute("data-pm-slice", `${o} ${s}${u ? ` -${u}` : ""} ${JSON.stringify(r)}`);
  let f = t.someProp("clipboardTextSerializer", (p) => p(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function J0(t, e, r, n, o) {
  let s = o.parent.type.spec.code, i, a;
  if (!r && !e)
    return null;
  let l = !!e && (n || s || !r);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, s || n, t);
    }), s)
      return a = new X(U.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), t.someProp("transformPasted", (f) => {
        a = f(a, t, !0);
      }), a;
    let u = t.someProp("clipboardTextParser", (f) => f(e, o, n, t));
    if (u)
      a = u;
    else {
      let f = o.marks(), { schema: p } = t.state, h = la.fromSchema(p);
      i = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let b = i.appendChild(document.createElement("p"));
        g && b.appendChild(h.serializeNode(p.text(g, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (u) => {
      r = u(r, t);
    }), i = i5(r), rc && a5(i);
  let d = i && i.querySelector("[data-pm-slice]"), c = d && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(d.getAttribute("data-pm-slice") || "");
  if (c && c[3])
    for (let u = +c[3]; u > 0; u--) {
      let f = i.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      i = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || xn.fromSchema(t.state.schema)).parseSlice(i, {
    preserveWhitespace: !!(l || c),
    context: o,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !n5.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), c)
    a = l5(zf(a, +c[1], +c[2]), c[4]);
  else if (a = X.maxOpen(o5(a.content, o), !0), a.openStart || a.openEnd) {
    let u = 0, f = 0;
    for (let p = a.content.firstChild; u < a.openStart && !p.type.spec.isolating; u++, p = p.firstChild)
      ;
    for (let p = a.content.lastChild; f < a.openEnd && !p.type.spec.isolating; f++, p = p.lastChild)
      ;
    a = zf(a, u, f);
  }
  return t.someProp("transformPasted", (u) => {
    a = u(a, t, l);
  }), a;
}
const n5 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function o5(t, e) {
  if (t.childCount < 2)
    return t;
  for (let r = e.depth; r >= 0; r--) {
    let o = e.node(r).contentMatchAt(e.index(r)), s, i = [];
    if (t.forEach((a) => {
      if (!i)
        return;
      let l = o.findWrapping(a.type), d;
      if (!l)
        return i = null;
      if (d = i.length && s.length && X0(l, s, a, i[i.length - 1], 0))
        i[i.length - 1] = d;
      else {
        i.length && (i[i.length - 1] = Z0(i[i.length - 1], s.length));
        let c = q0(a, l);
        i.push(c), o = o.matchType(c.type), s = l;
      }
    }), i)
      return U.from(i);
  }
  return t;
}
function q0(t, e, r = 0) {
  for (let n = e.length - 1; n >= r; n--)
    t = e[n].create(null, U.from(t));
  return t;
}
function X0(t, e, r, n, o) {
  if (o < t.length && o < e.length && t[o] == e[o]) {
    let s = X0(t, e, r, n.lastChild, o + 1);
    if (s)
      return n.copy(n.content.replaceChild(n.childCount - 1, s));
    if (n.contentMatchAt(n.childCount).matchType(o == t.length - 1 ? r.type : t[o + 1]))
      return n.copy(n.content.append(U.from(q0(r, t, o + 1))));
  }
}
function Z0(t, e) {
  if (e == 0)
    return t;
  let r = t.content.replaceChild(t.childCount - 1, Z0(t.lastChild, e - 1)), n = t.contentMatchAt(t.childCount).fillBefore(U.empty, !0);
  return t.copy(r.append(n));
}
function Xl(t, e, r, n, o, s) {
  let i = e < 0 ? t.firstChild : t.lastChild, a = i.content;
  return t.childCount > 1 && (s = 0), o < n - 1 && (a = Xl(a, e, r, n, o + 1, s)), o >= r && (a = e < 0 ? i.contentMatchAt(0).fillBefore(a, s <= o).append(a) : a.append(i.contentMatchAt(i.childCount).fillBefore(U.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, i.copy(a));
}
function zf(t, e, r) {
  return e < t.openStart && (t = new X(Xl(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), r < t.openEnd && (t = new X(Xl(t.content, 1, r, t.openEnd, 0, 0), t.openStart, r)), t;
}
const Q0 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Hf = null;
function eg() {
  return Hf || (Hf = document.implementation.createHTMLDocument("title"));
}
let Ka = null;
function s5(t) {
  let e = window.trustedTypes;
  return e ? (Ka || (Ka = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (r) => r })), Ka.createHTML(t)) : t;
}
function i5(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let r = eg().createElement("div"), n = /<([a-z][^>\s]+)/i.exec(t), o;
  if ((o = n && Q0[n[1].toLowerCase()]) && (t = o.map((s) => "<" + s + ">").join("") + t + o.map((s) => "</" + s + ">").reverse().join("")), r.innerHTML = s5(t), o)
    for (let s = 0; s < o.length; s++)
      r = r.querySelector(o[s]) || r;
  return r;
}
function a5(t) {
  let e = t.querySelectorAll(jr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    n.childNodes.length == 1 && n.textContent == "" && n.parentNode && n.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), n);
  }
}
function l5(t, e) {
  if (!t.size)
    return t;
  let r = t.content.firstChild.type.schema, n;
  try {
    n = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: o, openStart: s, openEnd: i } = t;
  for (let a = n.length - 2; a >= 0; a -= 2) {
    let l = r.nodes[n[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    o = U.from(l.create(n[a + 1], o)), s++, i++;
  }
  return new X(o, s, i);
}
const nr = {}, Bt = {};
function Zr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
Bt.keydown = (t, e) => {
  let r = e;
  if (t.input.shiftKey = r.keyCode == 16 || r.shiftKey, !rg(t, r) && (t.input.lastKeyCode = r.keyCode, t.input.lastKeyCodeTime = Date.now(), !(as && jr && r.keyCode == 13)))
    if (r.keyCode != 229 && t.domObserver.forceFlush(), tc && r.keyCode == 13 && !r.ctrlKey && !r.altKey && !r.metaKey) {
      let n = Date.now();
      t.input.lastIOSEnter = n, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == n && (t.someProp("handleKeyDown", (o) => o(t, z0(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (n) => n(t, r)) || r5(t, r) ? r.preventDefault() : Zr(t, "key");
};
Bt.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Bt.keypress = (t, e) => {
  let r = e;
  if (rg(t, r) || !r.charCode || r.ctrlKey && !r.altKey || Jt && r.metaKey)
    return;
  if (t.someProp("handleKeyPress", (o) => o(t, r))) {
    r.preventDefault();
    return;
  }
  let n = t.state.selection;
  if (!(n instanceof fe) || !n.$from.sameParent(n.$to)) {
    let o = String.fromCharCode(r.charCode), s = () => t.state.tr.insertText(o).scrollIntoView();
    !/[\r\n]/.test(o) && !t.someProp("handleTextInput", (i) => i(t, n.$from.pos, n.$to.pos, o, s)) && t.dispatch(s()), r.preventDefault();
  }
};
function pa(t) {
  return { left: t.clientX, top: t.clientY };
}
function d5(t, e) {
  let r = e.x - t.clientX, n = e.y - t.clientY;
  return r * r + n * n < 100;
}
function oc(t, e, r, n, o) {
  if (n == -1)
    return !1;
  let s = t.state.doc.resolve(n);
  for (let i = s.depth + 1; i > 0; i--)
    if (t.someProp(e, (a) => i > s.depth ? a(t, r, s.nodeAfter, s.before(i), o, !0) : a(t, r, s.node(i), s.before(i), o, !1)))
      return !0;
  return !1;
}
function eo(t, e, r) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let n = t.state.tr.setSelection(e);
  n.setMeta("pointer", !0), t.dispatch(n);
}
function c5(t, e) {
  if (e == -1)
    return !1;
  let r = t.state.doc.resolve(e), n = r.nodeAfter;
  return n && n.isAtom && ue.isSelectable(n) ? (eo(t, new ue(r)), !0) : !1;
}
function u5(t, e) {
  if (e == -1)
    return !1;
  let r = t.state.selection, n, o;
  r instanceof ue && (n = r.node);
  let s = t.state.doc.resolve(e);
  for (let i = s.depth + 1; i > 0; i--) {
    let a = i > s.depth ? s.nodeAfter : s.node(i);
    if (ue.isSelectable(a)) {
      n && r.$from.depth > 0 && i >= r.$from.depth && s.before(r.$from.depth + 1) == r.$from.pos ? o = s.before(r.$from.depth) : o = s.before(i);
      break;
    }
  }
  return o != null ? (eo(t, ue.create(t.state.doc, o)), !0) : !1;
}
function f5(t, e, r, n, o) {
  return oc(t, "handleClickOn", e, r, n) || t.someProp("handleClick", (s) => s(t, e, n)) || (o ? u5(t, r) : c5(t, r));
}
function p5(t, e, r, n) {
  return oc(t, "handleDoubleClickOn", e, r, n) || t.someProp("handleDoubleClick", (o) => o(t, e, n));
}
function h5(t, e, r, n) {
  return oc(t, "handleTripleClickOn", e, r, n) || t.someProp("handleTripleClick", (o) => o(t, e, n)) || m5(t, r, n);
}
function m5(t, e, r) {
  if (r.button != 0)
    return !1;
  let n = t.state.doc;
  if (e == -1)
    return n.inlineContent ? (eo(t, fe.create(n, 0, n.content.size)), !0) : !1;
  let o = n.resolve(e);
  for (let s = o.depth + 1; s > 0; s--) {
    let i = s > o.depth ? o.nodeAfter : o.node(s), a = o.before(s);
    if (i.inlineContent)
      eo(t, fe.create(n, a + 1, a + 1 + i.content.size));
    else if (ue.isSelectable(i))
      eo(t, ue.create(n, a));
    else
      continue;
    return !0;
  }
}
function sc(t) {
  return pi(t);
}
const tg = Jt ? "metaKey" : "ctrlKey";
nr.mousedown = (t, e) => {
  let r = e;
  t.input.shiftKey = r.shiftKey;
  let n = sc(t), o = Date.now(), s = "singleClick";
  o - t.input.lastClick.time < 500 && d5(r, t.input.lastClick) && !r[tg] && t.input.lastClick.button == r.button && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: o, x: r.clientX, y: r.clientY, type: s, button: r.button };
  let i = t.posAtCoords(pa(r));
  i && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new g5(t, i, r, !!n)) : (s == "doubleClick" ? p5 : h5)(t, i.pos, i.inside, r) ? r.preventDefault() : Zr(t, "pointer"));
};
class g5 {
  constructor(e, r, n, o) {
    this.view = e, this.pos = r, this.event = n, this.flushed = o, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!n[tg], this.allowDefault = n.shiftKey;
    let s, i;
    if (r.inside > -1)
      s = e.state.doc.nodeAt(r.inside), i = r.inside;
    else {
      let c = e.state.doc.resolve(r.pos);
      s = c.parent, i = c.depth ? c.before() : 0;
    }
    const a = o ? null : n.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.nodeDOM.nodeType == 1 ? l.nodeDOM : null;
    let { selection: d } = e.state;
    (n.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || d instanceof ue && d.from <= i && d.to > i) && (this.mightDrag = {
      node: s,
      pos: i,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && fa && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Zr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => nc(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let r = this.pos;
    this.view.state.doc != this.startDoc && (r = this.view.posAtCoords(pa(e))), this.updateAllowDefault(e), this.allowDefault || !r ? Zr(this.view, "pointer") : f5(this.view, r.pos, r.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Ln && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    jr && !this.view.state.selection.visible && Math.min(Math.abs(r.pos - this.view.state.selection.from), Math.abs(r.pos - this.view.state.selection.to)) <= 2) ? (eo(this.view, be.near(this.view.state.doc.resolve(r.pos))), e.preventDefault()) : Zr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Zr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
nr.touchstart = (t) => {
  t.input.lastTouch = Date.now(), sc(t), Zr(t, "pointer");
};
nr.touchmove = (t) => {
  t.input.lastTouch = Date.now(), Zr(t, "pointer");
};
nr.contextmenu = (t) => sc(t);
function rg(t, e) {
  return t.composing ? !0 : Ln && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const b5 = as ? 5e3 : -1;
Bt.compositionstart = Bt.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, r = e.selection.$to;
    if (e.selection instanceof fe && (e.storedMarks || !r.textOffset && r.parentOffset && r.nodeBefore.marks.some((n) => n.type.spec.inclusive === !1) || jr && W0 && y5(t)))
      t.markCursor = t.state.storedMarks || r.marks(), pi(t, !0), t.markCursor = null;
    else if (pi(t, !e.selection.empty), fa && e.selection.empty && r.parentOffset && !r.textOffset && r.nodeBefore.marks.length) {
      let n = t.domSelectionRange();
      for (let o = n.focusNode, s = n.focusOffset; o && o.nodeType == 1 && s != 0; ) {
        let i = s < 0 ? o.lastChild : o.childNodes[s - 1];
        if (!i)
          break;
        if (i.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(i, i.nodeValue.length);
          break;
        } else
          o = i, s = -1;
      }
    }
    t.input.composing = !0;
  }
  ng(t, b5);
};
function y5(t) {
  let { focusNode: e, focusOffset: r } = t.domSelectionRange();
  if (!e || e.nodeType != 1 || r >= e.childNodes.length)
    return !1;
  let n = e.childNodes[r];
  return n.nodeType == 1 && n.contentEditable == "false";
}
Bt.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.badSafariComposition ? t.domObserver.forceFlush() : t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, ng(t, 20));
};
function ng(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => pi(t), e));
}
function v5(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = $5()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function $5() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function pi(t, e = !1) {
  if (!(as && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), v5(t), e || t.docView && t.docView.dirty) {
      let r = U4(t), n = t.state.selection;
      return r && !r.eq(n) ? t.dispatch(t.state.tr.setSelection(r)) : (t.markCursor || e) && !n.$from.node(n.$from.sharedDepth(n.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function x5(t, e) {
  if (!t.dom.parentNode)
    return;
  let r = t.dom.parentNode.appendChild(document.createElement("div"));
  r.appendChild(e), r.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let n = getSelection(), o = document.createRange();
  o.selectNodeContents(e), t.dom.blur(), n.removeAllRanges(), n.addRange(o), setTimeout(() => {
    r.parentNode && r.parentNode.removeChild(r), t.focus();
  }, 50);
}
const Qo = is && B0 < 15 || tc && W4 < 604;
nr.copy = Bt.cut = (t, e) => {
  let r = e, n = t.state.selection, o = r.type == "cut";
  if (n.empty)
    return;
  let s = Qo ? null : r.clipboardData, i = n.content(), { dom: a, text: l } = Y0(t, i);
  s ? (r.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : x5(t, a), o && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function w5(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function k5(t, e) {
  if (!t.dom.parentNode)
    return;
  let r = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, n = t.dom.parentNode.appendChild(document.createElement(r ? "textarea" : "div"));
  r || (n.contentEditable = "true"), n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus();
  let o = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), n.parentNode && n.parentNode.removeChild(n), r ? Zl(t, n.value, null, o, e) : Zl(t, n.textContent, n.innerHTML, o, e);
  }, 50);
}
function Zl(t, e, r, n, o) {
  let s = J0(t, e, r, n, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, o, s || X.empty)))
    return !0;
  if (!s)
    return !1;
  let i = w5(s), a = i ? t.state.tr.replaceSelectionWith(i, n) : t.state.tr.replaceSelection(s);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function og(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let r = t.getData("text/uri-list");
  return r ? r.replace(/\r?\n/g, " ") : "";
}
Bt.paste = (t, e) => {
  let r = e;
  if (t.composing && !as)
    return;
  let n = Qo ? null : r.clipboardData, o = t.input.shiftKey && t.input.lastKeyCode != 45;
  n && Zl(t, og(n), n.getData("text/html"), o, r) ? r.preventDefault() : k5(t, r);
};
class E5 {
  constructor(e, r, n) {
    this.slice = e, this.move = r, this.node = n;
  }
}
const C5 = Jt ? "altKey" : "ctrlKey";
function sg(t, e) {
  let r = t.someProp("dragCopies", (n) => !n(e));
  return r ?? !e[C5];
}
nr.dragstart = (t, e) => {
  let r = e, n = t.input.mouseDown;
  if (n && n.done(), !r.dataTransfer)
    return;
  let o = t.state.selection, s = o.empty ? null : t.posAtCoords(pa(r)), i;
  if (!(s && s.pos >= o.from && s.pos <= (o instanceof ue ? o.to - 1 : o.to))) {
    if (n && n.mightDrag)
      i = ue.create(t.state.doc, n.mightDrag.pos);
    else if (r.target && r.target.nodeType == 1) {
      let u = t.docView.nearestDesc(r.target, !0);
      u && u.node.type.spec.draggable && u != t.docView && (i = ue.create(t.state.doc, u.posBefore));
    }
  }
  let a = (i || t.state.selection).content(), { dom: l, text: d, slice: c } = Y0(t, a);
  (!r.dataTransfer.files.length || !jr || V0 > 120) && r.dataTransfer.clearData(), r.dataTransfer.setData(Qo ? "Text" : "text/html", l.innerHTML), r.dataTransfer.effectAllowed = "copyMove", Qo || r.dataTransfer.setData("text/plain", d), t.dragging = new E5(c, sg(t, r), i);
};
nr.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Bt.dragover = Bt.dragenter = (t, e) => e.preventDefault();
Bt.drop = (t, e) => {
  try {
    S5(t, e, t.dragging);
  } finally {
    t.dragging = null;
  }
};
function S5(t, e, r) {
  if (!e.dataTransfer)
    return;
  let n = t.posAtCoords(pa(e));
  if (!n)
    return;
  let o = t.state.doc.resolve(n.pos), s = r && r.slice;
  s ? t.someProp("transformPasted", (p) => {
    s = p(s, t, !1);
  }) : s = J0(t, og(e.dataTransfer), Qo ? null : e.dataTransfer.getData("text/html"), !1, o);
  let i = !!(r && sg(t, e));
  if (t.someProp("handleDrop", (p) => p(t, e, s || X.empty, i))) {
    e.preventDefault();
    return;
  }
  if (!s)
    return;
  e.preventDefault();
  let a = s ? b0(t.state.doc, o.pos, s) : o.pos;
  a == null && (a = o.pos);
  let l = t.state.tr;
  if (i) {
    let { node: p } = r;
    p ? p.replace(l) : l.deleteSelection();
  }
  let d = l.mapping.map(a), c = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, u = l.doc;
  if (c ? l.replaceRangeWith(d, d, s.content.firstChild) : l.replaceRange(d, d, s), l.doc.eq(u))
    return;
  let f = l.doc.resolve(d);
  if (c && ue.isSelectable(s.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(s.content.firstChild))
    l.setSelection(new ue(f));
  else {
    let p = l.mapping.map(a);
    l.mapping.maps[l.mapping.maps.length - 1].forEach((h, g, b, y) => p = y), l.setSelection(G0(t, f, l.doc.resolve(p)));
  }
  t.focus(), t.dispatch(l.setMeta("uiEvent", "drop"));
}
nr.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && nc(t);
  }, 20));
};
nr.blur = (t, e) => {
  let r = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), r.relatedTarget && t.dom.contains(r.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
nr.beforeinput = (t, e) => {
  if (jr && as && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: n } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != n || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (s) => s(t, z0(8, "Backspace")))))
        return;
      let { $cursor: o } = t.state.selection;
      o && o.pos > 0 && t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Bt)
  nr[t] = Bt[t];
function es(t, e) {
  if (t == e)
    return !0;
  for (let r in t)
    if (t[r] !== e[r])
      return !1;
  for (let r in e)
    if (!(r in t))
      return !1;
  return !0;
}
class hi {
  constructor(e, r) {
    this.toDOM = e, this.spec = r || wn, this.side = this.spec.side || 0;
  }
  map(e, r, n, o) {
    let { pos: s, deleted: i } = e.mapResult(r.from + o, this.side < 0 ? -1 : 1);
    return i ? null : new Et(s - n, s - n, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof hi && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && es(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Qr {
  constructor(e, r) {
    this.attrs = e, this.spec = r || wn;
  }
  map(e, r, n, o) {
    let s = e.map(r.from + o, this.spec.inclusiveStart ? -1 : 1) - n, i = e.map(r.to + o, this.spec.inclusiveEnd ? 1 : -1) - n;
    return s >= i ? null : new Et(s, i, this);
  }
  valid(e, r) {
    return r.from < r.to;
  }
  eq(e) {
    return this == e || e instanceof Qr && es(this.attrs, e.attrs) && es(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Qr;
  }
  destroy() {
  }
}
class ic {
  constructor(e, r) {
    this.attrs = e, this.spec = r || wn;
  }
  map(e, r, n, o) {
    let s = e.mapResult(r.from + o, 1);
    if (s.deleted)
      return null;
    let i = e.mapResult(r.to + o, -1);
    return i.deleted || i.pos <= s.pos ? null : new Et(s.pos - n, i.pos - n, this);
  }
  valid(e, r) {
    let { index: n, offset: o } = e.content.findIndex(r.from), s;
    return o == r.from && !(s = e.child(n)).isText && o + s.nodeSize == r.to;
  }
  eq(e) {
    return this == e || e instanceof ic && es(this.attrs, e.attrs) && es(this.spec, e.spec);
  }
  destroy() {
  }
}
class Et {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.type = n;
  }
  /**
  @internal
  */
  copy(e, r) {
    return new Et(e, r, this.type);
  }
  /**
  @internal
  */
  eq(e, r = 0) {
    return this.type.eq(e.type) && this.from + r == e.from && this.to + r == e.to;
  }
  /**
  @internal
  */
  map(e, r, n) {
    return this.type.map(e, this, r, n);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, r, n) {
    return new Et(e, e, new hi(r, n));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, r, n, o) {
    return new Et(e, r, new Qr(n, o));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, r, n, o) {
    return new Et(e, r, new ic(n, o));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Qr;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof hi;
  }
}
const Un = [], wn = {};
class Ue {
  /**
  @internal
  */
  constructor(e, r) {
    this.local = e.length ? e : Un, this.children = r.length ? r : Un;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, r) {
    return r.length ? mi(r, e, 0, wn) : Mt;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, r, n) {
    let o = [];
    return this.findInner(e ?? 0, r ?? 1e9, o, 0, n), o;
  }
  findInner(e, r, n, o, s) {
    for (let i = 0; i < this.local.length; i++) {
      let a = this.local[i];
      a.from <= r && a.to >= e && (!s || s(a.spec)) && n.push(a.copy(a.from + o, a.to + o));
    }
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] < r && this.children[i + 1] > e) {
        let a = this.children[i] + 1;
        this.children[i + 2].findInner(e - a, r - a, n, o + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, r, n) {
    return this == Mt || e.maps.length == 0 ? this : this.mapInner(e, r, 0, 0, n || wn);
  }
  /**
  @internal
  */
  mapInner(e, r, n, o, s) {
    let i;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, n, o);
      l && l.type.valid(r, l) ? (i || (i = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? N5(this.children, i || [], e, r, n, o, s) : i ? new Ue(i.sort(kn), Un) : Mt;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, r) {
    return r.length ? this == Mt ? Ue.create(e, r) : this.addInner(e, r, 0) : this;
  }
  addInner(e, r, n) {
    let o, s = 0;
    e.forEach((a, l) => {
      let d = l + n, c;
      if (c = ag(r, a, d)) {
        for (o || (o = this.children.slice()); s < o.length && o[s] < l; )
          s += 3;
        o[s] == l ? o[s + 2] = o[s + 2].addInner(a, c, d + 1) : o.splice(s, 0, l, l + a.nodeSize, mi(c, a, d + 1, wn)), s += 3;
      }
    });
    let i = ig(s ? lg(r) : r, -n);
    for (let a = 0; a < i.length; a++)
      i[a].type.valid(e, i[a]) || i.splice(a--, 1);
    return new Ue(i.length ? this.local.concat(i).sort(kn) : this.local, o || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Mt ? this : this.removeInner(e, 0);
  }
  removeInner(e, r) {
    let n = this.children, o = this.local;
    for (let s = 0; s < n.length; s += 3) {
      let i, a = n[s] + r, l = n[s + 1] + r;
      for (let c = 0, u; c < e.length; c++)
        (u = e[c]) && u.from > a && u.to < l && (e[c] = null, (i || (i = [])).push(u));
      if (!i)
        continue;
      n == this.children && (n = this.children.slice());
      let d = n[s + 2].removeInner(i, a + 1);
      d != Mt ? n[s + 2] = d : (n.splice(s, 3), s -= 3);
    }
    if (o.length) {
      for (let s = 0, i; s < e.length; s++)
        if (i = e[s])
          for (let a = 0; a < o.length; a++)
            o[a].eq(i, r) && (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
    }
    return n == this.children && o == this.local ? this : o.length || n.length ? new Ue(o, n) : Mt;
  }
  forChild(e, r) {
    if (this == Mt)
      return this;
    if (r.isLeaf)
      return Ue.empty;
    let n, o;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (n = this.children[a + 2]);
        break;
      }
    let s = e + 1, i = s + r.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < i && l.to > s && l.type instanceof Qr) {
        let d = Math.max(s, l.from) - s, c = Math.min(i, l.to) - s;
        d < c && (o || (o = [])).push(l.copy(d, c));
      }
    }
    if (o) {
      let a = new Ue(o.sort(kn), Un);
      return n ? new pn([a, n]) : a;
    }
    return n || Mt;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Ue) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let r = 0; r < this.local.length; r++)
      if (!this.local[r].eq(e.local[r]))
        return !1;
    for (let r = 0; r < this.children.length; r += 3)
      if (this.children[r] != e.children[r] || this.children[r + 1] != e.children[r + 1] || !this.children[r + 2].eq(e.children[r + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return ac(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Mt)
      return Un;
    if (e.inlineContent || !this.local.some(Qr.is))
      return this.local;
    let r = [];
    for (let n = 0; n < this.local.length; n++)
      this.local[n].type instanceof Qr || r.push(this.local[n]);
    return r;
  }
  forEachSet(e) {
    e(this);
  }
}
Ue.empty = new Ue([], []);
Ue.removeOverlap = ac;
const Mt = Ue.empty;
class pn {
  constructor(e) {
    this.members = e;
  }
  map(e, r) {
    const n = this.members.map((o) => o.map(e, r, wn));
    return pn.from(n);
  }
  forChild(e, r) {
    if (r.isLeaf)
      return Ue.empty;
    let n = [];
    for (let o = 0; o < this.members.length; o++) {
      let s = this.members[o].forChild(e, r);
      s != Mt && (s instanceof pn ? n = n.concat(s.members) : n.push(s));
    }
    return pn.from(n);
  }
  eq(e) {
    if (!(e instanceof pn) || e.members.length != this.members.length)
      return !1;
    for (let r = 0; r < this.members.length; r++)
      if (!this.members[r].eq(e.members[r]))
        return !1;
    return !0;
  }
  locals(e) {
    let r, n = !0;
    for (let o = 0; o < this.members.length; o++) {
      let s = this.members[o].localsInner(e);
      if (s.length)
        if (!r)
          r = s;
        else {
          n && (r = r.slice(), n = !1);
          for (let i = 0; i < s.length; i++)
            r.push(s[i]);
        }
    }
    return r ? ac(n ? r : r.sort(kn)) : Un;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Mt;
      case 1:
        return e[0];
      default:
        return new pn(e.every((r) => r instanceof Ue) ? e : e.reduce((r, n) => r.concat(n instanceof Ue ? n : n.members), []));
    }
  }
  forEachSet(e) {
    for (let r = 0; r < this.members.length; r++)
      this.members[r].forEachSet(e);
  }
}
function N5(t, e, r, n, o, s, i) {
  let a = t.slice();
  for (let d = 0, c = s; d < r.maps.length; d++) {
    let u = 0;
    r.maps[d].forEach((f, p, h, g) => {
      let b = g - h - (p - f);
      for (let y = 0; y < a.length; y += 3) {
        let $ = a[y + 1];
        if ($ < 0 || f > $ + c - u)
          continue;
        let k = a[y] + c - u;
        p >= k ? a[y + 1] = f <= k ? -2 : -1 : f >= c && b && (a[y] += b, a[y + 1] += b);
      }
      u += b;
    }), c = r.maps[d].map(c, -1);
  }
  let l = !1;
  for (let d = 0; d < a.length; d += 3)
    if (a[d + 1] < 0) {
      if (a[d + 1] == -2) {
        l = !0, a[d + 1] = -1;
        continue;
      }
      let c = r.map(t[d] + s), u = c - o;
      if (u < 0 || u >= n.content.size) {
        l = !0;
        continue;
      }
      let f = r.map(t[d + 1] + s, -1), p = f - o, { index: h, offset: g } = n.content.findIndex(u), b = n.maybeChild(h);
      if (b && g == u && g + b.nodeSize == p) {
        let y = a[d + 2].mapInner(r, b, c + 1, t[d] + s + 1, i);
        y != Mt ? (a[d] = u, a[d + 1] = p, a[d + 2] = y) : (a[d + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let d = T5(a, t, e, r, o, s, i), c = mi(d, n, 0, i);
    e = c.local;
    for (let u = 0; u < a.length; u += 3)
      a[u + 1] < 0 && (a.splice(u, 3), u -= 3);
    for (let u = 0, f = 0; u < c.children.length; u += 3) {
      let p = c.children[u];
      for (; f < a.length && a[f] < p; )
        f += 3;
      a.splice(f, 0, c.children[u], c.children[u + 1], c.children[u + 2]);
    }
  }
  return new Ue(e.sort(kn), a);
}
function ig(t, e) {
  if (!e || !t.length)
    return t;
  let r = [];
  for (let n = 0; n < t.length; n++) {
    let o = t[n];
    r.push(new Et(o.from + e, o.to + e, o.type));
  }
  return r;
}
function T5(t, e, r, n, o, s, i) {
  function a(l, d) {
    for (let c = 0; c < l.local.length; c++) {
      let u = l.local[c].map(n, o, d);
      u ? r.push(u) : i.onRemove && i.onRemove(l.local[c].spec);
    }
    for (let c = 0; c < l.children.length; c += 3)
      a(l.children[c + 2], l.children[c] + d + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + s + 1);
  return r;
}
function ag(t, e, r) {
  if (e.isLeaf)
    return null;
  let n = r + e.nodeSize, o = null;
  for (let s = 0, i; s < t.length; s++)
    (i = t[s]) && i.from > r && i.to < n && ((o || (o = [])).push(i), t[s] = null);
  return o;
}
function lg(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    t[r] != null && e.push(t[r]);
  return e;
}
function mi(t, e, r, n) {
  let o = [], s = !1;
  e.forEach((a, l) => {
    let d = ag(t, a, l + r);
    if (d) {
      s = !0;
      let c = mi(d, a, r + l + 1, n);
      c != Mt && o.push(l, l + a.nodeSize, c);
    }
  });
  let i = ig(s ? lg(t) : t, -r).sort(kn);
  for (let a = 0; a < i.length; a++)
    i[a].type.valid(e, i[a]) || (n.onRemove && n.onRemove(i[a].spec), i.splice(a--, 1));
  return i.length || o.length ? new Ue(i, o) : Mt;
}
function kn(t, e) {
  return t.from - e.from || t.to - e.to;
}
function ac(t) {
  let e = t;
  for (let r = 0; r < e.length - 1; r++) {
    let n = e[r];
    if (n.from != n.to)
      for (let o = r + 1; o < e.length; o++) {
        let s = e[o];
        if (s.from == n.from) {
          s.to != n.to && (e == t && (e = t.slice()), e[o] = s.copy(s.from, n.to), Bf(e, o + 1, s.copy(n.to, s.to)));
          continue;
        } else {
          s.from < n.to && (e == t && (e = t.slice()), e[r] = n.copy(n.from, s.from), Bf(e, o, n.copy(s.from, n.to)));
          break;
        }
      }
  }
  return e;
}
function Bf(t, e, r) {
  for (; e < t.length && kn(r, t[e]) > 0; )
    e++;
  t.splice(e, 0, r);
}
var en = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, gi = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, A5 = typeof navigator < "u" && /Mac/.test(navigator.platform), M5 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var xt = 0; xt < 10; xt++) en[48 + xt] = en[96 + xt] = String(xt);
for (var xt = 1; xt <= 24; xt++) en[xt + 111] = "F" + xt;
for (var xt = 65; xt <= 90; xt++)
  en[xt] = String.fromCharCode(xt + 32), gi[xt] = String.fromCharCode(xt);
for (var Ya in en) gi.hasOwnProperty(Ya) || (gi[Ya] = en[Ya]);
function P5(t) {
  var e = A5 && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || M5 && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? gi : en)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
const I5 = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), R5 = typeof navigator < "u" && /Win/.test(navigator.platform);
function O5(t) {
  let e = t.split(/-(?!$)/), r = e[e.length - 1];
  r == "Space" && (r = " ");
  let n, o, s, i;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      i = !0;
    else if (/^a(lt)?$/i.test(l))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      o = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      I5 ? i = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return n && (r = "Alt-" + r), o && (r = "Ctrl-" + r), i && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
}
function L5(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t)
    e[O5(r)] = t[r];
  return e;
}
function Ja(t, e, r = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r && e.shiftKey && (t = "Shift-" + t), t;
}
function dg(t) {
  let e = L5(t);
  return function(r, n) {
    let o = P5(n), s, i = e[Ja(o, n)];
    if (i && i(r.state, r.dispatch, r))
      return !0;
    if (o.length == 1 && o != " ") {
      if (n.shiftKey) {
        let a = e[Ja(o, n, !1)];
        if (a && a(r.state, r.dispatch, r))
          return !0;
      }
      if ((n.altKey || n.metaKey || n.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(R5 && n.ctrlKey && n.altKey) && (s = en[n.keyCode]) && s != o) {
        let a = e[Ja(s, n)];
        if (a && a(r.state, r.dispatch, r))
          return !0;
      }
    }
    return !1;
  };
}
var j5 = Object.defineProperty, lc = (t, e) => {
  for (var r in e)
    j5(t, r, { get: e[r], enumerable: !0 });
};
function cg(t) {
  const { state: e, transaction: r } = t;
  let { selection: n } = r, { doc: o } = r, { storedMarks: s } = r;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return s;
    },
    get selection() {
      return n;
    },
    get doc() {
      return o;
    },
    get tr() {
      return n = r.selection, o = r.doc, s = r.storedMarks, r;
    }
  };
}
var D5 = class {
  constructor(t) {
    this.editor = t.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = t.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: t, editor: e, state: r } = this, { view: n } = e, { tr: o } = r, s = this.buildProps(o);
    return Object.fromEntries(
      Object.entries(t).map(([i, a]) => [i, (...d) => {
        const c = a(...d)(s);
        return !o.getMeta("preventDispatch") && !this.hasCustomState && n.dispatch(o), c;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(t, e = !0) {
    const { rawCommands: r, editor: n, state: o } = this, { view: s } = n, i = [], a = !!t, l = t || o.tr, d = () => (!a && e && !l.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(l), i.every((u) => u === !0)), c = {
      ...Object.fromEntries(
        Object.entries(r).map(([u, f]) => [u, (...h) => {
          const g = this.buildProps(l, e), b = f(...h)(g);
          return i.push(b), c;
        }])
      ),
      run: d
    };
    return c;
  }
  createCan(t) {
    const { rawCommands: e, state: r } = this, n = !1, o = t || r.tr, s = this.buildProps(o, n);
    return {
      ...Object.fromEntries(
        Object.entries(e).map(([a, l]) => [a, (...d) => l(...d)({ ...s, dispatch: void 0 })])
      ),
      chain: () => this.createChain(o, n)
    };
  }
  buildProps(t, e = !0) {
    const { rawCommands: r, editor: n, state: o } = this, { view: s } = n, i = {
      tr: t,
      editor: n,
      view: s,
      state: cg({
        state: o,
        transaction: t
      }),
      dispatch: e ? () => {
      } : void 0,
      chain: () => this.createChain(t, e),
      can: () => this.createCan(t),
      get commands() {
        return Object.fromEntries(
          Object.entries(r).map(([a, l]) => [a, (...d) => l(...d)(i)])
        );
      }
    };
    return i;
  }
}, ug = {};
lc(ug, {
  blur: () => _5,
  clearContent: () => F5,
  clearNodes: () => z5,
  command: () => H5,
  createParagraphNear: () => B5,
  cut: () => V5,
  deleteCurrentNode: () => W5,
  deleteNode: () => U5,
  deleteRange: () => G5,
  deleteSelection: () => K5,
  enter: () => Y5,
  exitCode: () => J5,
  extendMarkRange: () => X5,
  first: () => Z5,
  focus: () => t9,
  forEach: () => r9,
  insertContent: () => n9,
  insertContentAt: () => i9,
  joinBackward: () => d9,
  joinDown: () => l9,
  joinForward: () => c9,
  joinItemBackward: () => u9,
  joinItemForward: () => f9,
  joinTextblockBackward: () => p9,
  joinTextblockForward: () => h9,
  joinUp: () => a9,
  keyboardShortcut: () => g9,
  lift: () => b9,
  liftEmptyBlock: () => y9,
  liftListItem: () => v9,
  newlineInCode: () => $9,
  resetAttributes: () => x9,
  scrollIntoView: () => w9,
  selectAll: () => k9,
  selectNodeBackward: () => E9,
  selectNodeForward: () => C9,
  selectParentNode: () => S9,
  selectTextblockEnd: () => N9,
  selectTextblockStart: () => T9,
  setContent: () => M9,
  setMark: () => G9,
  setMeta: () => K9,
  setNode: () => Y9,
  setNodeSelection: () => J9,
  setTextDirection: () => q9,
  setTextSelection: () => X9,
  sinkListItem: () => Z9,
  splitBlock: () => Q9,
  splitListItem: () => e6,
  toggleList: () => t6,
  toggleMark: () => r6,
  toggleNode: () => n6,
  toggleWrap: () => o6,
  undoInputRule: () => s6,
  unsetAllMarks: () => i6,
  unsetMark: () => a6,
  unsetTextDirection: () => l6,
  updateAttributes: () => d6,
  wrapIn: () => c6,
  wrapInList: () => u6
});
var _5 = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var r;
  t.isDestroyed || (e.dom.blur(), (r = window == null ? void 0 : window.getSelection()) == null || r.removeAllRanges());
}), !0), F5 = (t = !0) => ({ commands: e }) => e.setContent("", { emitUpdate: t }), z5 = () => ({ state: t, tr: e, dispatch: r }) => {
  const { selection: n } = e, { ranges: o } = n;
  return r && o.forEach(({ $from: s, $to: i }) => {
    t.doc.nodesBetween(s.pos, i.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: d, mapping: c } = e, u = d.resolve(c.map(l)), f = d.resolve(c.map(l + a.nodeSize)), p = u.blockRange(f);
      if (!p)
        return;
      const h = ho(p);
      if (a.type.isTextblock) {
        const { defaultType: g } = u.parent.contentMatchAt(u.index());
        e.setNodeMarkup(p.start, g);
      }
      (h || h === 0) && e.lift(p, h);
    });
  }), !0;
}, H5 = (t) => (e) => t(e), B5 = () => ({ state: t, dispatch: e }) => O0(t, e), V5 = (t, e) => ({ editor: r, tr: n }) => {
  const { state: o } = r, s = o.doc.slice(t.from, t.to);
  n.deleteRange(t.from, t.to);
  const i = n.mapping.map(e);
  return n.insert(i, s.content), n.setSelection(new fe(n.doc.resolve(Math.max(i - 1, 0)))), !0;
}, W5 = () => ({ tr: t, dispatch: e }) => {
  const { selection: r } = t, n = r.$anchor.node();
  if (n.content.size > 0)
    return !1;
  const o = t.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === n.type) {
      if (e) {
        const a = o.before(s), l = o.after(s);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function dt(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
var U5 = (t) => ({ tr: e, state: r, dispatch: n }) => {
  const o = dt(t, r.schema), s = e.selection.$anchor;
  for (let i = s.depth; i > 0; i -= 1)
    if (s.node(i).type === o) {
      if (n) {
        const l = s.before(i), d = s.after(i);
        e.delete(l, d).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, G5 = (t) => ({ tr: e, dispatch: r }) => {
  const { from: n, to: o } = t;
  return r && e.delete(n, o), !0;
}, K5 = () => ({ state: t, dispatch: e }) => Jd(t, e), Y5 = () => ({ commands: t }) => t.keyboardShortcut("Enter"), J5 = () => ({ state: t, dispatch: e }) => N4(t, e);
function q5(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
function bi(t, e, r = { strict: !0 }) {
  const n = Object.keys(e);
  return n.length ? n.every((o) => r.strict ? e[o] === t[o] : q5(e[o]) ? e[o].test(t[o]) : e[o] === t[o]) : !0;
}
function fg(t, e, r = {}) {
  return t.find((n) => n.type === e && bi(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(r).map((o) => [o, n.attrs[o]])),
    r
  ));
}
function Vf(t, e, r = {}) {
  return !!fg(t, e, r);
}
function dc(t, e, r) {
  var n;
  if (!t || !e)
    return;
  let o = t.parent.childAfter(t.parentOffset);
  if ((!o.node || !o.node.marks.some((c) => c.type === e)) && (o = t.parent.childBefore(t.parentOffset)), !o.node || !o.node.marks.some((c) => c.type === e) || (r = r || ((n = o.node.marks[0]) == null ? void 0 : n.attrs), !fg([...o.node.marks], e, r)))
    return;
  let i = o.index, a = t.start() + o.offset, l = i + 1, d = a + o.node.nodeSize;
  for (; i > 0 && Vf([...t.parent.child(i - 1).marks], e, r); )
    i -= 1, a -= t.parent.child(i).nodeSize;
  for (; l < t.parent.childCount && Vf([...t.parent.child(l).marks], e, r); )
    d += t.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: d
  };
}
function on(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
var X5 = (t, e = {}) => ({ tr: r, state: n, dispatch: o }) => {
  const s = on(t, n.schema), { doc: i, selection: a } = r, { $from: l, from: d, to: c } = a;
  if (o) {
    const u = dc(l, s, e);
    if (u && u.from <= d && u.to >= c) {
      const f = fe.create(i, u.from, u.to);
      r.setSelection(f);
    }
  }
  return !0;
}, Z5 = (t) => (e) => {
  const r = typeof t == "function" ? t(e) : t;
  for (let n = 0; n < r.length; n += 1)
    if (r[n](e))
      return !0;
  return !1;
};
function pg(t) {
  return t instanceof fe;
}
function gn(t = 0, e = 0, r = 0) {
  return Math.min(Math.max(t, e), r);
}
function Q5(t, e = null) {
  if (!e)
    return null;
  const r = be.atStart(t), n = be.atEnd(t);
  if (e === "start" || e === !0)
    return r;
  if (e === "end")
    return n;
  const o = r.from, s = n.to;
  return e === "all" ? fe.create(t, gn(0, o, s), gn(t.content.size, o, s)) : fe.create(t, gn(e, o, s), gn(e, o, s));
}
function Wf() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function yi() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function e9() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var t9 = (t = null, e = {}) => ({ editor: r, view: n, tr: o, dispatch: s }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const i = () => {
    (yi() || Wf()) && n.dom.focus(), e9() && !yi() && !Wf() && n.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      r.isDestroyed || (n.focus(), e != null && e.scrollIntoView && r.commands.scrollIntoView());
    });
  };
  if (n.hasFocus() && t === null || t === !1)
    return !0;
  if (s && t === null && !pg(r.state.selection))
    return i(), !0;
  const a = Q5(o.doc, t) || r.state.selection, l = r.state.selection.eq(a);
  return s && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), i()), !0;
}, r9 = (t, e) => (r) => t.every((n, o) => e(n, { ...r, index: o })), n9 = (t, e) => ({ tr: r, commands: n }) => n.insertContentAt({ from: r.selection.from, to: r.selection.to }, t, e), hg = (t) => {
  const e = t.childNodes;
  for (let r = e.length - 1; r >= 0; r -= 1) {
    const n = e[r];
    n.nodeType === 3 && n.nodeValue && /^(\n\s\s|\n)$/.test(n.nodeValue) ? t.removeChild(n) : n.nodeType === 1 && hg(n);
  }
  return t;
};
function Ns(t) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const e = `<body>${t}</body>`, r = new window.DOMParser().parseFromString(e, "text/html").body;
  return hg(r);
}
function ts(t, e, r) {
  if (t instanceof $n || t instanceof U)
    return t;
  r = {
    slice: !0,
    parseOptions: {},
    ...r
  };
  const n = typeof t == "object" && t !== null, o = typeof t == "string";
  if (n)
    try {
      if (Array.isArray(t) && t.length > 0)
        return U.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const i = e.nodeFromJSON(t);
      return r.errorOnInvalidContent && i.check(), i;
    } catch (s) {
      if (r.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: s });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", s), ts("", e, r);
    }
  if (o) {
    if (r.errorOnInvalidContent) {
      let i = !1, a = "";
      const l = new Uw({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (d) => (i = !0, a = typeof d == "string" ? d : d.outerHTML, null)
              }
            ]
          }
        })
      });
      if (r.slice ? xn.fromSchema(l).parseSlice(Ns(t), r.parseOptions) : xn.fromSchema(l).parse(Ns(t), r.parseOptions), r.errorOnInvalidContent && i)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const s = xn.fromSchema(e);
    return r.slice ? s.parseSlice(Ns(t), r.parseOptions).content : s.parse(Ns(t), r.parseOptions);
  }
  return ts("", e, r);
}
function o9(t, e, r) {
  const n = t.steps.length - 1;
  if (n < e)
    return;
  const o = t.steps[n];
  if (!(o instanceof mt || o instanceof gt))
    return;
  const s = t.mapping.maps[n];
  let i = 0;
  s.forEach((a, l, d, c) => {
    i === 0 && (i = c);
  }), t.setSelection(be.near(t.doc.resolve(i), r));
}
var s9 = (t) => !("type" in t), i9 = (t, e, r) => ({ tr: n, dispatch: o, editor: s }) => {
  var i;
  if (o) {
    r = {
      parseOptions: s.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...r
    };
    let a;
    const l = (b) => {
      s.emit("contentError", {
        editor: s,
        error: b,
        disableCollaboration: () => {
          "collaboration" in s.storage && typeof s.storage.collaboration == "object" && s.storage.collaboration && (s.storage.collaboration.isDisabled = !0);
        }
      });
    }, d = {
      preserveWhitespace: "full",
      ...r.parseOptions
    };
    if (!r.errorOnInvalidContent && !s.options.enableContentCheck && s.options.emitContentError)
      try {
        ts(e, s.schema, {
          parseOptions: d,
          errorOnInvalidContent: !0
        });
      } catch (b) {
        l(b);
      }
    try {
      a = ts(e, s.schema, {
        parseOptions: d,
        errorOnInvalidContent: (i = r.errorOnInvalidContent) != null ? i : s.options.enableContentCheck
      });
    } catch (b) {
      return l(b), !1;
    }
    let { from: c, to: u } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, f = !0, p = !0;
    if ((s9(a) ? a : [a]).forEach((b) => {
      b.check(), f = f ? b.isText && b.marks.length === 0 : !1, p = p ? b.isBlock : !1;
    }), c === u && p) {
      const { parent: b } = n.doc.resolve(c);
      b.isTextblock && !b.type.spec.code && !b.childCount && (c -= 1, u += 1);
    }
    let g;
    if (f) {
      if (Array.isArray(e))
        g = e.map((b) => b.text || "").join("");
      else if (e instanceof U) {
        let b = "";
        e.forEach((y) => {
          y.text && (b += y.text);
        }), g = b;
      } else typeof e == "object" && e && e.text ? g = e.text : g = e;
      n.insertText(g, c, u);
    } else {
      g = a;
      const b = n.doc.resolve(c), y = b.node(), $ = b.parentOffset === 0, k = y.isText || y.isTextblock, w = y.content.size > 0;
      $ && k && w && (c = Math.max(0, c - 1)), n.replaceWith(c, u, g);
    }
    r.updateSelection && o9(n, n.steps.length - 1, -1), r.applyInputRules && n.setMeta("applyInputRules", { from: c, text: g }), r.applyPasteRules && n.setMeta("applyPasteRules", { from: c, text: g });
  }
  return !0;
}, a9 = () => ({ state: t, dispatch: e }) => E4(t, e), l9 = () => ({ state: t, dispatch: e }) => C4(t, e), d9 = () => ({ state: t, dispatch: e }) => N0(t, e), c9 = () => ({ state: t, dispatch: e }) => P0(t, e), u9 = () => ({ state: t, dispatch: e, tr: r }) => {
  try {
    const n = da(t.doc, t.selection.$from.pos, -1);
    return n == null ? !1 : (r.join(n, 2), e && e(r), !0);
  } catch {
    return !1;
  }
}, f9 = () => ({ state: t, dispatch: e, tr: r }) => {
  try {
    const n = da(t.doc, t.selection.$from.pos, 1);
    return n == null ? !1 : (r.join(n, 2), e && e(r), !0);
  } catch {
    return !1;
  }
}, p9 = () => ({ state: t, dispatch: e }) => w4(t, e), h9 = () => ({ state: t, dispatch: e }) => k4(t, e);
function mg() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function m9(t) {
  const e = t.split(/-(?!$)/);
  let r = e[e.length - 1];
  r === "Space" && (r = " ");
  let n, o, s, i;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      i = !0;
    else if (/^a(lt)?$/i.test(l))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      o = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      yi() || mg() ? i = !0 : o = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return n && (r = `Alt-${r}`), o && (r = `Ctrl-${r}`), i && (r = `Meta-${r}`), s && (r = `Shift-${r}`), r;
}
var g9 = (t) => ({ editor: e, view: r, tr: n, dispatch: o }) => {
  const s = m9(t).split(/-(?!$)/), i = s.find((d) => !["Alt", "Ctrl", "Meta", "Shift"].includes(d)), a = new KeyboardEvent("keydown", {
    key: i === "Space" ? " " : i,
    altKey: s.includes("Alt"),
    ctrlKey: s.includes("Ctrl"),
    metaKey: s.includes("Meta"),
    shiftKey: s.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    r.someProp("handleKeyDown", (d) => d(r, a));
  });
  return l == null || l.steps.forEach((d) => {
    const c = d.map(n.mapping);
    c && o && n.maybeStep(c);
  }), !0;
};
function ao(t, e, r = {}) {
  const { from: n, to: o, empty: s } = t.selection, i = e ? dt(e, t.schema) : null, a = [];
  t.doc.nodesBetween(n, o, (u, f) => {
    if (u.isText)
      return;
    const p = Math.max(n, f), h = Math.min(o, f + u.nodeSize);
    a.push({
      node: u,
      from: p,
      to: h
    });
  });
  const l = o - n, d = a.filter((u) => i ? i.name === u.node.type.name : !0).filter((u) => bi(u.node.attrs, r, { strict: !1 }));
  return s ? !!d.length : d.reduce((u, f) => u + f.to - f.from, 0) >= l;
}
var b9 = (t, e = {}) => ({ state: r, dispatch: n }) => {
  const o = dt(t, r.schema);
  return ao(r, o, e) ? S4(r, n) : !1;
}, y9 = () => ({ state: t, dispatch: e }) => L0(t, e), v9 = (t) => ({ state: e, dispatch: r }) => {
  const n = dt(t, e.schema);
  return _4(n)(e, r);
}, $9 = () => ({ state: t, dispatch: e }) => R0(t, e);
function cc(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Uf(t, e) {
  const r = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((n, o) => (r.includes(o) || (n[o] = t[o]), n), {});
}
var x9 = (t, e) => ({ tr: r, state: n, dispatch: o }) => {
  let s = null, i = null;
  const a = cc(
    typeof t == "string" ? t : t.name,
    n.schema
  );
  if (!a)
    return !1;
  a === "node" && (s = dt(t, n.schema)), a === "mark" && (i = on(t, n.schema));
  let l = !1;
  return r.selection.ranges.forEach((d) => {
    n.doc.nodesBetween(d.$from.pos, d.$to.pos, (c, u) => {
      s && s === c.type && (l = !0, o && r.setNodeMarkup(u, void 0, Uf(c.attrs, e))), i && c.marks.length && c.marks.forEach((f) => {
        i === f.type && (l = !0, o && r.addMark(u, u + c.nodeSize, i.create(Uf(f.attrs, e))));
      });
    });
  }), l;
}, w9 = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), k9 = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const r = new Ht(t.doc);
    t.setSelection(r);
  }
  return !0;
}, E9 = () => ({ state: t, dispatch: e }) => A0(t, e), C9 = () => ({ state: t, dispatch: e }) => I0(t, e), S9 = () => ({ state: t, dispatch: e }) => M4(t, e), N9 = () => ({ state: t, dispatch: e }) => R4(t, e), T9 = () => ({ state: t, dispatch: e }) => I4(t, e);
function A9(t, e, r = {}, n = {}) {
  return ts(t, e, {
    slice: !1,
    parseOptions: r,
    errorOnInvalidContent: n.errorOnInvalidContent
  });
}
var M9 = (t, { errorOnInvalidContent: e, emitUpdate: r = !0, parseOptions: n = {} } = {}) => ({ editor: o, tr: s, dispatch: i, commands: a }) => {
  const { doc: l } = s;
  if (n.preserveWhitespace !== "full") {
    const d = A9(t, o.schema, n, {
      errorOnInvalidContent: e ?? o.options.enableContentCheck
    });
    return i && s.replaceWith(0, l.content.size, d).setMeta("preventUpdate", !r), !0;
  }
  return i && s.setMeta("preventUpdate", !r), a.insertContentAt({ from: 0, to: l.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: e ?? o.options.enableContentCheck
  });
};
function gg(t, e) {
  const r = on(e, t.schema), { from: n, to: o, empty: s } = t.selection, i = [];
  s ? (t.storedMarks && i.push(...t.storedMarks), i.push(...t.selection.$head.marks())) : t.doc.nodesBetween(n, o, (l) => {
    i.push(...l.marks);
  });
  const a = i.find((l) => l.type.name === r.name);
  return a ? { ...a.attrs } : {};
}
function bg(t, e) {
  const r = new w0(t);
  return e.forEach((n) => {
    n.steps.forEach((o) => {
      r.step(o);
    });
  }), r;
}
function P9(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: r } = t.edge(e);
    if (r.isTextblock && !r.hasRequiredAttrs())
      return r;
  }
  return null;
}
function I9(t, e, r) {
  const n = [];
  return t.nodesBetween(e.from, e.to, (o, s) => {
    r(o) && n.push({
      node: o,
      pos: s
    });
  }), n;
}
function yg(t, e) {
  for (let r = t.depth; r > 0; r -= 1) {
    const n = t.node(r);
    if (e(n))
      return {
        pos: r > 0 ? t.before(r) : 0,
        start: t.start(r),
        depth: r,
        node: n
      };
  }
}
function ha(t) {
  return (e) => yg(e.$from, t);
}
function Tn(t, e, r) {
  return t.config[e] === void 0 && t.parent ? Tn(t.parent, e, r) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...r,
    parent: t.parent ? Tn(t.parent, e, r) : null
  }) : t.config[e];
}
function R9(t) {
  return typeof t == "function";
}
function hr(t, e = void 0, ...r) {
  return R9(t) ? e ? t.bind(e)(...r) : t(...r) : t;
}
function vg(t) {
  const e = t.filter((o) => o.type === "extension"), r = t.filter((o) => o.type === "node"), n = t.filter((o) => o.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: r,
    markExtensions: n
  };
}
function Re(...t) {
  return t.filter((e) => !!e).reduce((e, r) => {
    const n = { ...e };
    return Object.entries(r).forEach(([o, s]) => {
      if (!n[o]) {
        n[o] = s;
        return;
      }
      if (o === "class") {
        const a = s ? String(s).split(" ") : [], l = n[o] ? n[o].split(" ") : [], d = a.filter((c) => !l.includes(c));
        n[o] = [...l, ...d].join(" ");
      } else if (o === "style") {
        const a = s ? s.split(";").map((c) => c.trim()).filter(Boolean) : [], l = n[o] ? n[o].split(";").map((c) => c.trim()).filter(Boolean) : [], d = /* @__PURE__ */ new Map();
        l.forEach((c) => {
          const [u, f] = c.split(":").map((p) => p.trim());
          d.set(u, f);
        }), a.forEach((c) => {
          const [u, f] = c.split(":").map((p) => p.trim());
          d.set(u, f);
        }), n[o] = Array.from(d.entries()).map(([c, u]) => `${c}: ${u}`).join("; ");
      } else
        n[o] = s;
    }), n;
  }, {});
}
function O9(t, e) {
  return e.filter((r) => r.type === t.type.name).filter((r) => r.attribute.rendered).map((r) => r.attribute.renderHTML ? r.attribute.renderHTML(t.attrs) || {} : {
    [r.name]: t.attrs[r.name]
  }).reduce((r, n) => Re(r, n), {});
}
function L9(t, e, r) {
  const { from: n, to: o } = e, { blockSeparator: s = `

`, textSerializers: i = {} } = r || {};
  let a = "";
  return t.nodesBetween(n, o, (l, d, c, u) => {
    var f;
    l.isBlock && d > n && (a += s);
    const p = i == null ? void 0 : i[l.type.name];
    if (p)
      return c && (a += p({
        node: l,
        pos: d,
        parent: c,
        index: u,
        range: e
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) == null ? void 0 : f.slice(Math.max(n, d) - d, o - d));
  }), a;
}
function j9(t) {
  return Object.fromEntries(
    Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, r]) => [e, r.spec.toText])
  );
}
function D9(t, e) {
  const r = dt(e, t.schema), { from: n, to: o } = t.selection, s = [];
  t.doc.nodesBetween(n, o, (a) => {
    s.push(a);
  });
  const i = s.reverse().find((a) => a.type.name === r.name);
  return i ? { ...i.attrs } : {};
}
function _9(t, e) {
  const r = cc(
    typeof e == "string" ? e : e.name,
    t.schema
  );
  return r === "node" ? D9(t, e) : r === "mark" ? gg(t, e) : {};
}
function F9(t, e = JSON.stringify) {
  const r = {};
  return t.filter((n) => {
    const o = e(n);
    return Object.prototype.hasOwnProperty.call(r, o) ? !1 : r[o] = !0;
  });
}
function z9(t) {
  const e = F9(t);
  return e.length === 1 ? e : e.filter((r, n) => !e.filter((s, i) => i !== n).some((s) => r.oldRange.from >= s.oldRange.from && r.oldRange.to <= s.oldRange.to && r.newRange.from >= s.newRange.from && r.newRange.to <= s.newRange.to));
}
function $g(t) {
  const { mapping: e, steps: r } = t, n = [];
  return e.maps.forEach((o, s) => {
    const i = [];
    if (o.ranges.length)
      o.forEach((a, l) => {
        i.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = r[s];
      if (a === void 0 || l === void 0)
        return;
      i.push({ from: a, to: l });
    }
    i.forEach(({ from: a, to: l }) => {
      const d = e.slice(s).map(a, -1), c = e.slice(s).map(l), u = e.invert().map(d, -1), f = e.invert().map(c);
      n.push({
        oldRange: {
          from: u,
          to: f
        },
        newRange: {
          from: d,
          to: c
        }
      });
    });
  }), z9(n);
}
function uc(t, e, r) {
  const n = [];
  return t === e ? r.resolve(t).marks().forEach((o) => {
    const s = r.resolve(t), i = dc(s, o.type);
    i && n.push({
      mark: o,
      ...i
    });
  }) : r.nodesBetween(t, e, (o, s) => {
    !o || (o == null ? void 0 : o.nodeSize) === void 0 || n.push(
      ...o.marks.map((i) => ({
        from: s,
        to: s + o.nodeSize,
        mark: i
      }))
    );
  }), n;
}
var H9 = (t, e, r, n = 20) => {
  const o = t.doc.resolve(r);
  let s = n, i = null;
  for (; s > 0 && i === null; ) {
    const a = o.node(s);
    (a == null ? void 0 : a.type.name) === e ? i = a : s -= 1;
  }
  return [i, s];
};
function Hs(t, e, r) {
  return Object.fromEntries(
    Object.entries(r).filter(([n]) => {
      const o = t.find((s) => s.type === e && s.name === n);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
function B9(t, e, r = {}) {
  const { empty: n, ranges: o } = t.selection, s = e ? on(e, t.schema) : null;
  if (n)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((u) => s ? s.name === u.type.name : !0).find((u) => bi(u.attrs, r, { strict: !1 }));
  let i = 0;
  const a = [];
  if (o.forEach(({ $from: u, $to: f }) => {
    const p = u.pos, h = f.pos;
    t.doc.nodesBetween(p, h, (g, b) => {
      if (!g.isText && !g.marks.length)
        return;
      const y = Math.max(p, b), $ = Math.min(h, b + g.nodeSize), k = $ - y;
      i += k, a.push(
        ...g.marks.map((w) => ({
          mark: w,
          from: y,
          to: $
        }))
      );
    });
  }), i === 0)
    return !1;
  const l = a.filter((u) => s ? s.name === u.mark.type.name : !0).filter((u) => bi(u.mark.attrs, r, { strict: !1 })).reduce((u, f) => u + f.to - f.from, 0), d = a.filter((u) => s ? u.mark.type !== s && u.mark.type.excludes(s) : !0).reduce((u, f) => u + f.to - f.from, 0);
  return (l > 0 ? l + d : l) >= i;
}
var V9 = (t, e) => {
  const { $from: r, $to: n, $anchor: o } = t.selection;
  if (e) {
    const s = ha((a) => a.type.name === e)(t.selection);
    if (!s)
      return !1;
    const i = t.doc.resolve(s.pos + 1);
    return o.pos + 1 === i.end();
  }
  return !(n.parentOffset < n.parent.nodeSize - 2 || r.pos !== n.pos);
}, W9 = (t) => {
  const { $from: e, $to: r } = t.selection;
  return !(e.parentOffset > 0 || e.pos !== r.pos);
};
function Gf(t, e) {
  const { nodeExtensions: r } = vg(e), n = r.find((i) => i.name === t);
  if (!n)
    return !1;
  const o = {
    name: n.name,
    options: n.options,
    storage: n.storage
  }, s = hr(Tn(n, "group", o));
  return typeof s != "string" ? !1 : s.split(" ").includes("list");
}
function fc(t, {
  checkChildren: e = !0,
  ignoreWhitespace: r = !1
} = {}) {
  var n;
  if (r) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((n = t.text) != null ? n : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let o = !0;
    return t.content.forEach((s) => {
      o !== !1 && (fc(s, { ignoreWhitespace: r, checkChildren: e }) || (o = !1));
    }), o;
  }
  return !1;
}
function xg(t) {
  return t instanceof ue;
}
function U9(t, e, r) {
  var n;
  const { selection: o } = e;
  let s = null;
  if (pg(o) && (s = o.$cursor), s) {
    const a = (n = t.storedMarks) != null ? n : s.marks();
    return s.parent.type.allowsMarkType(r) && (!!r.isInSet(a) || !a.some((d) => d.type.excludes(r)));
  }
  const { ranges: i } = o;
  return i.some(({ $from: a, $to: l }) => {
    let d = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(r) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (c, u, f) => {
      if (d)
        return !1;
      if (c.isInline) {
        const p = !f || f.type.allowsMarkType(r), h = !!r.isInSet(c.marks) || !c.marks.some((g) => g.type.excludes(r));
        d = p && h;
      }
      return !d;
    }), d;
  });
}
var G9 = (t, e = {}) => ({ tr: r, state: n, dispatch: o }) => {
  const { selection: s } = r, { empty: i, ranges: a } = s, l = on(t, n.schema);
  if (o)
    if (i) {
      const d = gg(n, l);
      r.addStoredMark(
        l.create({
          ...d,
          ...e
        })
      );
    } else
      a.forEach((d) => {
        const c = d.$from.pos, u = d.$to.pos;
        n.doc.nodesBetween(c, u, (f, p) => {
          const h = Math.max(p, c), g = Math.min(p + f.nodeSize, u);
          f.marks.find((y) => y.type === l) ? f.marks.forEach((y) => {
            l === y.type && r.addMark(
              h,
              g,
              l.create({
                ...y.attrs,
                ...e
              })
            );
          }) : r.addMark(h, g, l.create(e));
        });
      });
  return U9(n, r, l);
}, K9 = (t, e) => ({ tr: r }) => (r.setMeta(t, e), !0), Y9 = (t, e = {}) => ({ state: r, dispatch: n, chain: o }) => {
  const s = dt(t, r.schema);
  let i;
  return r.selection.$anchor.sameParent(r.selection.$head) && (i = r.selection.$anchor.parent.attrs), s.isTextblock ? o().command(({ commands: a }) => Tf(s, { ...i, ...e })(r) ? !0 : a.clearNodes()).command(({ state: a }) => Tf(s, { ...i, ...e })(a, n)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, J9 = (t) => ({ tr: e, dispatch: r }) => {
  if (r) {
    const { doc: n } = e, o = gn(t, 0, n.content.size), s = ue.create(n, o);
    e.setSelection(s);
  }
  return !0;
}, q9 = (t, e) => ({ tr: r, state: n, dispatch: o }) => {
  const { selection: s } = n;
  let i, a;
  return typeof e == "number" ? (i = e, a = e) : e && "from" in e && "to" in e ? (i = e.from, a = e.to) : (i = s.from, a = s.to), o && r.doc.nodesBetween(i, a, (l, d) => {
    l.isText || r.setNodeMarkup(d, void 0, {
      ...l.attrs,
      dir: t
    });
  }), !0;
}, X9 = (t) => ({ tr: e, dispatch: r }) => {
  if (r) {
    const { doc: n } = e, { from: o, to: s } = typeof t == "number" ? { from: t, to: t } : t, i = fe.atStart(n).from, a = fe.atEnd(n).to, l = gn(o, i, a), d = gn(s, i, a), c = fe.create(n, l, d);
    e.setSelection(c);
  }
  return !0;
}, Z9 = (t) => ({ state: e, dispatch: r }) => {
  const n = dt(t, e.schema);
  return H4(n)(e, r);
};
function Kf(t, e) {
  const r = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (r) {
    const n = r.filter((o) => e == null ? void 0 : e.includes(o.type.name));
    t.tr.ensureMarks(n);
  }
}
var Q9 = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: r, dispatch: n, editor: o }) => {
  const { selection: s, doc: i } = e, { $from: a, $to: l } = s, d = o.extensionManager.attributes, c = Hs(d, a.node().type.name, a.node().attrs);
  if (s instanceof ue && s.node.isBlock)
    return !a.parentOffset || !Pr(i, a.pos) ? !1 : (n && (t && Kf(r, o.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const u = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : P9(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let p = u && f ? [
    {
      type: f,
      attrs: c
    }
  ] : void 0, h = Pr(e.doc, e.mapping.map(a.pos), 1, p);
  if (!p && !h && Pr(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (h = !0, p = f ? [
    {
      type: f,
      attrs: c
    }
  ] : void 0), n) {
    if (h && (s instanceof fe && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, p), f && !u && !a.parentOffset && a.parent.type !== f)) {
      const g = e.mapping.map(a.before()), b = e.doc.resolve(g);
      a.node(-1).canReplaceWith(b.index(), b.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && Kf(r, o.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return h;
}, e6 = (t, e = {}) => ({ tr: r, state: n, dispatch: o, editor: s }) => {
  var i;
  const a = dt(t, n.schema), { $from: l, $to: d } = n.selection, c = n.selection.node;
  if (c && c.isBlock || l.depth < 2 || !l.sameParent(d))
    return !1;
  const u = l.node(-1);
  if (u.type !== a)
    return !1;
  const f = s.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (o) {
      let y = U.empty;
      const $ = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let O = l.depth - $; O >= l.depth - 3; O -= 1)
        y = U.from(l.node(O).copy(y));
      const k = (
        // eslint-disable-next-line no-nested-ternary
        l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3
      ), w = {
        ...Hs(f, l.node().type.name, l.node().attrs),
        ...e
      }, C = ((i = a.contentMatch.defaultType) == null ? void 0 : i.createAndFill(w)) || void 0;
      y = y.append(U.from(a.createAndFill(null, C) || void 0));
      const T = l.before(l.depth - ($ - 1));
      r.replace(T, l.after(-k), new X(y, 4 - $, 0));
      let H = -1;
      r.doc.nodesBetween(T, r.doc.content.size, (O, j) => {
        if (H > -1)
          return !1;
        O.isTextblock && O.content.size === 0 && (H = j + 1);
      }), H > -1 && r.setSelection(fe.near(r.doc.resolve(H))), r.scrollIntoView();
    }
    return !0;
  }
  const p = d.pos === l.end() ? u.contentMatchAt(0).defaultType : null, h = {
    ...Hs(f, u.type.name, u.attrs),
    ...e
  }, g = {
    ...Hs(f, l.node().type.name, l.node().attrs),
    ...e
  };
  r.delete(l.pos, d.pos);
  const b = p ? [
    { type: a, attrs: h },
    { type: p, attrs: g }
  ] : [{ type: a, attrs: h }];
  if (!Pr(r.doc, l.pos, 2))
    return !1;
  if (o) {
    const { selection: y, storedMarks: $ } = n, { splittableMarks: k } = s.extensionManager, w = $ || y.$to.parentOffset && y.$from.marks();
    if (r.split(l.pos, 2, b).scrollIntoView(), !w || !o)
      return !0;
    const C = w.filter((T) => k.includes(T.type.name));
    r.ensureMarks(C);
  }
  return !0;
}, qa = (t, e) => {
  const r = ha((i) => i.type === e)(t.selection);
  if (!r)
    return !0;
  const n = t.doc.resolve(Math.max(0, r.pos - 1)).before(r.depth);
  if (n === void 0)
    return !0;
  const o = t.doc.nodeAt(n);
  return r.node.type === (o == null ? void 0 : o.type) && rn(t.doc, r.pos) && t.join(r.pos), !0;
}, Xa = (t, e) => {
  const r = ha((i) => i.type === e)(t.selection);
  if (!r)
    return !0;
  const n = t.doc.resolve(r.start).after(r.depth);
  if (n === void 0)
    return !0;
  const o = t.doc.nodeAt(n);
  return r.node.type === (o == null ? void 0 : o.type) && rn(t.doc, n) && t.join(n), !0;
}, t6 = (t, e, r, n = {}) => ({ editor: o, tr: s, state: i, dispatch: a, chain: l, commands: d, can: c }) => {
  const { extensions: u, splittableMarks: f } = o.extensionManager, p = dt(t, i.schema), h = dt(e, i.schema), { selection: g, storedMarks: b } = i, { $from: y, $to: $ } = g, k = y.blockRange($), w = b || g.$to.parentOffset && g.$from.marks();
  if (!k)
    return !1;
  const C = ha((T) => Gf(T.type.name, u))(g);
  if (k.depth >= 1 && C && k.depth - C.depth <= 1) {
    if (C.node.type === p)
      return d.liftListItem(h);
    if (Gf(C.node.type.name, u) && p.validContent(C.node.content) && a)
      return l().command(() => (s.setNodeMarkup(C.pos, p), !0)).command(() => qa(s, p)).command(() => Xa(s, p)).run();
  }
  return !r || !w || !a ? l().command(() => c().wrapInList(p, n) ? !0 : d.clearNodes()).wrapInList(p, n).command(() => qa(s, p)).command(() => Xa(s, p)).run() : l().command(() => {
    const T = c().wrapInList(p, n), H = w.filter((O) => f.includes(O.type.name));
    return s.ensureMarks(H), T ? !0 : d.clearNodes();
  }).wrapInList(p, n).command(() => qa(s, p)).command(() => Xa(s, p)).run();
}, r6 = (t, e = {}, r = {}) => ({ state: n, commands: o }) => {
  const { extendEmptyMarkRange: s = !1 } = r, i = on(t, n.schema);
  return B9(n, i, e) ? o.unsetMark(i, { extendEmptyMarkRange: s }) : o.setMark(i, e);
}, n6 = (t, e, r = {}) => ({ state: n, commands: o }) => {
  const s = dt(t, n.schema), i = dt(e, n.schema), a = ao(n, s, r);
  let l;
  return n.selection.$anchor.sameParent(n.selection.$head) && (l = n.selection.$anchor.parent.attrs), a ? o.setNode(i, l) : o.setNode(s, { ...l, ...r });
}, o6 = (t, e = {}) => ({ state: r, commands: n }) => {
  const o = dt(t, r.schema);
  return ao(r, o, e) ? n.lift(o) : n.wrapIn(o, e);
}, s6 = () => ({ state: t, dispatch: e }) => {
  const r = t.plugins;
  for (let n = 0; n < r.length; n += 1) {
    const o = r[n];
    let s;
    if (o.spec.isInputRules && (s = o.getState(t))) {
      if (e) {
        const i = t.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          i.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          const l = i.doc.resolve(s.from).marks();
          i.replaceWith(s.from, s.to, t.schema.text(s.text, l));
        } else
          i.delete(s.from, s.to);
      }
      return !0;
    }
  }
  return !1;
}, i6 = () => ({ tr: t, dispatch: e }) => {
  const { selection: r } = t, { empty: n, ranges: o } = r;
  return n || e && o.forEach((s) => {
    t.removeMark(s.$from.pos, s.$to.pos);
  }), !0;
}, a6 = (t, e = {}) => ({ tr: r, state: n, dispatch: o }) => {
  var s;
  const { extendEmptyMarkRange: i = !1 } = e, { selection: a } = r, l = on(t, n.schema), { $from: d, empty: c, ranges: u } = a;
  if (!o)
    return !0;
  if (c && i) {
    let { from: f, to: p } = a;
    const h = (s = d.marks().find((b) => b.type === l)) == null ? void 0 : s.attrs, g = dc(d, l, h);
    g && (f = g.from, p = g.to), r.removeMark(f, p, l);
  } else
    u.forEach((f) => {
      r.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return r.removeStoredMark(l), !0;
}, l6 = (t) => ({ tr: e, state: r, dispatch: n }) => {
  const { selection: o } = r;
  let s, i;
  return typeof t == "number" ? (s = t, i = t) : t && "from" in t && "to" in t ? (s = t.from, i = t.to) : (s = o.from, i = o.to), n && e.doc.nodesBetween(s, i, (a, l) => {
    if (a.isText)
      return;
    const d = { ...a.attrs };
    delete d.dir, e.setNodeMarkup(l, void 0, d);
  }), !0;
}, d6 = (t, e = {}) => ({ tr: r, state: n, dispatch: o }) => {
  let s = null, i = null;
  const a = cc(
    typeof t == "string" ? t : t.name,
    n.schema
  );
  if (!a)
    return !1;
  a === "node" && (s = dt(t, n.schema)), a === "mark" && (i = on(t, n.schema));
  let l = !1;
  return r.selection.ranges.forEach((d) => {
    const c = d.$from.pos, u = d.$to.pos;
    let f, p, h, g;
    r.selection.empty ? n.doc.nodesBetween(c, u, (b, y) => {
      s && s === b.type && (l = !0, h = Math.max(y, c), g = Math.min(y + b.nodeSize, u), f = y, p = b);
    }) : n.doc.nodesBetween(c, u, (b, y) => {
      y < c && s && s === b.type && (l = !0, h = Math.max(y, c), g = Math.min(y + b.nodeSize, u), f = y, p = b), y >= c && y <= u && (s && s === b.type && (l = !0, o && r.setNodeMarkup(y, void 0, {
        ...b.attrs,
        ...e
      })), i && b.marks.length && b.marks.forEach(($) => {
        if (i === $.type && (l = !0, o)) {
          const k = Math.max(y, c), w = Math.min(y + b.nodeSize, u);
          r.addMark(
            k,
            w,
            i.create({
              ...$.attrs,
              ...e
            })
          );
        }
      }));
    }), p && (f !== void 0 && o && r.setNodeMarkup(f, void 0, {
      ...p.attrs,
      ...e
    }), i && p.marks.length && p.marks.forEach((b) => {
      i === b.type && o && r.addMark(
        h,
        g,
        i.create({
          ...b.attrs,
          ...e
        })
      );
    }));
  }), l;
}, c6 = (t, e = {}) => ({ state: r, dispatch: n }) => {
  const o = dt(t, r.schema);
  return O4(o, e)(r, n);
}, u6 = (t, e = {}) => ({ state: r, dispatch: n }) => {
  const o = dt(t, r.schema);
  return L4(o, e)(r, n);
}, ma = class {
  constructor(t) {
    var e;
    this.find = t.find, this.handler = t.handler, this.undoable = (e = t.undoable) != null ? e : !0;
  }
};
function f6(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Ts(t) {
  return f6(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function wg(t, e) {
  const r = { ...t };
  return Ts(t) && Ts(e) && Object.keys(e).forEach((n) => {
    Ts(e[n]) && Ts(t[n]) ? r[n] = wg(t[n], e[n]) : r[n] = e[n];
  }), r;
}
var pc = class {
  constructor(t = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...hr(
        Tn(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...hr(
        Tn(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(t = {}) {
    const e = this.extend({
      ...this.config,
      addOptions: () => wg(this.options, t)
    });
    return e.name = this.name, e.parent = this.parent, e;
  }
  extend(t = {}) {
    const e = new this.constructor({ ...this.config, ...t });
    return e.parent = this, this.child = e, e.name = "name" in t ? t.name : e.parent.name, e;
  }
}, mr = class kg extends pc {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const r = typeof e == "function" ? e() : e;
    return new kg(r);
  }
  static handleExit({ editor: e, mark: r }) {
    const { tr: n } = e.state, o = e.state.selection.$from;
    if (o.pos === o.end()) {
      const i = o.marks();
      if (!!!i.find((d) => (d == null ? void 0 : d.type.name) === r.name))
        return !1;
      const l = i.find((d) => (d == null ? void 0 : d.type.name) === r.name);
      return l && n.removeStoredMark(l), n.insertText(" ", o.pos), e.view.dispatch(n), !0;
    }
    return !1;
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const r = typeof e == "function" ? e() : e;
    return super.extend(r);
  }
}, p6 = class {
  constructor(t) {
    this.find = t.find, this.handler = t.handler;
  }
}, h6 = {};
lc(h6, {
  ClipboardTextSerializer: () => m6,
  Commands: () => g6,
  Delete: () => b6,
  Drop: () => y6,
  Editable: () => v6,
  FocusEvents: () => $6,
  Keymap: () => x6,
  Paste: () => w6,
  Tabindex: () => k6,
  TextDirection: () => E6,
  focusEventsPluginKey: () => Cg
});
var Le = class Eg extends pc {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const r = typeof e == "function" ? e() : e;
    return new Eg(r);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const r = typeof e == "function" ? e() : e;
    return super.extend(r);
  }
}, m6 = Le.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: r } = t, { doc: n, selection: o } = e, { ranges: s } = o, i = Math.min(...s.map((c) => c.$from.pos)), a = Math.max(...s.map((c) => c.$to.pos)), l = j9(r);
            return L9(n, { from: i, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), g6 = Le.create({
  name: "commands",
  addCommands() {
    return {
      ...ug
    };
  }
}), b6 = Le.create({
  name: "delete",
  onUpdate({ transaction: t, appendedTransactions: e }) {
    var r, n, o;
    const s = () => {
      var i, a, l, d;
      if ((d = (l = (a = (i = this.editor.options.coreExtensionOptions) == null ? void 0 : i.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : l.call(a, t)) != null ? d : t.getMeta("y-sync$"))
        return;
      const c = bg(t.before, [t, ...e]);
      $g(c).forEach((p) => {
        c.mapping.mapResult(p.oldRange.from).deletedAfter && c.mapping.mapResult(p.oldRange.to).deletedBefore && c.before.nodesBetween(p.oldRange.from, p.oldRange.to, (h, g) => {
          const b = g + h.nodeSize - 2, y = p.oldRange.from <= g && b <= p.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: h,
            from: g,
            to: b,
            newFrom: c.mapping.map(g),
            newTo: c.mapping.map(b),
            deletedRange: p.oldRange,
            newRange: p.newRange,
            partial: !y,
            editor: this.editor,
            transaction: t,
            combinedTransform: c
          });
        });
      });
      const f = c.mapping;
      c.steps.forEach((p, h) => {
        var g, b;
        if (p instanceof tr) {
          const y = f.slice(h).map(p.from, -1), $ = f.slice(h).map(p.to), k = f.invert().map(y, -1), w = f.invert().map($), C = (g = c.doc.nodeAt(y - 1)) == null ? void 0 : g.marks.some((H) => H.eq(p.mark)), T = (b = c.doc.nodeAt($)) == null ? void 0 : b.marks.some((H) => H.eq(p.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: p.mark,
            from: p.from,
            to: p.to,
            deletedRange: {
              from: k,
              to: w
            },
            newRange: {
              from: y,
              to: $
            },
            partial: !!(T || C),
            editor: this.editor,
            transaction: t,
            combinedTransform: c
          });
        }
      });
    };
    (o = (n = (r = this.editor.options.coreExtensionOptions) == null ? void 0 : r.delete) == null ? void 0 : n.async) == null || o ? setTimeout(s, 0) : s();
  }
}), y6 = Le.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("tiptapDrop"),
        props: {
          handleDrop: (t, e, r, n) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: r,
              moved: n
            });
          }
        }
      })
    ];
  }
}), v6 = Le.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), Cg = new Qe("focusEvents"), $6 = Le.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Ze({
        key: Cg,
        props: {
          handleDOMEvents: {
            focus: (e, r) => {
              t.isFocused = !0;
              const n = t.state.tr.setMeta("focus", { event: r }).setMeta("addToHistory", !1);
              return e.dispatch(n), !1;
            },
            blur: (e, r) => {
              t.isFocused = !1;
              const n = t.state.tr.setMeta("blur", { event: r }).setMeta("addToHistory", !1);
              return e.dispatch(n), !1;
            }
          }
        }
      })
    ];
  }
}), x6 = Le.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: i }) => [
      () => i.undoInputRule(),
      // maybe convert first text block node to default node
      () => i.command(({ tr: a }) => {
        const { selection: l, doc: d } = a, { empty: c, $anchor: u } = l, { pos: f, parent: p } = u, h = u.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : u, g = h.parent.type.spec.isolating, b = u.pos - u.parentOffset, y = g && h.parent.childCount === 1 ? b === u.pos : be.atStart(d).from === f;
        return !c || !p.type.isTextblock || p.textContent.length || !y || y && u.parent.type.name === "paragraph" ? !1 : i.clearNodes();
      }),
      () => i.deleteSelection(),
      () => i.joinBackward(),
      () => i.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: i }) => [
      () => i.deleteSelection(),
      () => i.deleteCurrentNode(),
      () => i.joinForward(),
      () => i.selectNodeForward()
    ]), n = {
      Enter: () => this.editor.commands.first(({ commands: i }) => [
        () => i.newlineInCode(),
        () => i.createParagraphNear(),
        () => i.liftEmptyBlock(),
        () => i.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, o = {
      ...n
    }, s = {
      ...n,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return yi() || mg() ? s : o;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Ze({
        key: new Qe("clearDocument"),
        appendTransaction: (t, e, r) => {
          if (t.some((g) => g.getMeta("composition")))
            return;
          const n = t.some((g) => g.docChanged) && !e.doc.eq(r.doc), o = t.some((g) => g.getMeta("preventClearDocument"));
          if (!n || o)
            return;
          const { empty: s, from: i, to: a } = e.selection, l = be.atStart(e.doc).from, d = be.atEnd(e.doc).to;
          if (s || !(i === l && a === d) || !fc(r.doc))
            return;
          const f = r.tr, p = cg({
            state: r,
            transaction: f
          }), { commands: h } = new D5({
            editor: this.editor,
            state: p
          });
          if (h.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), w6 = Le.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("tiptapPaste"),
        props: {
          handlePaste: (t, e, r) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: r
            });
          }
        }
      })
    ];
  }
}), k6 = Le.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), E6 = Le.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: t } = vg(this.extensions);
    return [
      {
        types: t.filter((e) => e.name !== "text").map((e) => e.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (e) => {
              const r = e.getAttribute("dir");
              return r && (r === "ltr" || r === "rtl" || r === "auto") ? r : this.options.direction;
            },
            renderHTML: (e) => e.dir ? {
              dir: e.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("textDirection"),
        props: {
          attributes: () => {
            const t = this.options.direction;
            return t ? {
              dir: t
            } : {};
          }
        }
      })
    ];
  }
});
function An(t) {
  return new ma({
    find: t.find,
    handler: ({ state: e, range: r, match: n }) => {
      const o = hr(t.getAttributes, void 0, n);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = e, i = n[n.length - 1], a = n[0];
      if (i) {
        const l = a.search(/\S/), d = r.from + a.indexOf(i), c = d + i.length;
        if (uc(r.from, r.to, e.doc).filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        c < r.to && s.delete(c, r.to), d > r.from && s.delete(r.from + l, d);
        const f = r.from + l + i.length;
        s.addMark(r.from + l, f, t.type.create(o || {})), s.removeStoredMark(t.type);
      }
    },
    undoable: t.undoable
  });
}
function Sg(t) {
  return new ma({
    find: t.find,
    handler: ({ state: e, range: r, match: n }) => {
      const o = hr(t.getAttributes, void 0, n) || {}, { tr: s } = e, i = r.from;
      let a = r.to;
      const l = t.type.create(o);
      if (n[1]) {
        const d = n[0].lastIndexOf(n[1]);
        let c = i + d;
        c > a ? c = a : a = c + n[1].length;
        const u = n[0][n[0].length - 1];
        s.insertText(u, i + n[0].length - 1), s.replaceWith(c, a, l);
      } else if (n[0]) {
        const d = t.type.isInline ? i : i - 1;
        s.insert(d, t.type.create(o)).delete(s.mapping.map(i), s.mapping.map(a));
      }
      s.scrollIntoView();
    },
    undoable: t.undoable
  });
}
function Ql(t) {
  return new ma({
    find: t.find,
    handler: ({ state: e, range: r, match: n }) => {
      const o = e.doc.resolve(r.from), s = hr(t.getAttributes, void 0, n) || {};
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
        return null;
      e.tr.delete(r.from, r.to).setBlockType(r.from, r.from, t.type, s);
    },
    undoable: t.undoable
  });
}
function lo(t) {
  return new ma({
    find: t.find,
    handler: ({ state: e, range: r, match: n, chain: o }) => {
      const s = hr(t.getAttributes, void 0, n) || {}, i = e.tr.delete(r.from, r.to), l = i.doc.resolve(r.from).blockRange(), d = l && Kd(l, t.type, s);
      if (!d)
        return null;
      if (i.wrap(l, d), t.keepMarks && t.editor) {
        const { selection: u, storedMarks: f } = e, { splittableMarks: p } = t.editor.extensionManager, h = f || u.$to.parentOffset && u.$from.marks();
        if (h) {
          const g = h.filter((b) => p.includes(b.type.name));
          i.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const u = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        o().updateAttributes(u, s).run();
      }
      const c = i.doc.resolve(r.from - 1).nodeBefore;
      c && c.type === t.type && rn(i.doc, r.from - 1) && (!t.joinPredicate || t.joinPredicate(n, c)) && i.join(r.from - 1);
    },
    undoable: t.undoable
  });
}
var C6 = (t) => "touches" in t, S6 = class {
  /**
   * Creates a new ResizableNodeView instance.
   *
   * The constructor sets up the resize handles, applies initial sizing from
   * node attributes, and configures all resize behavior options.
   *
   * @param options - Configuration options for the resizable node view
   */
  constructor(t) {
    this.directions = ["bottom-left", "bottom-right", "top-left", "top-right"], this.minSize = {
      height: 8,
      width: 8
    }, this.preserveAspectRatio = !1, this.classNames = {
      container: "",
      wrapper: "",
      handle: "",
      resizing: ""
    }, this.initialWidth = 0, this.initialHeight = 0, this.aspectRatio = 1, this.isResizing = !1, this.activeHandle = null, this.startX = 0, this.startY = 0, this.startWidth = 0, this.startHeight = 0, this.isShiftKeyPressed = !1, this.lastEditableState = void 0, this.handleMap = /* @__PURE__ */ new Map(), this.handleMouseMove = (a) => {
      if (!this.isResizing || !this.activeHandle)
        return;
      const l = a.clientX - this.startX, d = a.clientY - this.startY;
      this.handleResize(l, d);
    }, this.handleTouchMove = (a) => {
      if (!this.isResizing || !this.activeHandle)
        return;
      const l = a.touches[0];
      if (!l)
        return;
      const d = l.clientX - this.startX, c = l.clientY - this.startY;
      this.handleResize(d, c);
    }, this.handleMouseUp = () => {
      if (!this.isResizing)
        return;
      const a = this.element.offsetWidth, l = this.element.offsetHeight;
      this.onCommit(a, l), this.isResizing = !1, this.activeHandle = null, this.container.dataset.resizeState = "false", this.classNames.resizing && this.container.classList.remove(this.classNames.resizing), document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("keyup", this.handleKeyUp);
    }, this.handleKeyDown = (a) => {
      a.key === "Shift" && (this.isShiftKeyPressed = !0);
    }, this.handleKeyUp = (a) => {
      a.key === "Shift" && (this.isShiftKeyPressed = !1);
    };
    var e, r, n, o, s, i;
    this.node = t.node, this.editor = t.editor, this.element = t.element, this.contentElement = t.contentElement, this.getPos = t.getPos, this.onResize = t.onResize, this.onCommit = t.onCommit, this.onUpdate = t.onUpdate, (e = t.options) != null && e.min && (this.minSize = {
      ...this.minSize,
      ...t.options.min
    }), (r = t.options) != null && r.max && (this.maxSize = t.options.max), (n = t == null ? void 0 : t.options) != null && n.directions && (this.directions = t.options.directions), (o = t.options) != null && o.preserveAspectRatio && (this.preserveAspectRatio = t.options.preserveAspectRatio), (s = t.options) != null && s.className && (this.classNames = {
      container: t.options.className.container || "",
      wrapper: t.options.className.wrapper || "",
      handle: t.options.className.handle || "",
      resizing: t.options.className.resizing || ""
    }), (i = t.options) != null && i.createCustomHandle && (this.createCustomHandle = t.options.createCustomHandle), this.wrapper = this.createWrapper(), this.container = this.createContainer(), this.applyInitialSize(), this.attachHandles(), this.editor.on("update", this.handleEditorUpdate.bind(this));
  }
  /**
   * Returns the top-level DOM node that should be placed in the editor.
   *
   * This is required by the ProseMirror NodeView interface. The container
   * includes the wrapper, handles, and the actual content element.
   *
   * @returns The container element to be inserted into the editor
   */
  get dom() {
    return this.container;
  }
  get contentDOM() {
    return this.contentElement;
  }
  handleEditorUpdate() {
    const t = this.editor.isEditable;
    t !== this.lastEditableState && (this.lastEditableState = t, t ? t && this.handleMap.size === 0 && this.attachHandles() : this.removeHandles());
  }
  /**
   * Called when the node's content or attributes change.
   *
   * Updates the internal node reference. If a custom `onUpdate` callback
   * was provided, it will be called to handle additional update logic.
   *
   * @param node - The new/updated node
   * @param decorations - Node decorations
   * @param innerDecorations - Inner decorations
   * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`
   */
  update(t, e, r) {
    return t.type !== this.node.type ? !1 : (this.node = t, this.onUpdate ? this.onUpdate(t, e, r) : !0);
  }
  /**
   * Cleanup method called when the node view is being removed.
   *
   * Removes all event listeners to prevent memory leaks. This is required
   * by the ProseMirror NodeView interface. If a resize is active when
   * destroy is called, it will be properly cancelled.
   */
  destroy() {
    this.isResizing && (this.container.dataset.resizeState = "false", this.classNames.resizing && this.container.classList.remove(this.classNames.resizing), document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("keyup", this.handleKeyUp), this.isResizing = !1, this.activeHandle = null), this.editor.off("update", this.handleEditorUpdate.bind(this)), this.container.remove();
  }
  /**
   * Creates the outer container element.
   *
   * The container is the top-level element returned by the NodeView and
   * wraps the entire resizable node. It's set up with flexbox to handle
   * alignment and includes data attributes for styling and identification.
   *
   * @returns The container element
   */
  createContainer() {
    const t = document.createElement("div");
    return t.dataset.resizeContainer = "", t.dataset.node = this.node.type.name, t.style.display = "flex", this.classNames.container && (t.className = this.classNames.container), t.appendChild(this.wrapper), t;
  }
  /**
   * Creates the wrapper element that contains the content and handles.
   *
   * The wrapper uses relative positioning so that resize handles can be
   * positioned absolutely within it. This is the direct parent of the
   * content element being made resizable.
   *
   * @returns The wrapper element
   */
  createWrapper() {
    const t = document.createElement("div");
    return t.style.position = "relative", t.style.display = "block", t.dataset.resizeWrapper = "", this.classNames.wrapper && (t.className = this.classNames.wrapper), t.appendChild(this.element), t;
  }
  /**
   * Creates a resize handle element for a specific direction.
   *
   * Each handle is absolutely positioned and includes a data attribute
   * identifying its direction for styling purposes.
   *
   * @param direction - The resize direction for this handle
   * @returns The handle element
   */
  createHandle(t) {
    const e = document.createElement("div");
    return e.dataset.resizeHandle = t, e.style.position = "absolute", this.classNames.handle && (e.className = this.classNames.handle), e;
  }
  /**
   * Positions a handle element according to its direction.
   *
   * Corner handles (e.g., 'top-left') are positioned at the intersection
   * of two edges. Edge handles (e.g., 'top') span the full width or height.
   *
   * @param handle - The handle element to position
   * @param direction - The direction determining the position
   */
  positionHandle(t, e) {
    const r = e.includes("top"), n = e.includes("bottom"), o = e.includes("left"), s = e.includes("right");
    r && (t.style.top = "0"), n && (t.style.bottom = "0"), o && (t.style.left = "0"), s && (t.style.right = "0"), (e === "top" || e === "bottom") && (t.style.left = "0", t.style.right = "0"), (e === "left" || e === "right") && (t.style.top = "0", t.style.bottom = "0");
  }
  /**
   * Creates and attaches all resize handles to the wrapper.
   *
   * Iterates through the configured directions, creates a handle for each,
   * positions it, attaches the mousedown listener, and appends it to the DOM.
   */
  attachHandles() {
    this.directions.forEach((t) => {
      let e;
      this.createCustomHandle ? e = this.createCustomHandle(t) : e = this.createHandle(t), e instanceof HTMLElement || (console.warn(
        `[ResizableNodeView] createCustomHandle("${t}") did not return an HTMLElement. Falling back to default handle.`
      ), e = this.createHandle(t)), this.createCustomHandle || this.positionHandle(e, t), e.addEventListener("mousedown", (r) => this.handleResizeStart(r, t)), e.addEventListener("touchstart", (r) => this.handleResizeStart(r, t)), this.handleMap.set(t, e), this.wrapper.appendChild(e);
    });
  }
  /**
   * Removes all resize handles from the wrapper.
   *
   * Cleans up the handle map and removes each handle element from the DOM.
   */
  removeHandles() {
    this.handleMap.forEach((t) => t.remove()), this.handleMap.clear();
  }
  /**
   * Applies initial sizing from node attributes to the element.
   *
   * If width/height attributes exist on the node, they're applied to the element.
   * Otherwise, the element's natural/current dimensions are measured. The aspect
   * ratio is calculated for later use in aspect-ratio-preserving resizes.
   */
  applyInitialSize() {
    const t = this.node.attrs.width, e = this.node.attrs.height;
    t ? (this.element.style.width = `${t}px`, this.initialWidth = t) : this.initialWidth = this.element.offsetWidth, e ? (this.element.style.height = `${e}px`, this.initialHeight = e) : this.initialHeight = this.element.offsetHeight, this.initialWidth > 0 && this.initialHeight > 0 && (this.aspectRatio = this.initialWidth / this.initialHeight);
  }
  /**
   * Initiates a resize operation when a handle is clicked.
   *
   * Captures the starting mouse position and element dimensions, sets up
   * the resize state, adds the resizing class and state attribute, and
   * attaches document-level listeners for mouse movement and keyboard input.
   *
   * @param event - The mouse down event
   * @param direction - The direction of the handle being dragged
   */
  handleResizeStart(t, e) {
    t.preventDefault(), t.stopPropagation(), this.isResizing = !0, this.activeHandle = e, C6(t) ? (this.startX = t.touches[0].clientX, this.startY = t.touches[0].clientY) : (this.startX = t.clientX, this.startY = t.clientY), this.startWidth = this.element.offsetWidth, this.startHeight = this.element.offsetHeight, this.startWidth > 0 && this.startHeight > 0 && (this.aspectRatio = this.startWidth / this.startHeight), this.getPos(), this.container.dataset.resizeState = "true", this.classNames.resizing && this.container.classList.add(this.classNames.resizing), document.addEventListener("mousemove", this.handleMouseMove), document.addEventListener("touchmove", this.handleTouchMove), document.addEventListener("mouseup", this.handleMouseUp), document.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keyup", this.handleKeyUp);
  }
  handleResize(t, e) {
    if (!this.activeHandle)
      return;
    const r = this.preserveAspectRatio || this.isShiftKeyPressed, { width: n, height: o } = this.calculateNewDimensions(this.activeHandle, t, e), s = this.applyConstraints(n, o, r);
    this.element.style.width = `${s.width}px`, this.element.style.height = `${s.height}px`, this.onResize && this.onResize(s.width, s.height);
  }
  /**
   * Calculates new dimensions based on mouse delta and resize direction.
   *
   * Takes the starting dimensions and applies the mouse movement delta
   * according to the handle direction. For corner handles, both dimensions
   * are affected. For edge handles, only one dimension changes. If aspect
   * ratio should be preserved, delegates to applyAspectRatio.
   *
   * @param direction - The active resize handle direction
   * @param deltaX - Horizontal mouse movement since resize start
   * @param deltaY - Vertical mouse movement since resize start
   * @returns The calculated width and height
   */
  calculateNewDimensions(t, e, r) {
    let n = this.startWidth, o = this.startHeight;
    const s = t.includes("right"), i = t.includes("left"), a = t.includes("bottom"), l = t.includes("top");
    return s ? n = this.startWidth + e : i && (n = this.startWidth - e), a ? o = this.startHeight + r : l && (o = this.startHeight - r), (t === "right" || t === "left") && (n = this.startWidth + (s ? e : -e)), (t === "top" || t === "bottom") && (o = this.startHeight + (a ? r : -r)), this.preserveAspectRatio || this.isShiftKeyPressed ? this.applyAspectRatio(n, o, t) : { width: n, height: o };
  }
  /**
   * Applies min/max constraints to dimensions.
   *
   * When aspect ratio is NOT preserved, constraints are applied independently
   * to width and height. When aspect ratio IS preserved, constraints are
   * applied while maintaining the aspect ratioif one dimension hits a limit,
   * the other is recalculated proportionally.
   *
   * This ensures that aspect ratio is never broken when constrained.
   *
   * @param width - The unconstrained width
   * @param height - The unconstrained height
   * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining
   * @returns The constrained dimensions
   */
  applyConstraints(t, e, r) {
    var n, o, s, i;
    if (!r) {
      let d = Math.max(this.minSize.width, t), c = Math.max(this.minSize.height, e);
      return (n = this.maxSize) != null && n.width && (d = Math.min(this.maxSize.width, d)), (o = this.maxSize) != null && o.height && (c = Math.min(this.maxSize.height, c)), { width: d, height: c };
    }
    let a = t, l = e;
    return a < this.minSize.width && (a = this.minSize.width, l = a / this.aspectRatio), l < this.minSize.height && (l = this.minSize.height, a = l * this.aspectRatio), (s = this.maxSize) != null && s.width && a > this.maxSize.width && (a = this.maxSize.width, l = a / this.aspectRatio), (i = this.maxSize) != null && i.height && l > this.maxSize.height && (l = this.maxSize.height, a = l * this.aspectRatio), { width: a, height: l };
  }
  /**
   * Adjusts dimensions to maintain the original aspect ratio.
   *
   * For horizontal handles (left/right), uses width as the primary dimension
   * and calculates height from it. For vertical handles (top/bottom), uses
   * height as primary and calculates width. For corner handles, uses width
   * as the primary dimension.
   *
   * @param width - The new width
   * @param height - The new height
   * @param direction - The active resize direction
   * @returns Dimensions adjusted to preserve aspect ratio
   */
  applyAspectRatio(t, e, r) {
    const n = r === "left" || r === "right", o = r === "top" || r === "bottom";
    return n ? {
      width: t,
      height: t / this.aspectRatio
    } : o ? {
      width: e * this.aspectRatio,
      height: e
    } : {
      width: t,
      height: t / this.aspectRatio
    };
  }
};
function N6(t, e) {
  const { selection: r } = t, { $from: n } = r;
  if (r instanceof ue) {
    const s = n.index();
    return n.parent.canReplaceWith(s, s + 1, e);
  }
  let o = n.depth;
  for (; o >= 0; ) {
    const s = n.index(o);
    if (n.node(o).contentMatchAt(s).matchType(e))
      return !0;
    o -= 1;
  }
  return !1;
}
var T6 = {};
lc(T6, {
  createAtomBlockMarkdownSpec: () => A6,
  createBlockMarkdownSpec: () => M6,
  createInlineMarkdownSpec: () => R6,
  parseAttributes: () => hc,
  parseIndentedBlocks: () => ed,
  renderNestedMarkdownContent: () => gc,
  serializeAttributes: () => mc
});
function hc(t) {
  if (!(t != null && t.trim()))
    return {};
  const e = {}, r = [], n = t.replace(/["']([^"']*)["']/g, (d) => (r.push(d), `__QUOTED_${r.length - 1}__`)), o = n.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (o) {
    const d = o.map((c) => c.trim().slice(1));
    e.class = d.join(" ");
  }
  const s = n.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  s && (e.id = s[1]);
  const i = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(n.matchAll(i)).forEach(([, d, c]) => {
    var u;
    const f = parseInt(((u = c.match(/__QUOTED_(\d+)__/)) == null ? void 0 : u[1]) || "0", 10), p = r[f];
    p && (e[d] = p.slice(1, -1));
  });
  const l = n.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return l && l.split(/\s+/).filter(Boolean).forEach((c) => {
    c.match(/^[a-zA-Z][\w-]*$/) && (e[c] = !0);
  }), e;
}
function mc(t) {
  if (!t || Object.keys(t).length === 0)
    return "";
  const e = [];
  return t.class && String(t.class).split(/\s+/).filter(Boolean).forEach((n) => e.push(`.${n}`)), t.id && e.push(`#${t.id}`), Object.entries(t).forEach(([r, n]) => {
    r === "class" || r === "id" || (n === !0 ? e.push(r) : n !== !1 && n != null && e.push(`${r}="${String(n)}"`));
  }), e.join(" ");
}
function A6(t) {
  const {
    nodeName: e,
    name: r,
    parseAttributes: n = hc,
    serializeAttributes: o = mc,
    defaultAttributes: s = {},
    requiredAttributes: i = [],
    allowedAttributes: a
  } = t, l = r || e, d = (c) => {
    if (!a)
      return c;
    const u = {};
    return a.forEach((f) => {
      f in c && (u[f] = c[f]);
    }), u;
  };
  return {
    parseMarkdown: (c, u) => {
      const f = { ...s, ...c.attributes };
      return u.createNode(e, f, []);
    },
    markdownTokenizer: {
      name: e,
      level: "block",
      start(c) {
        var u;
        const f = new RegExp(`^:::${l}(?:\\s|$)`, "m"), p = (u = c.match(f)) == null ? void 0 : u.index;
        return p !== void 0 ? p : -1;
      },
      tokenize(c, u, f) {
        const p = new RegExp(`^:::${l}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), h = c.match(p);
        if (!h)
          return;
        const g = h[1] || "", b = n(g);
        if (!i.find(($) => !($ in b)))
          return {
            type: e,
            raw: h[0],
            attributes: b
          };
      }
    },
    renderMarkdown: (c) => {
      const u = d(c.attrs || {}), f = o(u), p = f ? ` {${f}}` : "";
      return `:::${l}${p} :::`;
    }
  };
}
function M6(t) {
  const {
    nodeName: e,
    name: r,
    getContent: n,
    parseAttributes: o = hc,
    serializeAttributes: s = mc,
    defaultAttributes: i = {},
    content: a = "block",
    allowedAttributes: l
  } = t, d = r || e, c = (u) => {
    if (!l)
      return u;
    const f = {};
    return l.forEach((p) => {
      p in u && (f[p] = u[p]);
    }), f;
  };
  return {
    parseMarkdown: (u, f) => {
      let p;
      if (n) {
        const g = n(u);
        p = typeof g == "string" ? [{ type: "text", text: g }] : g;
      } else a === "block" ? p = f.parseChildren(u.tokens || []) : p = f.parseInline(u.tokens || []);
      const h = { ...i, ...u.attributes };
      return f.createNode(e, h, p);
    },
    markdownTokenizer: {
      name: e,
      level: "block",
      start(u) {
        var f;
        const p = new RegExp(`^:::${d}`, "m"), h = (f = u.match(p)) == null ? void 0 : f.index;
        return h !== void 0 ? h : -1;
      },
      tokenize(u, f, p) {
        var h;
        const g = new RegExp(`^:::${d}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), b = u.match(g);
        if (!b)
          return;
        const [y, $ = ""] = b, k = o($);
        let w = 1;
        const C = y.length;
        let T = "";
        const H = /^:::([\w-]*)(\s.*)?/gm, O = u.slice(C);
        for (H.lastIndex = 0; ; ) {
          const j = H.exec(O);
          if (j === null)
            break;
          const F = j.index, v = j[1];
          if (!((h = j[2]) != null && h.endsWith(":::"))) {
            if (v)
              w += 1;
            else if (w -= 1, w === 0) {
              const M = O.slice(0, F);
              T = M.trim();
              const E = u.slice(0, C + F + j[0].length);
              let N = [];
              if (T)
                if (a === "block")
                  for (N = p.blockTokens(M), N.forEach((R) => {
                    R.text && (!R.tokens || R.tokens.length === 0) && (R.tokens = p.inlineTokens(R.text));
                  }); N.length > 0; ) {
                    const R = N[N.length - 1];
                    if (R.type === "paragraph" && (!R.text || R.text.trim() === ""))
                      N.pop();
                    else
                      break;
                  }
                else
                  N = p.inlineTokens(T);
              return {
                type: e,
                raw: E,
                attributes: k,
                content: T,
                tokens: N
              };
            }
          }
        }
      }
    },
    renderMarkdown: (u, f) => {
      const p = c(u.attrs || {}), h = s(p), g = h ? ` {${h}}` : "", b = f.renderChildren(u.content || [], `

`);
      return `:::${d}${g}

${b}

:::`;
    }
  };
}
function P6(t) {
  if (!t.trim())
    return {};
  const e = {}, r = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let n = r.exec(t);
  for (; n !== null; ) {
    const [, o, s, i] = n;
    e[o] = s || i, n = r.exec(t);
  }
  return e;
}
function I6(t) {
  return Object.entries(t).filter(([, e]) => e != null).map(([e, r]) => `${e}="${r}"`).join(" ");
}
function R6(t) {
  const {
    nodeName: e,
    name: r,
    getContent: n,
    parseAttributes: o = P6,
    serializeAttributes: s = I6,
    defaultAttributes: i = {},
    selfClosing: a = !1,
    allowedAttributes: l
  } = t, d = r || e, c = (f) => {
    if (!l)
      return f;
    const p = {};
    return l.forEach((h) => {
      const g = typeof h == "string" ? h : h.name, b = typeof h == "string" ? void 0 : h.skipIfDefault;
      if (g in f) {
        const y = f[g];
        if (b !== void 0 && y === b)
          return;
        p[g] = y;
      }
    }), p;
  }, u = d.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (f, p) => {
      const h = { ...i, ...f.attributes };
      if (a)
        return p.createNode(e, h);
      const g = n ? n(f) : f.content || "";
      return g ? p.createNode(e, h, [p.createTextNode(g)]) : p.createNode(e, h, []);
    },
    markdownTokenizer: {
      name: e,
      level: "inline",
      start(f) {
        const p = a ? new RegExp(`\\[${u}\\s*[^\\]]*\\]`) : new RegExp(`\\[${u}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${u}\\]`), h = f.match(p), g = h == null ? void 0 : h.index;
        return g !== void 0 ? g : -1;
      },
      tokenize(f, p, h) {
        const g = a ? new RegExp(`^\\[${u}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${u}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${u}\\]`), b = f.match(g);
        if (!b)
          return;
        let y = "", $ = "";
        if (a) {
          const [, w] = b;
          $ = w;
        } else {
          const [, w, C] = b;
          $ = w, y = C || "";
        }
        const k = o($.trim());
        return {
          type: e,
          raw: b[0],
          content: y.trim(),
          attributes: k
        };
      }
    },
    renderMarkdown: (f) => {
      let p = "";
      n ? p = n(f) : f.content && f.content.length > 0 && (p = f.content.filter((y) => y.type === "text").map((y) => y.text).join(""));
      const h = c(f.attrs || {}), g = s(h), b = g ? ` ${g}` : "";
      return a ? `[${d}${b}]` : `[${d}${b}]${p}[/${d}]`;
    }
  };
}
function ed(t, e, r) {
  var n, o, s, i;
  const a = t.split(`
`), l = [];
  let d = "", c = 0;
  const u = e.baseIndentSize || 2;
  for (; c < a.length; ) {
    const f = a[c], p = f.match(e.itemPattern);
    if (!p) {
      if (l.length > 0)
        break;
      if (f.trim() === "") {
        c += 1, d = `${d}${f}
`;
        continue;
      } else
        return;
    }
    const h = e.extractItemData(p), { indentLevel: g, mainContent: b } = h;
    d = `${d}${f}
`;
    const y = [b];
    for (c += 1; c < a.length; ) {
      const C = a[c];
      if (C.trim() === "") {
        const H = a.slice(c + 1).findIndex((F) => F.trim() !== "");
        if (H === -1)
          break;
        if ((((o = (n = a[c + 1 + H].match(/^(\s*)/)) == null ? void 0 : n[1]) == null ? void 0 : o.length) || 0) > g) {
          y.push(C), d = `${d}${C}
`, c += 1;
          continue;
        } else
          break;
      }
      if ((((i = (s = C.match(/^(\s*)/)) == null ? void 0 : s[1]) == null ? void 0 : i.length) || 0) > g)
        y.push(C), d = `${d}${C}
`, c += 1;
      else
        break;
    }
    let $;
    const k = y.slice(1);
    if (k.length > 0) {
      const C = k.map((T) => T.slice(g + u)).join(`
`);
      C.trim() && (e.customNestedParser ? $ = e.customNestedParser(C) : $ = r.blockTokens(C));
    }
    const w = e.createToken(h, $);
    l.push(w);
  }
  if (l.length !== 0)
    return {
      items: l,
      raw: d
    };
}
function gc(t, e, r, n) {
  if (!t || !Array.isArray(t.content))
    return "";
  const o = typeof r == "function" ? r(n) : r, [s, ...i] = t.content, a = e.renderChildren([s]), l = [`${o}${a}`];
  return i && i.length > 0 && i.forEach((d) => {
    const c = e.renderChildren([d]);
    if (c) {
      const u = c.split(`
`).map((f) => f ? e.indent(f) : "").join(`
`);
      l.push(u);
    }
  }), l.join(`
`);
}
var yt = class Ng extends pc {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const r = typeof e == "function" ? e() : e;
    return new Ng(r);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const r = typeof e == "function" ? e() : e;
    return super.extend(r);
  }
};
function tn(t) {
  return new p6({
    find: t.find,
    handler: ({ state: e, range: r, match: n, pasteEvent: o }) => {
      const s = hr(t.getAttributes, void 0, n, o);
      if (s === !1 || s === null)
        return null;
      const { tr: i } = e, a = n[n.length - 1], l = n[0];
      let d = r.to;
      if (a) {
        const c = l.search(/\S/), u = r.from + l.indexOf(a), f = u + a.length;
        if (uc(r.from, r.to, e.doc).filter((h) => h.mark.type.excluded.find((b) => b === t.type && b !== h.mark.type)).filter((h) => h.to > u).length)
          return null;
        f < r.to && i.delete(f, r.to), u > r.from && i.delete(r.from + c, u), d = r.from + c + a.length, i.addMark(r.from + c, d, t.type.create(s || {})), i.removeStoredMark(t.type);
      }
    }
  });
}
var vi = (t, e) => {
  if (t === "slot")
    return 0;
  if (t instanceof Function)
    return t(e);
  const { children: r, ...n } = e ?? {};
  if (t === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [t, n, r];
}, O6 = /^\s*>\s$/, L6 = yt.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return /* @__PURE__ */ vi("blockquote", { ...Re(this.options.HTMLAttributes, t), children: /* @__PURE__ */ vi("slot", {}) });
  },
  parseMarkdown: (t, e) => e.createNode("blockquote", void 0, e.parseChildren(t.tokens || [])),
  renderMarkdown: (t, e) => {
    if (!t.content)
      return "";
    const r = ">", n = [];
    return t.content.forEach((o) => {
      const a = e.renderChildren([o]).split(`
`).map((l) => l.trim() === "" ? r : `${r} ${l}`);
      n.push(a.join(`
`));
    }), n.join(`
${r}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      lo({
        find: O6,
        type: this.type
      })
    ];
  }
}), j6 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, D6 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, _6 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, F6 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, z6 = mr.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return /* @__PURE__ */ vi("strong", { ...Re(this.options.HTMLAttributes, t), children: /* @__PURE__ */ vi("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (t, e) => e.applyMark("bold", e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => `**${e.renderChildren(t)}**`,
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      An({
        find: j6,
        type: this.type
      }),
      An({
        find: _6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      tn({
        find: D6,
        type: this.type
      }),
      tn({
        find: F6,
        type: this.type
      })
    ];
  }
}), H6 = /(^|[^`])`([^`]+)`(?!`)$/, B6 = /(^|[^`])`([^`]+)`(?!`)/g, V6 = mr.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", Re(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (t, e) => e.applyMark("code", [{ type: "text", text: t.text || "" }]),
  renderMarkdown: (t, e) => t.content ? `\`${e.renderChildren(t.content)}\`` : "",
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      An({
        find: H6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      tn({
        find: B6,
        type: this.type
      })
    ];
  }
}), Za = 4, W6 = /^```([a-z]+)?[\s\n]$/, U6 = /^~~~([a-z]+)?[\s\n]$/, G6 = yt.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      enableTabIndentation: !1,
      tabSize: Za,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: r } = this.options;
          if (!r)
            return null;
          const s = [...((e = t.firstElementChild) == null ? void 0 : e.classList) || []].filter((i) => i.startsWith(r)).map((i) => i.replace(r, ""))[0];
          return s || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      Re(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (t, e) => {
    var r;
    return ((r = t.raw) == null ? void 0 : r.startsWith("```")) === !1 && t.codeBlockStyle !== "indented" ? [] : e.createNode(
      "codeBlock",
      { language: t.lang || null },
      t.text ? [e.createTextNode(t.text)] : []
    );
  },
  renderMarkdown: (t, e) => {
    var r;
    let n = "";
    const o = ((r = t.attrs) == null ? void 0 : r.language) || "";
    return t.content ? n = [`\`\`\`${o}`, e.renderChildren(t.content), "```"].join(`
`) : n = `\`\`\`${o}

\`\`\``, n;
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, r = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : r || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // handle tab indentation
      Tab: ({ editor: t }) => {
        var e;
        if (!this.options.enableTabIndentation)
          return !1;
        const r = (e = this.options.tabSize) != null ? e : Za, { state: n } = t, { selection: o } = n, { $from: s, empty: i } = o;
        if (s.parent.type !== this.type)
          return !1;
        const a = " ".repeat(r);
        return i ? t.commands.insertContent(a) : t.commands.command(({ tr: l }) => {
          const { from: d, to: c } = o, p = n.doc.textBetween(d, c, `
`, `
`).split(`
`).map((h) => a + h).join(`
`);
          return l.replaceWith(d, c, n.schema.text(p)), !0;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor: t }) => {
        var e;
        if (!this.options.enableTabIndentation)
          return !1;
        const r = (e = this.options.tabSize) != null ? e : Za, { state: n } = t, { selection: o } = n, { $from: s, empty: i } = o;
        return s.parent.type !== this.type ? !1 : i ? t.commands.command(({ tr: a }) => {
          var l;
          const { pos: d } = s, c = s.start(), u = s.end(), p = n.doc.textBetween(c, u, `
`, `
`).split(`
`);
          let h = 0, g = 0;
          const b = d - c;
          for (let T = 0; T < p.length; T += 1) {
            if (g + p[T].length >= b) {
              h = T;
              break;
            }
            g += p[T].length + 1;
          }
          const $ = ((l = p[h].match(/^ */)) == null ? void 0 : l[0]) || "", k = Math.min($.length, r);
          if (k === 0)
            return !0;
          let w = c;
          for (let T = 0; T < h; T += 1)
            w += p[T].length + 1;
          return a.delete(w, w + k), d - w <= k && a.setSelection(fe.create(a.doc, w)), !0;
        }) : t.commands.command(({ tr: a }) => {
          const { from: l, to: d } = o, f = n.doc.textBetween(l, d, `
`, `
`).split(`
`).map((p) => {
            var h;
            const g = ((h = p.match(/^ */)) == null ? void 0 : h[0]) || "", b = Math.min(g.length, r);
            return p.slice(b);
          }).join(`
`);
          return a.replaceWith(l, d, n.schema.text(f)), !0;
        });
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: r } = e, { $from: n, empty: o } = r;
        if (!o || n.parent.type !== this.type)
          return !1;
        const s = n.parentOffset === n.parent.nodeSize - 2, i = n.parent.textContent.endsWith(`

`);
        return !s || !i ? !1 : t.chain().command(({ tr: a }) => (a.delete(n.pos - 2, n.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: r, doc: n } = e, { $from: o, empty: s } = r;
        if (!s || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
          return !1;
        const a = o.after();
        return a === void 0 ? !1 : n.nodeAt(a) ? t.commands.command(({ tr: d }) => (d.setSelection(be.near(n.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      Ql({
        find: W6,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      Ql({
        find: U6,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Ze({
        key: new Qe("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const r = e.clipboardData.getData("text/plain"), n = e.clipboardData.getData("vscode-editor-data"), o = n ? JSON.parse(n) : void 0, s = o == null ? void 0 : o.mode;
            if (!r || !s)
              return !1;
            const { tr: i, schema: a } = t.state, l = a.text(r.replace(/\r\n?/g, `
`));
            return i.replaceSelectionWith(this.type.create({ language: s }, l)), i.selection.$from.parent.type !== this.type && i.setSelection(fe.near(i.doc.resolve(Math.max(0, i.selection.from - 2)))), i.setMeta("paste", !0), t.dispatch(i), !0;
          }
        }
      })
    ];
  }
}), K6 = yt.create({
  name: "doc",
  topNode: !0,
  content: "block+",
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `

`) : ""
}), Y6 = yt.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", Re(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => ({
    type: "hardBreak"
  }),
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: r, editor: n }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: o, storedMarks: s } = r;
          if (o.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: i } = this.options, { splittableMarks: a } = n.extensionManager, l = s || o.$to.parentOffset && o.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: d, dispatch: c }) => {
            if (c && l && i) {
              const u = l.filter((f) => a.includes(f.type.name));
              d.ensureMarks(u);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), J6 = yt.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Re(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown: (t, e) => e.createNode("heading", { level: t.depth || 1 }, e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => {
    var r;
    const n = (r = t.attrs) != null && r.level ? parseInt(t.attrs.level, 10) : 1, o = "#".repeat(n);
    return t.content ? `${o} ${e.renderChildren(t.content)}` : "";
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (t, e) => ({
        ...t,
        [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((t) => Ql({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), q6 = yt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", Re(this.options.HTMLAttributes, t)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (t, e) => e.createNode("horizontalRule"),
  renderMarkdown: () => "---",
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        if (!N6(e, e.schema.nodes[this.name]))
          return !1;
        const { selection: r } = e, { $to: n } = r, o = t();
        return xg(r) ? o.insertContentAt(n.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ state: s, tr: i, dispatch: a }) => {
          if (a) {
            const { $to: l } = i.selection, d = l.end();
            if (l.nodeAfter)
              l.nodeAfter.isTextblock ? i.setSelection(fe.create(i.doc, l.pos + 1)) : l.nodeAfter.isBlock ? i.setSelection(ue.create(i.doc, l.pos)) : i.setSelection(fe.create(i.doc, l.pos));
            else {
              const c = s.schema.nodes[this.options.nextNodeType] || l.parent.type.contentMatch.defaultType, u = c == null ? void 0 : c.create();
              u && (i.insert(d, u), i.setSelection(fe.create(i.doc, d + 1)));
            }
            i.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      Sg({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), X6 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, Z6 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Q6 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, ek = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, tk = mr.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", Re(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (t, e) => e.applyMark("italic", e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => `*${e.renderChildren(t)}*`,
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      An({
        find: X6,
        type: this.type
      }),
      An({
        find: Q6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      tn({
        find: Z6,
        type: this.type
      }),
      tn({
        find: ek,
        type: this.type
      })
    ];
  }
});
const rk = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", nk = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", td = "numeric", rd = "ascii", nd = "alpha", Lo = "asciinumeric", Ao = "alphanumeric", od = "domain", Tg = "emoji", ok = "scheme", sk = "slashscheme", Qa = "whitespace";
function ik(t, e) {
  return t in e || (e[t] = []), e[t];
}
function bn(t, e, r) {
  e[td] && (e[Lo] = !0, e[Ao] = !0), e[rd] && (e[Lo] = !0, e[nd] = !0), e[Lo] && (e[Ao] = !0), e[nd] && (e[Ao] = !0), e[Ao] && (e[od] = !0), e[Tg] && (e[od] = !0);
  for (const n in e) {
    const o = ik(n, r);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function ak(t, e) {
  const r = {};
  for (const n in e)
    e[n].indexOf(t) >= 0 && (r[n] = !0);
  return r;
}
function Lt(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
Lt.groups = {};
Lt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, r = e.j[t];
    if (r)
      return r;
    for (let n = 0; n < e.jr.length; n++) {
      const o = e.jr[n][0], s = e.jr[n][1];
      if (s && o.test(t))
        return s;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, r, n) {
    for (let o = 0; o < t.length; o++)
      this.tt(t[o], e, r, n);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, r, n) {
    n = n || Lt.groups;
    let o;
    return e && e.j ? o = e : (o = new Lt(e), r && n && bn(e, r, n)), this.jr.push([t, o]), o;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, r, n) {
    let o = this;
    const s = t.length;
    if (!s)
      return o;
    for (let i = 0; i < s - 1; i++)
      o = o.tt(t[i]);
    return o.tt(t[s - 1], e, r, n);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, r, n) {
    n = n || Lt.groups;
    const o = this;
    if (e && e.j)
      return o.j[t] = e, e;
    const s = e;
    let i, a = o.go(t);
    if (a ? (i = new Lt(), Object.assign(i.j, a.j), i.jr.push.apply(i.jr, a.jr), i.jd = a.jd, i.t = a.t) : i = new Lt(), s) {
      if (n)
        if (i.t && typeof i.t == "string") {
          const l = Object.assign(ak(i.t, n), r);
          bn(s, l, n);
        } else r && bn(s, r, n);
      i.t = s;
    }
    return o.j[t] = i, i;
  }
};
const xe = (t, e, r, n, o) => t.ta(e, r, n, o), Je = (t, e, r, n, o) => t.tr(e, r, n, o), Yf = (t, e, r, n, o) => t.ts(e, r, n, o), J = (t, e, r, n, o) => t.tt(e, r, n, o), Cr = "WORD", sd = "UWORD", Ag = "ASCIINUMERICAL", Mg = "ALPHANUMERICAL", rs = "LOCALHOST", id = "TLD", ad = "UTLD", Bs = "SCHEME", Gn = "SLASH_SCHEME", bc = "NUM", ld = "WS", yc = "NL", jo = "OPENBRACE", Do = "CLOSEBRACE", $i = "OPENBRACKET", xi = "CLOSEBRACKET", wi = "OPENPAREN", ki = "CLOSEPAREN", Ei = "OPENANGLEBRACKET", Ci = "CLOSEANGLEBRACKET", Si = "FULLWIDTHLEFTPAREN", Ni = "FULLWIDTHRIGHTPAREN", Ti = "LEFTCORNERBRACKET", Ai = "RIGHTCORNERBRACKET", Mi = "LEFTWHITECORNERBRACKET", Pi = "RIGHTWHITECORNERBRACKET", Ii = "FULLWIDTHLESSTHAN", Ri = "FULLWIDTHGREATERTHAN", Oi = "AMPERSAND", Li = "APOSTROPHE", ji = "ASTERISK", Vr = "AT", Di = "BACKSLASH", _i = "BACKTICK", Fi = "CARET", Gr = "COLON", vc = "COMMA", zi = "DOLLAR", lr = "DOT", Hi = "EQUALS", $c = "EXCLAMATION", Kt = "HYPHEN", _o = "PERCENT", Bi = "PIPE", Vi = "PLUS", Wi = "POUND", Fo = "QUERY", xc = "QUOTE", Pg = "FULLWIDTHMIDDLEDOT", wc = "SEMI", dr = "SLASH", zo = "TILDE", Ui = "UNDERSCORE", Ig = "EMOJI", Gi = "SYM";
var Rg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: Mg,
  AMPERSAND: Oi,
  APOSTROPHE: Li,
  ASCIINUMERICAL: Ag,
  ASTERISK: ji,
  AT: Vr,
  BACKSLASH: Di,
  BACKTICK: _i,
  CARET: Fi,
  CLOSEANGLEBRACKET: Ci,
  CLOSEBRACE: Do,
  CLOSEBRACKET: xi,
  CLOSEPAREN: ki,
  COLON: Gr,
  COMMA: vc,
  DOLLAR: zi,
  DOT: lr,
  EMOJI: Ig,
  EQUALS: Hi,
  EXCLAMATION: $c,
  FULLWIDTHGREATERTHAN: Ri,
  FULLWIDTHLEFTPAREN: Si,
  FULLWIDTHLESSTHAN: Ii,
  FULLWIDTHMIDDLEDOT: Pg,
  FULLWIDTHRIGHTPAREN: Ni,
  HYPHEN: Kt,
  LEFTCORNERBRACKET: Ti,
  LEFTWHITECORNERBRACKET: Mi,
  LOCALHOST: rs,
  NL: yc,
  NUM: bc,
  OPENANGLEBRACKET: Ei,
  OPENBRACE: jo,
  OPENBRACKET: $i,
  OPENPAREN: wi,
  PERCENT: _o,
  PIPE: Bi,
  PLUS: Vi,
  POUND: Wi,
  QUERY: Fo,
  QUOTE: xc,
  RIGHTCORNERBRACKET: Ai,
  RIGHTWHITECORNERBRACKET: Pi,
  SCHEME: Bs,
  SEMI: wc,
  SLASH: dr,
  SLASH_SCHEME: Gn,
  SYM: Gi,
  TILDE: zo,
  TLD: id,
  UNDERSCORE: Ui,
  UTLD: ad,
  UWORD: sd,
  WORD: Cr,
  WS: ld
});
const kr = /[a-z]/, wo = new RegExp("\\p{L}", "u"), el = new RegExp("\\p{Emoji}", "u"), Er = /\d/, tl = /\s/, Jf = "\r", rl = `
`, lk = "", dk = "", nl = "";
let As = null, Ms = null;
function ck(t = []) {
  const e = {};
  Lt.groups = e;
  const r = new Lt();
  As == null && (As = qf(rk)), Ms == null && (Ms = qf(nk)), J(r, "'", Li), J(r, "{", jo), J(r, "}", Do), J(r, "[", $i), J(r, "]", xi), J(r, "(", wi), J(r, ")", ki), J(r, "<", Ei), J(r, ">", Ci), J(r, "", Si), J(r, "", Ni), J(r, "", Ti), J(r, "", Ai), J(r, "", Mi), J(r, "", Pi), J(r, "", Ii), J(r, "", Ri), J(r, "&", Oi), J(r, "*", ji), J(r, "@", Vr), J(r, "`", _i), J(r, "^", Fi), J(r, ":", Gr), J(r, ",", vc), J(r, "$", zi), J(r, ".", lr), J(r, "=", Hi), J(r, "!", $c), J(r, "-", Kt), J(r, "%", _o), J(r, "|", Bi), J(r, "+", Vi), J(r, "#", Wi), J(r, "?", Fo), J(r, '"', xc), J(r, "/", dr), J(r, ";", wc), J(r, "~", zo), J(r, "_", Ui), J(r, "\\", Di), J(r, "", Pg);
  const n = Je(r, Er, bc, {
    [td]: !0
  });
  Je(n, Er, n);
  const o = Je(n, kr, Ag, {
    [Lo]: !0
  }), s = Je(n, wo, Mg, {
    [Ao]: !0
  }), i = Je(r, kr, Cr, {
    [rd]: !0
  });
  Je(i, Er, o), Je(i, kr, i), Je(o, Er, o), Je(o, kr, o);
  const a = Je(r, wo, sd, {
    [nd]: !0
  });
  Je(a, kr), Je(a, Er, s), Je(a, wo, a), Je(s, Er, s), Je(s, kr), Je(s, wo, s);
  const l = J(r, rl, yc, {
    [Qa]: !0
  }), d = J(r, Jf, ld, {
    [Qa]: !0
  }), c = Je(r, tl, ld, {
    [Qa]: !0
  });
  J(r, nl, c), J(d, rl, l), J(d, nl, c), Je(d, tl, c), J(c, Jf), J(c, rl), Je(c, tl, c), J(c, nl, c);
  const u = Je(r, el, Ig, {
    [Tg]: !0
  });
  J(u, "#"), Je(u, el, u), J(u, lk, u);
  const f = J(u, dk);
  J(f, "#"), Je(f, el, u);
  const p = [[kr, i], [Er, o]], h = [[kr, null], [wo, a], [Er, s]];
  for (let g = 0; g < As.length; g++)
    Hr(r, As[g], id, Cr, p);
  for (let g = 0; g < Ms.length; g++)
    Hr(r, Ms[g], ad, sd, h);
  bn(id, {
    tld: !0,
    ascii: !0
  }, e), bn(ad, {
    utld: !0,
    alpha: !0
  }, e), Hr(r, "file", Bs, Cr, p), Hr(r, "mailto", Bs, Cr, p), Hr(r, "http", Gn, Cr, p), Hr(r, "https", Gn, Cr, p), Hr(r, "ftp", Gn, Cr, p), Hr(r, "ftps", Gn, Cr, p), bn(Bs, {
    scheme: !0,
    ascii: !0
  }, e), bn(Gn, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((g, b) => g[0] > b[0] ? 1 : -1);
  for (let g = 0; g < t.length; g++) {
    const b = t[g][0], $ = t[g][1] ? {
      [ok]: !0
    } : {
      [sk]: !0
    };
    b.indexOf("-") >= 0 ? $[od] = !0 : kr.test(b) ? Er.test(b) ? $[Lo] = !0 : $[rd] = !0 : $[td] = !0, Yf(r, b, b, $);
  }
  return Yf(r, "localhost", rs, {
    ascii: !0
  }), r.jd = new Lt(Gi), {
    start: r,
    tokens: Object.assign({
      groups: e
    }, Rg)
  };
}
function Og(t, e) {
  const r = uk(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), n = r.length, o = [];
  let s = 0, i = 0;
  for (; i < n; ) {
    let a = t, l = null, d = 0, c = null, u = -1, f = -1;
    for (; i < n && (l = a.go(r[i])); )
      a = l, a.accepts() ? (u = 0, f = 0, c = a) : u >= 0 && (u += r[i].length, f++), d += r[i].length, s += r[i].length, i++;
    s -= u, i -= f, d -= u, o.push({
      t: c.t,
      // token type/name
      v: e.slice(s - d, s),
      // string value
      s: s - d,
      // start index
      e: s
      // end index (excluding)
    });
  }
  return o;
}
function uk(t) {
  const e = [], r = t.length;
  let n = 0;
  for (; n < r; ) {
    let o = t.charCodeAt(n), s, i = o < 55296 || o > 56319 || n + 1 === r || (s = t.charCodeAt(n + 1)) < 56320 || s > 57343 ? t[n] : t.slice(n, n + 2);
    e.push(i), n += i.length;
  }
  return e;
}
function Hr(t, e, r, n, o) {
  let s;
  const i = e.length;
  for (let a = 0; a < i - 1; a++) {
    const l = e[a];
    t.j[l] ? s = t.j[l] : (s = new Lt(n), s.jr = o.slice(), t.j[l] = s), t = s;
  }
  return s = new Lt(r), s.jr = o.slice(), t.j[e[i - 1]] = s, s;
}
function qf(t) {
  const e = [], r = [];
  let n = 0, o = "0123456789";
  for (; n < t.length; ) {
    let s = 0;
    for (; o.indexOf(t[n + s]) >= 0; )
      s++;
    if (s > 0) {
      e.push(r.join(""));
      for (let i = parseInt(t.substring(n, n + s), 10); i > 0; i--)
        r.pop();
      n += s;
    } else
      r.push(t[n]), n++;
  }
  return e;
}
const ns = {
  defaultProtocol: "http",
  events: null,
  format: Xf,
  formatHref: Xf,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function kc(t, e = null) {
  let r = Object.assign({}, ns);
  t && (r = Object.assign(r, t instanceof kc ? t.o : t));
  const n = r.ignoreTags, o = [];
  for (let s = 0; s < n.length; s++)
    o.push(n[s].toUpperCase());
  this.o = r, e && (this.defaultRender = e), this.ignoreTags = o;
}
kc.prototype = {
  o: ns,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, r) {
    const n = e != null;
    let o = this.o[t];
    return o && (typeof o == "object" ? (o = r.t in o ? o[r.t] : ns[t], typeof o == "function" && n && (o = o(e, r))) : typeof o == "function" && n && (o = o(e, r.t, r)), o);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, r) {
    let n = this.o[t];
    return typeof n == "function" && e != null && (n = n(e, r.t, r)), n;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function Xf(t) {
  return t;
}
function Lg(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
Lg.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), r = t.get("truncate", e, this), n = t.get("format", e, this);
    return r && n.length > r ? n.substring(0, r) + "" : n;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = ns.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, r = this.toHref(t.get("defaultProtocol")), n = t.get("formatHref", r, this), o = t.get("tagName", r, e), s = this.toFormattedString(t), i = {}, a = t.get("className", r, e), l = t.get("target", r, e), d = t.get("rel", r, e), c = t.getObj("attributes", r, e), u = t.getObj("events", r, e);
    return i.href = n, a && (i.class = a), l && (i.target = l), d && (i.rel = d), c && Object.assign(i, c), {
      tagName: o,
      attributes: i,
      content: s,
      eventListeners: u
    };
  }
};
function ga(t, e) {
  class r extends Lg {
    constructor(o, s) {
      super(o, s), this.t = t;
    }
  }
  for (const n in e)
    r.prototype[n] = e[n];
  return r.t = t, r;
}
const Zf = ga("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), Qf = ga("text"), fk = ga("nl"), Ps = ga("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = ns.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== rs && t[1].t === Gr;
  }
}), Gt = (t) => new Lt(t);
function pk({
  groups: t
}) {
  const e = t.domain.concat([Oi, ji, Vr, Di, _i, Fi, zi, Hi, Kt, bc, _o, Bi, Vi, Wi, dr, Gi, zo, Ui]), r = [Li, Gr, vc, lr, $c, _o, Fo, xc, wc, Ei, Ci, jo, Do, xi, $i, wi, ki, Si, Ni, Ti, Ai, Mi, Pi, Ii, Ri], n = [Oi, Li, ji, Di, _i, Fi, zi, Hi, Kt, jo, Do, _o, Bi, Vi, Wi, Fo, dr, Gi, zo, Ui], o = Gt(), s = J(o, zo);
  xe(s, n, s), xe(s, t.domain, s);
  const i = Gt(), a = Gt(), l = Gt();
  xe(o, t.domain, i), xe(o, t.scheme, a), xe(o, t.slashscheme, l), xe(i, n, s), xe(i, t.domain, i);
  const d = J(i, Vr);
  J(s, Vr, d), J(a, Vr, d), J(l, Vr, d);
  const c = J(s, lr);
  xe(c, n, s), xe(c, t.domain, s);
  const u = Gt();
  xe(d, t.domain, u), xe(u, t.domain, u);
  const f = J(u, lr);
  xe(f, t.domain, u);
  const p = Gt(Zf);
  xe(f, t.tld, p), xe(f, t.utld, p), J(d, rs, p);
  const h = J(u, Kt);
  J(h, Kt, h), xe(h, t.domain, u), xe(p, t.domain, u), J(p, lr, f), J(p, Kt, h);
  const g = J(p, Gr);
  xe(g, t.numeric, Zf);
  const b = J(i, Kt), y = J(i, lr);
  J(b, Kt, b), xe(b, t.domain, i), xe(y, n, s), xe(y, t.domain, i);
  const $ = Gt(Ps);
  xe(y, t.tld, $), xe(y, t.utld, $), xe($, t.domain, i), xe($, n, s), J($, lr, y), J($, Kt, b), J($, Vr, d);
  const k = J($, Gr), w = Gt(Ps);
  xe(k, t.numeric, w);
  const C = Gt(Ps), T = Gt();
  xe(C, e, C), xe(C, r, T), xe(T, e, C), xe(T, r, T), J($, dr, C), J(w, dr, C);
  const H = J(a, Gr), O = J(l, Gr), j = J(O, dr), F = J(j, dr);
  xe(a, t.domain, i), J(a, lr, y), J(a, Kt, b), xe(l, t.domain, i), J(l, lr, y), J(l, Kt, b), xe(H, t.domain, C), J(H, dr, C), J(H, Fo, C), xe(F, t.domain, C), xe(F, e, C), J(F, dr, C);
  const v = [
    [jo, Do],
    // {}
    [$i, xi],
    // []
    [wi, ki],
    // ()
    [Ei, Ci],
    // <>
    [Si, Ni],
    // 
    [Ti, Ai],
    // 
    [Mi, Pi],
    // 
    [Ii, Ri]
    // 
  ];
  for (let M = 0; M < v.length; M++) {
    const [E, N] = v[M], R = J(C, E);
    J(T, E, R), J(R, N, C);
    const x = Gt(Ps);
    xe(R, e, x);
    const P = Gt();
    xe(R, r), xe(x, e, x), xe(x, r, P), xe(P, e, x), xe(P, r, P), J(x, N, C), J(P, N, C);
  }
  return J(o, rs, $), J(o, yc, fk), {
    start: o,
    tokens: Rg
  };
}
function hk(t, e, r) {
  let n = r.length, o = 0, s = [], i = [];
  for (; o < n; ) {
    let a = t, l = null, d = null, c = 0, u = null, f = -1;
    for (; o < n && !(l = a.go(r[o].t)); )
      i.push(r[o++]);
    for (; o < n && (d = l || a.go(r[o].t)); )
      l = null, a = d, a.accepts() ? (f = 0, u = a) : f >= 0 && f++, o++, c++;
    if (f < 0)
      o -= c, o < n && (i.push(r[o]), o++);
    else {
      i.length > 0 && (s.push(ol(Qf, e, i)), i = []), o -= f, c -= f;
      const p = u.t, h = r.slice(o - c, o);
      s.push(ol(p, e, h));
    }
  }
  return i.length > 0 && s.push(ol(Qf, e, i)), s;
}
function ol(t, e, r) {
  const n = r[0].s, o = r[r.length - 1].e, s = e.slice(n, o);
  return new t(s, r);
}
const mk = typeof console < "u" && console && console.warn || (() => {
}), gk = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", We = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function bk() {
  return Lt.groups = {}, We.scanner = null, We.parser = null, We.tokenQueue = [], We.pluginQueue = [], We.customSchemes = [], We.initialized = !1, We;
}
function ep(t, e = !1) {
  if (We.initialized && mk(`linkifyjs: already initialized - will not register custom scheme "${t}" ${gk}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  We.customSchemes.push([t, e]);
}
function yk() {
  We.scanner = ck(We.customSchemes);
  for (let t = 0; t < We.tokenQueue.length; t++)
    We.tokenQueue[t][1]({
      scanner: We.scanner
    });
  We.parser = pk(We.scanner.tokens);
  for (let t = 0; t < We.pluginQueue.length; t++)
    We.pluginQueue[t][1]({
      scanner: We.scanner,
      parser: We.parser
    });
  return We.initialized = !0, We;
}
function Ec(t) {
  return We.initialized || yk(), hk(We.parser.start, t, Og(We.scanner.start, t));
}
Ec.scan = Og;
function jg(t, e = null, r = null) {
  if (e && typeof e == "object") {
    if (r)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    r = e, e = null;
  }
  const n = new kc(r), o = Ec(t), s = [];
  for (let i = 0; i < o.length; i++) {
    const a = o[i];
    a.isLink && (!e || a.t === e) && n.check(a) && s.push(a.toFormattedObject(n));
  }
  return s;
}
var Cc = "[\0- -\u2029]", vk = new RegExp(Cc), $k = new RegExp(`${Cc}$`), xk = new RegExp(Cc, "g");
function wk(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function kk(t) {
  return new Ze({
    key: new Qe("autolink"),
    appendTransaction: (e, r, n) => {
      const o = e.some((d) => d.docChanged) && !r.doc.eq(n.doc), s = e.some((d) => d.getMeta("preventAutolink"));
      if (!o || s)
        return;
      const { tr: i } = n, a = bg(r.doc, [...e]);
      if ($g(a).forEach(({ newRange: d }) => {
        const c = I9(n.doc, d, (p) => p.isTextblock);
        let u, f;
        if (c.length > 1)
          u = c[0], f = n.doc.textBetween(
            u.pos,
            u.pos + u.node.nodeSize,
            void 0,
            " "
          );
        else if (c.length) {
          const p = n.doc.textBetween(d.from, d.to, " ", " ");
          if (!$k.test(p))
            return;
          u = c[0], f = n.doc.textBetween(u.pos, d.to, void 0, " ");
        }
        if (u && f) {
          const p = f.split(vk).filter(Boolean);
          if (p.length <= 0)
            return !1;
          const h = p[p.length - 1], g = u.pos + f.lastIndexOf(h);
          if (!h)
            return !1;
          const b = Ec(h).map((y) => y.toObject(t.defaultProtocol));
          if (!wk(b))
            return !1;
          b.filter((y) => y.isLink).map((y) => ({
            ...y,
            from: g + y.start + 1,
            to: g + y.end + 1
          })).filter((y) => n.schema.marks.code ? !n.doc.rangeHasMark(y.from, y.to, n.schema.marks.code) : !0).filter((y) => t.validate(y.value)).filter((y) => t.shouldAutoLink(y.value)).forEach((y) => {
            uc(y.from, y.to, n.doc).some(($) => $.mark.type === t.type) || i.addMark(
              y.from,
              y.to,
              t.type.create({
                href: y.href
              })
            );
          });
        }
      }), !!i.steps.length)
        return i;
    }
  });
}
function Ek(t) {
  return new Ze({
    key: new Qe("handleClickLink"),
    props: {
      handleClick: (e, r, n) => {
        var o, s;
        if (n.button !== 0 || !e.editable)
          return !1;
        let i = !1;
        if (t.enableClickSelection && (i = t.editor.commands.extendMarkRange(t.type.name)), t.openOnClick) {
          let a = null;
          if (n.target instanceof HTMLAnchorElement)
            a = n.target;
          else {
            let u = n.target;
            const f = [];
            for (; u.nodeName !== "DIV"; )
              f.push(u), u = u.parentNode;
            a = f.find((p) => p.nodeName === "A");
          }
          if (!a)
            return i;
          const l = _9(e.state, t.type.name), d = (o = a == null ? void 0 : a.href) != null ? o : l.href, c = (s = a == null ? void 0 : a.target) != null ? s : l.target;
          a && d && (window.open(d, c), i = !0);
        }
        return i;
      }
    }
  });
}
function Ck(t) {
  return new Ze({
    key: new Qe("handlePasteLink"),
    props: {
      handlePaste: (e, r, n) => {
        const { shouldAutoLink: o } = t, { state: s } = e, { selection: i } = s, { empty: a } = i;
        if (a)
          return !1;
        let l = "";
        n.content.forEach((c) => {
          l += c.textContent;
        });
        const d = jg(l, { defaultProtocol: t.defaultProtocol }).find(
          (c) => c.isLink && c.value === l
        );
        return !l || !d || o !== void 0 && !o(d.value) ? !1 : t.editor.commands.setMark(t.type, {
          href: d.href
        });
      }
    }
  });
}
function fn(t, e) {
  const r = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return e && e.forEach((n) => {
    const o = typeof n == "string" ? n : n.scheme;
    o && r.push(o);
  }), !t || t.replace(xk, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${r.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Sk = mr.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        ep(t);
        return;
      }
      ep(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    bk();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!fn(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => {
        const e = /^[a-z][a-z0-9+.-]*:\/\//i.test(t), r = /^[a-z][a-z0-9+.-]*:/i.test(t);
        if (e || r && !t.includes("@"))
          return !0;
        const o = (t.includes("@") ? t.split("@").pop() : t).split(/[/?#:]/)[0];
        return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(o) || !/\./.test(o));
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (r) => !!fn(r, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!fn(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Re(this.options.HTMLAttributes, t), 0] : ["a", Re(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (t, e) => e.applyMark("link", e.parseInline(t.tokens || []), {
    href: t.href,
    title: t.title || null
  }),
  renderMarkdown: (t, e) => {
    var r;
    const n = ((r = t.attrs) == null ? void 0 : r.href) || "";
    return `[${e.renderChildren(t)}](${n})`;
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: r } = t;
        return this.options.isAllowedUri(r, {
          defaultValidate: (n) => !!fn(n, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: r } = t || {};
        return r && !this.options.isAllowedUri(r, {
          defaultValidate: (n) => !!fn(n, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      tn({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: r, defaultProtocol: n } = this.options, o = jg(t).filter(
              (s) => s.isLink && this.options.isAllowedUri(s.value, {
                defaultValidate: (i) => !!fn(i, r),
                protocols: r,
                defaultProtocol: n
              })
            );
            o.length && o.forEach((s) => {
              this.options.shouldAutoLink(s.value) && e.push({
                text: s.value,
                data: {
                  href: s.href
                },
                index: s.start
              });
            });
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: r } = this.options;
    return this.options.autolink && t.push(
      kk({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (n) => this.options.isAllowedUri(n, {
          defaultValidate: (o) => !!fn(o, e),
          protocols: e,
          defaultProtocol: r
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), t.push(
      Ek({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && t.push(
      Ck({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), t;
  }
}), Nk = Object.defineProperty, Tk = (t, e) => {
  for (var r in e)
    Nk(t, r, { get: e[r], enumerable: !0 });
}, Ak = "listItem", tp = "textStyle", rp = /^\s*([-+*])\s$/, Dg = yt.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Re(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (t, e) => t.type !== "list" || t.ordered ? [] : {
    type: "bulletList",
    content: t.items ? e.parseChildren(t.items) : []
  },
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Ak, this.editor.getAttributes(tp)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = lo({
      find: rp,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = lo({
      find: rp,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(tp),
      editor: this.editor
    })), [t];
  }
}), _g = yt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", Re(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (t, e) => {
    if (t.type !== "list_item")
      return [];
    let r = [];
    if (t.tokens && t.tokens.length > 0)
      if (t.tokens.some((o) => o.type === "paragraph"))
        r = e.parseChildren(t.tokens);
      else {
        const o = t.tokens[0];
        if (o && o.type === "text" && o.tokens && o.tokens.length > 0) {
          if (r = [
            {
              type: "paragraph",
              content: e.parseInline(o.tokens)
            }
          ], t.tokens.length > 1) {
            const i = t.tokens.slice(1), a = e.parseChildren(i);
            r.push(...a);
          }
        } else
          r = e.parseChildren(t.tokens);
      }
    return r.length === 0 && (r = [
      {
        type: "paragraph",
        content: []
      }
    ]), {
      type: "listItem",
      content: r
    };
  },
  renderMarkdown: (t, e, r) => gc(
    t,
    e,
    (n) => n.parentType === "bulletList" ? "- " : n.parentType === "orderedList" ? `${n.index + 1}. ` : "- ",
    r
  ),
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Mk = {};
Tk(Mk, {
  findListItemPos: () => ls,
  getNextListDepth: () => Sc,
  handleBackspace: () => dd,
  handleDelete: () => cd,
  hasListBefore: () => Fg,
  hasListItemAfter: () => Pk,
  hasListItemBefore: () => zg,
  listItemHasSubList: () => Hg,
  nextListIsDeeper: () => Bg,
  nextListIsHigher: () => Vg
});
var ls = (t, e) => {
  const { $from: r } = e.selection, n = dt(t, e.schema);
  let o = null, s = r.depth, i = r.pos, a = null;
  for (; s > 0 && a === null; )
    o = r.node(s), o.type === n ? a = s : (s -= 1, i -= 1);
  return a === null ? null : { $pos: e.doc.resolve(i), depth: a };
}, Sc = (t, e) => {
  const r = ls(t, e);
  if (!r)
    return !1;
  const [, n] = H9(e, t, r.$pos.pos + 4);
  return n;
}, Fg = (t, e, r) => {
  const { $anchor: n } = t.selection, o = Math.max(0, n.pos - 2), s = t.doc.resolve(o).node();
  return !(!s || !r.includes(s.type.name));
}, zg = (t, e) => {
  var r;
  const { $anchor: n } = e.selection, o = e.doc.resolve(n.pos - 2);
  return !(o.index() === 0 || ((r = o.nodeBefore) == null ? void 0 : r.type.name) !== t);
}, Hg = (t, e, r) => {
  if (!r)
    return !1;
  const n = dt(t, e.schema);
  let o = !1;
  return r.descendants((s) => {
    s.type === n && (o = !0);
  }), o;
}, dd = (t, e, r) => {
  if (t.commands.undoInputRule())
    return !0;
  if (t.state.selection.from !== t.state.selection.to)
    return !1;
  if (!ao(t.state, e) && Fg(t.state, e, r)) {
    const { $anchor: a } = t.state.selection, l = t.state.doc.resolve(a.before() - 1), d = [];
    l.node().descendants((f, p) => {
      f.type.name === e && d.push({ node: f, pos: p });
    });
    const c = d.at(-1);
    if (!c)
      return !1;
    const u = t.state.doc.resolve(l.start() + c.pos + 1);
    return t.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, u.end()).joinForward().run();
  }
  if (!ao(t.state, e) || !W9(t.state))
    return !1;
  const n = ls(e, t.state);
  if (!n)
    return !1;
  const s = t.state.doc.resolve(n.$pos.pos - 2).node(n.depth), i = Hg(e, t.state, s);
  return zg(e, t.state) && !i ? t.commands.joinItemBackward() : t.chain().liftListItem(e).run();
}, Bg = (t, e) => {
  const r = Sc(t, e), n = ls(t, e);
  return !n || !r ? !1 : r > n.depth;
}, Vg = (t, e) => {
  const r = Sc(t, e), n = ls(t, e);
  return !n || !r ? !1 : r < n.depth;
}, cd = (t, e) => {
  if (!ao(t.state, e) || !V9(t.state, e))
    return !1;
  const { selection: r } = t.state, { $from: n, $to: o } = r;
  return !r.empty && n.sameParent(o) ? !1 : Bg(e, t.state) ? t.chain().focus(t.state.selection.from + 4).lift(e).joinBackward().run() : Vg(e, t.state) ? t.chain().joinForward().joinBackward().run() : t.commands.joinItemForward();
}, Pk = (t, e) => {
  var r;
  const { $anchor: n } = e.selection, o = e.doc.resolve(n.pos - n.parentOffset - 2);
  return !(o.index() === o.parent.childCount - 1 || ((r = o.nodeAfter) == null ? void 0 : r.type.name) !== t);
}, Wg = Le.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: r }) => {
          t.state.schema.nodes[r] !== void 0 && cd(t, r) && (e = !0);
        }), e;
      },
      "Mod-Delete": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: r }) => {
          t.state.schema.nodes[r] !== void 0 && cd(t, r) && (e = !0);
        }), e;
      },
      Backspace: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: r, wrapperNames: n }) => {
          t.state.schema.nodes[r] !== void 0 && dd(t, r, n) && (e = !0);
        }), e;
      },
      "Mod-Backspace": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: r, wrapperNames: n }) => {
          t.state.schema.nodes[r] !== void 0 && dd(t, r, n) && (e = !0);
        }), e;
      }
    };
  }
}), np = /^(\s*)(\d+)\.\s+(.*)$/, Ik = /^\s/;
function Rk(t) {
  const e = [];
  let r = 0, n = 0;
  for (; r < t.length; ) {
    const o = t[r], s = o.match(np);
    if (!s)
      break;
    const [, i, a, l] = s, d = i.length;
    let c = l, u = r + 1;
    const f = [o];
    for (; u < t.length; ) {
      const p = t[u];
      if (p.match(np))
        break;
      if (p.trim() === "")
        f.push(p), c += `
`, u += 1;
      else if (p.match(Ik))
        f.push(p), c += `
${p.slice(d + 2)}`, u += 1;
      else
        break;
    }
    e.push({
      indent: d,
      number: parseInt(a, 10),
      content: c.trim(),
      raw: f.join(`
`)
    }), n = u, r = u;
  }
  return [e, n];
}
function Ug(t, e, r) {
  var n;
  const o = [];
  let s = 0;
  for (; s < t.length; ) {
    const i = t[s];
    if (i.indent === e) {
      const a = i.content.split(`
`), l = ((n = a[0]) == null ? void 0 : n.trim()) || "", d = [];
      l && d.push({
        type: "paragraph",
        raw: l,
        tokens: r.inlineTokens(l)
      });
      const c = a.slice(1).join(`
`).trim();
      if (c) {
        const p = r.blockTokens(c);
        d.push(...p);
      }
      let u = s + 1;
      const f = [];
      for (; u < t.length && t[u].indent > e; )
        f.push(t[u]), u += 1;
      if (f.length > 0) {
        const p = Math.min(...f.map((g) => g.indent)), h = Ug(f, p, r);
        d.push({
          type: "list",
          ordered: !0,
          start: f[0].number,
          items: h,
          raw: f.map((g) => g.raw).join(`
`)
        });
      }
      o.push({
        type: "list_item",
        raw: i.raw,
        tokens: d
      }), s = u;
    } else
      s += 1;
  }
  return o;
}
function Ok(t, e) {
  return t.map((r) => {
    if (r.type !== "list_item")
      return e.parseChildren([r])[0];
    const n = [];
    return r.tokens && r.tokens.length > 0 && r.tokens.forEach((o) => {
      if (o.type === "paragraph" || o.type === "list" || o.type === "blockquote" || o.type === "code")
        n.push(...e.parseChildren([o]));
      else if (o.type === "text" && o.tokens) {
        const s = e.parseChildren([o]);
        n.push({
          type: "paragraph",
          content: s
        });
      } else {
        const s = e.parseChildren([o]);
        s.length > 0 && n.push(...s);
      }
    }), {
      type: "listItem",
      content: n
    };
  });
}
var Lk = "listItem", op = "textStyle", sp = /^(\d+)\.\s$/, Gg = yt.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...r } = t;
    return e === 1 ? ["ol", Re(this.options.HTMLAttributes, r), 0] : ["ol", Re(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (t, e) => {
    if (t.type !== "list" || !t.ordered)
      return [];
    const r = t.start || 1, n = t.items ? Ok(t.items, e) : [];
    return r !== 1 ? {
      type: "orderedList",
      attrs: { start: r },
      content: n
    } : {
      type: "orderedList",
      content: n
    };
  },
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (t) => {
      const e = t.match(/^(\s*)(\d+)\.\s+/), r = e == null ? void 0 : e.index;
      return r !== void 0 ? r : -1;
    },
    tokenize: (t, e, r) => {
      var n;
      const o = t.split(`
`), [s, i] = Rk(o);
      if (s.length === 0)
        return;
      const a = Ug(s, 0, r);
      return a.length === 0 ? void 0 : {
        type: "list",
        ordered: !0,
        start: ((n = s[0]) == null ? void 0 : n.number) || 1,
        items: a,
        raw: o.slice(0, i).join(`
`)
      };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Lk, this.editor.getAttributes(op)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = lo({
      find: sp,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, r) => r.childCount + r.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = lo({
      find: sp,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(op) }),
      joinPredicate: (e, r) => r.childCount + r.attrs.start === +e[1],
      editor: this.editor
    })), [t];
  }
}), jk = /^\s*(\[([( |x])?\])\s$/, Dk = yt.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      Re(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (t, e) => {
    const r = [];
    if (t.tokens && t.tokens.length > 0 ? r.push(e.createNode("paragraph", {}, e.parseInline(t.tokens))) : t.text ? r.push(e.createNode("paragraph", {}, [e.createNode("text", { text: t.text })])) : r.push(e.createNode("paragraph", {}, [])), t.nestedTokens && t.nestedTokens.length > 0) {
      const n = e.parseChildren(t.nestedTokens);
      r.push(...n);
    }
    return e.createNode("taskItem", { checked: t.checked || !1 }, r);
  },
  renderMarkdown: (t, e) => {
    var r;
    const o = `- [${(r = t.attrs) != null && r.checked ? "x" : " "}] `;
    return gc(t, e, o);
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: r, editor: n }) => {
      const o = document.createElement("li"), s = document.createElement("label"), i = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div"), d = (u) => {
        var f, p;
        a.ariaLabel = ((p = (f = this.options.a11y) == null ? void 0 : f.checkboxLabel) == null ? void 0 : p.call(f, u, a.checked)) || `Task item checkbox for ${u.textContent || "empty task item"}`;
      };
      d(t), s.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (u) => u.preventDefault()), a.addEventListener("change", (u) => {
        if (!n.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: f } = u.target;
        n.isEditable && typeof r == "function" && n.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: p }) => {
          const h = r();
          if (typeof h != "number")
            return !1;
          const g = p.doc.nodeAt(h);
          return p.setNodeMarkup(h, void 0, {
            ...g == null ? void 0 : g.attrs,
            checked: f
          }), !0;
        }).run(), !n.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, f) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([u, f]) => {
        o.setAttribute(u, f);
      }), o.dataset.checked = t.attrs.checked, a.checked = t.attrs.checked, s.append(a, i), o.append(s, l), Object.entries(e).forEach(([u, f]) => {
        o.setAttribute(u, f);
      });
      let c = new Set(Object.keys(e));
      return {
        dom: o,
        contentDOM: l,
        update: (u) => {
          if (u.type !== this.type)
            return !1;
          o.dataset.checked = u.attrs.checked, a.checked = u.attrs.checked, d(u);
          const f = n.extensionManager.attributes, p = O9(u, f), h = new Set(Object.keys(p)), g = this.options.HTMLAttributes;
          return c.forEach((b) => {
            h.has(b) || (b in g ? o.setAttribute(b, g[b]) : o.removeAttribute(b));
          }), Object.entries(p).forEach(([b, y]) => {
            y == null ? b in g ? o.setAttribute(b, g[b]) : o.removeAttribute(b) : o.setAttribute(b, y);
          }), c = h, !0;
        }
      };
    };
  },
  addInputRules() {
    return [
      lo({
        find: jk,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), _k = yt.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", Re(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  parseMarkdown: (t, e) => e.createNode("taskList", {}, e.parseChildren(t.items || [])),
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(t) {
      var e;
      const r = (e = t.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : e.index;
      return r !== void 0 ? r : -1;
    },
    tokenize(t, e, r) {
      const n = (s) => {
        const i = ed(
          s,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (a) => ({
              indentLevel: a[1].length,
              mainContent: a[4],
              checked: a[3].toLowerCase() === "x"
            }),
            createToken: (a, l) => ({
              type: "taskItem",
              raw: "",
              mainContent: a.mainContent,
              indentLevel: a.indentLevel,
              checked: a.checked,
              text: a.mainContent,
              tokens: r.inlineTokens(a.mainContent),
              nestedTokens: l
            }),
            // Allow recursive nesting
            customNestedParser: n
          },
          r
        );
        return i ? [
          {
            type: "taskList",
            raw: i.raw,
            items: i.items
          }
        ] : r.blockTokens(s);
      }, o = ed(
        t,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (s) => ({
            indentLevel: s[1].length,
            mainContent: s[4],
            checked: s[3].toLowerCase() === "x"
          }),
          createToken: (s, i) => ({
            type: "taskItem",
            raw: "",
            mainContent: s.mainContent,
            indentLevel: s.indentLevel,
            checked: s.checked,
            text: s.mainContent,
            tokens: r.inlineTokens(s.mainContent),
            nestedTokens: i
          }),
          // Use the recursive parser for nested content
          customNestedParser: n
        },
        r
      );
      if (o)
        return {
          type: "taskList",
          raw: o.raw,
          items: o.items
        };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
Le.create({
  name: "listKit",
  addExtensions() {
    const t = [];
    return this.options.bulletList !== !1 && t.push(Dg.configure(this.options.bulletList)), this.options.listItem !== !1 && t.push(_g.configure(this.options.listItem)), this.options.listKeymap !== !1 && t.push(Wg.configure(this.options.listKeymap)), this.options.orderedList !== !1 && t.push(Gg.configure(this.options.orderedList)), this.options.taskItem !== !1 && t.push(Dk.configure(this.options.taskItem)), this.options.taskList !== !1 && t.push(_k.configure(this.options.taskList)), t;
  }
});
var Fk = yt.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", Re(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown: (t, e) => {
    const r = t.tokens || [];
    return r.length === 1 && r[0].type === "image" ? e.parseChildren([r[0]]) : e.createNode(
      "paragraph",
      void 0,
      // no attributes for paragraph
      e.parseInline(r)
    );
  },
  renderMarkdown: (t, e) => !t || !Array.isArray(t.content) ? "" : e.renderChildren(t.content),
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), zk = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Hk = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Bk = mr.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", Re(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (t, e) => e.applyMark("strike", e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => `~~${e.renderChildren(t)}~~`,
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      An({
        find: zk,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      tn({
        find: Hk,
        type: this.type
      })
    ];
  }
}), Vk = yt.create({
  name: "text",
  group: "inline",
  parseMarkdown: (t) => ({
    type: "text",
    text: t.text || ""
  }),
  renderMarkdown: (t) => t.text || ""
}), Wk = mr.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", Re(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown(t, e) {
    return e.applyMark(this.name || "underline", e.parseInline(t.tokens || []));
  },
  renderMarkdown(t, e) {
    return `++${e.renderChildren(t)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(t) {
      return t.indexOf("++");
    },
    tokenize(t, e, r) {
      const o = /^(\+\+)([\s\S]+?)(\+\+)/.exec(t);
      if (!o)
        return;
      const s = o[2].trim();
      return {
        type: "underline",
        raw: o[0],
        text: s,
        tokens: r.inlineTokens(s)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
function Uk(t = {}) {
  return new Ze({
    view(e) {
      return new Gk(e, t);
    }
  });
}
class Gk {
  constructor(e, r) {
    var n;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (n = r.width) !== null && n !== void 0 ? n : 1, this.color = r.color === !1 ? void 0 : r.color || "black", this.class = r.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
      let s = (i) => {
        this[o](i);
      };
      return e.dom.addEventListener(o, s), { name: o, handler: s };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: r }) => this.editorView.dom.removeEventListener(e, r));
  }
  update(e, r) {
    this.cursorPos != null && r.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), r = !e.parent.inlineContent, n, o = this.editorView.dom, s = o.getBoundingClientRect(), i = s.width / o.offsetWidth, a = s.height / o.offsetHeight;
    if (r) {
      let u = e.nodeBefore, f = e.nodeAfter;
      if (u || f) {
        let p = this.editorView.nodeDOM(this.cursorPos - (u ? u.nodeSize : 0));
        if (p) {
          let h = p.getBoundingClientRect(), g = u ? h.bottom : h.top;
          u && f && (g = (g + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let b = this.width / 2 * a;
          n = { left: h.left, right: h.right, top: g - b, bottom: g + b };
        }
      }
    }
    if (!n) {
      let u = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * i;
      n = { left: u.left - f, right: u.left + f, top: u.top, bottom: u.bottom };
    }
    let l = this.editorView.dom.offsetParent;
    this.element || (this.element = l.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", r), this.element.classList.toggle("prosemirror-dropcursor-inline", !r);
    let d, c;
    if (!l || l == document.body && getComputedStyle(l).position == "static")
      d = -pageXOffset, c = -pageYOffset;
    else {
      let u = l.getBoundingClientRect(), f = u.width / l.offsetWidth, p = u.height / l.offsetHeight;
      d = u.left - l.scrollLeft * f, c = u.top - l.scrollTop * p;
    }
    this.element.style.left = (n.left - d) / i + "px", this.element.style.top = (n.top - c) / a + "px", this.element.style.width = (n.right - n.left) / i + "px", this.element.style.height = (n.bottom - n.top) / a + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let r = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), n = r && r.inside >= 0 && this.editorView.state.doc.nodeAt(r.inside), o = n && n.type.spec.disableDropCursor, s = typeof o == "function" ? o(this.editorView, r, e) : o;
    if (r && !s) {
      let i = r.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = b0(this.editorView.state.doc, i, this.editorView.dragging.slice);
        a != null && (i = a);
      }
      this.setCursor(i), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class qe extends be {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, r) {
    let n = e.resolve(r.map(this.head));
    return qe.valid(n) ? new qe(n) : be.near(n);
  }
  content() {
    return X.empty;
  }
  eq(e) {
    return e instanceof qe && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new qe(e.resolve(r.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Nc(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let r = e.parent;
    if (r.isTextblock || !Kk(e) || !Yk(e))
      return !1;
    let n = r.type.spec.allowGapCursor;
    if (n != null)
      return n;
    let o = r.contentMatchAt(e.index()).defaultType;
    return o && o.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, r, n = !1) {
    e: for (; ; ) {
      if (!n && qe.valid(e))
        return e;
      let o = e.pos, s = null;
      for (let i = e.depth; ; i--) {
        let a = e.node(i);
        if (r > 0 ? e.indexAfter(i) < a.childCount : e.index(i) > 0) {
          s = a.child(r > 0 ? e.indexAfter(i) : e.index(i) - 1);
          break;
        } else if (i == 0)
          return null;
        o += r;
        let l = e.doc.resolve(o);
        if (qe.valid(l))
          return l;
      }
      for (; ; ) {
        let i = r > 0 ? s.firstChild : s.lastChild;
        if (!i) {
          if (s.isAtom && !s.isText && !ue.isSelectable(s)) {
            e = e.doc.resolve(o + s.nodeSize * r), n = !1;
            continue e;
          }
          break;
        }
        s = i, o += r;
        let a = e.doc.resolve(o);
        if (qe.valid(a))
          return a;
      }
      return null;
    }
  }
}
qe.prototype.visible = !1;
qe.findFrom = qe.findGapCursorFrom;
be.jsonID("gapcursor", qe);
class Nc {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Nc(e.map(this.pos));
  }
  resolve(e) {
    let r = e.resolve(this.pos);
    return qe.valid(r) ? new qe(r) : be.near(r);
  }
}
function Kg(t) {
  return t.isAtom || t.spec.isolating || t.spec.createGapCursor;
}
function Kk(t) {
  for (let e = t.depth; e >= 0; e--) {
    let r = t.index(e), n = t.node(e);
    if (r == 0) {
      if (n.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = n.child(r - 1); ; o = o.lastChild) {
      if (o.childCount == 0 && !o.inlineContent || Kg(o.type))
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Yk(t) {
  for (let e = t.depth; e >= 0; e--) {
    let r = t.indexAfter(e), n = t.node(e);
    if (r == n.childCount) {
      if (n.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = n.child(r); ; o = o.firstChild) {
      if (o.childCount == 0 && !o.inlineContent || Kg(o.type))
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Jk() {
  return new Ze({
    props: {
      decorations: Qk,
      createSelectionBetween(t, e, r) {
        return e.pos == r.pos && qe.valid(r) ? new qe(r) : null;
      },
      handleClick: Xk,
      handleKeyDown: qk,
      handleDOMEvents: { beforeinput: Zk }
    }
  });
}
const qk = dg({
  ArrowLeft: Is("horiz", -1),
  ArrowRight: Is("horiz", 1),
  ArrowUp: Is("vert", -1),
  ArrowDown: Is("vert", 1)
});
function Is(t, e) {
  const r = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(n, o, s) {
    let i = n.selection, a = e > 0 ? i.$to : i.$from, l = i.empty;
    if (i instanceof fe) {
      if (!s.endOfTextblock(r) || a.depth == 0)
        return !1;
      l = !1, a = n.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let d = qe.findGapCursorFrom(a, e, l);
    return d ? (o && o(n.tr.setSelection(new qe(d))), !0) : !1;
  };
}
function Xk(t, e, r) {
  if (!t || !t.editable)
    return !1;
  let n = t.state.doc.resolve(e);
  if (!qe.valid(n))
    return !1;
  let o = t.posAtCoords({ left: r.clientX, top: r.clientY });
  return o && o.inside > -1 && ue.isSelectable(t.state.doc.nodeAt(o.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new qe(n))), !0);
}
function Zk(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof qe))
    return !1;
  let { $from: r } = t.state.selection, n = r.parent.contentMatchAt(r.index()).findWrapping(t.state.schema.nodes.text);
  if (!n)
    return !1;
  let o = U.empty;
  for (let i = n.length - 1; i >= 0; i--)
    o = U.from(n[i].createAndFill(null, o));
  let s = t.state.tr.replace(r.pos, r.pos, new X(o, 0, 0));
  return s.setSelection(fe.near(s.doc.resolve(r.pos + 1))), t.dispatch(s), !1;
}
function Qk(t) {
  if (!(t.selection instanceof qe))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Ue.create(t.doc, [Et.widget(t.selection.head, e, { key: "gapcursor" })]);
}
var Ki = 200, bt = function() {
};
bt.prototype.append = function(e) {
  return e.length ? (e = bt.from(e), !this.length && e || e.length < Ki && this.leafAppend(e) || this.length < Ki && e.leafPrepend(this) || this.appendInner(e)) : this;
};
bt.prototype.prepend = function(e) {
  return e.length ? bt.from(e).append(this) : this;
};
bt.prototype.appendInner = function(e) {
  return new e8(this, e);
};
bt.prototype.slice = function(e, r) {
  return e === void 0 && (e = 0), r === void 0 && (r = this.length), e >= r ? bt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, r));
};
bt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
bt.prototype.forEach = function(e, r, n) {
  r === void 0 && (r = 0), n === void 0 && (n = this.length), r <= n ? this.forEachInner(e, r, n, 0) : this.forEachInvertedInner(e, r, n, 0);
};
bt.prototype.map = function(e, r, n) {
  r === void 0 && (r = 0), n === void 0 && (n = this.length);
  var o = [];
  return this.forEach(function(s, i) {
    return o.push(e(s, i));
  }, r, n), o;
};
bt.from = function(e) {
  return e instanceof bt ? e : e && e.length ? new Yg(e) : bt.empty;
};
var Yg = /* @__PURE__ */ function(t) {
  function e(n) {
    t.call(this), this.values = n;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var r = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(o, s) {
    return o == 0 && s == this.length ? this : new e(this.values.slice(o, s));
  }, e.prototype.getInner = function(o) {
    return this.values[o];
  }, e.prototype.forEachInner = function(o, s, i, a) {
    for (var l = s; l < i; l++)
      if (o(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(o, s, i, a) {
    for (var l = s - 1; l >= i; l--)
      if (o(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(o) {
    if (this.length + o.length <= Ki)
      return new e(this.values.concat(o.flatten()));
  }, e.prototype.leafPrepend = function(o) {
    if (this.length + o.length <= Ki)
      return new e(o.flatten().concat(this.values));
  }, r.length.get = function() {
    return this.values.length;
  }, r.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, r), e;
}(bt);
bt.empty = new Yg([]);
var e8 = /* @__PURE__ */ function(t) {
  function e(r, n) {
    t.call(this), this.left = r, this.right = n, this.length = r.length + n.length, this.depth = Math.max(r.depth, n.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(n) {
    return n < this.left.length ? this.left.get(n) : this.right.get(n - this.left.length);
  }, e.prototype.forEachInner = function(n, o, s, i) {
    var a = this.left.length;
    if (o < a && this.left.forEachInner(n, o, Math.min(s, a), i) === !1 || s > a && this.right.forEachInner(n, Math.max(o - a, 0), Math.min(this.length, s) - a, i + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(n, o, s, i) {
    var a = this.left.length;
    if (o > a && this.right.forEachInvertedInner(n, o - a, Math.max(s, a) - a, i + a) === !1 || s < a && this.left.forEachInvertedInner(n, Math.min(o, a), s, i) === !1)
      return !1;
  }, e.prototype.sliceInner = function(n, o) {
    if (n == 0 && o == this.length)
      return this;
    var s = this.left.length;
    return o <= s ? this.left.slice(n, o) : n >= s ? this.right.slice(n - s, o - s) : this.left.slice(n, s).append(this.right.slice(0, o - s));
  }, e.prototype.leafAppend = function(n) {
    var o = this.right.leafAppend(n);
    if (o)
      return new e(this.left, o);
  }, e.prototype.leafPrepend = function(n) {
    var o = this.left.leafPrepend(n);
    if (o)
      return new e(o, this.right);
  }, e.prototype.appendInner = function(n) {
    return this.left.depth >= Math.max(this.right.depth, n.depth) + 1 ? new e(this.left, new e(this.right, n)) : new e(this, n);
  }, e;
}(bt);
const t8 = 500;
class er {
  constructor(e, r) {
    this.items = e, this.eventCount = r;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, r) {
    if (this.eventCount == 0)
      return null;
    let n = this.items.length;
    for (; ; n--)
      if (this.items.get(n - 1).selection) {
        --n;
        break;
      }
    let o, s;
    r && (o = this.remapping(n, this.items.length), s = o.maps.length);
    let i = e.tr, a, l, d = [], c = [];
    return this.items.forEach((u, f) => {
      if (!u.step) {
        o || (o = this.remapping(n, f + 1), s = o.maps.length), s--, c.push(u);
        return;
      }
      if (o) {
        c.push(new cr(u.map));
        let p = u.step.map(o.slice(s)), h;
        p && i.maybeStep(p).doc && (h = i.mapping.maps[i.mapping.maps.length - 1], d.push(new cr(h, void 0, void 0, d.length + c.length))), s--, h && o.appendMap(h, s);
      } else
        i.maybeStep(u.step);
      if (u.selection)
        return a = o ? u.selection.map(o.slice(s)) : u.selection, l = new er(this.items.slice(0, n).append(c.reverse().concat(d)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: i, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, r, n, o) {
    let s = [], i = this.eventCount, a = this.items, l = !o && a.length ? a.get(a.length - 1) : null;
    for (let c = 0; c < e.steps.length; c++) {
      let u = e.steps[c].invert(e.docs[c]), f = new cr(e.mapping.maps[c], u, r), p;
      (p = l && l.merge(f)) && (f = p, c ? s.pop() : a = a.slice(0, a.length - 1)), s.push(f), r && (i++, r = void 0), o || (l = f);
    }
    let d = i - n.depth;
    return d > n8 && (a = r8(a, d), i -= d), new er(a.append(s), i);
  }
  remapping(e, r) {
    let n = new Xo();
    return this.items.forEach((o, s) => {
      let i = o.mirrorOffset != null && s - o.mirrorOffset >= e ? n.maps.length - o.mirrorOffset : void 0;
      n.appendMap(o.map, i);
    }, e, r), n;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new er(this.items.append(e.map((r) => new cr(r))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, r) {
    if (!this.eventCount)
      return this;
    let n = [], o = Math.max(0, this.items.length - r), s = e.mapping, i = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, o);
    let l = r;
    this.items.forEach((f) => {
      let p = s.getMirror(--l);
      if (p == null)
        return;
      i = Math.min(i, p);
      let h = s.maps[p];
      if (f.step) {
        let g = e.steps[p].invert(e.docs[p]), b = f.selection && f.selection.map(s.slice(l + 1, p));
        b && a++, n.push(new cr(h, g, b));
      } else
        n.push(new cr(h));
    }, o);
    let d = [];
    for (let f = r; f < i; f++)
      d.push(new cr(s.maps[f]));
    let c = this.items.slice(0, o).append(d).append(n), u = new er(c, a);
    return u.emptyItemCount() > t8 && (u = u.compress(this.items.length - n.length)), u;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((r) => {
      r.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let r = this.remapping(0, e), n = r.maps.length, o = [], s = 0;
    return this.items.forEach((i, a) => {
      if (a >= e)
        o.push(i), i.selection && s++;
      else if (i.step) {
        let l = i.step.map(r.slice(n)), d = l && l.getMap();
        if (n--, d && r.appendMap(d, n), l) {
          let c = i.selection && i.selection.map(r.slice(n));
          c && s++;
          let u = new cr(d.invert(), l, c), f, p = o.length - 1;
          (f = o.length && o[p].merge(u)) ? o[p] = f : o.push(u);
        }
      } else i.map && n--;
    }, this.items.length, 0), new er(bt.from(o.reverse()), s);
  }
}
er.empty = new er(bt.empty, 0);
function r8(t, e) {
  let r;
  return t.forEach((n, o) => {
    if (n.selection && e-- == 0)
      return r = o, !1;
  }), t.slice(r);
}
class cr {
  constructor(e, r, n, o) {
    this.map = e, this.step = r, this.selection = n, this.mirrorOffset = o;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let r = e.step.merge(this.step);
      if (r)
        return new cr(r.getMap().invert(), r, this.selection);
    }
  }
}
class Wr {
  constructor(e, r, n, o, s) {
    this.done = e, this.undone = r, this.prevRanges = n, this.prevTime = o, this.prevComposition = s;
  }
}
const n8 = 20;
function o8(t, e, r, n) {
  let o = r.getMeta(En), s;
  if (o)
    return o.historyState;
  r.getMeta(a8) && (t = new Wr(t.done, t.undone, null, 0, -1));
  let i = r.getMeta("appendedTransaction");
  if (r.steps.length == 0)
    return t;
  if (i && i.getMeta(En))
    return i.getMeta(En).redo ? new Wr(t.done.addTransform(r, void 0, n, Vs(e)), t.undone, ip(r.mapping.maps), t.prevTime, t.prevComposition) : new Wr(t.done, t.undone.addTransform(r, void 0, n, Vs(e)), null, t.prevTime, t.prevComposition);
  if (r.getMeta("addToHistory") !== !1 && !(i && i.getMeta("addToHistory") === !1)) {
    let a = r.getMeta("composition"), l = t.prevTime == 0 || !i && t.prevComposition != a && (t.prevTime < (r.time || 0) - n.newGroupDelay || !s8(r, t.prevRanges)), d = i ? sl(t.prevRanges, r.mapping) : ip(r.mapping.maps);
    return new Wr(t.done.addTransform(r, l ? e.selection.getBookmark() : void 0, n, Vs(e)), er.empty, d, r.time, a ?? t.prevComposition);
  } else return (s = r.getMeta("rebased")) ? new Wr(t.done.rebased(r, s), t.undone.rebased(r, s), sl(t.prevRanges, r.mapping), t.prevTime, t.prevComposition) : new Wr(t.done.addMaps(r.mapping.maps), t.undone.addMaps(r.mapping.maps), sl(t.prevRanges, r.mapping), t.prevTime, t.prevComposition);
}
function s8(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let r = !1;
  return t.mapping.maps[0].forEach((n, o) => {
    for (let s = 0; s < e.length; s += 2)
      n <= e[s + 1] && o >= e[s] && (r = !0);
  }), r;
}
function ip(t) {
  let e = [];
  for (let r = t.length - 1; r >= 0 && e.length == 0; r--)
    t[r].forEach((n, o, s, i) => e.push(s, i));
  return e;
}
function sl(t, e) {
  if (!t)
    return null;
  let r = [];
  for (let n = 0; n < t.length; n += 2) {
    let o = e.map(t[n], 1), s = e.map(t[n + 1], -1);
    o <= s && r.push(o, s);
  }
  return r;
}
function i8(t, e, r) {
  let n = Vs(e), o = En.get(e).spec.config, s = (r ? t.undone : t.done).popEvent(e, n);
  if (!s)
    return null;
  let i = s.selection.resolve(s.transform.doc), a = (r ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), o, n), l = new Wr(r ? a : s.remaining, r ? s.remaining : a, null, 0, -1);
  return s.transform.setSelection(i).setMeta(En, { redo: r, historyState: l });
}
let il = !1, ap = null;
function Vs(t) {
  let e = t.plugins;
  if (ap != e) {
    il = !1, ap = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].spec.historyPreserveItems) {
        il = !0;
        break;
      }
  }
  return il;
}
const En = new Qe("history"), a8 = new Qe("closeHistory");
function l8(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Ze({
    key: En,
    state: {
      init() {
        return new Wr(er.empty, er.empty, null, 0, -1);
      },
      apply(e, r, n) {
        return o8(r, n, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, r) {
          let n = r.inputType, o = n == "historyUndo" ? qg : n == "historyRedo" ? Xg : null;
          return !o || !e.editable ? !1 : (r.preventDefault(), o(e.state, e.dispatch));
        }
      }
    }
  });
}
function Jg(t, e) {
  return (r, n) => {
    let o = En.getState(r);
    if (!o || (t ? o.undone : o.done).eventCount == 0)
      return !1;
    if (n) {
      let s = i8(o, r, t);
      s && n(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const qg = Jg(!1, !0), Xg = Jg(!0, !0);
Le.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
      if (((t == null ? void 0 : t.mode) || this.options.mode) === "textSize") {
        const n = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(n);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc, r = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(r);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new Ze({
        key: new Qe("characterCount"),
        appendTransaction: (e, r, n) => {
          if (t)
            return;
          const o = this.options.limit;
          if (o == null || o === 0) {
            t = !0;
            return;
          }
          const s = this.storage.characters({ node: n.doc });
          if (s > o) {
            const i = s - o, a = 0, l = i;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${o} characters. Content was automatically trimmed.`
            );
            const d = n.tr.deleteRange(a, l);
            return t = !0, d;
          }
          t = !0;
        },
        filterTransaction: (e, r) => {
          const n = this.options.limit;
          if (!e.docChanged || n === 0 || n === null || n === void 0)
            return !0;
          const o = this.storage.characters({ node: r.doc }), s = this.storage.characters({ node: e.doc });
          if (s <= n || o > n && s > n && s <= o)
            return !0;
          if (o > n && s > n && s > o || !e.getMeta("paste"))
            return !1;
          const a = e.selection.$head.pos, l = s - n, d = a - l, c = a;
          return e.deleteRange(d, c), !(this.storage.characters({ node: e.doc }) > n);
        }
      })
    ];
  }
});
var d8 = Le.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [Uk(this.options)];
  }
});
Le.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: r, isFocused: n } = this.editor, { anchor: o } = e, s = [];
            if (!r || !n)
              return Ue.create(t, []);
            let i = 0;
            this.options.mode === "deepest" && t.descendants((l, d) => {
              if (l.isText)
                return;
              if (!(o >= d && o <= d + l.nodeSize - 1))
                return !1;
              i += 1;
            });
            let a = 0;
            return t.descendants((l, d) => {
              if (l.isText || !(o >= d && o <= d + l.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && i - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              s.push(
                Et.node(d, d + l.nodeSize, {
                  class: this.options.className
                })
              );
            }), Ue.create(t, s);
          }
        }
      })
    ];
  }
});
var c8 = Le.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [Jk()];
  },
  extendNodeSchema(t) {
    var e;
    const r = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = hr(Tn(t, "allowGapCursor", r))) != null ? e : null
    };
  }
});
Le.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ze({
        key: new Qe("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: n } = e, o = [];
            if (!r)
              return null;
            const s = this.editor.isEmpty;
            return t.descendants((i, a) => {
              const l = n >= a && n <= a + i.nodeSize, d = !i.isLeaf && fc(i);
              if ((l || !this.options.showOnlyCurrent) && d) {
                const c = [this.options.emptyNodeClass];
                s && c.push(this.options.emptyEditorClass);
                const u = Et.node(a, a + i.nodeSize, {
                  class: c.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: i,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                o.push(u);
              }
              return this.options.includeChildren;
            }), Ue.create(t, o);
          }
        }
      })
    ];
  }
});
Le.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: t, options: e } = this;
    return [
      new Ze({
        key: new Qe("selection"),
        props: {
          decorations(r) {
            return r.selection.empty || t.isFocused || !t.isEditable || xg(r.selection) || t.view.dragging ? null : Ue.create(r.doc, [
              Et.inline(r.selection.from, r.selection.to, {
                class: e.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function lp({ types: t, node: e }) {
  return e && Array.isArray(t) && t.includes(e.type) || (e == null ? void 0 : e.type) === t;
}
var u8 = Le.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var t;
    const e = new Qe(this.name), r = this.options.node || ((t = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : t.name) || "paragraph", n = Object.entries(this.editor.schema.nodes).map(([, o]) => o).filter((o) => (this.options.notAfter || []).concat(r).includes(o.name));
    return [
      new Ze({
        key: e,
        appendTransaction: (o, s, i) => {
          const { doc: a, tr: l, schema: d } = i, c = e.getState(i), u = a.content.size, f = d.nodes[r];
          if (c)
            return l.insert(u, f.create());
        },
        state: {
          init: (o, s) => {
            const i = s.tr.doc.lastChild;
            return !lp({ node: i, types: n });
          },
          apply: (o, s) => {
            if (!o.docChanged || o.getMeta("__uniqueIDTransaction"))
              return s;
            const i = o.doc.lastChild;
            return !lp({ node: i, types: n });
          }
        }
      })
    ];
  }
}), f8 = Le.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => qg(t, e),
      redo: () => ({ state: t, dispatch: e }) => Xg(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [l8(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
});
Le.create({
  name: "starterKit",
  addExtensions() {
    var t, e, r, n;
    const o = [];
    return this.options.bold !== !1 && o.push(z6.configure(this.options.bold)), this.options.blockquote !== !1 && o.push(L6.configure(this.options.blockquote)), this.options.bulletList !== !1 && o.push(Dg.configure(this.options.bulletList)), this.options.code !== !1 && o.push(V6.configure(this.options.code)), this.options.codeBlock !== !1 && o.push(G6.configure(this.options.codeBlock)), this.options.document !== !1 && o.push(K6.configure(this.options.document)), this.options.dropcursor !== !1 && o.push(d8.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && o.push(c8.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && o.push(Y6.configure(this.options.hardBreak)), this.options.heading !== !1 && o.push(J6.configure(this.options.heading)), this.options.undoRedo !== !1 && o.push(f8.configure(this.options.undoRedo)), this.options.horizontalRule !== !1 && o.push(q6.configure(this.options.horizontalRule)), this.options.italic !== !1 && o.push(tk.configure(this.options.italic)), this.options.listItem !== !1 && o.push(_g.configure(this.options.listItem)), this.options.listKeymap !== !1 && o.push(Wg.configure((t = this.options) == null ? void 0 : t.listKeymap)), this.options.link !== !1 && o.push(Sk.configure((e = this.options) == null ? void 0 : e.link)), this.options.orderedList !== !1 && o.push(Gg.configure(this.options.orderedList)), this.options.paragraph !== !1 && o.push(Fk.configure(this.options.paragraph)), this.options.strike !== !1 && o.push(Bk.configure(this.options.strike)), this.options.text !== !1 && o.push(Vk.configure(this.options.text)), this.options.underline !== !1 && o.push(Wk.configure((r = this.options) == null ? void 0 : r.underline)), this.options.trailingNode !== !1 && o.push(u8.configure((n = this.options) == null ? void 0 : n.trailingNode)), o;
  }
});
var p8 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
yt.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {},
      resize: !1
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", Re(this.options.HTMLAttributes, t)];
  },
  parseMarkdown: (t, e) => e.createNode("image", {
    src: t.href,
    title: t.title,
    alt: t.text
  }),
  renderMarkdown: (t) => {
    var e, r, n, o, s, i;
    const a = (r = (e = t.attrs) == null ? void 0 : e.src) != null ? r : "", l = (o = (n = t.attrs) == null ? void 0 : n.alt) != null ? o : "", d = (i = (s = t.attrs) == null ? void 0 : s.title) != null ? i : "";
    return d ? `![${l}](${a} "${d}")` : `![${l}](${a})`;
  },
  addNodeView() {
    if (!this.options.resize || !this.options.resize.enabled || typeof document > "u")
      return null;
    const { directions: t, minWidth: e, minHeight: r, alwaysPreserveAspectRatio: n } = this.options.resize;
    return ({ node: o, getPos: s, HTMLAttributes: i, editor: a }) => {
      const l = document.createElement("img");
      Object.entries(i).forEach(([u, f]) => {
        if (f != null)
          switch (u) {
            case "width":
            case "height":
              break;
            default:
              l.setAttribute(u, f);
              break;
          }
      }), l.src = i.src;
      const d = new S6({
        element: l,
        editor: a,
        node: o,
        getPos: s,
        onResize: (u, f) => {
          l.style.width = `${u}px`, l.style.height = `${f}px`;
        },
        onCommit: (u, f) => {
          const p = s();
          p !== void 0 && this.editor.chain().setNodeSelection(p).updateAttributes(this.name, {
            width: u,
            height: f
          }).run();
        },
        onUpdate: (u, f, p) => u.type === o.type,
        options: {
          directions: t,
          min: {
            width: e,
            height: r
          },
          preserveAspectRatio: n === !0
        }
      }), c = d.dom;
      return c.style.visibility = "hidden", c.style.pointerEvents = "none", l.onload = () => {
        c.style.visibility = "", c.style.pointerEvents = "";
      }, d;
    };
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      Sg({
        find: p8,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, r, n] = t;
          return { src: r, alt: e, title: n };
        }
      })
    ];
  }
});
Le.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((r) => e.updateAttributes(r, { textAlign: t })).some((r) => r) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).some((e) => e),
      toggleTextAlign: (t) => ({ editor: e, commands: r }) => this.options.alignments.includes(t) ? e.isActive({ textAlign: t }) ? r.unsetTextAlign() : r.setTextAlign(t) : !1
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
var h8 = 20, Zg = (t, e = 0) => {
  const r = [];
  return !t.children.length || e > h8 || Array.from(t.children).forEach((n) => {
    n.tagName === "SPAN" ? r.push(n) : n.children.length && r.push(...Zg(n, e + 1));
  }), r;
}, m8 = (t) => {
  if (!t.children.length)
    return;
  const e = Zg(t);
  e && e.forEach((r) => {
    var n, o;
    const s = r.getAttribute("style"), i = (o = (n = r.parentElement) == null ? void 0 : n.closest("span")) == null ? void 0 : o.getAttribute("style");
    r.setAttribute("style", `${i};${s}`);
  });
}, g8 = mr.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !0
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        consuming: !1,
        getAttrs: (t) => t.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && m8(t), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", Re(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleTextStyle: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      removeEmptyTextStyle: () => ({ tr: t }) => {
        const { selection: e } = t;
        return t.doc.nodesBetween(e.from, e.to, (r, n) => {
          if (r.isTextblock)
            return !0;
          r.marks.filter((o) => o.type === this.type).some((o) => Object.values(o.attrs).some((s) => !!s)) || t.removeMark(n, n + r.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), b8 = Le.create({
  name: "backgroundColor",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            default: null,
            parseHTML: (t) => {
              var e;
              const r = t.getAttribute("style");
              if (r) {
                const n = r.split(";").map((o) => o.trim()).filter(Boolean);
                for (let o = n.length - 1; o >= 0; o -= 1) {
                  const s = n[o].split(":");
                  if (s.length >= 2) {
                    const i = s[0].trim().toLowerCase(), a = s.slice(1).join(":").trim();
                    if (i === "background-color")
                      return a.replace(/['"]+/g, "");
                  }
                }
              }
              return (e = t.style.backgroundColor) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.backgroundColor ? {
              style: `background-color: ${t.backgroundColor}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setBackgroundColor: (t) => ({ chain: e }) => e().setMark("textStyle", { backgroundColor: t }).run(),
      unsetBackgroundColor: () => ({ chain: t }) => t().setMark("textStyle", { backgroundColor: null }).removeEmptyTextStyle().run()
    };
  }
}), y8 = Le.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              const r = t.getAttribute("style");
              if (r) {
                const n = r.split(";").map((o) => o.trim()).filter(Boolean);
                for (let o = n.length - 1; o >= 0; o -= 1) {
                  const s = n[o].split(":");
                  if (s.length >= 2) {
                    const i = s[0].trim().toLowerCase(), a = s.slice(1).join(":").trim();
                    if (i === "color")
                      return a.replace(/['"]+/g, "");
                  }
                }
              }
              return (e = t.style.color) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), v8 = Le.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily,
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
}), $8 = Le.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize,
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
}), x8 = Le.create({
  name: "lineHeight",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (t) => t.style.lineHeight,
            renderHTML: (t) => t.lineHeight ? {
              style: `line-height: ${t.lineHeight}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (t) => ({ chain: e }) => e().setMark("textStyle", { lineHeight: t }).run(),
      unsetLineHeight: () => ({ chain: t }) => t().setMark("textStyle", { lineHeight: null }).removeEmptyTextStyle().run()
    };
  }
});
Le.create({
  name: "textStyleKit",
  addExtensions() {
    const t = [];
    return this.options.backgroundColor !== !1 && t.push(b8.configure(this.options.backgroundColor)), this.options.color !== !1 && t.push(y8.configure(this.options.color)), this.options.fontFamily !== !1 && t.push(v8.configure(this.options.fontFamily)), this.options.fontSize !== !1 && t.push($8.configure(this.options.fontSize)), this.options.lineHeight !== !1 && t.push(x8.configure(this.options.lineHeight)), this.options.textStyle !== !1 && t.push(g8.configure(this.options.textStyle)), t;
  }
});
let ud, fd;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  ud = (e) => t.get(e), fd = (e, r) => (t.set(e, r), r);
} else {
  const t = [];
  let r = 0;
  ud = (n) => {
    for (let o = 0; o < t.length; o += 2) if (t[o] == n) return t[o + 1];
  }, fd = (n, o) => (r == 10 && (r = 0), t[r++] = n, t[r++] = o);
}
var Xe = class {
  constructor(t, e, r, n) {
    this.width = t, this.height = e, this.map = r, this.problems = n;
  }
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const r = this.map[e];
      if (r != t) continue;
      const n = e % this.width, o = e / this.width | 0;
      let s = n + 1, i = o + 1;
      for (let a = 1; s < this.width && this.map[e + a] == r; a++) s++;
      for (let a = 1; i < this.height && this.map[e + this.width * a] == r; a++) i++;
      return {
        left: n,
        top: o,
        right: s,
        bottom: i
      };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  colCount(t) {
    for (let e = 0; e < this.map.length; e++) if (this.map[e] == t) return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  nextCell(t, e, r) {
    const { left: n, right: o, top: s, bottom: i } = this.findCell(t);
    return e == "horiz" ? (r < 0 ? n == 0 : o == this.width) ? null : this.map[s * this.width + (r < 0 ? n - 1 : o)] : (r < 0 ? s == 0 : i == this.height) ? null : this.map[n + this.width * (r < 0 ? s - 1 : i)];
  }
  rectBetween(t, e) {
    const { left: r, right: n, top: o, bottom: s } = this.findCell(t), { left: i, right: a, top: l, bottom: d } = this.findCell(e);
    return {
      left: Math.min(r, i),
      top: Math.min(o, l),
      right: Math.max(n, a),
      bottom: Math.max(s, d)
    };
  }
  cellsInRect(t) {
    const e = [], r = {};
    for (let n = t.top; n < t.bottom; n++) for (let o = t.left; o < t.right; o++) {
      const s = n * this.width + o, i = this.map[s];
      r[i] || (r[i] = !0, !(o == t.left && o && this.map[s - 1] == i || n == t.top && n && this.map[s - this.width] == i) && e.push(i));
    }
    return e;
  }
  positionAt(t, e, r) {
    for (let n = 0, o = 0; ; n++) {
      const s = o + r.child(n).nodeSize;
      if (n == t) {
        let i = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; i < a && this.map[i] < o; ) i++;
        return i == a ? s - 1 : this.map[i];
      }
      o = s;
    }
  }
  static get(t) {
    return ud(t) || fd(t, w8(t));
  }
};
function w8(t) {
  if (t.type.spec.tableRole != "table") throw new RangeError("Not a table node: " + t.type.name);
  const e = k8(t), r = t.childCount, n = [];
  let o = 0, s = null;
  const i = [];
  for (let d = 0, c = e * r; d < c; d++) n[d] = 0;
  for (let d = 0, c = 0; d < r; d++) {
    const u = t.child(d);
    c++;
    for (let h = 0; ; h++) {
      for (; o < n.length && n[o] != 0; ) o++;
      if (h == u.childCount) break;
      const g = u.child(h), { colspan: b, rowspan: y, colwidth: $ } = g.attrs;
      for (let k = 0; k < y; k++) {
        if (k + d >= r) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: c,
            n: y - k
          });
          break;
        }
        const w = o + k * e;
        for (let C = 0; C < b; C++) {
          n[w + C] == 0 ? n[w + C] = c : (s || (s = [])).push({
            type: "collision",
            row: d,
            pos: c,
            n: b - C
          });
          const T = $ && $[C];
          if (T) {
            const H = (w + C) % e * 2, O = i[H];
            O == null || O != T && i[H + 1] == 1 ? (i[H] = T, i[H + 1] = 1) : O == T && i[H + 1]++;
          }
        }
      }
      o += b, c += g.nodeSize;
    }
    const f = (d + 1) * e;
    let p = 0;
    for (; o < f; ) n[o++] == 0 && p++;
    p && (s || (s = [])).push({
      type: "missing",
      row: d,
      n: p
    }), c++;
  }
  (e === 0 || r === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const a = new Xe(e, r, n, s);
  let l = !1;
  for (let d = 0; !l && d < i.length; d += 2) i[d] != null && i[d + 1] < r && (l = !0);
  return l && E8(a, i, t), a;
}
function k8(t) {
  let e = -1, r = !1;
  for (let n = 0; n < t.childCount; n++) {
    const o = t.child(n);
    let s = 0;
    if (r) for (let i = 0; i < n; i++) {
      const a = t.child(i);
      for (let l = 0; l < a.childCount; l++) {
        const d = a.child(l);
        i + d.attrs.rowspan > n && (s += d.attrs.colspan);
      }
    }
    for (let i = 0; i < o.childCount; i++) {
      const a = o.child(i);
      s += a.attrs.colspan, a.attrs.rowspan > 1 && (r = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function E8(t, e, r) {
  t.problems || (t.problems = []);
  const n = {};
  for (let o = 0; o < t.map.length; o++) {
    const s = t.map[o];
    if (n[s]) continue;
    n[s] = !0;
    const i = r.nodeAt(s);
    if (!i) throw new RangeError(`No cell with offset ${s} found`);
    let a = null;
    const l = i.attrs;
    for (let d = 0; d < l.colspan; d++) {
      const c = e[(o + d) % t.width * 2];
      c != null && (!l.colwidth || l.colwidth[d] != c) && ((a || (a = C8(l)))[d] = c);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: a
    });
  }
}
function C8(t) {
  if (t.colwidth) return t.colwidth.slice();
  const e = [];
  for (let r = 0; r < t.colspan; r++) e.push(0);
  return e;
}
function Ct(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const r in t.nodes) {
      const n = t.nodes[r], o = n.spec.tableRole;
      o && (e[o] = n);
    }
  }
  return e;
}
const Kr = new Qe("selectingCells");
function Mn(t) {
  for (let e = t.depth - 1; e > 0; e--) if (t.node(e).type.spec.tableRole == "row") return t.node(0).resolve(t.before(e + 1));
  return null;
}
function S8(t) {
  for (let e = t.depth; e > 0; e--) {
    const r = t.node(e).type.spec.tableRole;
    if (r === "cell" || r === "header_cell") return t.node(e);
  }
  return null;
}
function or(t) {
  const e = t.selection.$head;
  for (let r = e.depth; r > 0; r--) if (e.node(r).type.spec.tableRole == "row") return !0;
  return !1;
}
function ba(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell) return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell") return e.$anchor;
  const r = Mn(e.$head) || N8(e.$head);
  if (r) return r;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function N8(t) {
  for (let e = t.nodeAfter, r = t.pos; e; e = e.firstChild, r++) {
    const n = e.type.spec.tableRole;
    if (n == "cell" || n == "header_cell") return t.doc.resolve(r);
  }
  for (let e = t.nodeBefore, r = t.pos; e; e = e.lastChild, r--) {
    const n = e.type.spec.tableRole;
    if (n == "cell" || n == "header_cell") return t.doc.resolve(r - e.nodeSize);
  }
}
function pd(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function T8(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Tc(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function Qg(t, e, r) {
  const n = t.node(-1), o = Xe.get(n), s = t.start(-1), i = o.nextCell(t.pos - s, e, r);
  return i == null ? null : t.node(0).resolve(s + i);
}
function Pn(t, e, r = 1) {
  const n = {
    ...t,
    colspan: t.colspan - r
  };
  return n.colwidth && (n.colwidth = n.colwidth.slice(), n.colwidth.splice(e, r), n.colwidth.some((o) => o > 0) || (n.colwidth = null)), n;
}
function e1(t, e, r = 1) {
  const n = {
    ...t,
    colspan: t.colspan + r
  };
  if (n.colwidth) {
    n.colwidth = n.colwidth.slice();
    for (let o = 0; o < r; o++) n.colwidth.splice(e, 0, 0);
  }
  return n;
}
function A8(t, e, r) {
  const n = Ct(e.type.schema).header_cell;
  for (let o = 0; o < t.height; o++) if (e.nodeAt(t.map[r + o * t.width]).type != n) return !1;
  return !0;
}
var He = class Sr extends be {
  constructor(e, r = e) {
    const n = e.node(-1), o = Xe.get(n), s = e.start(-1), i = o.rectBetween(e.pos - s, r.pos - s), a = e.node(0), l = o.cellsInRect(i).filter((c) => c != r.pos - s);
    l.unshift(r.pos - s);
    const d = l.map((c) => {
      const u = n.nodeAt(c);
      if (!u) throw new RangeError(`No cell with offset ${c} found`);
      const f = s + c + 1;
      return new k0(a.resolve(f), a.resolve(f + u.content.size));
    });
    super(d[0].$from, d[0].$to, d), this.$anchorCell = e, this.$headCell = r;
  }
  map(e, r) {
    const n = e.resolve(r.map(this.$anchorCell.pos)), o = e.resolve(r.map(this.$headCell.pos));
    if (pd(n) && pd(o) && Tc(n, o)) {
      const s = this.$anchorCell.node(-1) != n.node(-1);
      return s && this.isRowSelection() ? Sr.rowSelection(n, o) : s && this.isColSelection() ? Sr.colSelection(n, o) : new Sr(n, o);
    }
    return fe.between(n, o);
  }
  content() {
    const e = this.$anchorCell.node(-1), r = Xe.get(e), n = this.$anchorCell.start(-1), o = r.rectBetween(this.$anchorCell.pos - n, this.$headCell.pos - n), s = {}, i = [];
    for (let l = o.top; l < o.bottom; l++) {
      const d = [];
      for (let c = l * r.width + o.left, u = o.left; u < o.right; u++, c++) {
        const f = r.map[c];
        if (s[f]) continue;
        s[f] = !0;
        const p = r.findCell(f);
        let h = e.nodeAt(f);
        if (!h) throw new RangeError(`No cell with offset ${f} found`);
        const g = o.left - p.left, b = p.right - o.right;
        if (g > 0 || b > 0) {
          let y = h.attrs;
          if (g > 0 && (y = Pn(y, 0, g)), b > 0 && (y = Pn(y, y.colspan - b, b)), p.left < o.left) {
            if (h = h.type.createAndFill(y), !h) throw new RangeError(`Could not create cell with attrs ${JSON.stringify(y)}`);
          } else h = h.type.create(y, h.content);
        }
        if (p.top < o.top || p.bottom > o.bottom) {
          const y = {
            ...h.attrs,
            rowspan: Math.min(p.bottom, o.bottom) - Math.max(p.top, o.top)
          };
          p.top < o.top ? h = h.type.createAndFill(y) : h = h.type.create(y, h.content);
        }
        d.push(h);
      }
      i.push(e.child(l).copy(U.from(d)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : i;
    return new X(U.from(a), 1, 1);
  }
  replace(e, r = X.empty) {
    const n = e.steps.length, o = this.ranges;
    for (let i = 0; i < o.length; i++) {
      const { $from: a, $to: l } = o[i], d = e.mapping.slice(n);
      e.replace(d.map(a.pos), d.map(l.pos), i ? X.empty : r);
    }
    const s = be.findFrom(e.doc.resolve(e.mapping.slice(n).map(this.to)), -1);
    s && e.setSelection(s);
  }
  replaceWith(e, r) {
    this.replace(e, new X(U.from(r), 0, 0));
  }
  forEachCell(e) {
    const r = this.$anchorCell.node(-1), n = Xe.get(r), o = this.$anchorCell.start(-1), s = n.cellsInRect(n.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o));
    for (let i = 0; i < s.length; i++) e(r.nodeAt(s[i]), o + s[i]);
  }
  isColSelection() {
    const e = this.$anchorCell.index(-1), r = this.$headCell.index(-1);
    if (Math.min(e, r) > 0) return !1;
    const n = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = r + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(n, o) == this.$headCell.node(-1).childCount;
  }
  static colSelection(e, r = e) {
    const n = e.node(-1), o = Xe.get(n), s = e.start(-1), i = o.findCell(e.pos - s), a = o.findCell(r.pos - s), l = e.node(0);
    return i.top <= a.top ? (i.top > 0 && (e = l.resolve(s + o.map[i.left])), a.bottom < o.height && (r = l.resolve(s + o.map[o.width * (o.height - 1) + a.right - 1]))) : (a.top > 0 && (r = l.resolve(s + o.map[a.left])), i.bottom < o.height && (e = l.resolve(s + o.map[o.width * (o.height - 1) + i.right - 1]))), new Sr(e, r);
  }
  isRowSelection() {
    const e = this.$anchorCell.node(-1), r = Xe.get(e), n = this.$anchorCell.start(-1), o = r.colCount(this.$anchorCell.pos - n), s = r.colCount(this.$headCell.pos - n);
    if (Math.min(o, s) > 0) return !1;
    const i = o + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(i, a) == r.width;
  }
  eq(e) {
    return e instanceof Sr && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  static rowSelection(e, r = e) {
    const n = e.node(-1), o = Xe.get(n), s = e.start(-1), i = o.findCell(e.pos - s), a = o.findCell(r.pos - s), l = e.node(0);
    return i.left <= a.left ? (i.left > 0 && (e = l.resolve(s + o.map[i.top * o.width])), a.right < o.width && (r = l.resolve(s + o.map[o.width * (a.top + 1) - 1]))) : (a.left > 0 && (r = l.resolve(s + o.map[a.top * o.width])), i.right < o.width && (e = l.resolve(s + o.map[o.width * (i.top + 1) - 1]))), new Sr(e, r);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, r) {
    return new Sr(e.resolve(r.anchor), e.resolve(r.head));
  }
  static create(e, r, n = r) {
    return new Sr(e.resolve(r), e.resolve(n));
  }
  getBookmark() {
    return new M8(this.$anchorCell.pos, this.$headCell.pos);
  }
};
He.prototype.visible = !1;
be.jsonID("cell", He);
var M8 = class t1 {
  constructor(e, r) {
    this.anchor = e, this.head = r;
  }
  map(e) {
    return new t1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const r = e.resolve(this.anchor), n = e.resolve(this.head);
    return r.parent.type.spec.tableRole == "row" && n.parent.type.spec.tableRole == "row" && r.index() < r.parent.childCount && n.index() < n.parent.childCount && Tc(r, n) ? new He(r, n) : be.near(n, 1);
  }
};
function P8(t) {
  if (!(t.selection instanceof He)) return null;
  const e = [];
  return t.selection.forEachCell((r, n) => {
    e.push(Et.node(n, n + r.nodeSize, { class: "selectedCell" }));
  }), Ue.create(t.doc, e);
}
function I8({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
  let r = t.pos, n = e.pos, o = t.depth;
  for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, r++) ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, n--) ;
  return r == n && /row|table/.test(t.node(o).type.spec.tableRole);
}
function R8({ $from: t, $to: e }) {
  let r, n;
  for (let o = t.depth; o > 0; o--) {
    const s = t.node(o);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  for (let o = e.depth; o > 0; o--) {
    const s = e.node(o);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      n = s;
      break;
    }
  }
  return r !== n && e.parentOffset === 0;
}
function O8(t, e, r) {
  const n = (e || t).selection, o = (e || t).doc;
  let s, i;
  if (n instanceof ue && (i = n.node.type.spec.tableRole)) {
    if (i == "cell" || i == "header_cell") s = He.create(o, n.from);
    else if (i == "row") {
      const a = o.resolve(n.from + 1);
      s = He.rowSelection(a, a);
    } else if (!r) {
      const a = Xe.get(n.node), l = n.from + 1, d = l + a.map[a.width * a.height - 1];
      s = He.create(o, l + 1, d);
    }
  } else n instanceof fe && I8(n) ? s = fe.create(o, n.from) : n instanceof fe && R8(n) && (s = fe.create(o, n.$from.start(), n.$from.end()));
  return s && (e || (e = t.tr)).setSelection(s), e;
}
const L8 = new Qe("fix-tables");
function r1(t, e, r, n) {
  const o = t.childCount, s = e.childCount;
  e: for (let i = 0, a = 0; i < s; i++) {
    const l = e.child(i);
    for (let d = a, c = Math.min(o, i + 3); d < c; d++) if (t.child(d) == l) {
      a = d + 1, r += l.nodeSize;
      continue e;
    }
    n(l, r), a < o && t.child(a).sameMarkup(l) ? r1(t.child(a), l, r + 1, n) : l.nodesBetween(0, l.content.size, n, r + 1), r += l.nodeSize;
  }
}
function n1(t, e) {
  let r;
  const n = (o, s) => {
    o.type.spec.tableRole == "table" && (r = j8(t, o, s, r));
  };
  return e ? e.doc != t.doc && r1(e.doc, t.doc, 0, n) : t.doc.descendants(n), r;
}
function j8(t, e, r, n) {
  const o = Xe.get(e);
  if (!o.problems) return n;
  n || (n = t.tr);
  const s = [];
  for (let l = 0; l < o.height; l++) s.push(0);
  for (let l = 0; l < o.problems.length; l++) {
    const d = o.problems[l];
    if (d.type == "collision") {
      const c = e.nodeAt(d.pos);
      if (!c) continue;
      const u = c.attrs;
      for (let f = 0; f < u.rowspan; f++) s[d.row + f] += d.n;
      n.setNodeMarkup(n.mapping.map(r + 1 + d.pos), null, Pn(u, u.colspan - d.n, d.n));
    } else if (d.type == "missing") s[d.row] += d.n;
    else if (d.type == "overlong_rowspan") {
      const c = e.nodeAt(d.pos);
      if (!c) continue;
      n.setNodeMarkup(n.mapping.map(r + 1 + d.pos), null, {
        ...c.attrs,
        rowspan: c.attrs.rowspan - d.n
      });
    } else if (d.type == "colwidth mismatch") {
      const c = e.nodeAt(d.pos);
      if (!c) continue;
      n.setNodeMarkup(n.mapping.map(r + 1 + d.pos), null, {
        ...c.attrs,
        colwidth: d.colwidth
      });
    } else if (d.type == "zero_sized") {
      const c = n.mapping.map(r);
      n.delete(c, c + e.nodeSize);
    }
  }
  let i, a;
  for (let l = 0; l < s.length; l++) s[l] && (i == null && (i = l), a = l);
  for (let l = 0, d = r + 1; l < o.height; l++) {
    const c = e.child(l), u = d + c.nodeSize, f = s[l];
    if (f > 0) {
      let p = "cell";
      c.firstChild && (p = c.firstChild.type.spec.tableRole);
      const h = [];
      for (let b = 0; b < f; b++) {
        const y = Ct(t.schema)[p].createAndFill();
        y && h.push(y);
      }
      const g = (l == 0 || i == l - 1) && a == l ? d + 1 : u - 1;
      n.insert(n.mapping.map(g), h);
    }
    d = u;
  }
  return n.setMeta(L8, { fixTables: !0 });
}
function gr(t) {
  const e = t.selection, r = ba(t), n = r.node(-1), o = r.start(-1), s = Xe.get(n);
  return {
    ...e instanceof He ? s.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o) : s.findCell(r.pos - o),
    tableStart: o,
    map: s,
    table: n
  };
}
function o1(t, { map: e, tableStart: r, table: n }, o) {
  let s = o > 0 ? -1 : 0;
  A8(e, n, o + s) && (s = o == 0 || o == e.width ? null : 0);
  for (let i = 0; i < e.height; i++) {
    const a = i * e.width + o;
    if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], d = n.nodeAt(l);
      t.setNodeMarkup(t.mapping.map(r + l), null, e1(d.attrs, o - e.colCount(l))), i += d.attrs.rowspan - 1;
    } else {
      const l = s == null ? Ct(n.type.schema).cell : n.nodeAt(e.map[a + s]).type, d = e.positionAt(i, o, n);
      t.insert(t.mapping.map(r + d), l.createAndFill());
    }
  }
  return t;
}
function D8(t, e) {
  if (!or(t)) return !1;
  if (e) {
    const r = gr(t);
    e(o1(t.tr, r, r.left));
  }
  return !0;
}
function _8(t, e) {
  if (!or(t)) return !1;
  if (e) {
    const r = gr(t);
    e(o1(t.tr, r, r.right));
  }
  return !0;
}
function F8(t, { map: e, table: r, tableStart: n }, o) {
  const s = t.mapping.maps.length;
  for (let i = 0; i < e.height; ) {
    const a = i * e.width + o, l = e.map[a], d = r.nodeAt(l), c = d.attrs;
    if (o > 0 && e.map[a - 1] == l || o < e.width - 1 && e.map[a + 1] == l) t.setNodeMarkup(t.mapping.slice(s).map(n + l), null, Pn(c, o - e.colCount(l)));
    else {
      const u = t.mapping.slice(s).map(n + l);
      t.delete(u, u + d.nodeSize);
    }
    i += c.rowspan;
  }
}
function z8(t, e) {
  if (!or(t)) return !1;
  if (e) {
    const r = gr(t), n = t.tr;
    if (r.left == 0 && r.right == r.map.width) return !1;
    for (let o = r.right - 1; F8(n, r, o), o != r.left; o--) {
      const s = r.tableStart ? n.doc.nodeAt(r.tableStart - 1) : n.doc;
      if (!s) throw new RangeError("No table found");
      r.table = s, r.map = Xe.get(s);
    }
    e(n);
  }
  return !0;
}
function H8(t, e, r) {
  var n;
  const o = Ct(e.type.schema).header_cell;
  for (let s = 0; s < t.width; s++) if (((n = e.nodeAt(t.map[s + r * t.width])) === null || n === void 0 ? void 0 : n.type) != o) return !1;
  return !0;
}
function s1(t, { map: e, tableStart: r, table: n }, o) {
  let s = r;
  for (let d = 0; d < o; d++) s += n.child(d).nodeSize;
  const i = [];
  let a = o > 0 ? -1 : 0;
  H8(e, n, o + a) && (a = o == 0 || o == e.height ? null : 0);
  for (let d = 0, c = e.width * o; d < e.width; d++, c++) if (o > 0 && o < e.height && e.map[c] == e.map[c - e.width]) {
    const u = e.map[c], f = n.nodeAt(u).attrs;
    t.setNodeMarkup(r + u, null, {
      ...f,
      rowspan: f.rowspan + 1
    }), d += f.colspan - 1;
  } else {
    var l;
    const u = a == null ? Ct(n.type.schema).cell : (l = n.nodeAt(e.map[c + a * e.width])) === null || l === void 0 ? void 0 : l.type, f = u == null ? void 0 : u.createAndFill();
    f && i.push(f);
  }
  return t.insert(s, Ct(n.type.schema).row.create(null, i)), t;
}
function B8(t, e) {
  if (!or(t)) return !1;
  if (e) {
    const r = gr(t);
    e(s1(t.tr, r, r.top));
  }
  return !0;
}
function V8(t, e) {
  if (!or(t)) return !1;
  if (e) {
    const r = gr(t);
    e(s1(t.tr, r, r.bottom));
  }
  return !0;
}
function W8(t, { map: e, table: r, tableStart: n }, o) {
  let s = 0;
  for (let d = 0; d < o; d++) s += r.child(d).nodeSize;
  const i = s + r.child(o).nodeSize, a = t.mapping.maps.length;
  t.delete(s + n, i + n);
  const l = /* @__PURE__ */ new Set();
  for (let d = 0, c = o * e.width; d < e.width; d++, c++) {
    const u = e.map[c];
    if (!l.has(u)) {
      if (l.add(u), o > 0 && u == e.map[c - e.width]) {
        const f = r.nodeAt(u).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(u + n), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), d += f.colspan - 1;
      } else if (o < e.height && u == e.map[c + e.width]) {
        const f = r.nodeAt(u), p = f.attrs, h = f.type.create({
          ...p,
          rowspan: f.attrs.rowspan - 1
        }, f.content), g = e.positionAt(o + 1, d, r);
        t.insert(t.mapping.slice(a).map(n + g), h), d += p.colspan - 1;
      }
    }
  }
}
function U8(t, e) {
  if (!or(t)) return !1;
  if (e) {
    const r = gr(t), n = t.tr;
    if (r.top == 0 && r.bottom == r.map.height) return !1;
    for (let o = r.bottom - 1; W8(n, r, o), o != r.top; o--) {
      const s = r.tableStart ? n.doc.nodeAt(r.tableStart - 1) : n.doc;
      if (!s) throw new RangeError("No table found");
      r.table = s, r.map = Xe.get(r.table);
    }
    e(n);
  }
  return !0;
}
function dp(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function G8({ width: t, height: e, map: r }, n) {
  let o = n.top * t + n.left, s = o, i = (n.bottom - 1) * t + n.left, a = o + (n.right - n.left - 1);
  for (let l = n.top; l < n.bottom; l++) {
    if (n.left > 0 && r[s] == r[s - 1] || n.right < t && r[a] == r[a + 1]) return !0;
    s += t, a += t;
  }
  for (let l = n.left; l < n.right; l++) {
    if (n.top > 0 && r[o] == r[o - t] || n.bottom < e && r[i] == r[i + t]) return !0;
    o++, i++;
  }
  return !1;
}
function cp(t, e) {
  const r = t.selection;
  if (!(r instanceof He) || r.$anchorCell.pos == r.$headCell.pos) return !1;
  const n = gr(t), { map: o } = n;
  if (G8(o, n)) return !1;
  if (e) {
    const s = t.tr, i = {};
    let a = U.empty, l, d;
    for (let c = n.top; c < n.bottom; c++) for (let u = n.left; u < n.right; u++) {
      const f = o.map[c * o.width + u], p = n.table.nodeAt(f);
      if (!(i[f] || !p))
        if (i[f] = !0, l == null)
          l = f, d = p;
        else {
          dp(p) || (a = a.append(p.content));
          const h = s.mapping.map(f + n.tableStart);
          s.delete(h, h + p.nodeSize);
        }
    }
    if (l == null || d == null) return !0;
    if (s.setNodeMarkup(l + n.tableStart, null, {
      ...e1(d.attrs, d.attrs.colspan, n.right - n.left - d.attrs.colspan),
      rowspan: n.bottom - n.top
    }), a.size > 0) {
      const c = l + 1 + d.content.size, u = dp(d) ? l + 1 : c;
      s.replaceWith(u + n.tableStart, c + n.tableStart, a);
    }
    s.setSelection(new He(s.doc.resolve(l + n.tableStart))), e(s);
  }
  return !0;
}
function up(t, e) {
  const r = Ct(t.schema);
  return K8(({ node: n }) => r[n.type.spec.tableRole])(t, e);
}
function K8(t) {
  return (e, r) => {
    const n = e.selection;
    let o, s;
    if (n instanceof He) {
      if (n.$anchorCell.pos != n.$headCell.pos) return !1;
      o = n.$anchorCell.nodeAfter, s = n.$anchorCell.pos;
    } else {
      var i;
      if (o = S8(n.$from), !o) return !1;
      s = (i = Mn(n.$from)) === null || i === void 0 ? void 0 : i.pos;
    }
    if (o == null || s == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1) return !1;
    if (r) {
      let a = o.attrs;
      const l = [], d = a.colwidth;
      a.rowspan > 1 && (a = {
        ...a,
        rowspan: 1
      }), a.colspan > 1 && (a = {
        ...a,
        colspan: 1
      });
      const c = gr(e), u = e.tr;
      for (let p = 0; p < c.right - c.left; p++) l.push(d ? {
        ...a,
        colwidth: d && d[p] ? [d[p]] : null
      } : a);
      let f;
      for (let p = c.top; p < c.bottom; p++) {
        let h = c.map.positionAt(p, c.left, c.table);
        p == c.top && (h += o.nodeSize);
        for (let g = c.left, b = 0; g < c.right; g++, b++)
          g == c.left && p == c.top || u.insert(f = u.mapping.map(h + c.tableStart, 1), t({
            node: o,
            row: p,
            col: g
          }).createAndFill(l[b]));
      }
      u.setNodeMarkup(s, t({
        node: o,
        row: c.top,
        col: c.left
      }), l[0]), n instanceof He && u.setSelection(new He(u.doc.resolve(n.$anchorCell.pos), f ? u.doc.resolve(f) : void 0)), r(u);
    }
    return !0;
  };
}
function Y8(t, e) {
  return function(r, n) {
    if (!or(r)) return !1;
    const o = ba(r);
    if (o.nodeAfter.attrs[t] === e) return !1;
    if (n) {
      const s = r.tr;
      r.selection instanceof He ? r.selection.forEachCell((i, a) => {
        i.attrs[t] !== e && s.setNodeMarkup(a, null, {
          ...i.attrs,
          [t]: e
        });
      }) : s.setNodeMarkup(o.pos, null, {
        ...o.nodeAfter.attrs,
        [t]: e
      }), n(s);
    }
    return !0;
  };
}
function J8(t) {
  return function(e, r) {
    if (!or(e)) return !1;
    if (r) {
      const n = Ct(e.schema), o = gr(e), s = e.tr, i = o.map.cellsInRect(t == "column" ? {
        left: o.left,
        top: 0,
        right: o.right,
        bottom: o.map.height
      } : t == "row" ? {
        left: 0,
        top: o.top,
        right: o.map.width,
        bottom: o.bottom
      } : o), a = i.map((l) => o.table.nodeAt(l));
      for (let l = 0; l < i.length; l++) a[l].type == n.header_cell && s.setNodeMarkup(o.tableStart + i[l], n.cell, a[l].attrs);
      if (s.steps.length === 0) for (let l = 0; l < i.length; l++) s.setNodeMarkup(o.tableStart + i[l], n.header_cell, a[l].attrs);
      r(s);
    }
    return !0;
  };
}
function fp(t, e, r) {
  const n = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let o = 0; o < n.length; o++) {
    const s = e.table.nodeAt(n[o]);
    if (s && s.type !== r.header_cell) return !1;
  }
  return !0;
}
function ss(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? J8(t) : function(r, n) {
    if (!or(r)) return !1;
    if (n) {
      const o = Ct(r.schema), s = gr(r), i = r.tr, a = fp("row", s, o), l = fp("column", s, o), d = (t === "column" ? a : t === "row" && l) ? 1 : 0, c = t == "column" ? {
        left: 0,
        top: d,
        right: 1,
        bottom: s.map.height
      } : t == "row" ? {
        left: d,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, u = t == "column" ? l ? o.cell : o.header_cell : t == "row" ? a ? o.cell : o.header_cell : o.cell;
      s.map.cellsInRect(c).forEach((f) => {
        const p = f + s.tableStart, h = i.doc.nodeAt(p);
        h && i.setNodeMarkup(p, u, h.attrs);
      }), n(i);
    }
    return !0;
  };
}
ss("row", { useDeprecatedLogic: !0 });
ss("column", { useDeprecatedLogic: !0 });
const q8 = ss("cell", { useDeprecatedLogic: !0 });
function X8(t, e) {
  if (e < 0) {
    const r = t.nodeBefore;
    if (r) return t.pos - r.nodeSize;
    for (let n = t.index(-1) - 1, o = t.before(); n >= 0; n--) {
      const s = t.node(-1).child(n), i = s.lastChild;
      if (i) return o - 1 - i.nodeSize;
      o -= s.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1) return t.pos + t.nodeAfter.nodeSize;
    const r = t.node(-1);
    for (let n = t.indexAfter(-1), o = t.after(); n < r.childCount; n++) {
      const s = r.child(n);
      if (s.childCount) return o + 1;
      o += s.nodeSize;
    }
  }
  return null;
}
function pp(t) {
  return function(e, r) {
    if (!or(e)) return !1;
    const n = X8(ba(e), t);
    if (n == null) return !1;
    if (r) {
      const o = e.doc.resolve(n);
      r(e.tr.setSelection(fe.between(o, T8(o))).scrollIntoView());
    }
    return !0;
  };
}
function Z8(t, e) {
  const r = t.selection.$anchor;
  for (let n = r.depth; n > 0; n--) if (r.node(n).type.spec.tableRole == "table")
    return e && e(t.tr.delete(r.before(n), r.after(n)).scrollIntoView()), !0;
  return !1;
}
function Rs(t, e) {
  const r = t.selection;
  if (!(r instanceof He)) return !1;
  if (e) {
    const n = t.tr, o = Ct(t.schema).cell.createAndFill().content;
    r.forEachCell((s, i) => {
      s.content.eq(o) || n.replace(n.mapping.map(i + 1), n.mapping.map(i + s.nodeSize - 1), new X(o, 0, 0));
    }), n.docChanged && e(n);
  }
  return !0;
}
function Q8(t) {
  if (t.size === 0) return null;
  let { content: e, openStart: r, openEnd: n } = t;
  for (; e.childCount == 1 && (r > 0 && n > 0 || e.child(0).type.spec.tableRole == "table"); )
    r--, n--, e = e.child(0).content;
  const o = e.child(0), s = o.type.spec.tableRole, i = o.type.schema, a = [];
  if (s == "row") for (let l = 0; l < e.childCount; l++) {
    let d = e.child(l).content;
    const c = l ? 0 : Math.max(0, r - 1), u = l < e.childCount - 1 ? 0 : Math.max(0, n - 1);
    (c || u) && (d = hd(Ct(i).row, new X(d, c, u)).content), a.push(d);
  }
  else if (s == "cell" || s == "header_cell") a.push(r || n ? hd(Ct(i).row, new X(e, r, n)).content : e);
  else return null;
  return e7(i, a);
}
function e7(t, e) {
  const r = [];
  for (let o = 0; o < e.length; o++) {
    const s = e[o];
    for (let i = s.childCount - 1; i >= 0; i--) {
      const { rowspan: a, colspan: l } = s.child(i).attrs;
      for (let d = o; d < o + a; d++) r[d] = (r[d] || 0) + l;
    }
  }
  let n = 0;
  for (let o = 0; o < r.length; o++) n = Math.max(n, r[o]);
  for (let o = 0; o < r.length; o++)
    if (o >= e.length && e.push(U.empty), r[o] < n) {
      const s = Ct(t).cell.createAndFill(), i = [];
      for (let a = r[o]; a < n; a++) i.push(s);
      e[o] = e[o].append(U.from(i));
    }
  return {
    height: e.length,
    width: n,
    rows: e
  };
}
function hd(t, e) {
  const r = t.createAndFill();
  return new w0(r).replace(0, r.content.size, e).doc;
}
function t7({ width: t, height: e, rows: r }, n, o) {
  if (t != n) {
    const s = [], i = [];
    for (let a = 0; a < r.length; a++) {
      const l = r[a], d = [];
      for (let c = s[a] || 0, u = 0; c < n; u++) {
        let f = l.child(u % l.childCount);
        c + f.attrs.colspan > n && (f = f.type.createChecked(Pn(f.attrs, f.attrs.colspan, c + f.attrs.colspan - n), f.content)), d.push(f), c += f.attrs.colspan;
        for (let p = 1; p < f.attrs.rowspan; p++) s[a + p] = (s[a + p] || 0) + f.attrs.colspan;
      }
      i.push(U.from(d));
    }
    r = i, t = n;
  }
  if (e != o) {
    const s = [];
    for (let i = 0, a = 0; i < o; i++, a++) {
      const l = [], d = r[a % e];
      for (let c = 0; c < d.childCount; c++) {
        let u = d.child(c);
        i + u.attrs.rowspan > o && (u = u.type.create({
          ...u.attrs,
          rowspan: Math.max(1, o - u.attrs.rowspan)
        }, u.content)), l.push(u);
      }
      s.push(U.from(l));
    }
    r = s, e = o;
  }
  return {
    width: t,
    height: e,
    rows: r
  };
}
function r7(t, e, r, n, o, s, i) {
  const a = t.doc.type.schema, l = Ct(a);
  let d, c;
  if (o > e.width) for (let u = 0, f = 0; u < e.height; u++) {
    const p = r.child(u);
    f += p.nodeSize;
    const h = [];
    let g;
    p.lastChild == null || p.lastChild.type == l.cell ? g = d || (d = l.cell.createAndFill()) : g = c || (c = l.header_cell.createAndFill());
    for (let b = e.width; b < o; b++) h.push(g);
    t.insert(t.mapping.slice(i).map(f - 1 + n), h);
  }
  if (s > e.height) {
    const u = [];
    for (let h = 0, g = (e.height - 1) * e.width; h < Math.max(e.width, o); h++) {
      const b = h >= e.width ? !1 : r.nodeAt(e.map[g + h]).type == l.header_cell;
      u.push(b ? c || (c = l.header_cell.createAndFill()) : d || (d = l.cell.createAndFill()));
    }
    const f = l.row.create(null, U.from(u)), p = [];
    for (let h = e.height; h < s; h++) p.push(f);
    t.insert(t.mapping.slice(i).map(n + r.nodeSize - 2), p);
  }
  return !!(d || c);
}
function hp(t, e, r, n, o, s, i, a) {
  if (i == 0 || i == e.height) return !1;
  let l = !1;
  for (let d = o; d < s; d++) {
    const c = i * e.width + d, u = e.map[c];
    if (e.map[c - e.width] == u) {
      l = !0;
      const f = r.nodeAt(u), { top: p, left: h } = e.findCell(u);
      t.setNodeMarkup(t.mapping.slice(a).map(u + n), null, {
        ...f.attrs,
        rowspan: i - p
      }), t.insert(t.mapping.slice(a).map(e.positionAt(i, h, r)), f.type.createAndFill({
        ...f.attrs,
        rowspan: p + f.attrs.rowspan - i
      })), d += f.attrs.colspan - 1;
    }
  }
  return l;
}
function mp(t, e, r, n, o, s, i, a) {
  if (i == 0 || i == e.width) return !1;
  let l = !1;
  for (let d = o; d < s; d++) {
    const c = d * e.width + i, u = e.map[c];
    if (e.map[c - 1] == u) {
      l = !0;
      const f = r.nodeAt(u), p = e.colCount(u), h = t.mapping.slice(a).map(u + n);
      t.setNodeMarkup(h, null, Pn(f.attrs, i - p, f.attrs.colspan - (i - p))), t.insert(h + f.nodeSize, f.type.createAndFill(Pn(f.attrs, 0, i - p))), d += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function gp(t, e, r, n, o) {
  let s = r ? t.doc.nodeAt(r - 1) : t.doc;
  if (!s) throw new Error("No table found");
  let i = Xe.get(s);
  const { top: a, left: l } = n, d = l + o.width, c = a + o.height, u = t.tr;
  let f = 0;
  function p() {
    if (s = r ? u.doc.nodeAt(r - 1) : u.doc, !s) throw new Error("No table found");
    i = Xe.get(s), f = u.mapping.maps.length;
  }
  r7(u, i, s, r, d, c, f) && p(), hp(u, i, s, r, l, d, a, f) && p(), hp(u, i, s, r, l, d, c, f) && p(), mp(u, i, s, r, a, c, l, f) && p(), mp(u, i, s, r, a, c, d, f) && p();
  for (let h = a; h < c; h++) {
    const g = i.positionAt(h, l, s), b = i.positionAt(h, d, s);
    u.replace(u.mapping.slice(f).map(g + r), u.mapping.slice(f).map(b + r), new X(o.rows[h - a], 0, 0));
  }
  p(), u.setSelection(new He(u.doc.resolve(r + i.positionAt(a, l, s)), u.doc.resolve(r + i.positionAt(c - 1, d - 1, s)))), e(u);
}
const n7 = dg({
  ArrowLeft: Os("horiz", -1),
  ArrowRight: Os("horiz", 1),
  ArrowUp: Os("vert", -1),
  ArrowDown: Os("vert", 1),
  "Shift-ArrowLeft": Ls("horiz", -1),
  "Shift-ArrowRight": Ls("horiz", 1),
  "Shift-ArrowUp": Ls("vert", -1),
  "Shift-ArrowDown": Ls("vert", 1),
  Backspace: Rs,
  "Mod-Backspace": Rs,
  Delete: Rs,
  "Mod-Delete": Rs
});
function Ws(t, e, r) {
  return r.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(r).scrollIntoView()), !0);
}
function Os(t, e) {
  return (r, n, o) => {
    if (!o) return !1;
    const s = r.selection;
    if (s instanceof He) return Ws(r, n, be.near(s.$headCell, e));
    if (t != "horiz" && !s.empty) return !1;
    const i = i1(o, t, e);
    if (i == null) return !1;
    if (t == "horiz") return Ws(r, n, be.near(r.doc.resolve(s.head + e), e));
    {
      const a = r.doc.resolve(i), l = Qg(a, t, e);
      let d;
      return l ? d = be.near(l, 1) : e < 0 ? d = be.near(r.doc.resolve(a.before(-1)), -1) : d = be.near(r.doc.resolve(a.after(-1)), 1), Ws(r, n, d);
    }
  };
}
function Ls(t, e) {
  return (r, n, o) => {
    if (!o) return !1;
    const s = r.selection;
    let i;
    if (s instanceof He) i = s;
    else {
      const l = i1(o, t, e);
      if (l == null) return !1;
      i = new He(r.doc.resolve(l));
    }
    const a = Qg(i.$headCell, t, e);
    return a ? Ws(r, n, new He(i.$anchorCell, a)) : !1;
  };
}
function o7(t, e) {
  const r = t.state.doc, n = Mn(r.resolve(e));
  return n ? (t.dispatch(t.state.tr.setSelection(new He(n))), !0) : !1;
}
function s7(t, e, r) {
  if (!or(t.state)) return !1;
  let n = Q8(r);
  const o = t.state.selection;
  if (o instanceof He) {
    n || (n = {
      width: 1,
      height: 1,
      rows: [U.from(hd(Ct(t.state.schema).cell, r))]
    });
    const s = o.$anchorCell.node(-1), i = o.$anchorCell.start(-1), a = Xe.get(s).rectBetween(o.$anchorCell.pos - i, o.$headCell.pos - i);
    return n = t7(n, a.right - a.left, a.bottom - a.top), gp(t.state, t.dispatch, i, a, n), !0;
  } else if (n) {
    const s = ba(t.state), i = s.start(-1);
    return gp(t.state, t.dispatch, i, Xe.get(s.node(-1)).findCell(s.pos - i), n), !0;
  } else return !1;
}
function i7(t, e) {
  var r;
  if (e.button != 0 || e.ctrlKey || e.metaKey) return;
  const n = bp(t, e.target);
  let o;
  if (e.shiftKey && t.state.selection instanceof He)
    s(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && n && (o = Mn(t.state.selection.$anchor)) != null && ((r = al(t, e)) === null || r === void 0 ? void 0 : r.pos) != o.pos)
    s(o, e), e.preventDefault();
  else if (!n) return;
  function s(l, d) {
    let c = al(t, d);
    const u = Kr.getState(t.state) == null;
    if (!c || !Tc(l, c)) if (u) c = l;
    else return;
    const f = new He(l, c);
    if (u || !t.state.selection.eq(f)) {
      const p = t.state.tr.setSelection(f);
      u && p.setMeta(Kr, l.pos), t.dispatch(p);
    }
  }
  function i() {
    t.root.removeEventListener("mouseup", i), t.root.removeEventListener("dragstart", i), t.root.removeEventListener("mousemove", a), Kr.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(Kr, -1));
  }
  function a(l) {
    const d = l, c = Kr.getState(t.state);
    let u;
    if (c != null) u = t.state.doc.resolve(c);
    else if (bp(t, d.target) != n && (u = al(t, e), !u))
      return i();
    u && s(u, d);
  }
  t.root.addEventListener("mouseup", i), t.root.addEventListener("dragstart", i), t.root.addEventListener("mousemove", a);
}
function i1(t, e, r) {
  if (!(t.state.selection instanceof fe)) return null;
  const { $head: n } = t.state.selection;
  for (let o = n.depth - 1; o >= 0; o--) {
    const s = n.node(o);
    if ((r < 0 ? n.index(o) : n.indexAfter(o)) != (r < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const i = n.before(o), a = e == "vert" ? r > 0 ? "down" : "up" : r > 0 ? "right" : "left";
      return t.endOfTextblock(a) ? i : null;
    }
  }
  return null;
}
function bp(t, e) {
  for (; e && e != t.dom; e = e.parentNode) if (e.nodeName == "TD" || e.nodeName == "TH") return e;
  return null;
}
function al(t, e) {
  const r = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  if (!r) return null;
  let { inside: n, pos: o } = r;
  return n >= 0 && Mn(t.state.doc.resolve(n)) || Mn(t.state.doc.resolve(o));
}
var a7 = class {
  constructor(e, r) {
    this.node = e, this.defaultCellMinWidth = r, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty("--default-cell-min-width", `${r}px`), this.colgroup = this.table.appendChild(document.createElement("colgroup")), md(e, this.colgroup, this.table, r), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, md(e, this.colgroup, this.table, this.defaultCellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function md(t, e, r, n, o, s) {
  let i = 0, a = !0, l = e.firstChild;
  const d = t.firstChild;
  if (d) {
    for (let u = 0, f = 0; u < d.childCount; u++) {
      const { colspan: p, colwidth: h } = d.child(u).attrs;
      for (let g = 0; g < p; g++, f++) {
        const b = o == f ? s : h && h[g], y = b ? b + "px" : "";
        if (i += b || n, b || (a = !1), l)
          l.style.width != y && (l.style.width = y), l = l.nextSibling;
        else {
          const $ = document.createElement("col");
          $.style.width = y, e.appendChild($);
        }
      }
    }
    for (; l; ) {
      var c;
      const u = l.nextSibling;
      (c = l.parentNode) === null || c === void 0 || c.removeChild(l), l = u;
    }
    a ? (r.style.width = i + "px", r.style.minWidth = "") : (r.style.width = "", r.style.minWidth = i + "px");
  }
}
const Ft = new Qe("tableColumnResizing");
function l7({ handleWidth: t = 5, cellMinWidth: e = 25, defaultCellMinWidth: r = 100, View: n = a7, lastColumnResizable: o = !0 } = {}) {
  const s = new Ze({
    key: Ft,
    state: {
      init(i, a) {
        var l;
        const d = (l = s.spec) === null || l === void 0 || (l = l.props) === null || l === void 0 ? void 0 : l.nodeViews, c = Ct(a.schema).table.name;
        return n && d && (d[c] = (u, f) => new n(u, r, f)), new d7(-1, !1);
      },
      apply(i, a) {
        return a.apply(i);
      }
    },
    props: {
      attributes: (i) => {
        const a = Ft.getState(i);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (i, a) => {
          c7(i, a, t, o);
        },
        mouseleave: (i) => {
          u7(i);
        },
        mousedown: (i, a) => {
          f7(i, a, e, r);
        }
      },
      decorations: (i) => {
        const a = Ft.getState(i);
        if (a && a.activeHandle > -1) return b7(i, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var d7 = class Us {
  constructor(e, r) {
    this.activeHandle = e, this.dragging = r;
  }
  apply(e) {
    const r = this, n = e.getMeta(Ft);
    if (n && n.setHandle != null) return new Us(n.setHandle, !1);
    if (n && n.setDragging !== void 0) return new Us(r.activeHandle, n.setDragging);
    if (r.activeHandle > -1 && e.docChanged) {
      let o = e.mapping.map(r.activeHandle, -1);
      return pd(e.doc.resolve(o)) || (o = -1), new Us(o, r.dragging);
    }
    return r;
  }
};
function c7(t, e, r, n) {
  if (!t.editable) return;
  const o = Ft.getState(t.state);
  if (o && !o.dragging) {
    const s = h7(e.target);
    let i = -1;
    if (s) {
      const { left: a, right: l } = s.getBoundingClientRect();
      e.clientX - a <= r ? i = yp(t, e, "left", r) : l - e.clientX <= r && (i = yp(t, e, "right", r));
    }
    if (i != o.activeHandle) {
      if (!n && i !== -1) {
        const a = t.state.doc.resolve(i), l = a.node(-1), d = Xe.get(l), c = a.start(-1);
        if (d.colCount(a.pos - c) + a.nodeAfter.attrs.colspan - 1 == d.width - 1) return;
      }
      a1(t, i);
    }
  }
}
function u7(t) {
  if (!t.editable) return;
  const e = Ft.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && a1(t, -1);
}
function f7(t, e, r, n) {
  var o;
  if (!t.editable) return !1;
  const s = (o = t.dom.ownerDocument.defaultView) !== null && o !== void 0 ? o : window, i = Ft.getState(t.state);
  if (!i || i.activeHandle == -1 || i.dragging) return !1;
  const a = t.state.doc.nodeAt(i.activeHandle), l = p7(t, i.activeHandle, a.attrs);
  t.dispatch(t.state.tr.setMeta(Ft, { setDragging: {
    startX: e.clientX,
    startWidth: l
  } }));
  function d(u) {
    s.removeEventListener("mouseup", d), s.removeEventListener("mousemove", c);
    const f = Ft.getState(t.state);
    f != null && f.dragging && (m7(t, f.activeHandle, vp(f.dragging, u, r)), t.dispatch(t.state.tr.setMeta(Ft, { setDragging: null })));
  }
  function c(u) {
    if (!u.which) return d(u);
    const f = Ft.getState(t.state);
    if (f && f.dragging) {
      const p = vp(f.dragging, u, r);
      $p(t, f.activeHandle, p, n);
    }
  }
  return $p(t, i.activeHandle, l, n), s.addEventListener("mouseup", d), s.addEventListener("mousemove", c), e.preventDefault(), !0;
}
function p7(t, e, { colspan: r, colwidth: n }) {
  const o = n && n[n.length - 1];
  if (o) return o;
  const s = t.domAtPos(e);
  let i = s.node.childNodes[s.offset].offsetWidth, a = r;
  if (n)
    for (let l = 0; l < r; l++) n[l] && (i -= n[l], a--);
  return i / a;
}
function h7(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; ) t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function yp(t, e, r, n) {
  const o = r == "right" ? -n : n, s = t.posAtCoords({
    left: e.clientX + o,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: i } = s, a = Mn(t.state.doc.resolve(i));
  if (!a) return -1;
  if (r == "right") return a.pos;
  const l = Xe.get(a.node(-1)), d = a.start(-1), c = l.map.indexOf(a.pos - d);
  return c % l.width == 0 ? -1 : d + l.map[c - 1];
}
function vp(t, e, r) {
  const n = e.clientX - t.startX;
  return Math.max(r, t.startWidth + n);
}
function a1(t, e) {
  t.dispatch(t.state.tr.setMeta(Ft, { setHandle: e }));
}
function m7(t, e, r) {
  const n = t.state.doc.resolve(e), o = n.node(-1), s = Xe.get(o), i = n.start(-1), a = s.colCount(n.pos - i) + n.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let d = 0; d < s.height; d++) {
    const c = d * s.width + a;
    if (d && s.map[c] == s.map[c - s.width]) continue;
    const u = s.map[c], f = o.nodeAt(u).attrs, p = f.colspan == 1 ? 0 : a - s.colCount(u);
    if (f.colwidth && f.colwidth[p] == r) continue;
    const h = f.colwidth ? f.colwidth.slice() : g7(f.colspan);
    h[p] = r, l.setNodeMarkup(i + u, null, {
      ...f,
      colwidth: h
    });
  }
  l.docChanged && t.dispatch(l);
}
function $p(t, e, r, n) {
  const o = t.state.doc.resolve(e), s = o.node(-1), i = o.start(-1), a = Xe.get(s).colCount(o.pos - i) + o.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(o.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; ) l = l.parentNode;
  l && md(s, l.firstChild, l, n, a, r);
}
function g7(t) {
  return Array(t).fill(0);
}
function b7(t, e) {
  const r = [], n = t.doc.resolve(e), o = n.node(-1);
  if (!o) return Ue.empty;
  const s = Xe.get(o), i = n.start(-1), a = s.colCount(n.pos - i) + n.nodeAfter.attrs.colspan - 1;
  for (let d = 0; d < s.height; d++) {
    const c = a + d * s.width;
    if ((a == s.width - 1 || s.map[c] != s.map[c + 1]) && (d == 0 || s.map[c] != s.map[c - s.width])) {
      var l;
      const u = s.map[c], f = i + u + o.nodeAt(u).nodeSize - 1, p = document.createElement("div");
      p.className = "column-resize-handle", !((l = Ft.getState(t)) === null || l === void 0) && l.dragging && r.push(Et.node(i + u, i + u + o.nodeAt(u).nodeSize, { class: "column-resize-dragging" })), r.push(Et.widget(f, p));
    }
  }
  return Ue.create(t.doc, r);
}
function y7({ allowTableNodeSelection: t = !1 } = {}) {
  return new Ze({
    key: Kr,
    state: {
      init() {
        return null;
      },
      apply(e, r) {
        const n = e.getMeta(Kr);
        if (n != null) return n == -1 ? null : n;
        if (r == null || !e.docChanged) return r;
        const { deleted: o, pos: s } = e.mapping.mapResult(r);
        return o ? null : s;
      }
    },
    props: {
      decorations: P8,
      handleDOMEvents: { mousedown: i7 },
      createSelectionBetween(e) {
        return Kr.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: o7,
      handleKeyDown: n7,
      handlePaste: s7
    },
    appendTransaction(e, r, n) {
      return O8(n, n1(n, r), t);
    }
  });
}
var v7 = yt.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          var e, r;
          const n = t.getAttribute("colwidth"), o = n ? n.split(",").map((s) => parseInt(s, 10)) : null;
          if (!o) {
            const s = (e = t.closest("table")) == null ? void 0 : e.querySelectorAll("colgroup > col"), i = Array.from(((r = t.parentElement) == null ? void 0 : r.children) || []).indexOf(t);
            if (i && i > -1 && s && s[i]) {
              const a = s[i].getAttribute("width");
              return a ? [parseInt(a, 10)] : null;
            }
          }
          return o;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", Re(this.options.HTMLAttributes, t), 0];
  }
}), $7 = yt.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((n) => parseInt(n, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", Re(this.options.HTMLAttributes, t), 0];
  }
}), x7 = yt.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", Re(this.options.HTMLAttributes, t), 0];
  }
});
function gd(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function xp(t, e, r, n, o, s) {
  var i;
  let a = 0, l = !0, d = e.firstChild;
  const c = t.firstChild;
  if (c !== null)
    for (let f = 0, p = 0; f < c.childCount; f += 1) {
      const { colspan: h, colwidth: g } = c.child(f).attrs;
      for (let b = 0; b < h; b += 1, p += 1) {
        const y = o === p ? s : g && g[b], $ = y ? `${y}px` : "";
        if (a += y || n, y || (l = !1), d) {
          if (d.style.width !== $) {
            const [k, w] = gd(n, y);
            d.style.setProperty(k, w);
          }
          d = d.nextSibling;
        } else {
          const k = document.createElement("col"), [w, C] = gd(n, y);
          k.style.setProperty(w, C), e.appendChild(k);
        }
      }
    }
  for (; d; ) {
    const f = d.nextSibling;
    (i = d.parentNode) == null || i.removeChild(d), d = f;
  }
  const u = t.attrs.style && typeof t.attrs.style == "string" && /\bwidth\s*:/i.test(t.attrs.style);
  l && !u ? (r.style.width = `${a}px`, r.style.minWidth = "") : (r.style.width = "", r.style.minWidth = `${a}px`);
}
var w7 = class {
  constructor(t, e) {
    this.node = t, this.cellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), t.attrs.style && (this.table.style.cssText = t.attrs.style), this.colgroup = this.table.appendChild(document.createElement("colgroup")), xp(t, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(t) {
    return t.type !== this.node.type ? !1 : (this.node = t, xp(t, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(t) {
    const e = t.target, r = this.dom.contains(e), n = this.contentDOM.contains(e);
    return !!(r && !n && (t.type === "attributes" || t.type === "childList" || t.type === "characterData"));
  }
};
function k7(t, e, r, n) {
  let o = 0, s = !0;
  const i = [], a = t.firstChild;
  if (!a)
    return {};
  for (let u = 0, f = 0; u < a.childCount; u += 1) {
    const { colspan: p, colwidth: h } = a.child(u).attrs;
    for (let g = 0; g < p; g += 1, f += 1) {
      const b = r === f ? n : h && h[g];
      o += b || e, b || (s = !1);
      const [y, $] = gd(e, b);
      i.push(["col", { style: `${y}: ${$}` }]);
    }
  }
  const l = s ? `${o}px` : "", d = s ? "" : `${o}px`;
  return { colgroup: ["colgroup", {}, ...i], tableWidth: l, tableMinWidth: d };
}
function wp(t, e) {
  return t.createAndFill();
}
function E7(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((r) => {
    const n = t.nodes[r];
    n.spec.tableRole && (e[n.spec.tableRole] = n);
  }), t.cached.tableNodeTypes = e, e;
}
function C7(t, e, r, n, o) {
  const s = E7(t), i = [], a = [];
  for (let d = 0; d < r; d += 1) {
    const c = wp(s.cell);
    if (c && a.push(c), n) {
      const u = wp(s.header_cell);
      u && i.push(u);
    }
  }
  const l = [];
  for (let d = 0; d < e; d += 1)
    l.push(s.row.createChecked(null, n && d === 0 ? i : a));
  return s.table.createChecked(null, l);
}
function S7(t) {
  return t instanceof He;
}
var js = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!S7(e))
    return !1;
  let r = 0;
  const n = yg(e.ranges[0].$from, (s) => s.type.name === "table");
  return n == null || n.node.descendants((s) => {
    if (s.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(s.type.name) && (r += 1);
  }), r === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, N7 = "";
function T7(t) {
  return (t || "").replace(/\s+/g, " ").trim();
}
function A7(t, e, r = {}) {
  var n;
  const o = (n = r.cellLineSeparator) != null ? n : N7;
  if (!t || !t.content || t.content.length === 0)
    return "";
  const s = [];
  t.content.forEach((h) => {
    const g = [];
    h.content && h.content.forEach((b) => {
      let y = "";
      b.content && Array.isArray(b.content) && b.content.length > 1 ? y = b.content.map((C) => e.renderChildren(C)).join(o) : y = b.content ? e.renderChildren(b.content) : "";
      const $ = T7(y), k = b.type === "tableHeader";
      g.push({ text: $, isHeader: k });
    }), s.push(g);
  });
  const i = s.reduce((h, g) => Math.max(h, g.length), 0);
  if (i === 0)
    return "";
  const a = new Array(i).fill(0);
  s.forEach((h) => {
    var g;
    for (let b = 0; b < i; b += 1) {
      const $ = (((g = h[b]) == null ? void 0 : g.text) || "").length;
      $ > a[b] && (a[b] = $), a[b] < 3 && (a[b] = 3);
    }
  });
  const l = (h, g) => h + " ".repeat(Math.max(0, g - h.length)), d = s[0], c = d.some((h) => h.isHeader);
  let u = `
`;
  const f = new Array(i).fill(0).map((h, g) => c && d[g] && d[g].text || "");
  return u += `| ${f.map((h, g) => l(h, a[g])).join(" | ")} |
`, u += `| ${a.map((h) => "-".repeat(Math.max(3, h))).join(" | ")} |
`, (c ? s.slice(1) : s).forEach((h) => {
    u += `| ${new Array(i).fill(0).map((g, b) => l(h[b] && h[b].text || "", a[b])).join(" | ")} |
`;
  }), u;
}
var M7 = A7, P7 = yt.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      renderWrapper: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: w7,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: r, tableWidth: n, tableMinWidth: o } = k7(t, this.options.cellMinWidth), s = e.style;
    function i() {
      return s || (n ? `width: ${n}` : `min-width: ${o}`);
    }
    const a = [
      "table",
      Re(this.options.HTMLAttributes, e, {
        style: i()
      }),
      r,
      ["tbody", 0]
    ];
    return this.options.renderWrapper ? ["div", { class: "tableWrapper" }, a] : a;
  },
  parseMarkdown: (t, e) => {
    const r = [];
    if (t.header) {
      const n = [];
      t.header.forEach((o) => {
        n.push(e.createNode("tableHeader", {}, [{ type: "paragraph", content: e.parseInline(o.tokens) }]));
      }), r.push(e.createNode("tableRow", {}, n));
    }
    return t.rows && t.rows.forEach((n) => {
      const o = [];
      n.forEach((s) => {
        o.push(e.createNode("tableCell", {}, [{ type: "paragraph", content: e.parseInline(s.tokens) }]));
      }), r.push(e.createNode("tableRow", {}, o));
    }), e.createNode("table", void 0, r);
  },
  renderMarkdown: (t, e) => M7(t, e),
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: r = !0 } = {}) => ({ tr: n, dispatch: o, editor: s }) => {
        const i = C7(s.schema, t, e, r);
        if (o) {
          const a = n.selection.from + 1;
          n.replaceSelectionWith(i).scrollIntoView().setSelection(fe.near(n.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => D8(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => _8(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => z8(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => B8(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => V8(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => U8(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => Z8(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => cp(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => up(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => ss("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => ss("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => q8(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => cp(t, e) ? !0 : up(t, e),
      setCellAttribute: (t, e) => ({ state: r, dispatch: n }) => Y8(t, e)(r, n),
      goToNextCell: () => ({ state: t, dispatch: e }) => pp(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => pp(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && n1(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: r }) => {
        if (r) {
          const n = He.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(n);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: js,
      "Mod-Backspace": js,
      Delete: js,
      "Mod-Delete": js
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        l7({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      y7({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: hr(Tn(t, "tableRole", e))
    };
  }
});
Le.create({
  name: "tableKit",
  addExtensions() {
    const t = [];
    return this.options.table !== !1 && t.push(P7.configure(this.options.table)), this.options.tableCell !== !1 && t.push(v7.configure(this.options.tableCell)), this.options.tableHeader !== !1 && t.push($7.configure(this.options.tableHeader)), this.options.tableRow !== !1 && t.push(x7.configure(this.options.tableRow)), t;
  }
});
var I7 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, R7 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
mr.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", Re(this.options.HTMLAttributes, t), 0];
  },
  renderMarkdown: (t, e) => `==${e.renderChildren(t)}==`,
  parseMarkdown: (t, e) => e.applyMark("highlight", e.parseInline(t.tokens || [])),
  markdownTokenizer: {
    name: "highlight",
    level: "inline",
    start: (t) => t.indexOf("=="),
    tokenize(t, e, r) {
      const o = /^(==)([^=]+)(==)/.exec(t);
      if (o) {
        const s = o[2].trim(), i = r.inlineTokens(s);
        return {
          type: "highlight",
          raw: o[0],
          text: s,
          tokens: i
        };
      }
    }
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      An({
        find: I7,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      tn({
        find: R7,
        type: this.type
      })
    ];
  }
});
mr.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", Re(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});
mr.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", Re(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});
export {
  F7 as Accordion,
  iE as AnimatedList,
  ib as AutoComplete,
  z7 as Avatar,
  H7 as Badge,
  nE as BadgeNotif,
  gw as Breadcrumbs,
  kt as Button,
  jp as Card,
  fb as CheckBoxGroup,
  Ds as Checkbox,
  B7 as Chip,
  xb as DatePicker,
  kb as Dialog,
  Sb as DialogActions,
  Cb as DialogBody,
  Fp as DialogHeader,
  Eb as DialogTitle,
  Nb as Divider,
  rE as ErrorWrapper,
  Mb as FileUpload,
  $e as Icon,
  Op as Input,
  kw as InputOTP,
  oE as Loader,
  sE as NegativeCase,
  V7 as Notification,
  Rb as Pagination,
  Bm as PhoneInput,
  X7 as PhoneInputDemo,
  Z7 as Popover,
  cl as PrimitiveDatePicker,
  q$ as Progress,
  Hp as Radio,
  Lb as RadioGroup,
  zp as Select,
  Ji as SelectItem,
  jb as Skeleton,
  Db as Slider,
  W7 as StarRating,
  U7 as StatusIndicator,
  G7 as Stepper,
  Wb as Switch,
  Q7 as Table,
  K7 as Tabs,
  Ho as Text,
  Gb as Textarea,
  Yb as TimePicker,
  Wm as Toast,
  eE as ToastProvider,
  Xb as Toggle,
  q7 as Tooltip,
  cb as buttonVariants,
  ub as cardVariants,
  V as cn,
  ww as inputOTPVariants,
  Jb as toggleVariants,
  tE as useToast
};
