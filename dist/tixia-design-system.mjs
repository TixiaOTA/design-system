import * as qs from "react";
import Xe, { forwardRef as Ue, useState as Ie, useRef as $e, useEffect as ut, useCallback as xt, Children as pa, isValidElement as us, cloneElement as Sl, createContext as kl, useContext as Cl } from "react";
import { createPortal as Qt } from "react-dom";
var Al = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xn(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Ml(r) {
  if (r.__esModule) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(i) {
    var s = Object.getOwnPropertyDescriptor(r, i);
    Object.defineProperty(t, i, s.get ? s : {
      enumerable: !0,
      get: function() {
        return r[i];
      }
    });
  }), t;
}
var Zs = { exports: {} }, ni = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xa;
function Rl() {
  if (xa) return ni;
  xa = 1;
  var r = Xe, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), i = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function n(o, l, c) {
    var h, d = {}, u = null, g = null;
    c !== void 0 && (u = "" + c), l.key !== void 0 && (u = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (h in l) i.call(l, h) && !a.hasOwnProperty(h) && (d[h] = l[h]);
    if (o && o.defaultProps) for (h in l = o.defaultProps, l) d[h] === void 0 && (d[h] = l[h]);
    return { $$typeof: e, type: o, key: u, ref: g, props: d, _owner: s.current };
  }
  return ni.Fragment = t, ni.jsx = n, ni.jsxs = n, ni;
}
var oi = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ma;
function Pl() {
  return ma || (ma = 1, process.env.NODE_ENV !== "production" && function() {
    var r = Xe, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), n = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), u = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), p = Symbol.iterator, f = "@@iterator";
    function x(T) {
      if (T === null || typeof T != "object")
        return null;
      var U = p && T[p] || T[f];
      return typeof U == "function" ? U : null;
    }
    var m = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(T) {
      {
        for (var U = arguments.length, se = new Array(U > 1 ? U - 1 : 0), he = 1; he < U; he++)
          se[he - 1] = arguments[he];
        w("error", T, se);
      }
    }
    function w(T, U, se) {
      {
        var he = m.ReactDebugCurrentFrame, we = he.getStackAddendum();
        we !== "" && (U += "%s", se = se.concat([we]));
        var Pe = se.map(function(me) {
          return String(me);
        });
        Pe.unshift("Warning: " + U), Function.prototype.apply.call(console[T], console, Pe);
      }
    }
    var y = !1, v = !1, S = !1, k = !1, C = !1, R;
    R = Symbol.for("react.module.reference");
    function P(T) {
      return !!(typeof T == "string" || typeof T == "function" || T === i || T === a || C || T === s || T === c || T === h || k || T === g || y || v || S || typeof T == "object" && T !== null && (T.$$typeof === u || T.$$typeof === d || T.$$typeof === n || T.$$typeof === o || T.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      T.$$typeof === R || T.getModuleId !== void 0));
    }
    function A(T, U, se) {
      var he = T.displayName;
      if (he)
        return he;
      var we = U.displayName || U.name || "";
      return we !== "" ? se + "(" + we + ")" : se;
    }
    function E(T) {
      return T.displayName || "Context";
    }
    function N(T) {
      if (T == null)
        return null;
      if (typeof T.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof T == "function")
        return T.displayName || T.name || null;
      if (typeof T == "string")
        return T;
      switch (T) {
        case i:
          return "Fragment";
        case t:
          return "Portal";
        case a:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof T == "object")
        switch (T.$$typeof) {
          case o:
            var U = T;
            return E(U) + ".Consumer";
          case n:
            var se = T;
            return E(se._context) + ".Provider";
          case l:
            return A(T, T.render, "ForwardRef");
          case d:
            var he = T.displayName || null;
            return he !== null ? he : N(T.type) || "Memo";
          case u: {
            var we = T, Pe = we._payload, me = we._init;
            try {
              return N(me(Pe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var O = Object.assign, L = 0, I, F, D, Y, _, H, V;
    function Z() {
    }
    Z.__reactDisabledLog = !0;
    function X() {
      {
        if (L === 0) {
          I = console.log, F = console.info, D = console.warn, Y = console.error, _ = console.group, H = console.groupCollapsed, V = console.groupEnd;
          var T = {
            configurable: !0,
            enumerable: !0,
            value: Z,
            writable: !0
          };
          Object.defineProperties(console, {
            info: T,
            log: T,
            warn: T,
            error: T,
            group: T,
            groupCollapsed: T,
            groupEnd: T
          });
        }
        L++;
      }
    }
    function J() {
      {
        if (L--, L === 0) {
          var T = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: O({}, T, {
              value: I
            }),
            info: O({}, T, {
              value: F
            }),
            warn: O({}, T, {
              value: D
            }),
            error: O({}, T, {
              value: Y
            }),
            group: O({}, T, {
              value: _
            }),
            groupCollapsed: O({}, T, {
              value: H
            }),
            groupEnd: O({}, T, {
              value: V
            })
          });
        }
        L < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var G = m.ReactCurrentDispatcher, $;
    function K(T, U, se) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (we) {
            var he = we.stack.trim().match(/\n( *(at )?)/);
            $ = he && he[1] || "";
          }
        return `
` + $ + T;
      }
    }
    var re = !1, Q;
    {
      var ae = typeof WeakMap == "function" ? WeakMap : Map;
      Q = new ae();
    }
    function W(T, U) {
      if (!T || re)
        return "";
      {
        var se = Q.get(T);
        if (se !== void 0)
          return se;
      }
      var he;
      re = !0;
      var we = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Pe;
      Pe = G.current, G.current = null, X();
      try {
        if (U) {
          var me = function() {
            throw Error();
          };
          if (Object.defineProperty(me.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(me, []);
            } catch (Ze) {
              he = Ze;
            }
            Reflect.construct(T, [], me);
          } else {
            try {
              me.call();
            } catch (Ze) {
              he = Ze;
            }
            T.call(me.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ze) {
            he = Ze;
          }
          T();
        }
      } catch (Ze) {
        if (Ze && he && typeof Ze.stack == "string") {
          for (var pe = Ze.stack.split(`
`), Ve = he.stack.split(`
`), Fe = pe.length - 1, Ne = Ve.length - 1; Fe >= 1 && Ne >= 0 && pe[Fe] !== Ve[Ne]; )
            Ne--;
          for (; Fe >= 1 && Ne >= 0; Fe--, Ne--)
            if (pe[Fe] !== Ve[Ne]) {
              if (Fe !== 1 || Ne !== 1)
                do
                  if (Fe--, Ne--, Ne < 0 || pe[Fe] !== Ve[Ne]) {
                    var st = `
` + pe[Fe].replace(" at new ", " at ");
                    return T.displayName && st.includes("<anonymous>") && (st = st.replace("<anonymous>", T.displayName)), typeof T == "function" && Q.set(T, st), st;
                  }
                while (Fe >= 1 && Ne >= 0);
              break;
            }
        }
      } finally {
        re = !1, G.current = Pe, J(), Error.prepareStackTrace = we;
      }
      var Wt = T ? T.displayName || T.name : "", It = Wt ? K(Wt) : "";
      return typeof T == "function" && Q.set(T, It), It;
    }
    function fe(T, U, se) {
      return W(T, !1);
    }
    function _e(T) {
      var U = T.prototype;
      return !!(U && U.isReactComponent);
    }
    function He(T, U, se) {
      if (T == null)
        return "";
      if (typeof T == "function")
        return W(T, _e(T));
      if (typeof T == "string")
        return K(T);
      switch (T) {
        case c:
          return K("Suspense");
        case h:
          return K("SuspenseList");
      }
      if (typeof T == "object")
        switch (T.$$typeof) {
          case l:
            return fe(T.render);
          case d:
            return He(T.type, U, se);
          case u: {
            var he = T, we = he._payload, Pe = he._init;
            try {
              return He(Pe(we), U, se);
            } catch {
            }
          }
        }
      return "";
    }
    var it = Object.prototype.hasOwnProperty, _i = {}, ia = m.ReactDebugCurrentFrame;
    function Oi(T) {
      if (T) {
        var U = T._owner, se = He(T.type, T._source, U ? U.type : null);
        ia.setExtraStackFrame(se);
      } else
        ia.setExtraStackFrame(null);
    }
    function el(T, U, se, he, we) {
      {
        var Pe = Function.call.bind(it);
        for (var me in T)
          if (Pe(T, me)) {
            var pe = void 0;
            try {
              if (typeof T[me] != "function") {
                var Ve = Error((he || "React class") + ": " + se + " type `" + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof T[me] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ve.name = "Invariant Violation", Ve;
              }
              pe = T[me](U, me, he, se, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Fe) {
              pe = Fe;
            }
            pe && !(pe instanceof Error) && (Oi(we), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", he || "React class", se, me, typeof pe), Oi(null)), pe instanceof Error && !(pe.message in _i) && (_i[pe.message] = !0, Oi(we), b("Failed %s type: %s", se, pe.message), Oi(null));
          }
      }
    }
    var tl = Array.isArray;
    function os(T) {
      return tl(T);
    }
    function il(T) {
      {
        var U = typeof Symbol == "function" && Symbol.toStringTag, se = U && T[Symbol.toStringTag] || T.constructor.name || "Object";
        return se;
      }
    }
    function sl(T) {
      try {
        return sa(T), !1;
      } catch {
        return !0;
      }
    }
    function sa(T) {
      return "" + T;
    }
    function ra(T) {
      if (sl(T))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", il(T)), sa(T);
    }
    var aa = m.ReactCurrentOwner, rl = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, na, oa;
    function al(T) {
      if (it.call(T, "ref")) {
        var U = Object.getOwnPropertyDescriptor(T, "ref").get;
        if (U && U.isReactWarning)
          return !1;
      }
      return T.ref !== void 0;
    }
    function nl(T) {
      if (it.call(T, "key")) {
        var U = Object.getOwnPropertyDescriptor(T, "key").get;
        if (U && U.isReactWarning)
          return !1;
      }
      return T.key !== void 0;
    }
    function ol(T, U) {
      typeof T.ref == "string" && aa.current;
    }
    function ll(T, U) {
      {
        var se = function() {
          na || (na = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", U));
        };
        se.isReactWarning = !0, Object.defineProperty(T, "key", {
          get: se,
          configurable: !0
        });
      }
    }
    function cl(T, U) {
      {
        var se = function() {
          oa || (oa = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", U));
        };
        se.isReactWarning = !0, Object.defineProperty(T, "ref", {
          get: se,
          configurable: !0
        });
      }
    }
    var hl = function(T, U, se, he, we, Pe, me) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: T,
        key: U,
        ref: se,
        props: me,
        // Record the component responsible for creating this element.
        _owner: Pe
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: he
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: we
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function dl(T, U, se, he, we) {
      {
        var Pe, me = {}, pe = null, Ve = null;
        se !== void 0 && (ra(se), pe = "" + se), nl(U) && (ra(U.key), pe = "" + U.key), al(U) && (Ve = U.ref, ol(U, we));
        for (Pe in U)
          it.call(U, Pe) && !rl.hasOwnProperty(Pe) && (me[Pe] = U[Pe]);
        if (T && T.defaultProps) {
          var Fe = T.defaultProps;
          for (Pe in Fe)
            me[Pe] === void 0 && (me[Pe] = Fe[Pe]);
        }
        if (pe || Ve) {
          var Ne = typeof T == "function" ? T.displayName || T.name || "Unknown" : T;
          pe && ll(me, Ne), Ve && cl(me, Ne);
        }
        return hl(T, pe, Ve, we, he, aa.current, me);
      }
    }
    var ls = m.ReactCurrentOwner, la = m.ReactDebugCurrentFrame;
    function Bt(T) {
      if (T) {
        var U = T._owner, se = He(T.type, T._source, U ? U.type : null);
        la.setExtraStackFrame(se);
      } else
        la.setExtraStackFrame(null);
    }
    var cs;
    cs = !1;
    function hs(T) {
      return typeof T == "object" && T !== null && T.$$typeof === e;
    }
    function ca() {
      {
        if (ls.current) {
          var T = N(ls.current.type);
          if (T)
            return `

Check the render method of \`` + T + "`.";
        }
        return "";
      }
    }
    function ul(T) {
      return "";
    }
    var ha = {};
    function gl(T) {
      {
        var U = ca();
        if (!U) {
          var se = typeof T == "string" ? T : T.displayName || T.name;
          se && (U = `

Check the top-level render call using <` + se + ">.");
        }
        return U;
      }
    }
    function da(T, U) {
      {
        if (!T._store || T._store.validated || T.key != null)
          return;
        T._store.validated = !0;
        var se = gl(U);
        if (ha[se])
          return;
        ha[se] = !0;
        var he = "";
        T && T._owner && T._owner !== ls.current && (he = " It was passed a child from " + N(T._owner.type) + "."), Bt(T), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', se, he), Bt(null);
      }
    }
    function ua(T, U) {
      {
        if (typeof T != "object")
          return;
        if (os(T))
          for (var se = 0; se < T.length; se++) {
            var he = T[se];
            hs(he) && da(he, U);
          }
        else if (hs(T))
          T._store && (T._store.validated = !0);
        else if (T) {
          var we = x(T);
          if (typeof we == "function" && we !== T.entries)
            for (var Pe = we.call(T), me; !(me = Pe.next()).done; )
              hs(me.value) && da(me.value, U);
        }
      }
    }
    function fl(T) {
      {
        var U = T.type;
        if (U == null || typeof U == "string")
          return;
        var se;
        if (typeof U == "function")
          se = U.propTypes;
        else if (typeof U == "object" && (U.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        U.$$typeof === d))
          se = U.propTypes;
        else
          return;
        if (se) {
          var he = N(U);
          el(se, T.props, "prop", he, T);
        } else if (U.PropTypes !== void 0 && !cs) {
          cs = !0;
          var we = N(U);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", we || "Unknown");
        }
        typeof U.getDefaultProps == "function" && !U.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function pl(T) {
      {
        for (var U = Object.keys(T.props), se = 0; se < U.length; se++) {
          var he = U[se];
          if (he !== "children" && he !== "key") {
            Bt(T), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", he), Bt(null);
            break;
          }
        }
        T.ref !== null && (Bt(T), b("Invalid attribute `ref` supplied to `React.Fragment`."), Bt(null));
      }
    }
    var ga = {};
    function fa(T, U, se, he, we, Pe) {
      {
        var me = P(T);
        if (!me) {
          var pe = "";
          (T === void 0 || typeof T == "object" && T !== null && Object.keys(T).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ve = ul();
          Ve ? pe += Ve : pe += ca();
          var Fe;
          T === null ? Fe = "null" : os(T) ? Fe = "array" : T !== void 0 && T.$$typeof === e ? (Fe = "<" + (N(T.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Fe = typeof T, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Fe, pe);
        }
        var Ne = dl(T, U, se, we, Pe);
        if (Ne == null)
          return Ne;
        if (me) {
          var st = U.children;
          if (st !== void 0)
            if (he)
              if (os(st)) {
                for (var Wt = 0; Wt < st.length; Wt++)
                  ua(st[Wt], T);
                Object.freeze && Object.freeze(st);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ua(st, T);
        }
        if (it.call(U, "key")) {
          var It = N(T), Ze = Object.keys(U).filter(function(wl) {
            return wl !== "key";
          }), ds = Ze.length > 0 ? "{key: someKey, " + Ze.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ga[It + ds]) {
            var yl = Ze.length > 0 ? "{" + Ze.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ds, It, yl, It), ga[It + ds] = !0;
          }
        }
        return T === i ? pl(Ne) : fl(Ne), Ne;
      }
    }
    function xl(T, U, se) {
      return fa(T, U, se, !0);
    }
    function ml(T, U, se) {
      return fa(T, U, se, !1);
    }
    var bl = ml, vl = xl;
    oi.Fragment = i, oi.jsx = bl, oi.jsxs = vl;
  }()), oi;
}
process.env.NODE_ENV === "production" ? Zs.exports = Rl() : Zs.exports = Pl();
var M = Zs.exports;
function mn(r) {
  var e, t, i = "";
  if (typeof r == "string" || typeof r == "number") i += r;
  else if (typeof r == "object") if (Array.isArray(r)) {
    var s = r.length;
    for (e = 0; e < s; e++) r[e] && (t = mn(r[e])) && (i && (i += " "), i += t);
  } else for (t in r) r[t] && (i && (i += " "), i += t);
  return i;
}
function xe() {
  for (var r, e, t = 0, i = "", s = arguments.length; t < s; t++) (r = arguments[t]) && (e = mn(r)) && (i && (i += " "), i += e);
  return i;
}
const ba = (r) => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, va = xe, gt = (r, e) => (t) => {
  var i;
  if ((e == null ? void 0 : e.variants) == null) return va(r, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
  const { variants: s, defaultVariants: a } = e, n = Object.keys(s).map((c) => {
    const h = t == null ? void 0 : t[c], d = a == null ? void 0 : a[c];
    if (h === null) return null;
    const u = ba(h) || ba(d);
    return s[c][u];
  }), o = t && Object.entries(t).reduce((c, h) => {
    let [d, u] = h;
    return u === void 0 || (c[d] = u), c;
  }, {}), l = e == null || (i = e.compoundVariants) === null || i === void 0 ? void 0 : i.reduce((c, h) => {
    let { class: d, className: u, ...g } = h;
    return Object.entries(g).every((p) => {
      let [f, x] = p;
      return Array.isArray(x) ? x.includes({
        ...a,
        ...o
      }[f]) : {
        ...a,
        ...o
      }[f] === x;
    }) ? [
      ...c,
      d,
      u
    ] : c;
  }, []);
  return va(r, n, l, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
}, Ir = "-", Ll = (r) => {
  const e = El(r), {
    conflictingClassGroups: t,
    conflictingClassGroupModifiers: i
  } = r;
  return {
    getClassGroupId: (n) => {
      const o = n.split(Ir);
      return o[0] === "" && o.length !== 1 && o.shift(), bn(o, e) || Il(n);
    },
    getConflictingClassGroupIds: (n, o) => {
      const l = t[n] || [];
      return o && i[n] ? [...l, ...i[n]] : l;
    }
  };
}, bn = (r, e) => {
  var n;
  if (r.length === 0)
    return e.classGroupId;
  const t = r[0], i = e.nextPart.get(t), s = i ? bn(r.slice(1), i) : void 0;
  if (s)
    return s;
  if (e.validators.length === 0)
    return;
  const a = r.join(Ir);
  return (n = e.validators.find(({
    validator: o
  }) => o(a))) == null ? void 0 : n.classGroupId;
}, ya = /^\[(.+)\]$/, Il = (r) => {
  if (ya.test(r)) {
    const e = ya.exec(r)[1], t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (t)
      return "arbitrary.." + t;
  }
}, El = (r) => {
  const {
    theme: e,
    prefix: t
  } = r, i = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return _l(Object.entries(r.classGroups), t).forEach(([a, n]) => {
    Js(n, i, a, e);
  }), i;
}, Js = (r, e, t, i) => {
  r.forEach((s) => {
    if (typeof s == "string") {
      const a = s === "" ? e : wa(e, s);
      a.classGroupId = t;
      return;
    }
    if (typeof s == "function") {
      if (Tl(s)) {
        Js(s(i), e, t, i);
        return;
      }
      e.validators.push({
        validator: s,
        classGroupId: t
      });
      return;
    }
    Object.entries(s).forEach(([a, n]) => {
      Js(n, wa(e, a), t, i);
    });
  });
}, wa = (r, e) => {
  let t = r;
  return e.split(Ir).forEach((i) => {
    t.nextPart.has(i) || t.nextPart.set(i, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), t = t.nextPart.get(i);
  }), t;
}, Tl = (r) => r.isThemeGetter, _l = (r, e) => e ? r.map(([t, i]) => {
  const s = i.map((a) => typeof a == "string" ? e + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([n, o]) => [e + n, o])) : a);
  return [t, s];
}) : r, Ol = (r) => {
  if (r < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  const s = (a, n) => {
    t.set(a, n), e++, e > r && (e = 0, i = t, t = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let n = t.get(a);
      if (n !== void 0)
        return n;
      if ((n = i.get(a)) !== void 0)
        return s(a, n), n;
    },
    set(a, n) {
      t.has(a) ? t.set(a, n) : s(a, n);
    }
  };
}, vn = "!", zl = (r) => {
  const {
    separator: e,
    experimentalParseClassName: t
  } = r, i = e.length === 1, s = e[0], a = e.length, n = (o) => {
    const l = [];
    let c = 0, h = 0, d;
    for (let x = 0; x < o.length; x++) {
      let m = o[x];
      if (c === 0) {
        if (m === s && (i || o.slice(x, x + a) === e)) {
          l.push(o.slice(h, x)), h = x + a;
          continue;
        }
        if (m === "/") {
          d = x;
          continue;
        }
      }
      m === "[" ? c++ : m === "]" && c--;
    }
    const u = l.length === 0 ? o : o.substring(h), g = u.startsWith(vn), p = g ? u.substring(1) : u, f = d && d > h ? d - h : void 0;
    return {
      modifiers: l,
      hasImportantModifier: g,
      baseClassName: p,
      maybePostfixModifierPosition: f
    };
  };
  return t ? (o) => t({
    className: o,
    parseClassName: n
  }) : n;
}, Fl = (r) => {
  if (r.length <= 1)
    return r;
  const e = [];
  let t = [];
  return r.forEach((i) => {
    i[0] === "[" ? (e.push(...t.sort(), i), t = []) : t.push(i);
  }), e.push(...t.sort()), e;
}, Nl = (r) => ({
  cache: Ol(r.cacheSize),
  parseClassName: zl(r),
  ...Ll(r)
}), Dl = /\s+/, Hl = (r, e) => {
  const {
    parseClassName: t,
    getClassGroupId: i,
    getConflictingClassGroupIds: s
  } = e, a = [], n = r.trim().split(Dl);
  let o = "";
  for (let l = n.length - 1; l >= 0; l -= 1) {
    const c = n[l], {
      modifiers: h,
      hasImportantModifier: d,
      baseClassName: u,
      maybePostfixModifierPosition: g
    } = t(c);
    let p = !!g, f = i(p ? u.substring(0, g) : u);
    if (!f) {
      if (!p) {
        o = c + (o.length > 0 ? " " + o : o);
        continue;
      }
      if (f = i(u), !f) {
        o = c + (o.length > 0 ? " " + o : o);
        continue;
      }
      p = !1;
    }
    const x = Fl(h).join(":"), m = d ? x + vn : x, b = m + f;
    if (a.includes(b))
      continue;
    a.push(b);
    const w = s(f, p);
    for (let y = 0; y < w.length; ++y) {
      const v = w[y];
      a.push(m + v);
    }
    o = c + (o.length > 0 ? " " + o : o);
  }
  return o;
};
function Yl() {
  let r = 0, e, t, i = "";
  for (; r < arguments.length; )
    (e = arguments[r++]) && (t = yn(e)) && (i && (i += " "), i += t);
  return i;
}
const yn = (r) => {
  if (typeof r == "string")
    return r;
  let e, t = "";
  for (let i = 0; i < r.length; i++)
    r[i] && (e = yn(r[i])) && (t && (t += " "), t += e);
  return t;
};
function jl(r, ...e) {
  let t, i, s, a = n;
  function n(l) {
    const c = e.reduce((h, d) => d(h), r());
    return t = Nl(c), i = t.cache.get, s = t.cache.set, a = o, o(l);
  }
  function o(l) {
    const c = i(l);
    if (c)
      return c;
    const h = Hl(l, t);
    return s(l, h), h;
  }
  return function() {
    return a(Yl.apply(null, arguments));
  };
}
const Te = (r) => {
  const e = (t) => t[r] || [];
  return e.isThemeGetter = !0, e;
}, wn = /^\[(?:([a-z-]+):)?(.+)\]$/i, Xl = /^\d+\/\d+$/, Bl = /* @__PURE__ */ new Set(["px", "full", "screen"]), Wl = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Vl = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Gl = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, $l = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Ul = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, ft = (r) => Ut(r) || Bl.has(r) || Xl.test(r), wt = (r) => ei(r, "length", ic), Ut = (r) => !!r && !Number.isNaN(Number(r)), gs = (r) => ei(r, "number", Ut), li = (r) => !!r && Number.isInteger(Number(r)), ql = (r) => r.endsWith("%") && Ut(r.slice(0, -1)), ue = (r) => wn.test(r), St = (r) => Wl.test(r), Zl = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Jl = (r) => ei(r, Zl, Sn), Kl = (r) => ei(r, "position", Sn), Ql = /* @__PURE__ */ new Set(["image", "url"]), ec = (r) => ei(r, Ql, rc), tc = (r) => ei(r, "", sc), ci = () => !0, ei = (r, e, t) => {
  const i = wn.exec(r);
  return i ? i[1] ? typeof e == "string" ? i[1] === e : e.has(i[1]) : t(i[2]) : !1;
}, ic = (r) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Vl.test(r) && !Gl.test(r)
), Sn = () => !1, sc = (r) => $l.test(r), rc = (r) => Ul.test(r), ac = () => {
  const r = Te("colors"), e = Te("spacing"), t = Te("blur"), i = Te("brightness"), s = Te("borderColor"), a = Te("borderRadius"), n = Te("borderSpacing"), o = Te("borderWidth"), l = Te("contrast"), c = Te("grayscale"), h = Te("hueRotate"), d = Te("invert"), u = Te("gap"), g = Te("gradientColorStops"), p = Te("gradientColorStopPositions"), f = Te("inset"), x = Te("margin"), m = Te("opacity"), b = Te("padding"), w = Te("saturate"), y = Te("scale"), v = Te("sepia"), S = Te("skew"), k = Te("space"), C = Te("translate"), R = () => ["auto", "contain", "none"], P = () => ["auto", "hidden", "clip", "visible", "scroll"], A = () => ["auto", ue, e], E = () => [ue, e], N = () => ["", ft, wt], O = () => ["auto", Ut, ue], L = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], I = () => ["solid", "dashed", "dotted", "double", "none"], F = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], D = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Y = () => ["", "0", ue], _ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], H = () => [Ut, ue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [ci],
      spacing: [ft, wt],
      blur: ["none", "", St, ue],
      brightness: H(),
      borderColor: [r],
      borderRadius: ["none", "", "full", St, ue],
      borderSpacing: E(),
      borderWidth: N(),
      contrast: H(),
      grayscale: Y(),
      hueRotate: H(),
      invert: Y(),
      gap: E(),
      gradientColorStops: [r],
      gradientColorStopPositions: [ql, wt],
      inset: A(),
      margin: A(),
      opacity: H(),
      padding: E(),
      saturate: H(),
      scale: H(),
      sepia: Y(),
      skew: H(),
      space: E(),
      translate: E()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [St]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": _()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": _()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...L(), ue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: P()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": P()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": P()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: R()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": R()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": R()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [f]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [f]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [f]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [f]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [f]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [f]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [f]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [f]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [f]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", li, ue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: A()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: Y()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: Y()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", li, ue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [ci]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", li, ue]
        }, ue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": O()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": O()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [ci]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [li, ue]
        }, ue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": O()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": O()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [u]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [u]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [u]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...D()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...D(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...D(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [b]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [b]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [b]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [b]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [b]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [b]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [b]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [b]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [b]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [x]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [x]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [x]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [x]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [x]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [x]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [x]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [x]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [x]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [k]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [k]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ue, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ue, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ue, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [St]
        }, St]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ue, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ue, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ue, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ue, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", St, wt]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", gs]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [ci]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Ut, gs]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", ft, ue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [r]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [m]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [r]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [m]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...I(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", ft, wt]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", ft, ue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [r]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: E()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [m]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...L(), Kl]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Jl]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, ec]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [r]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [g]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [g]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [g]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [o]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [o]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [o]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [o]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [o]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [o]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [o]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [o]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [o]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [m]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...I(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [o]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [o]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [m]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: I()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [s]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [s]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [s]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [s]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [s]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [s]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [s]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [s]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [s]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [s]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...I()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [ft, ue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [ft, wt]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [r]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: N()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [r]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [m]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [ft, wt]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [r]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", St, tc]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [ci]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [m]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...F(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": F()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [t]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [i]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", St, ue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [h]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [w]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [v]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [t]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [i]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [h]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [m]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [w]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [v]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [n]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [n]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [n]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: H()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: H()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [y]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [y]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [y]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [li, ue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [C]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [C]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [S]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [S]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", r]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [r]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": E()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": E()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": E()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": E()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": E()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": E()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": E()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": E()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": E()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": E()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": E()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": E()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": E()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": E()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": E()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": E()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": E()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": E()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [r, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [ft, wt, gs]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [r, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Dt = /* @__PURE__ */ jl(ac);
function ie(...r) {
  return Dt(xe(r));
}
const fi = /^[a-z0-9]+(-[a-z0-9]+)*$/, ts = (r, e, t, i = "") => {
  const s = r.split(":");
  if (r.slice(0, 1) === "@") {
    if (s.length < 2 || s.length > 3)
      return null;
    i = s.shift().slice(1);
  }
  if (s.length > 3 || !s.length)
    return null;
  if (s.length > 1) {
    const o = s.pop(), l = s.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: s.length > 0 ? s[0] : i,
      prefix: l,
      name: o
    };
    return e && !Xi(c) ? null : c;
  }
  const a = s[0], n = a.split("-");
  if (n.length > 1) {
    const o = {
      provider: i,
      prefix: n.shift(),
      name: n.join("-")
    };
    return e && !Xi(o) ? null : o;
  }
  if (t && i === "") {
    const o = {
      provider: i,
      prefix: "",
      name: a
    };
    return e && !Xi(o, t) ? null : o;
  }
  return null;
}, Xi = (r, e) => r ? !!((r.provider === "" || r.provider.match(fi)) && (e && r.prefix === "" || r.prefix.match(fi)) && r.name.match(fi)) : !1, kn = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), qi = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), Er = Object.freeze({
  ...kn,
  ...qi
}), Ks = Object.freeze({
  ...Er,
  body: "",
  hidden: !1
});
function nc(r, e) {
  const t = {};
  !r.hFlip != !e.hFlip && (t.hFlip = !0), !r.vFlip != !e.vFlip && (t.vFlip = !0);
  const i = ((r.rotate || 0) + (e.rotate || 0)) % 4;
  return i && (t.rotate = i), t;
}
function Sa(r, e) {
  const t = nc(r, e);
  for (const i in Ks)
    i in qi ? i in r && !(i in t) && (t[i] = qi[i]) : i in e ? t[i] = e[i] : i in r && (t[i] = r[i]);
  return t;
}
function oc(r, e) {
  const t = r.icons, i = r.aliases || /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
  function a(n) {
    if (t[n])
      return s[n] = [];
    if (!(n in s)) {
      s[n] = null;
      const o = i[n] && i[n].parent, l = o && a(o);
      l && (s[n] = [o].concat(l));
    }
    return s[n];
  }
  return Object.keys(t).concat(Object.keys(i)).forEach(a), s;
}
function lc(r, e, t) {
  const i = r.icons, s = r.aliases || /* @__PURE__ */ Object.create(null);
  let a = {};
  function n(o) {
    a = Sa(
      i[o] || s[o],
      a
    );
  }
  return n(e), t.forEach(n), Sa(r, a);
}
function Cn(r, e) {
  const t = [];
  if (typeof r != "object" || typeof r.icons != "object")
    return t;
  r.not_found instanceof Array && r.not_found.forEach((s) => {
    e(s, null), t.push(s);
  });
  const i = oc(r);
  for (const s in i) {
    const a = i[s];
    a && (e(s, lc(r, s, a)), t.push(s));
  }
  return t;
}
const cc = {
  provider: "",
  aliases: {},
  not_found: {},
  ...kn
};
function fs(r, e) {
  for (const t in e)
    if (t in r && typeof r[t] != typeof e[t])
      return !1;
  return !0;
}
function An(r) {
  if (typeof r != "object" || r === null)
    return null;
  const e = r;
  if (typeof e.prefix != "string" || !r.icons || typeof r.icons != "object" || !fs(r, cc))
    return null;
  const t = e.icons;
  for (const s in t) {
    const a = t[s];
    if (!s.match(fi) || typeof a.body != "string" || !fs(
      a,
      Ks
    ))
      return null;
  }
  const i = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const s in i) {
    const a = i[s], n = a.parent;
    if (!s.match(fi) || typeof n != "string" || !t[n] && !i[n] || !fs(
      a,
      Ks
    ))
      return null;
  }
  return e;
}
const ka = /* @__PURE__ */ Object.create(null);
function hc(r, e) {
  return {
    provider: r,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Ht(r, e) {
  const t = ka[r] || (ka[r] = /* @__PURE__ */ Object.create(null));
  return t[e] || (t[e] = hc(r, e));
}
function Tr(r, e) {
  return An(e) ? Cn(e, (t, i) => {
    i ? r.icons[t] = i : r.missing.add(t);
  }) : [];
}
function dc(r, e, t) {
  try {
    if (typeof t.body == "string")
      return r.icons[e] = { ...t }, !0;
  } catch {
  }
  return !1;
}
let vi = !1;
function Mn(r) {
  return typeof r == "boolean" && (vi = r), vi;
}
function uc(r) {
  const e = typeof r == "string" ? ts(r, !0, vi) : r;
  if (e) {
    const t = Ht(e.provider, e.prefix), i = e.name;
    return t.icons[i] || (t.missing.has(i) ? null : void 0);
  }
}
function gc(r, e) {
  const t = ts(r, !0, vi);
  if (!t)
    return !1;
  const i = Ht(t.provider, t.prefix);
  return dc(i, t.name, e);
}
function fc(r, e) {
  if (typeof r != "object")
    return !1;
  if (typeof e != "string" && (e = r.provider || ""), vi && !e && !r.prefix) {
    let s = !1;
    return An(r) && (r.prefix = "", Cn(r, (a, n) => {
      n && gc(a, n) && (s = !0);
    })), s;
  }
  const t = r.prefix;
  if (!Xi({
    provider: e,
    prefix: t,
    name: "a"
  }))
    return !1;
  const i = Ht(e, t);
  return !!Tr(i, r);
}
const Rn = Object.freeze({
  width: null,
  height: null
}), Pn = Object.freeze({
  // Dimensions
  ...Rn,
  // Transformations
  ...qi
}), pc = /(-?[0-9.]*[0-9]+[0-9.]*)/g, xc = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Ca(r, e, t) {
  if (e === 1)
    return r;
  if (t = t || 100, typeof r == "number")
    return Math.ceil(r * e * t) / t;
  if (typeof r != "string")
    return r;
  const i = r.split(pc);
  if (i === null || !i.length)
    return r;
  const s = [];
  let a = i.shift(), n = xc.test(a);
  for (; ; ) {
    if (n) {
      const o = parseFloat(a);
      isNaN(o) ? s.push(a) : s.push(Math.ceil(o * e * t) / t);
    } else
      s.push(a);
    if (a = i.shift(), a === void 0)
      return s.join("");
    n = !n;
  }
}
const mc = (r) => r === "unset" || r === "undefined" || r === "none";
function bc(r, e) {
  const t = {
    ...Er,
    ...r
  }, i = {
    ...Pn,
    ...e
  }, s = {
    left: t.left,
    top: t.top,
    width: t.width,
    height: t.height
  };
  let a = t.body;
  [t, i].forEach((p) => {
    const f = [], x = p.hFlip, m = p.vFlip;
    let b = p.rotate;
    x ? m ? b += 2 : (f.push(
      "translate(" + (s.width + s.left).toString() + " " + (0 - s.top).toString() + ")"
    ), f.push("scale(-1 1)"), s.top = s.left = 0) : m && (f.push(
      "translate(" + (0 - s.left).toString() + " " + (s.height + s.top).toString() + ")"
    ), f.push("scale(1 -1)"), s.top = s.left = 0);
    let w;
    switch (b < 0 && (b -= Math.floor(b / 4) * 4), b = b % 4, b) {
      case 1:
        w = s.height / 2 + s.top, f.unshift(
          "rotate(90 " + w.toString() + " " + w.toString() + ")"
        );
        break;
      case 2:
        f.unshift(
          "rotate(180 " + (s.width / 2 + s.left).toString() + " " + (s.height / 2 + s.top).toString() + ")"
        );
        break;
      case 3:
        w = s.width / 2 + s.left, f.unshift(
          "rotate(-90 " + w.toString() + " " + w.toString() + ")"
        );
        break;
    }
    b % 2 === 1 && (s.left !== s.top && (w = s.left, s.left = s.top, s.top = w), s.width !== s.height && (w = s.width, s.width = s.height, s.height = w)), f.length && (a = '<g transform="' + f.join(" ") + '">' + a + "</g>");
  });
  const n = i.width, o = i.height, l = s.width, c = s.height;
  let h, d;
  n === null ? (d = o === null ? "1em" : o === "auto" ? c : o, h = Ca(d, l / c)) : (h = n === "auto" ? l : n, d = o === null ? Ca(h, c / l) : o === "auto" ? c : o);
  const u = {}, g = (p, f) => {
    mc(f) || (u[p] = f.toString());
  };
  return g("width", h), g("height", d), u.viewBox = s.left.toString() + " " + s.top.toString() + " " + l.toString() + " " + c.toString(), {
    attributes: u,
    body: a
  };
}
const vc = /\sid="(\S+)"/g, yc = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let wc = 0;
function Sc(r, e = yc) {
  const t = [];
  let i;
  for (; i = vc.exec(r); )
    t.push(i[1]);
  if (!t.length)
    return r;
  const s = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return t.forEach((a) => {
    const n = typeof e == "function" ? e(a) : e + (wc++).toString(), o = a.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    r = r.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + o + ')([")]|\\.[a-z])', "g"),
      "$1" + n + s + "$3"
    );
  }), r = r.replace(new RegExp(s, "g"), ""), r;
}
const Qs = /* @__PURE__ */ Object.create(null);
function kc(r, e) {
  Qs[r] = e;
}
function er(r) {
  return Qs[r] || Qs[""];
}
function _r(r) {
  let e;
  if (typeof r.resources == "string")
    e = [r.resources];
  else if (e = r.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: r.path || "/",
    // URL length limit
    maxURL: r.maxURL || 500,
    // Timeout before next host is used.
    rotate: r.rotate || 750,
    // Timeout before failing query.
    timeout: r.timeout || 5e3,
    // Randomise default API end point.
    random: r.random === !0,
    // Start index
    index: r.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: r.dataAfterTimeout !== !1
  };
}
const Or = /* @__PURE__ */ Object.create(null), hi = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Bi = [];
for (; hi.length > 0; )
  hi.length === 1 || Math.random() > 0.5 ? Bi.push(hi.shift()) : Bi.push(hi.pop());
Or[""] = _r({
  resources: ["https://api.iconify.design"].concat(Bi)
});
function Cc(r, e) {
  const t = _r(e);
  return t === null ? !1 : (Or[r] = t, !0);
}
function zr(r) {
  return Or[r];
}
const Ac = () => {
  let r;
  try {
    if (r = fetch, typeof r == "function")
      return r;
  } catch {
  }
};
let Aa = Ac();
function Mc(r, e) {
  const t = zr(r);
  if (!t)
    return 0;
  let i;
  if (!t.maxURL)
    i = 0;
  else {
    let s = 0;
    t.resources.forEach((n) => {
      s = Math.max(s, n.length);
    });
    const a = e + ".json?icons=";
    i = t.maxURL - s - t.path.length - a.length;
  }
  return i;
}
function Rc(r) {
  return r === 404;
}
const Pc = (r, e, t) => {
  const i = [], s = Mc(r, e), a = "icons";
  let n = {
    type: a,
    provider: r,
    prefix: e,
    icons: []
  }, o = 0;
  return t.forEach((l, c) => {
    o += l.length + 1, o >= s && c > 0 && (i.push(n), n = {
      type: a,
      provider: r,
      prefix: e,
      icons: []
    }, o = l.length), n.icons.push(l);
  }), i.push(n), i;
};
function Lc(r) {
  if (typeof r == "string") {
    const e = zr(r);
    if (e)
      return e.path;
  }
  return "/";
}
const Ic = (r, e, t) => {
  if (!Aa) {
    t("abort", 424);
    return;
  }
  let i = Lc(e.provider);
  switch (e.type) {
    case "icons": {
      const a = e.prefix, o = e.icons.join(","), l = new URLSearchParams({
        icons: o
      });
      i += a + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const a = e.uri;
      i += a.slice(0, 1) === "/" ? a.slice(1) : a;
      break;
    }
    default:
      t("abort", 400);
      return;
  }
  let s = 503;
  Aa(r + i).then((a) => {
    const n = a.status;
    if (n !== 200) {
      setTimeout(() => {
        t(Rc(n) ? "abort" : "next", n);
      });
      return;
    }
    return s = 501, a.json();
  }).then((a) => {
    if (typeof a != "object" || a === null) {
      setTimeout(() => {
        a === 404 ? t("abort", a) : t("next", s);
      });
      return;
    }
    setTimeout(() => {
      t("success", a);
    });
  }).catch(() => {
    t("next", s);
  });
}, Ec = {
  prepare: Pc,
  send: Ic
};
function Tc(r) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, t = /* @__PURE__ */ Object.create(null);
  r.sort((s, a) => s.provider !== a.provider ? s.provider.localeCompare(a.provider) : s.prefix !== a.prefix ? s.prefix.localeCompare(a.prefix) : s.name.localeCompare(a.name));
  let i = {
    provider: "",
    prefix: "",
    name: ""
  };
  return r.forEach((s) => {
    if (i.name === s.name && i.prefix === s.prefix && i.provider === s.provider)
      return;
    i = s;
    const a = s.provider, n = s.prefix, o = s.name, l = t[a] || (t[a] = /* @__PURE__ */ Object.create(null)), c = l[n] || (l[n] = Ht(a, n));
    let h;
    o in c.icons ? h = e.loaded : n === "" || c.missing.has(o) ? h = e.missing : h = e.pending;
    const d = {
      provider: a,
      prefix: n,
      name: o
    };
    h.push(d);
  }), e;
}
function Ln(r, e) {
  r.forEach((t) => {
    const i = t.loaderCallbacks;
    i && (t.loaderCallbacks = i.filter((s) => s.id !== e));
  });
}
function _c(r) {
  r.pendingCallbacksFlag || (r.pendingCallbacksFlag = !0, setTimeout(() => {
    r.pendingCallbacksFlag = !1;
    const e = r.loaderCallbacks ? r.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let t = !1;
    const i = r.provider, s = r.prefix;
    e.forEach((a) => {
      const n = a.icons, o = n.pending.length;
      n.pending = n.pending.filter((l) => {
        if (l.prefix !== s)
          return !0;
        const c = l.name;
        if (r.icons[c])
          n.loaded.push({
            provider: i,
            prefix: s,
            name: c
          });
        else if (r.missing.has(c))
          n.missing.push({
            provider: i,
            prefix: s,
            name: c
          });
        else
          return t = !0, !0;
        return !1;
      }), n.pending.length !== o && (t || Ln([r], a.id), a.callback(
        n.loaded.slice(0),
        n.missing.slice(0),
        n.pending.slice(0),
        a.abort
      ));
    });
  }));
}
let Oc = 0;
function zc(r, e, t) {
  const i = Oc++, s = Ln.bind(null, t, i);
  if (!e.pending.length)
    return s;
  const a = {
    id: i,
    icons: e,
    callback: r,
    abort: s
  };
  return t.forEach((n) => {
    (n.loaderCallbacks || (n.loaderCallbacks = [])).push(a);
  }), s;
}
function Fc(r, e = !0, t = !1) {
  const i = [];
  return r.forEach((s) => {
    const a = typeof s == "string" ? ts(s, e, t) : s;
    a && i.push(a);
  }), i;
}
var Nc = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function Dc(r, e, t, i) {
  const s = r.resources.length, a = r.random ? Math.floor(Math.random() * s) : r.index;
  let n;
  if (r.random) {
    let S = r.resources.slice(0);
    for (n = []; S.length > 1; ) {
      const k = Math.floor(Math.random() * S.length);
      n.push(S[k]), S = S.slice(0, k).concat(S.slice(k + 1));
    }
    n = n.concat(S);
  } else
    n = r.resources.slice(a).concat(r.resources.slice(0, a));
  const o = Date.now();
  let l = "pending", c = 0, h, d = null, u = [], g = [];
  typeof i == "function" && g.push(i);
  function p() {
    d && (clearTimeout(d), d = null);
  }
  function f() {
    l === "pending" && (l = "aborted"), p(), u.forEach((S) => {
      S.status === "pending" && (S.status = "aborted");
    }), u = [];
  }
  function x(S, k) {
    k && (g = []), typeof S == "function" && g.push(S);
  }
  function m() {
    return {
      startTime: o,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: u.length,
      subscribe: x,
      abort: f
    };
  }
  function b() {
    l = "failed", g.forEach((S) => {
      S(void 0, h);
    });
  }
  function w() {
    u.forEach((S) => {
      S.status === "pending" && (S.status = "aborted");
    }), u = [];
  }
  function y(S, k, C) {
    const R = k !== "success";
    switch (u = u.filter((P) => P !== S), l) {
      case "pending":
        break;
      case "failed":
        if (R || !r.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (k === "abort") {
      h = C, b();
      return;
    }
    if (R) {
      h = C, u.length || (n.length ? v() : b());
      return;
    }
    if (p(), w(), !r.random) {
      const P = r.resources.indexOf(S.resource);
      P !== -1 && P !== r.index && (r.index = P);
    }
    l = "completed", g.forEach((P) => {
      P(C);
    });
  }
  function v() {
    if (l !== "pending")
      return;
    p();
    const S = n.shift();
    if (S === void 0) {
      if (u.length) {
        d = setTimeout(() => {
          p(), l === "pending" && (w(), b());
        }, r.timeout);
        return;
      }
      b();
      return;
    }
    const k = {
      status: "pending",
      resource: S,
      callback: (C, R) => {
        y(k, C, R);
      }
    };
    u.push(k), c++, d = setTimeout(v, r.rotate), t(S, e, k.callback);
  }
  return setTimeout(v), m;
}
function In(r) {
  const e = {
    ...Nc,
    ...r
  };
  let t = [];
  function i() {
    t = t.filter((o) => o().status === "pending");
  }
  function s(o, l, c) {
    const h = Dc(
      e,
      o,
      l,
      (d, u) => {
        i(), c && c(d, u);
      }
    );
    return t.push(h), h;
  }
  function a(o) {
    return t.find((l) => o(l)) || null;
  }
  return {
    query: s,
    find: a,
    setIndex: (o) => {
      e.index = o;
    },
    getIndex: () => e.index,
    cleanup: i
  };
}
function Ma() {
}
const ps = /* @__PURE__ */ Object.create(null);
function Hc(r) {
  if (!ps[r]) {
    const e = zr(r);
    if (!e)
      return;
    const t = In(e), i = {
      config: e,
      redundancy: t
    };
    ps[r] = i;
  }
  return ps[r];
}
function Yc(r, e, t) {
  let i, s;
  if (typeof r == "string") {
    const a = er(r);
    if (!a)
      return t(void 0, 424), Ma;
    s = a.send;
    const n = Hc(r);
    n && (i = n.redundancy);
  } else {
    const a = _r(r);
    if (a) {
      i = In(a);
      const n = r.resources ? r.resources[0] : "", o = er(n);
      o && (s = o.send);
    }
  }
  return !i || !s ? (t(void 0, 424), Ma) : i.query(e, s, t)().abort;
}
const Ra = "iconify2", yi = "iconify", En = yi + "-count", Pa = yi + "-version", Tn = 36e5, jc = 168;
function tr(r, e) {
  try {
    return r.getItem(e);
  } catch {
  }
}
function Fr(r, e, t) {
  try {
    return r.setItem(e, t), !0;
  } catch {
  }
}
function La(r, e) {
  try {
    r.removeItem(e);
  } catch {
  }
}
function ir(r, e) {
  return Fr(r, En, e.toString());
}
function sr(r) {
  return parseInt(tr(r, En)) || 0;
}
const is = {
  local: !0,
  session: !0
}, _n = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Nr = !1;
function Xc(r) {
  Nr = r;
}
let zi = typeof window > "u" ? {} : window;
function On(r) {
  const e = r + "Storage";
  try {
    if (zi && zi[e] && typeof zi[e].length == "number")
      return zi[e];
  } catch {
  }
  is[r] = !1;
}
function zn(r, e) {
  const t = On(r);
  if (!t)
    return;
  const i = tr(t, Pa);
  if (i !== Ra) {
    if (i) {
      const o = sr(t);
      for (let l = 0; l < o; l++)
        La(t, yi + l.toString());
    }
    Fr(t, Pa, Ra), ir(t, 0);
    return;
  }
  const s = Math.floor(Date.now() / Tn) - jc, a = (o) => {
    const l = yi + o.toString(), c = tr(t, l);
    if (typeof c == "string") {
      try {
        const h = JSON.parse(c);
        if (typeof h == "object" && typeof h.cached == "number" && h.cached > s && typeof h.provider == "string" && typeof h.data == "object" && typeof h.data.prefix == "string" && // Valid item: run callback
        e(h, o))
          return !0;
      } catch {
      }
      La(t, l);
    }
  };
  let n = sr(t);
  for (let o = n - 1; o >= 0; o--)
    a(o) || (o === n - 1 ? (n--, ir(t, n)) : _n[r].add(o));
}
function Fn() {
  if (!Nr) {
    Xc(!0);
    for (const r in is)
      zn(r, (e) => {
        const t = e.data, i = e.provider, s = t.prefix, a = Ht(
          i,
          s
        );
        if (!Tr(a, t).length)
          return !1;
        const n = t.lastModified || -1;
        return a.lastModifiedCached = a.lastModifiedCached ? Math.min(a.lastModifiedCached, n) : n, !0;
      });
  }
}
function Bc(r, e) {
  const t = r.lastModifiedCached;
  if (
    // Matches or newer
    t && t >= e
  )
    return t === e;
  if (r.lastModifiedCached = e, t)
    for (const i in is)
      zn(i, (s) => {
        const a = s.data;
        return s.provider !== r.provider || a.prefix !== r.prefix || a.lastModified === e;
      });
  return !0;
}
function Wc(r, e) {
  Nr || Fn();
  function t(i) {
    let s;
    if (!is[i] || !(s = On(i)))
      return;
    const a = _n[i];
    let n;
    if (a.size)
      a.delete(n = Array.from(a).shift());
    else if (n = sr(s), !ir(s, n + 1))
      return;
    const o = {
      cached: Math.floor(Date.now() / Tn),
      provider: r.provider,
      data: e
    };
    return Fr(
      s,
      yi + n.toString(),
      JSON.stringify(o)
    );
  }
  e.lastModified && !Bc(r, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), t("local") || t("session"));
}
function Ia() {
}
function Vc(r) {
  r.iconsLoaderFlag || (r.iconsLoaderFlag = !0, setTimeout(() => {
    r.iconsLoaderFlag = !1, _c(r);
  }));
}
function Gc(r, e) {
  r.iconsToLoad ? r.iconsToLoad = r.iconsToLoad.concat(e).sort() : r.iconsToLoad = e, r.iconsQueueFlag || (r.iconsQueueFlag = !0, setTimeout(() => {
    r.iconsQueueFlag = !1;
    const { provider: t, prefix: i } = r, s = r.iconsToLoad;
    delete r.iconsToLoad;
    let a;
    if (!s || !(a = er(t)))
      return;
    a.prepare(t, i, s).forEach((o) => {
      Yc(t, o, (l) => {
        if (typeof l != "object")
          o.icons.forEach((c) => {
            r.missing.add(c);
          });
        else
          try {
            const c = Tr(
              r,
              l
            );
            if (!c.length)
              return;
            const h = r.pendingIcons;
            h && c.forEach((d) => {
              h.delete(d);
            }), Wc(r, l);
          } catch (c) {
            console.error(c);
          }
        Vc(r);
      });
    });
  }));
}
const $c = (r, e) => {
  const t = Fc(r, !0, Mn()), i = Tc(t);
  if (!i.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        i.loaded,
        i.missing,
        i.pending,
        Ia
      );
    }), () => {
      l = !1;
    };
  }
  const s = /* @__PURE__ */ Object.create(null), a = [];
  let n, o;
  return i.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === o && c === n)
      return;
    n = c, o = h, a.push(Ht(c, h));
    const d = s[c] || (s[c] = /* @__PURE__ */ Object.create(null));
    d[h] || (d[h] = []);
  }), i.pending.forEach((l) => {
    const { provider: c, prefix: h, name: d } = l, u = Ht(c, h), g = u.pendingIcons || (u.pendingIcons = /* @__PURE__ */ new Set());
    g.has(d) || (g.add(d), s[c][h].push(d));
  }), a.forEach((l) => {
    const { provider: c, prefix: h } = l;
    s[c][h].length && Gc(l, s[c][h]);
  }), e ? zc(e, i, a) : Ia;
};
function Uc(r, e) {
  const t = {
    ...r
  };
  for (const i in e) {
    const s = e[i], a = typeof s;
    i in Rn ? (s === null || s && (a === "string" || a === "number")) && (t[i] = s) : a === typeof t[i] && (t[i] = i === "rotate" ? s % 4 : s);
  }
  return t;
}
const qc = /[\s,]+/;
function Zc(r, e) {
  e.split(qc).forEach((t) => {
    switch (t.trim()) {
      case "horizontal":
        r.hFlip = !0;
        break;
      case "vertical":
        r.vFlip = !0;
        break;
    }
  });
}
function Jc(r, e = 0) {
  const t = r.replace(/^-?[0-9.]*/, "");
  function i(s) {
    for (; s < 0; )
      s += 4;
    return s % 4;
  }
  if (t === "") {
    const s = parseInt(r);
    return isNaN(s) ? 0 : i(s);
  } else if (t !== r) {
    let s = 0;
    switch (t) {
      case "%":
        s = 25;
        break;
      case "deg":
        s = 90;
    }
    if (s) {
      let a = parseFloat(r.slice(0, r.length - t.length));
      return isNaN(a) ? 0 : (a = a / s, a % 1 === 0 ? i(a) : 0);
    }
  }
  return e;
}
function Kc(r, e) {
  let t = r.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const i in e)
    t += " " + i + '="' + e[i] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + t + ">" + r + "</svg>";
}
function Qc(r) {
  return r.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function eh(r) {
  return "data:image/svg+xml," + Qc(r);
}
function th(r) {
  return 'url("' + eh(r) + '")';
}
let pi;
function ih() {
  try {
    pi = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (r) => r
    });
  } catch {
    pi = null;
  }
}
function sh(r) {
  return pi === void 0 && ih(), pi ? pi.createHTML(r) : r;
}
const Nn = {
  ...Pn,
  inline: !1
}, rh = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, ah = {
  display: "inline-block"
}, rr = {
  backgroundColor: "currentColor"
}, Dn = {
  backgroundColor: "transparent"
}, Ea = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, Ta = {
  WebkitMask: rr,
  mask: rr,
  background: Dn
};
for (const r in Ta) {
  const e = Ta[r];
  for (const t in Ea)
    e[r + t] = Ea[t];
}
const nh = {
  ...Nn,
  inline: !0
};
function _a(r) {
  return r + (r.match(/^[-0-9.]+$/) ? "px" : "");
}
const oh = (r, e, t, i) => {
  const s = t ? nh : Nn, a = Uc(s, e), n = e.mode || "svg", o = {}, l = e.style || {}, c = {
    ...n === "svg" ? rh : {},
    ref: i
  };
  for (let m in e) {
    const b = e[m];
    if (b !== void 0)
      switch (m) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          a[m] = b === !0 || b === "true" || b === 1;
          break;
        case "flip":
          typeof b == "string" && Zc(a, b);
          break;
        case "color":
          o.color = b;
          break;
        case "rotate":
          typeof b == "string" ? a[m] = Jc(b) : typeof b == "number" && (a[m] = b);
          break;
        case "ariaHidden":
        case "aria-hidden":
          b !== !0 && b !== "true" && delete c["aria-hidden"];
          break;
        default:
          s[m] === void 0 && (c[m] = b);
      }
  }
  const h = bc(r, a), d = h.attributes;
  if (a.inline && (o.verticalAlign = "-0.125em"), n === "svg") {
    c.style = {
      ...o,
      ...l
    }, Object.assign(c, d);
    let m = 0, b = e.id;
    return typeof b == "string" && (b = b.replace(/-/g, "_")), c.dangerouslySetInnerHTML = {
      __html: sh(Sc(h.body, b ? () => b + "ID" + m++ : "iconifyReact"))
    }, Xe.createElement("svg", c);
  }
  const { body: u, width: g, height: p } = r, f = n === "mask" || (n === "bg" ? !1 : u.indexOf("currentColor") !== -1), x = Kc(u, {
    ...d,
    width: g + "",
    height: p + ""
  });
  return c.style = {
    ...o,
    "--svg": th(x),
    width: _a(d.width),
    height: _a(d.height),
    ...ah,
    ...f ? rr : Dn,
    ...l
  }, Xe.createElement("span", c);
};
Mn(!0);
kc("", Ec);
if (typeof document < "u" && typeof window < "u") {
  Fn();
  const r = window;
  if (r.IconifyPreload !== void 0) {
    const e = r.IconifyPreload, t = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((i) => {
      try {
        // Check if item is an object and not null/array
        (typeof i != "object" || i === null || i instanceof Array || // Check for 'icons' and 'prefix'
        typeof i.icons != "object" || typeof i.prefix != "string" || // Add icon set
        !fc(i)) && console.error(t);
      } catch {
        console.error(t);
      }
    });
  }
  if (r.IconifyProviders !== void 0) {
    const e = r.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let t in e) {
        const i = "IconifyProviders[" + t + "] is invalid.";
        try {
          const s = e[t];
          if (typeof s != "object" || !s || s.resources === void 0)
            continue;
          Cc(t, s) || console.error(i);
        } catch {
          console.error(i);
        }
      }
  }
}
class Hn extends Xe.Component {
  constructor(e) {
    super(e), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(e) {
    this.state.icon !== e && this.setState({
      icon: e
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(e) {
    const t = this.state, i = this.props.icon;
    if (typeof i == "object" && i !== null && typeof i.body == "string") {
      this._icon = "", this._abortLoading(), (e || t.icon === null) && this._setData({
        data: i
      });
      return;
    }
    let s;
    if (typeof i != "string" || (s = ts(i, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const a = uc(s);
    if (!a) {
      (!this._loading || this._loading.name !== i) && (this._abortLoading(), this._icon = "", this._setData(null), a !== null && (this._loading = {
        name: i,
        abort: $c([s], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== i || t.icon === null) {
      this._abortLoading(), this._icon = i;
      const n = ["iconify"];
      s.prefix !== "" && n.push("iconify--" + s.prefix), s.provider !== "" && n.push("iconify--" + s.provider), this._setData({
        data: a,
        classes: n
      }), this.props.onLoad && this.props.onLoad(i);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(e) {
    e.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const e = this.props, t = this.state.icon;
    if (t === null)
      return e.children ? e.children : Xe.createElement("span", {});
    let i = e;
    return t.classes && (i = {
      ...e,
      className: (typeof e.className == "string" ? e.className + " " : "") + t.classes.join(" ")
    }), oh({
      ...Er,
      ...t.data
    }, i, e._inline, e._ref);
  }
}
const Ee = Xe.forwardRef(function(e, t) {
  const i = {
    ...e,
    _ref: t,
    _inline: !1
  };
  return Xe.createElement(Hn, i);
});
Xe.forwardRef(function(e, t) {
  const i = {
    ...e,
    _ref: t,
    _inline: !0
  };
  return Xe.createElement(Hn, i);
});
const lh = gt(
  "rounded-md border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      inputSize: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      inputSize: "md",
      fullWidth: !0
    }
  }
), Yn = Ue(
  ({
    className: r,
    wrapperClassName: e,
    variant: t = "default",
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    error: n = !1,
    errorText: o,
    helperText: l,
    label: c,
    required: h = !1,
    labelPlacement: d = "top",
    fullWidth: u = !0,
    id: g,
    ...p
  }, f) => {
    const x = g || Xe.useId(), m = `${x}-helper`, b = `${x}-error`, w = /* @__PURE__ */ M.jsxs("div", { className: ie("relative", !u && "inline-block"), children: [
      s && /* @__PURE__ */ M.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ M.jsx(Ee, { icon: s, className: "w-4 h-4" }) }),
      /* @__PURE__ */ M.jsx(
        "input",
        {
          id: x,
          type: "text",
          ref: f,
          className: ie(
            lh({ variant: n ? "error" : t, inputSize: i, fullWidth: u }),
            s && "pl-10",
            a && "pr-10",
            r
          ),
          "aria-describedby": n ? b : l ? m : void 0,
          "aria-invalid": n,
          "aria-required": h,
          ...p
        }
      ),
      a && /* @__PURE__ */ M.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ M.jsx(Ee, { icon: a, className: "w-4 h-4" }) })
    ] }), y = /* @__PURE__ */ M.jsxs(M.Fragment, { children: [
      n && o && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-xs text-danger-500", id: b, children: o }),
      !n && l && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-xs text-neutral-500", id: m, children: l })
    ] });
    return d === "left" ? /* @__PURE__ */ M.jsx("div", { className: ie(u ? "w-full" : "inline-block", e), children: /* @__PURE__ */ M.jsxs("div", { className: "flex items-start gap-4", children: [
      c && /* @__PURE__ */ M.jsxs(
        "label",
        {
          htmlFor: x,
          className: "block text-sm text-neutral-900 pt-2",
          children: [
            c,
            h && /* @__PURE__ */ M.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ M.jsxs("div", { className: ie("flex-1", !u && "inline-block"), children: [
        w,
        y
      ] })
    ] }) }) : /* @__PURE__ */ M.jsxs("div", { className: ie(u ? "w-full" : "inline-block", e), children: [
      c && /* @__PURE__ */ M.jsxs(
        "label",
        {
          htmlFor: x,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            c,
            h && /* @__PURE__ */ M.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
          ]
        }
      ),
      w,
      y
    ] });
  }
);
Yn.displayName = "Input";
const ss = Xe.forwardRef(
  ({ className: r, children: e, selected: t, disabled: i, ...s }, a) => /* @__PURE__ */ M.jsx(
    "div",
    {
      ref: a,
      className: ie(
        "relative flex w-full cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors",
        "hover:bg-primary-50",
        t && "bg-primary-50 text-primary-900",
        i && "pointer-events-none opacity-50",
        r
      ),
      ...s,
      children: e
    }
  )
);
ss.displayName = "SelectItem";
const xs = "autocomplete-dropdown-opened", ch = gt(
  "fixed z-[9999] min-w-[8rem] rounded-md border border-neutral-200 bg-white py-1 shadow-lg",
  {
    variants: {
      position: {
        bottom: "top-full",
        top: "bottom-full"
      }
    },
    defaultVariants: {
      position: "bottom"
    }
  }
), hh = Ue(
  ({
    className: r,
    options: e,
    onSelect: t,
    isOpen: i,
    dropdownPosition: s = "bottom",
    loading: a = !1,
    renderOption: n,
    variant: o = "default",
    size: l = "md",
    leftIcon: c,
    rightIcon: h,
    error: d = !1,
    errorText: u,
    helperText: g,
    label: p,
    required: f = !1,
    labelPlacement: x = "top",
    fullWidth: m = !1,
    value: b,
    onChange: w,
    onFocus: y,
    onBlur: v,
    showClear: S = !1,
    onClear: k,
    ...C
  }, R) => {
    const [P, A] = Ie(!1), [E, N] = Ie(b || ""), O = $e(null), L = $e(null), I = $e(null), F = i !== void 0, Y = `autocomplete-${Xe.useId().replace(/:/g, "")}`, _ = () => {
      if (!P || !L.current || !I.current) return;
      const { bottom: ae, top: W, left: fe, width: _e } = L.current.getBoundingClientRect(), He = I.current, it = {
        position: "fixed",
        left: `${fe}px`,
        width: `${_e}px`
      }, _i = s === "bottom" ? {
        ...it,
        top: `${ae + 4}px`,
        maxHeight: `${window.innerHeight - ae - 8}px`
      } : {
        ...it,
        bottom: `${window.innerHeight - W + 4}px`,
        maxHeight: `${W - 8}px`
      };
      Object.assign(He.style, _i);
    };
    ut(() => {
      N(b || "");
    }, [b]), ut(() => {
      const ae = () => {
        P && _();
      }, W = () => {
        P && _();
      }, fe = (He) => {
        He.detail.id !== Y && A(!1);
      }, _e = (He) => {
        const it = He.target;
        O.current && !O.current.contains(it) && I.current && !I.current.contains(it) && A(!1);
      };
      return P && (_(), window.addEventListener("scroll", ae, !0), window.addEventListener("resize", W)), document.addEventListener(xs, fe), document.addEventListener("click", _e), () => {
        window.removeEventListener("scroll", ae, !0), window.removeEventListener("resize", W), document.removeEventListener(xs, fe), document.removeEventListener("click", _e);
      };
    }, [P, Y]);
    const H = (ae) => {
      const { value: W } = ae.target;
      if (N(W), !W.trim()) {
        A(!1);
        return;
      }
      A(!0), w == null || w(ae);
    }, V = (ae) => {
      ae.stopPropagation(), N(""), k == null || k();
      const W = new Event("change");
      W.target = { value: "" }, w == null || w(W);
    }, Z = (ae) => {
      var He;
      if (!ae) return;
      const { value: W, label: fe } = ae;
      N(fe), A(!1), t == null || t(W);
      const _e = new CustomEvent("autocomplete-select", {
        detail: { selectedOption: ae }
      });
      (He = L.current) == null || He.dispatchEvent(_e);
    }, X = (ae) => {
      F || (document.dispatchEvent(
        new CustomEvent(xs, {
          detail: { id: Y }
        })
      ), A(!0)), y == null || y(ae);
    }, J = (ae) => {
      v == null || v(ae);
    }, G = e.filter(
      ({ label: ae }) => ae.toLowerCase().includes((E || "").toLowerCase().trim())
    ), $ = F ? i : P, K = S && E && !C.disabled && !C.readOnly, re = K ? "mdi:close" : h, Q = () => {
      if (!$) return null;
      const ae = /* @__PURE__ */ M.jsx(
        "div",
        {
          ref: I,
          className: ie(
            ch({ position: s }),
            "overflow-auto"
          ),
          onClick: (W) => W.stopPropagation(),
          children: a ? /* @__PURE__ */ M.jsx("div", { className: "flex items-center justify-center py-2", children: /* @__PURE__ */ M.jsx("div", { className: "h-4 w-4 animate-spin rounded-full border-2 border-primary-500 border-t-transparent" }) }) : G.length > 0 ? G.map((W) => /* @__PURE__ */ M.jsx(
            ss,
            {
              value: W.value,
              selected: W.label === E,
              onClick: () => Z(W),
              children: n ? n(W) : W.label
            },
            W.value
          )) : /* @__PURE__ */ M.jsx("div", { className: "px-2 py-2 text-sm text-neutral-500", children: "No options found" })
        }
      );
      return Qt(ae, document.body);
    };
    return /* @__PURE__ */ M.jsxs("div", { ref: O, className: ie("relative", m ? "w-full" : "inline-block"), children: [
      /* @__PURE__ */ M.jsx("div", { ref: L, className: ie(!m && "inline-block"), children: /* @__PURE__ */ M.jsx(
        Yn,
        {
          ref: R,
          value: E,
          onChange: H,
          onFocus: X,
          onBlur: J,
          variant: o,
          size: l,
          leftIcon: c,
          rightIcon: re,
          error: d,
          errorText: u,
          helperText: g,
          label: p,
          required: f,
          labelPlacement: x,
          fullWidth: m,
          className: r,
          ...C,
          onClick: K ? V : C.onClick
        }
      ) }),
      Q()
    ] });
  }
);
hh.displayName = "AutoComplete";
const gg = ({
  items: r,
  multiple: e = !1,
  defaultOpenIds: t = [],
  icon: i = "mdi:chevron-down",
  iconPosition: s = "right",
  className: a,
  itemClassName: n,
  headerClassName: o,
  contentClassName: l
}) => {
  const [c, h] = Ie(t), d = (u) => {
    h(
      e ? (g) => g.includes(u) ? g.filter((p) => p !== u) : [...g, u] : (g) => g.includes(u) ? [] : [u]
    );
  };
  return /* @__PURE__ */ M.jsx("div", { className: xe("w-full space-y-2", a), children: r.map((u) => {
    const g = c.includes(u.id), p = !!u.disabled;
    return /* @__PURE__ */ M.jsxs(
      "div",
      {
        className: xe(
          "border rounded-lg overflow-hidden",
          "bg-white",
          "border-gray-200",
          n
        ),
        children: [
          /* @__PURE__ */ M.jsxs(
            "button",
            {
              onClick: () => !p && d(u.id),
              disabled: p,
              className: xe(
                "w-full flex items-center justify-between p-4",
                "text-left transition-colors",
                "hover:bg-primary-50",
                p && "opacity-50 cursor-not-allowed",
                o
              ),
              children: [
                s === "left" && /* @__PURE__ */ M.jsx(
                  "div",
                  {
                    className: xe(
                      "mr-3 transition-transform duration-200",
                      g && "rotate-180"
                    ),
                    children: /* @__PURE__ */ M.jsx(Ee, { icon: i, className: "w-5 h-5" })
                  }
                ),
                /* @__PURE__ */ M.jsx("div", { className: "flex-1", children: u.title }),
                s === "right" && /* @__PURE__ */ M.jsx(
                  "div",
                  {
                    className: xe(
                      "ml-3 transition-transform duration-200",
                      g && "rotate-180"
                    ),
                    children: /* @__PURE__ */ M.jsx(Ee, { icon: i, className: "w-5 h-5" })
                  }
                )
              ]
            }
          ),
          g && /* @__PURE__ */ M.jsx(
            "div",
            {
              className: xe(
                "p-4 border-t border-gray-200",
                l
              ),
              children: u.content
            }
          )
        ]
      },
      u.id
    );
  }) });
}, fg = ({
  src: r,
  alt: e = "avatar",
  size: t = "medium",
  shape: i = "circle",
  className: s = ""
}) => {
  const a = {
    small: "w-8 h-8",
    medium: "w-12 h-12",
    large: "w-16 h-16"
  }, n = {
    circle: "rounded-full",
    square: "rounded-lg"
  }, o = Dt(
    "inline-flex items-center justify-center overflow-hidden bg-gray-200",
    a[t],
    n[i],
    s
  );
  return /* @__PURE__ */ M.jsx("div", { className: o, children: r ? /* @__PURE__ */ M.jsx("img", { src: r, alt: e, className: "w-full h-full object-cover" }) : /* @__PURE__ */ M.jsx(
    "svg",
    {
      className: "w-6 h-6 text-gray-500",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ M.jsx(
        "path",
        {
          d: "M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z",
          fill: "currentColor"
        }
      )
    }
  ) });
}, pg = ({
  children: r,
  variant: e = "primary",
  size: t = "medium",
  className: i = ""
}) => {
  const s = {
    primary: "bg-blue-100 text-blue-800",
    secondary: "bg-gray-100 text-gray-800",
    success: "bg-green-100 text-green-800",
    warning: "bg-yellow-100 text-yellow-800",
    error: "bg-red-100 text-red-800"
  }, a = {
    small: "px-2 py-0.5 text-xs",
    medium: "px-2.5 py-1 text-sm",
    large: "px-3 py-1.5 text-base"
  }, n = Dt(
    "inline-flex items-center font-medium rounded-full",
    s[e],
    a[t],
    i
  );
  return /* @__PURE__ */ M.jsx("span", { className: n, children: r });
}, dh = gt(
  "inline-flex items-center justify-center gap-2 font-medium transition-all duration-200 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed",
  {
    variants: {
      variant: {
        primary: "bg-primary-500 text-white hover:bg-primary-600 active:bg-primary-700 shadow-sm hover:shadow-md active:shadow-none",
        secondary: "bg-secondary-500 text-white hover:bg-secondary-600 active:bg-secondary-700 shadow-sm hover:shadow-md active:shadow-none",
        outline: "border border-neutral-300 text-primary-500 hover:bg-primary-50 active:bg-primary-100 hover:border-primary-500",
        "outline-primary": "border border-primary-600 text-primary-600 hover:bg-primary-50",
        "outline-secondary": "border border-secondary-600 text-secondary-600 hover:bg-secondary-50",
        "outline-success": "border border-success-600 text-success-600 hover:bg-success-50",
        "outline-warning": "border border-warning-600 text-warning-600 hover:bg-warning-50",
        "outline-danger": "border border-danger-600 text-danger-600 hover:bg-danger-50",
        ghost: "text-primary-500 hover:bg-primary-50 active:bg-primary-100",
        link: "text-primary-500 hover:underline p-0",
        success: "bg-success-500 text-white hover:bg-success-600 active:bg-success-700 shadow-sm hover:shadow-md active:shadow-none",
        warning: "bg-warning-500 text-white hover:bg-warning-600 active:bg-warning-700 shadow-sm hover:shadow-md active:shadow-none",
        danger: "bg-danger-500 text-white hover:bg-danger-600 active:bg-danger-700 shadow-sm hover:shadow-md active:shadow-none"
      },
      size: {
        xs: "text-xs px-2 py-1",
        sm: "text-sm px-3 py-1.5",
        md: "text-base px-4 py-2",
        lg: "text-lg px-5 py-2.5"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      rounded: "none",
      fullWidth: !1
    }
  }
), mt = Ue(
  ({
    className: r,
    variant: e = "primary",
    size: t = "md",
    rounded: i = "md",
    fullWidth: s = !1,
    isLoading: a = !1,
    leftIcon: n,
    rightIcon: o,
    children: l,
    ...c
  }, h) => /* @__PURE__ */ M.jsxs(
    "button",
    {
      className: ie(dh({ variant: e, size: t, rounded: i, fullWidth: s, className: r })),
      ref: h,
      disabled: c.disabled || a,
      ...c,
      children: [
        a && /* @__PURE__ */ M.jsx("span", { className: "animate-spin inline-block w-4 h-4 border-2 border-current border-r-transparent rounded-full" }),
        !a && n && /* @__PURE__ */ M.jsx(Ee, { icon: n, className: "w-4 h-4" }),
        /* @__PURE__ */ M.jsx("span", { children: l }),
        !a && o && /* @__PURE__ */ M.jsx(Ee, { icon: o, className: "w-4 h-4" })
      ]
    }
  )
);
mt.displayName = "Button";
const uh = gt(
  "border bg-card text-card-foreground",
  {
    variants: {
      variant: {
        default: "border-border shadow-sm",
        elevated: "border-border shadow-lg",
        outline: "border-border bg-transparent",
        ghost: "border-transparent bg-transparent"
      },
      padding: {
        none: "p-0",
        sm: "p-4",
        md: "p-6",
        lg: "p-8"
      },
      shadow: {
        none: "",
        sm: "shadow-sm",
        md: "shadow-md",
        lg: "shadow-lg",
        xl: "shadow-xl"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      padding: "md",
      shadow: "sm",
      rounded: "md"
    }
  }
), jn = Ue(
  ({
    className: r,
    variant: e = "default",
    padding: t = "md",
    shadow: i = "none",
    rounded: s = "md",
    asChild: a = !1,
    ...n
  }, o) => /* @__PURE__ */ M.jsx(
    "div",
    {
      className: ie(uh({ variant: e, padding: t, shadow: i, rounded: s, className: r })),
      ref: o,
      ...n
    }
  )
);
jn.displayName = "Card";
var Xn = {};
/*!
 * ApexCharts v4.7.0
 * (c) 2018-2025 ApexCharts
 * Released under the MIT License.
 */
function ar(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, i = Array(e); t < e; t++) i[t] = r[t];
  return i;
}
function Bn(r) {
  if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function ee(r, e) {
  if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function Oa(r, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, Gn(i.key), i);
  }
}
function te(r, e, t) {
  return e && Oa(r.prototype, e), t && Oa(r, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function gi(r, e) {
  var t = typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = Dr(r)) || e) {
      t && (r = t);
      var i = 0, s = function() {
      };
      return { s, n: function() {
        return i >= r.length ? { done: !0 } : { done: !1, value: r[i++] };
      }, e: function(l) {
        throw l;
      }, f: s };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, n = !0, o = !1;
  return { s: function() {
    t = t.call(r);
  }, n: function() {
    var l = t.next();
    return n = l.done, l;
  }, e: function(l) {
    o = !0, a = l;
  }, f: function() {
    try {
      n || t.return == null || t.return();
    } finally {
      if (o) throw a;
    }
  } };
}
function Ri(r) {
  var e = Wn();
  return function() {
    var t, i = Ji(r);
    if (e) {
      var s = Ji(this).constructor;
      t = Reflect.construct(i, arguments, s);
    } else t = i.apply(this, arguments);
    return function(a, n) {
      if (n && (typeof n == "object" || typeof n == "function")) return n;
      if (n !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return Bn(a);
    }(this, t);
  };
}
function Zi(r, e, t) {
  return (e = Gn(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = t, r;
}
function Ji(r) {
  return Ji = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Ji(r);
}
function Pi(r, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  r.prototype = Object.create(e && e.prototype, { constructor: { value: r, writable: !0, configurable: !0 } }), Object.defineProperty(r, "prototype", { writable: !1 }), e && nr(r, e);
}
function Wn() {
  try {
    var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Wn = function() {
    return !!r;
  })();
}
function za(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function q(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? za(Object(t), !0).forEach(function(i) {
      Zi(r, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : za(Object(t)).forEach(function(i) {
      Object.defineProperty(r, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return r;
}
function nr(r, e) {
  return nr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, i) {
    return t.__proto__ = i, t;
  }, nr(r, e);
}
function Vn(r, e) {
  return function(t) {
    if (Array.isArray(t)) return t;
  }(r) || function(t, i) {
    var s = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (s != null) {
      var a, n, o, l, c = [], h = !0, d = !1;
      try {
        if (o = (s = s.call(t)).next, i === 0) {
          if (Object(s) !== s) return;
          h = !1;
        } else for (; !(h = (a = o.call(s)).done) && (c.push(a.value), c.length !== i); h = !0) ;
      } catch (u) {
        d = !0, n = u;
      } finally {
        try {
          if (!h && s.return != null && (l = s.return(), Object(l) !== l)) return;
        } finally {
          if (d) throw n;
        }
      }
      return c;
    }
  }(r, e) || Dr(r, e) || function() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function De(r) {
  return function(e) {
    if (Array.isArray(e)) return ar(e);
  }(r) || function(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }(r) || Dr(r) || function() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function Gn(r) {
  var e = function(t, i) {
    if (typeof t != "object" || !t) return t;
    var s = t[Symbol.toPrimitive];
    if (s !== void 0) {
      var a = s.call(t, i);
      if (typeof a != "object") return a;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (i === "string" ? String : Number)(t);
  }(r, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Zt(r) {
  return Zt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Zt(r);
}
function Dr(r, e) {
  if (r) {
    if (typeof r == "string") return ar(r, e);
    var t = {}.toString.call(r).slice(8, -1);
    return t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set" ? Array.from(r) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ar(r, e) : void 0;
  }
}
var z = function() {
  function r() {
    ee(this, r);
  }
  return te(r, [{ key: "shadeRGBColor", value: function(e, t) {
    var i = t.split(","), s = e < 0 ? 0 : 255, a = e < 0 ? -1 * e : e, n = parseInt(i[0].slice(4), 10), o = parseInt(i[1], 10), l = parseInt(i[2], 10);
    return "rgb(" + (Math.round((s - n) * a) + n) + "," + (Math.round((s - o) * a) + o) + "," + (Math.round((s - l) * a) + l) + ")";
  } }, { key: "shadeHexColor", value: function(e, t) {
    var i = parseInt(t.slice(1), 16), s = e < 0 ? 0 : 255, a = e < 0 ? -1 * e : e, n = i >> 16, o = i >> 8 & 255, l = 255 & i;
    return "#" + (16777216 + 65536 * (Math.round((s - n) * a) + n) + 256 * (Math.round((s - o) * a) + o) + (Math.round((s - l) * a) + l)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(e, t) {
    return r.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t);
  } }], [{ key: "bind", value: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  } }, { key: "isObject", value: function(e) {
    return e && Zt(e) === "object" && !Array.isArray(e) && e != null;
  } }, { key: "is", value: function(e, t) {
    return Object.prototype.toString.call(t) === "[object " + e + "]";
  } }, { key: "isSafari", value: function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  } }, { key: "listToArray", value: function(e) {
    var t, i = [];
    for (t = 0; t < e.length; t++) i[t] = e[t];
    return i;
  } }, { key: "extend", value: function(e, t) {
    var i = this;
    typeof Object.assign != "function" && (Object.assign = function(a) {
      if (a == null) throw new TypeError("Cannot convert undefined or null to object");
      for (var n = Object(a), o = 1; o < arguments.length; o++) {
        var l = arguments[o];
        if (l != null) for (var c in l) l.hasOwnProperty(c) && (n[c] = l[c]);
      }
      return n;
    });
    var s = Object.assign({}, e);
    return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach(function(a) {
      i.isObject(t[a]) && a in e ? s[a] = i.extend(e[a], t[a]) : Object.assign(s, Zi({}, a, t[a]));
    }), s;
  } }, { key: "extendArray", value: function(e, t) {
    var i = [];
    return e.map(function(s) {
      i.push(r.extend(t, s));
    }), e = i;
  } }, { key: "monthMod", value: function(e) {
    return e % 12;
  } }, { key: "clone", value: function(e) {
    var t, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new WeakMap();
    if (e === null || Zt(e) !== "object") return e;
    if (i.has(e)) return i.get(e);
    if (Array.isArray(e)) {
      t = [], i.set(e, t);
      for (var s = 0; s < e.length; s++) t[s] = this.clone(e[s], i);
    } else if (e instanceof Date) t = new Date(e.getTime());
    else for (var a in t = {}, i.set(e, t), e) e.hasOwnProperty(a) && (t[a] = this.clone(e[a], i));
    return t;
  } }, { key: "log10", value: function(e) {
    return Math.log(e) / Math.LN10;
  } }, { key: "roundToBase10", value: function(e) {
    return Math.pow(10, Math.floor(Math.log10(e)));
  } }, { key: "roundToBase", value: function(e, t) {
    return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)));
  } }, { key: "parseNumber", value: function(e) {
    return e === null ? e : parseFloat(e);
  } }, { key: "stripNumber", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t));
  } }, { key: "randomId", value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: "noExponents", value: function(e) {
    return e.toString().includes("e") ? Math.round(e) : e;
  } }, { key: "elementExists", value: function(e) {
    return !(!e || !e.isConnected);
  } }, { key: "getDimensions", value: function(e) {
    var t = getComputedStyle(e, null), i = e.clientHeight, s = e.clientWidth;
    return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), [s -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), i];
  } }, { key: "getBoundingClientRect", value: function(e) {
    var t = e.getBoundingClientRect();
    return { top: t.top, right: t.right, bottom: t.bottom, left: t.left, width: e.clientWidth, height: e.clientHeight, x: t.left, y: t.top };
  } }, { key: "getLargestStringFromArr", value: function(e) {
    return e.reduce(function(t, i) {
      return Array.isArray(i) && (i = i.reduce(function(s, a) {
        return s.length > a.length ? s : a;
      })), t.length > i.length ? t : i;
    }, 0);
  } }, { key: "hexToRgba", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
    e.substring(0, 1) !== "#" && (e = "#999999");
    var i = e.replace("#", "");
    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
    for (var s = 0; s < i.length; s++) i[s] = parseInt(i[s].length === 1 ? i[s] + i[s] : i[s], 16);
    return t !== void 0 && i.push(t), "rgba(" + i.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(e) {
    return parseFloat(e.replace(/^.*,(.+)\)/, "$1"));
  } }, { key: "rgb2hex", value: function(e) {
    return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && e.length === 4 ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(e) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e);
  } }, { key: "getPolygonPos", value: function(e, t) {
    for (var i = [], s = 2 * Math.PI / t, a = 0; a < t; a++) {
      var n = {};
      n.x = e * Math.sin(a * s), n.y = -e * Math.cos(a * s), i.push(n);
    }
    return i;
  } }, { key: "polarToCartesian", value: function(e, t, i, s) {
    var a = (s - 90) * Math.PI / 180;
    return { x: e + i * Math.cos(a), y: t + i * Math.sin(a) };
  } }, { key: "escapeString", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i = e.toString().slice();
    return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t);
  } }, { key: "negToZero", value: function(e) {
    return e < 0 ? 0 : e;
  } }, { key: "moveIndexInArray", value: function(e, t, i) {
    if (i >= e.length) for (var s = i - e.length + 1; s--; ) e.push(void 0);
    return e.splice(i, 0, e.splice(t, 1)[0]), e;
  } }, { key: "extractNumber", value: function(e) {
    return parseFloat(e.replace(/[^\d.]*/g, ""));
  } }, { key: "findAncestor", value: function(e, t) {
    for (; (e = e.parentElement) && !e.classList.contains(t); ) ;
    return e;
  } }, { key: "setELstyles", value: function(e, t) {
    for (var i in t) t.hasOwnProperty(i) && (e.style.key = t[i]);
  } }, { key: "preciseAddition", value: function(e, t) {
    var i = (String(e).split(".")[1] || "").length, s = (String(t).split(".")[1] || "").length, a = Math.pow(10, Math.max(i, s));
    return (Math.round(e * a) + Math.round(t * a)) / a;
  } }, { key: "isNumber", value: function(e) {
    return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10));
  } }, { key: "isFloat", value: function(e) {
    return Number(e) === e && e % 1 != 0;
  } }, { key: "isMsEdge", value: function() {
    var e = window.navigator.userAgent, t = e.indexOf("Edge/");
    return t > 0 && parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
  } }, { key: "getGCD", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7, s = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    for (e = Math.round(Math.abs(e) * s), t = Math.round(Math.abs(t) * s); t; ) {
      var a = t;
      t = e % t, e = a;
    }
    return e / s;
  } }, { key: "getPrimeFactors", value: function(e) {
    for (var t = [], i = 2; e >= 2; ) e % i == 0 ? (t.push(i), e /= i) : i++;
    return t;
  } }, { key: "mod", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7, s = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    return (e = Math.round(Math.abs(e) * s)) % (t = Math.round(Math.abs(t) * s)) / s;
  } }]), r;
}(), ti = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "animateLine", value: function(e, t, i, s) {
    e.attr(t).animate(s).attr(i);
  } }, { key: "animateMarker", value: function(e, t, i, s) {
    e.attr({ opacity: 0 }).animate(t).attr({ opacity: 1 }).after(function() {
      s();
    });
  } }, { key: "animateRect", value: function(e, t, i, s, a) {
    e.attr(t).animate(s).attr(i).after(function() {
      return a();
    });
  } }, { key: "animatePathsGradually", value: function(e) {
    var t = e.el, i = e.realIndex, s = e.j, a = e.fill, n = e.pathFrom, o = e.pathTo, l = e.speed, c = e.delay, h = this.w, d = 0;
    h.config.chart.animations.animateGradually.enabled && (d = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && h.config.chart.type !== "bar" && (d = 0), this.morphSVG(t, i, s, h.config.chart.type !== "line" || h.globals.comboCharts ? a : "stroke", n, o, l, c * d);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach(function(e) {
      var t = e.el;
      t.classList.remove("apexcharts-element-hidden"), t.classList.add("apexcharts-hidden-element-shown");
    });
  } }, { key: "animationCompleted", value: function(e) {
    var t = this.w;
    t.globals.animationEnded || (t.globals.animationEnded = !0, this.showDelayedElements(), typeof t.config.chart.events.animationEnd == "function" && t.config.chart.events.animationEnd(this.ctx, { el: e, w: t }));
  } }, { key: "morphSVG", value: function(e, t, i, s, a, n, o, l) {
    var c = this, h = this.w;
    a || (a = e.attr("pathFrom")), n || (n = e.attr("pathTo"));
    var d = function(u) {
      return h.config.chart.type === "radar" && (o = 1), "M 0 ".concat(h.globals.gridHeight);
    };
    (!a || a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = d()), (!n.trim() || n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = d()), h.globals.shouldAnimate || (o = 1), e.plot(a).animate(1, l).plot(a).animate(o, l).plot(n).after(function() {
      z.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && c.animationCompleted(e) : s !== "none" && h.globals.shouldAnimate && (!h.globals.comboCharts && t === h.globals.series.length - 1 || h.globals.comboCharts) && c.animationCompleted(e), c.showDelayedElements();
    });
  } }]), r;
}();
const or = {}, $n = [];
function ge(r, e) {
  if (Array.isArray(r)) for (const t of r) ge(t, e);
  else if (typeof r != "object") Un(Object.getOwnPropertyNames(e)), or[r] = Object.assign(or[r] || {}, e);
  else for (const t in r) ge(t, r[t]);
}
function Je(r) {
  return or[r] || {};
}
function Un(r) {
  $n.push(...r);
}
function Hr(r, e) {
  let t;
  const i = r.length, s = [];
  for (t = 0; t < i; t++) s.push(e(r[t]));
  return s;
}
function ms(r) {
  return r % 360 * Math.PI / 180;
}
function ii(r) {
  return r.charAt(0).toUpperCase() + r.slice(1);
}
function si(r, e, t, i) {
  return e != null && t != null || (i = i || r.bbox(), e == null ? e = i.width / i.height * t : t == null && (t = i.height / i.width * e)), { width: e, height: t };
}
function lr(r, e) {
  const t = r.origin;
  let i = r.ox != null ? r.ox : r.originX != null ? r.originX : "center", s = r.oy != null ? r.oy : r.originY != null ? r.originY : "center";
  t != null && ([i, s] = Array.isArray(t) ? t : typeof t == "object" ? [t.x, t.y] : [t, t]);
  const a = typeof i == "string", n = typeof s == "string";
  if (a || n) {
    const { height: o, width: l, x: c, y: h } = e.bbox();
    a && (i = i.includes("left") ? c : i.includes("right") ? c + l : c + l / 2), n && (s = s.includes("top") ? h : s.includes("bottom") ? h + o : h + o / 2);
  }
  return [i, s];
}
const gh = /* @__PURE__ */ new Set(["desc", "metadata", "title"]), cr = (r) => gh.has(r.nodeName), qn = (r, e, t = {}) => {
  const i = { ...e };
  for (const s in i) i[s].valueOf() === t[s] && delete i[s];
  Object.keys(i).length ? r.node.setAttribute("data-svgjs", JSON.stringify(i)) : (r.node.removeAttribute("data-svgjs"), r.node.removeAttribute("svgjs:data"));
}, Yr = "http://www.w3.org/2000/svg", bs = "http://www.w3.org/2000/xmlns/", ri = "http://www.w3.org/1999/xlink", be = { window: typeof window > "u" ? null : window, document: typeof document > "u" ? null : document };
function Li() {
  return be.window;
}
let jr = class {
};
const Nt = {}, Xr = "___SYMBOL___ROOT___";
function wi(r, e = Yr) {
  return be.document.createElementNS(e, r);
}
function Ge(r, e = !1) {
  if (r instanceof jr) return r;
  if (typeof r == "object") return vs(r);
  if (r == null) return new Nt[Xr]();
  if (typeof r == "string" && r.charAt(0) !== "<") return vs(be.document.querySelector(r));
  const t = e ? be.document.createElement("div") : wi("svg");
  return t.innerHTML = r, r = vs(t.firstChild), t.removeChild(t.firstChild), r;
}
function Re(r, e) {
  return e && (e instanceof be.window.Node || e.ownerDocument && e instanceof e.ownerDocument.defaultView.Node) ? e : wi(r);
}
function at(r) {
  if (!r) return null;
  if (r.instance instanceof jr) return r.instance;
  if (r.nodeName === "#document-fragment") return new Nt.Fragment(r);
  let e = ii(r.nodeName || "Dom");
  return e === "LinearGradient" || e === "RadialGradient" ? e = "Gradient" : Nt[e] || (e = "Dom"), new Nt[e](r);
}
let vs = at;
function ve(r, e = r.name, t = !1) {
  return Nt[e] = r, t && (Nt[Xr] = r), Un(Object.getOwnPropertyNames(r.prototype)), r;
}
let fh = 1e3;
function Zn(r) {
  return "Svgjs" + ii(r) + fh++;
}
function Jn(r) {
  for (let e = r.children.length - 1; e >= 0; e--) Jn(r.children[e]);
  return r.id && (r.id = Zn(r.nodeName)), r;
}
function oe(r, e) {
  let t, i;
  for (i = (r = Array.isArray(r) ? r : [r]).length - 1; i >= 0; i--) for (t in e) r[i].prototype[t] = e[t];
}
function Me(r) {
  return function(...e) {
    const t = e[e.length - 1];
    return !t || t.constructor !== Object || t instanceof Array ? r.apply(this, e) : r.apply(this, e.slice(0, -1)).attr(t);
  };
}
ge("Dom", { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const r = this.position();
  return this.parent().add(this.remove(), r + 1), this;
}, backward: function() {
  const r = this.position();
  return this.parent().add(this.remove(), r ? r - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(r) {
  (r = Ge(r)).remove();
  const e = this.position();
  return this.parent().add(r, e), this;
}, after: function(r) {
  (r = Ge(r)).remove();
  const e = this.position();
  return this.parent().add(r, e + 1), this;
}, insertBefore: function(r) {
  return (r = Ge(r)).before(this), this;
}, insertAfter: function(r) {
  return (r = Ge(r)).after(this), this;
} });
const Kn = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, ph = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, xh = /rgb\((\d+),(\d+),(\d+)\)/, mh = /(#[a-z_][a-z0-9\-_]*)/i, bh = /\)\s*,?\s*/, vh = /\s/g, Fa = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i, Na = /^rgb\(/, Da = /^(\s+)?$/, Ha = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, yh = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, yt = /[\s,]+/, Br = /[MLHVCSQTAZ]/i;
function wh(r) {
  const e = Math.round(r), t = Math.max(0, Math.min(255, e)).toString(16);
  return t.length === 1 ? "0" + t : t;
}
function Vt(r, e) {
  for (let t = e.length; t--; ) if (r[e[t]] == null) return !1;
  return !0;
}
function ys(r, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + 6 * (e - r) * t : t < 0.5 ? e : t < 2 / 3 ? r + (e - r) * (2 / 3 - t) * 6 : r;
}
ge("Dom", { classes: function() {
  const r = this.attr("class");
  return r == null ? [] : r.trim().split(yt);
}, hasClass: function(r) {
  return this.classes().indexOf(r) !== -1;
}, addClass: function(r) {
  if (!this.hasClass(r)) {
    const e = this.classes();
    e.push(r), this.attr("class", e.join(" "));
  }
  return this;
}, removeClass: function(r) {
  return this.hasClass(r) && this.attr("class", this.classes().filter(function(e) {
    return e !== r;
  }).join(" ")), this;
}, toggleClass: function(r) {
  return this.hasClass(r) ? this.removeClass(r) : this.addClass(r);
} }), ge("Dom", { css: function(r, e) {
  const t = {};
  if (arguments.length === 0) return this.node.style.cssText.split(/\s*;\s*/).filter(function(i) {
    return !!i.length;
  }).forEach(function(i) {
    const s = i.split(/\s*:\s*/);
    t[s[0]] = s[1];
  }), t;
  if (arguments.length < 2) {
    if (Array.isArray(r)) {
      for (const i of r) {
        const s = i;
        t[i] = this.node.style.getPropertyValue(s);
      }
      return t;
    }
    if (typeof r == "string") return this.node.style.getPropertyValue(r);
    if (typeof r == "object") for (const i in r) this.node.style.setProperty(i, r[i] == null || Da.test(r[i]) ? "" : r[i]);
  }
  return arguments.length === 2 && this.node.style.setProperty(r, e == null || Da.test(e) ? "" : e), this;
}, show: function() {
  return this.css("display", "");
}, hide: function() {
  return this.css("display", "none");
}, visible: function() {
  return this.css("display") !== "none";
} }), ge("Dom", { data: function(r, e, t) {
  if (r == null) return this.data(Hr(function(i, s) {
    let a;
    const n = i.length, o = [];
    for (a = 0; a < n; a++) s(i[a]) && o.push(i[a]);
    return o;
  }(this.node.attributes, (i) => i.nodeName.indexOf("data-") === 0), (i) => i.nodeName.slice(5)));
  if (r instanceof Array) {
    const i = {};
    for (const s of r) i[s] = this.data(s);
    return i;
  }
  if (typeof r == "object") for (e in r) this.data(e, r[e]);
  else if (arguments.length < 2) try {
    return JSON.parse(this.attr("data-" + r));
  } catch {
    return this.attr("data-" + r);
  }
  else this.attr("data-" + r, e === null ? null : t === !0 || typeof e == "string" || typeof e == "number" ? e : JSON.stringify(e));
  return this;
} }), ge("Dom", { remember: function(r, e) {
  if (typeof arguments[0] == "object") for (const t in r) this.remember(t, r[t]);
  else {
    if (arguments.length === 1) return this.memory()[r];
    this.memory()[r] = e;
  }
  return this;
}, forget: function() {
  if (arguments.length === 0) this._memory = {};
  else for (let r = arguments.length - 1; r >= 0; r--) delete this.memory()[arguments[r]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });
class Ae {
  constructor(...e) {
    this.init(...e);
  }
  static isColor(e) {
    return e && (e instanceof Ae || this.isRgb(e) || this.test(e));
  }
  static isRgb(e) {
    return e && typeof e.r == "number" && typeof e.g == "number" && typeof e.b == "number";
  }
  static random(e = "vibrant", t) {
    const { random: i, round: s, sin: a, PI: n } = Math;
    if (e === "vibrant") {
      const o = 24 * i() + 57, l = 38 * i() + 45, c = 360 * i();
      return new Ae(o, l, c, "lch");
    }
    if (e === "sine") {
      const o = s(80 * a(2 * n * (t = t ?? i()) / 0.5 + 0.01) + 150), l = s(50 * a(2 * n * t / 0.5 + 4.6) + 200), c = s(100 * a(2 * n * t / 0.5 + 2.3) + 150);
      return new Ae(o, l, c);
    }
    if (e === "pastel") {
      const o = 8 * i() + 86, l = 17 * i() + 9, c = 360 * i();
      return new Ae(o, l, c, "lch");
    }
    if (e === "dark") {
      const o = 10 + 10 * i(), l = 50 * i() + 86, c = 360 * i();
      return new Ae(o, l, c, "lch");
    }
    if (e === "rgb") {
      const o = 255 * i(), l = 255 * i(), c = 255 * i();
      return new Ae(o, l, c);
    }
    if (e === "lab") {
      const o = 100 * i(), l = 256 * i() - 128, c = 256 * i() - 128;
      return new Ae(o, l, c, "lab");
    }
    if (e === "grey") {
      const o = 255 * i();
      return new Ae(o, o, o);
    }
    throw new Error("Unsupported random color mode");
  }
  static test(e) {
    return typeof e == "string" && (Fa.test(e) || Na.test(e));
  }
  cmyk() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [s, a, n] = [e, t, i].map((l) => l / 255), o = Math.min(1 - s, 1 - a, 1 - n);
    return o === 1 ? new Ae(0, 0, 0, 1, "cmyk") : new Ae((1 - s - o) / (1 - o), (1 - a - o) / (1 - o), (1 - n - o) / (1 - o), o, "cmyk");
  }
  hsl() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [s, a, n] = [e, t, i].map((u) => u / 255), o = Math.max(s, a, n), l = Math.min(s, a, n), c = (o + l) / 2, h = o === l, d = o - l;
    return new Ae(360 * (h ? 0 : o === s ? ((a - n) / d + (a < n ? 6 : 0)) / 6 : o === a ? ((n - s) / d + 2) / 6 : o === n ? ((s - a) / d + 4) / 6 : 0), 100 * (h ? 0 : c > 0.5 ? d / (2 - o - l) : d / (o + l)), 100 * c, "hsl");
  }
  init(e = 0, t = 0, i = 0, s = 0, a = "rgb") {
    if (e = e || 0, this.space) for (const d in this.space) delete this[this.space[d]];
    if (typeof e == "number") a = typeof s == "string" ? s : a, s = typeof s == "string" ? 0 : s, Object.assign(this, { _a: e, _b: t, _c: i, _d: s, space: a });
    else if (e instanceof Array) this.space = t || (typeof e[3] == "string" ? e[3] : e[4]) || "rgb", Object.assign(this, { _a: e[0], _b: e[1], _c: e[2], _d: e[3] || 0 });
    else if (e instanceof Object) {
      const d = function(u, g) {
        const p = Vt(u, "rgb") ? { _a: u.r, _b: u.g, _c: u.b, _d: 0, space: "rgb" } : Vt(u, "xyz") ? { _a: u.x, _b: u.y, _c: u.z, _d: 0, space: "xyz" } : Vt(u, "hsl") ? { _a: u.h, _b: u.s, _c: u.l, _d: 0, space: "hsl" } : Vt(u, "lab") ? { _a: u.l, _b: u.a, _c: u.b, _d: 0, space: "lab" } : Vt(u, "lch") ? { _a: u.l, _b: u.c, _c: u.h, _d: 0, space: "lch" } : Vt(u, "cmyk") ? { _a: u.c, _b: u.m, _c: u.y, _d: u.k, space: "cmyk" } : { _a: 0, _b: 0, _c: 0, space: "rgb" };
        return p.space = g || p.space, p;
      }(e, t);
      Object.assign(this, d);
    } else if (typeof e == "string") if (Na.test(e)) {
      const d = e.replace(vh, ""), [u, g, p] = xh.exec(d).slice(1, 4).map((f) => parseInt(f));
      Object.assign(this, { _a: u, _b: g, _c: p, _d: 0, space: "rgb" });
    } else {
      if (!Fa.test(e)) throw Error("Unsupported string format, can't construct Color");
      {
        const d = (f) => parseInt(f, 16), [, u, g, p] = ph.exec(function(f) {
          return f.length === 4 ? ["#", f.substring(1, 2), f.substring(1, 2), f.substring(2, 3), f.substring(2, 3), f.substring(3, 4), f.substring(3, 4)].join("") : f;
        }(e)).map(d);
        Object.assign(this, { _a: u, _b: g, _c: p, _d: 0, space: "rgb" });
      }
    }
    const { _a: n, _b: o, _c: l, _d: c } = this, h = this.space === "rgb" ? { r: n, g: o, b: l } : this.space === "xyz" ? { x: n, y: o, z: l } : this.space === "hsl" ? { h: n, s: o, l } : this.space === "lab" ? { l: n, a: o, b: l } : this.space === "lch" ? { l: n, c: o, h: l } : this.space === "cmyk" ? { c: n, m: o, y: l, k: c } : {};
    Object.assign(this, h);
  }
  lab() {
    const { x: e, y: t, z: i } = this.xyz();
    return new Ae(116 * t - 16, 500 * (e - t), 200 * (t - i), "lab");
  }
  lch() {
    const { l: e, a: t, b: i } = this.lab(), s = Math.sqrt(t ** 2 + i ** 2);
    let a = 180 * Math.atan2(i, t) / Math.PI;
    return a < 0 && (a *= -1, a = 360 - a), new Ae(e, s, a, "lch");
  }
  rgb() {
    if (this.space === "rgb") return this;
    if ((e = this.space) === "lab" || e === "xyz" || e === "lch") {
      let { x: t, y: i, z: s } = this;
      if (this.space === "lab" || this.space === "lch") {
        let { l: g, a: p, b: f } = this;
        if (this.space === "lch") {
          const { c: S, h: k } = this, C = Math.PI / 180;
          p = S * Math.cos(C * k), f = S * Math.sin(C * k);
        }
        const x = (g + 16) / 116, m = p / 500 + x, b = x - f / 200, w = 16 / 116, y = 8856e-6, v = 7.787;
        t = 0.95047 * (m ** 3 > y ? m ** 3 : (m - w) / v), i = 1 * (x ** 3 > y ? x ** 3 : (x - w) / v), s = 1.08883 * (b ** 3 > y ? b ** 3 : (b - w) / v);
      }
      const a = 3.2406 * t + -1.5372 * i + -0.4986 * s, n = -0.9689 * t + 1.8758 * i + 0.0415 * s, o = 0.0557 * t + -0.204 * i + 1.057 * s, l = Math.pow, c = 31308e-7, h = a > c ? 1.055 * l(a, 1 / 2.4) - 0.055 : 12.92 * a, d = n > c ? 1.055 * l(n, 1 / 2.4) - 0.055 : 12.92 * n, u = o > c ? 1.055 * l(o, 1 / 2.4) - 0.055 : 12.92 * o;
      return new Ae(255 * h, 255 * d, 255 * u);
    }
    if (this.space === "hsl") {
      let { h: t, s: i, l: s } = this;
      if (t /= 360, i /= 100, s /= 100, i === 0)
        return s *= 255, new Ae(s, s, s);
      const a = s < 0.5 ? s * (1 + i) : s + i - s * i, n = 2 * s - a, o = 255 * ys(n, a, t + 1 / 3), l = 255 * ys(n, a, t), c = 255 * ys(n, a, t - 1 / 3);
      return new Ae(o, l, c);
    }
    if (this.space === "cmyk") {
      const { c: t, m: i, y: s, k: a } = this, n = 255 * (1 - Math.min(1, t * (1 - a) + a)), o = 255 * (1 - Math.min(1, i * (1 - a) + a)), l = 255 * (1 - Math.min(1, s * (1 - a) + a));
      return new Ae(n, o, l);
    }
    return this;
    var e;
  }
  toArray() {
    const { _a: e, _b: t, _c: i, _d: s, space: a } = this;
    return [e, t, i, s, a];
  }
  toHex() {
    const [e, t, i] = this._clamped().map(wh);
    return `#${e}${t}${i}`;
  }
  toRgb() {
    const [e, t, i] = this._clamped();
    return `rgb(${e},${t},${i})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [s, a, n] = [e, t, i].map((x) => x / 255), o = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92, l = a > 0.04045 ? Math.pow((a + 0.055) / 1.055, 2.4) : a / 12.92, c = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, h = (0.4124 * o + 0.3576 * l + 0.1805 * c) / 0.95047, d = (0.2126 * o + 0.7152 * l + 0.0722 * c) / 1, u = (0.0193 * o + 0.1192 * l + 0.9505 * c) / 1.08883, g = h > 8856e-6 ? Math.pow(h, 1 / 3) : 7.787 * h + 16 / 116, p = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, f = u > 8856e-6 ? Math.pow(u, 1 / 3) : 7.787 * u + 16 / 116;
    return new Ae(g, p, f, "xyz");
  }
  _clamped() {
    const { _a: e, _b: t, _c: i } = this.rgb(), { max: s, min: a, round: n } = Math;
    return [e, t, i].map((o) => s(0, a(n(o), 255)));
  }
}
class ye {
  constructor(...e) {
    this.init(...e);
  }
  clone() {
    return new ye(this);
  }
  init(e, t) {
    const a = Array.isArray(e) ? { x: e[0], y: e[1] } : typeof e == "object" ? { x: e.x, y: e.y } : { x: e, y: t };
    return this.x = a.x == null ? 0 : a.x, this.y = a.y == null ? 0 : a.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(e) {
    return this.clone().transformO(e);
  }
  transformO(e) {
    ne.isMatrixLike(e) || (e = new ne(e));
    const { x: t, y: i } = this;
    return this.x = e.a * t + e.c * i + e.e, this.y = e.b * t + e.d * i + e.f, this;
  }
}
function Gt(r, e, t) {
  return Math.abs(e - r) < 1e-6;
}
class ne {
  constructor(...e) {
    this.init(...e);
  }
  static formatTransforms(e) {
    const t = e.flip === "both" || e.flip === !0, i = e.flip && (t || e.flip === "x") ? -1 : 1, s = e.flip && (t || e.flip === "y") ? -1 : 1, a = e.skew && e.skew.length ? e.skew[0] : isFinite(e.skew) ? e.skew : isFinite(e.skewX) ? e.skewX : 0, n = e.skew && e.skew.length ? e.skew[1] : isFinite(e.skew) ? e.skew : isFinite(e.skewY) ? e.skewY : 0, o = e.scale && e.scale.length ? e.scale[0] * i : isFinite(e.scale) ? e.scale * i : isFinite(e.scaleX) ? e.scaleX * i : i, l = e.scale && e.scale.length ? e.scale[1] * s : isFinite(e.scale) ? e.scale * s : isFinite(e.scaleY) ? e.scaleY * s : s, c = e.shear || 0, h = e.rotate || e.theta || 0, d = new ye(e.origin || e.around || e.ox || e.originX, e.oy || e.originY), u = d.x, g = d.y, p = new ye(e.position || e.px || e.positionX || NaN, e.py || e.positionY || NaN), f = p.x, x = p.y, m = new ye(e.translate || e.tx || e.translateX, e.ty || e.translateY), b = m.x, w = m.y, y = new ye(e.relative || e.rx || e.relativeX, e.ry || e.relativeY);
    return { scaleX: o, scaleY: l, skewX: a, skewY: n, shear: c, theta: h, rx: y.x, ry: y.y, tx: b, ty: w, ox: u, oy: g, px: f, py: x };
  }
  static fromArray(e) {
    return { a: e[0], b: e[1], c: e[2], d: e[3], e: e[4], f: e[5] };
  }
  static isMatrixLike(e) {
    return e.a != null || e.b != null || e.c != null || e.d != null || e.e != null || e.f != null;
  }
  static matrixMultiply(e, t, i) {
    const s = e.a * t.a + e.c * t.b, a = e.b * t.a + e.d * t.b, n = e.a * t.c + e.c * t.d, o = e.b * t.c + e.d * t.d, l = e.e + e.a * t.e + e.c * t.f, c = e.f + e.b * t.e + e.d * t.f;
    return i.a = s, i.b = a, i.c = n, i.d = o, i.e = l, i.f = c, i;
  }
  around(e, t, i) {
    return this.clone().aroundO(e, t, i);
  }
  aroundO(e, t, i) {
    const s = e || 0, a = t || 0;
    return this.translateO(-s, -a).lmultiplyO(i).translateO(s, a);
  }
  clone() {
    return new ne(this);
  }
  decompose(e = 0, t = 0) {
    const i = this.a, s = this.b, a = this.c, n = this.d, o = this.e, l = this.f, c = i * n - s * a, h = c > 0 ? 1 : -1, d = h * Math.sqrt(i * i + s * s), u = Math.atan2(h * s, h * i), g = 180 / Math.PI * u, p = Math.cos(u), f = Math.sin(u), x = (i * a + s * n) / c, m = a * d / (x * i - s) || n * d / (x * s + i);
    return { scaleX: d, scaleY: m, shear: x, rotate: g, translateX: o - e + e * p * d + t * (x * p * d - f * m), translateY: l - t + e * f * d + t * (x * f * d + p * m), originX: e, originY: t, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(e) {
    if (e === this) return !0;
    const t = new ne(e);
    return Gt(this.a, t.a) && Gt(this.b, t.b) && Gt(this.c, t.c) && Gt(this.d, t.d) && Gt(this.e, t.e) && Gt(this.f, t.f);
  }
  flip(e, t) {
    return this.clone().flipO(e, t);
  }
  flipO(e, t) {
    return e === "x" ? this.scaleO(-1, 1, t, 0) : e === "y" ? this.scaleO(1, -1, 0, t) : this.scaleO(-1, -1, e, t || e);
  }
  init(e) {
    const t = ne.fromArray([1, 0, 0, 1, 0, 0]);
    return e = e instanceof Be ? e.matrixify() : typeof e == "string" ? ne.fromArray(e.split(yt).map(parseFloat)) : Array.isArray(e) ? ne.fromArray(e) : typeof e == "object" && ne.isMatrixLike(e) ? e : typeof e == "object" ? new ne().transform(e) : arguments.length === 6 ? ne.fromArray([].slice.call(arguments)) : t, this.a = e.a != null ? e.a : t.a, this.b = e.b != null ? e.b : t.b, this.c = e.c != null ? e.c : t.c, this.d = e.d != null ? e.d : t.d, this.e = e.e != null ? e.e : t.e, this.f = e.f != null ? e.f : t.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const e = this.a, t = this.b, i = this.c, s = this.d, a = this.e, n = this.f, o = e * s - t * i;
    if (!o) throw new Error("Cannot invert " + this);
    const l = s / o, c = -t / o, h = -i / o, d = e / o, u = -(l * a + h * n), g = -(c * a + d * n);
    return this.a = l, this.b = c, this.c = h, this.d = d, this.e = u, this.f = g, this;
  }
  lmultiply(e) {
    return this.clone().lmultiplyO(e);
  }
  lmultiplyO(e) {
    const t = e instanceof ne ? e : new ne(e);
    return ne.matrixMultiply(t, this, this);
  }
  multiply(e) {
    return this.clone().multiplyO(e);
  }
  multiplyO(e) {
    const t = e instanceof ne ? e : new ne(e);
    return ne.matrixMultiply(this, t, this);
  }
  rotate(e, t, i) {
    return this.clone().rotateO(e, t, i);
  }
  rotateO(e, t = 0, i = 0) {
    e = ms(e);
    const s = Math.cos(e), a = Math.sin(e), { a: n, b: o, c: l, d: c, e: h, f: d } = this;
    return this.a = n * s - o * a, this.b = o * s + n * a, this.c = l * s - c * a, this.d = c * s + l * a, this.e = h * s - d * a + i * a - t * s + t, this.f = d * s + h * a - t * a - i * s + i, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(e, t = e, i = 0, s = 0) {
    arguments.length === 3 && (s = i, i = t, t = e);
    const { a, b: n, c: o, d: l, e: c, f: h } = this;
    return this.a = a * e, this.b = n * t, this.c = o * e, this.d = l * t, this.e = c * e - i * e + i, this.f = h * t - s * t + s, this;
  }
  shear(e, t, i) {
    return this.clone().shearO(e, t, i);
  }
  shearO(e, t = 0, i = 0) {
    const { a: s, b: a, c: n, d: o, e: l, f: c } = this;
    return this.a = s + a * e, this.c = n + o * e, this.e = l + c * e - i * e, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(e, t = e, i = 0, s = 0) {
    arguments.length === 3 && (s = i, i = t, t = e), e = ms(e), t = ms(t);
    const a = Math.tan(e), n = Math.tan(t), { a: o, b: l, c, d: h, e: d, f: u } = this;
    return this.a = o + l * a, this.b = l + o * n, this.c = c + h * a, this.d = h + c * n, this.e = d + u * a - s * a, this.f = u + d * n - i * n, this;
  }
  skewX(e, t, i) {
    return this.skew(e, 0, t, i);
  }
  skewY(e, t, i) {
    return this.skew(0, e, t, i);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  transform(e) {
    if (ne.isMatrixLike(e))
      return new ne(e).multiplyO(this);
    const t = ne.formatTransforms(e), { x: i, y: s } = new ye(t.ox, t.oy).transform(this), a = new ne().translateO(t.rx, t.ry).lmultiplyO(this).translateO(-i, -s).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(i, s);
    if (isFinite(t.px) || isFinite(t.py)) {
      const n = new ye(i, s).transform(a), o = isFinite(t.px) ? t.px - n.x : 0, l = isFinite(t.py) ? t.py - n.y : 0;
      a.translateO(o, l);
    }
    return a.translateO(t.tx, t.ty), a;
  }
  translate(e, t) {
    return this.clone().translateO(e, t);
  }
  translateO(e, t) {
    return this.e += e || 0, this.f += t || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
}
function kt() {
  if (!kt.nodes) {
    const r = Ge().size(2, 0);
    r.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";"), r.attr("focusable", "false"), r.attr("aria-hidden", "true");
    const e = r.path().node;
    kt.nodes = { svg: r, path: e };
  }
  if (!kt.nodes.svg.node.parentNode) {
    const r = be.document.body || be.document.documentElement;
    kt.nodes.svg.addTo(r);
  }
  return kt.nodes;
}
function Qn(r) {
  return !(r.width || r.height || r.x || r.y);
}
ve(ne, "Matrix");
class Oe {
  constructor(...e) {
    this.init(...e);
  }
  addOffset() {
    return this.x += be.window.pageXOffset, this.y += be.window.pageYOffset, new Oe(this);
  }
  init(e) {
    return e = typeof e == "string" ? e.split(yt).map(parseFloat) : Array.isArray(e) ? e : typeof e == "object" ? [e.left != null ? e.left : e.x, e.top != null ? e.top : e.y, e.width, e.height] : arguments.length === 4 ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = e[0] || 0, this.y = e[1] || 0, this.width = this.w = e[2] || 0, this.height = this.h = e[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return Qn(this);
  }
  merge(e) {
    const t = Math.min(this.x, e.x), i = Math.min(this.y, e.y), s = Math.max(this.x + this.width, e.x + e.width) - t, a = Math.max(this.y + this.height, e.y + e.height) - i;
    return new Oe(t, i, s, a);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(e) {
    e instanceof ne || (e = new ne(e));
    let t = 1 / 0, i = -1 / 0, s = 1 / 0, a = -1 / 0;
    return [new ye(this.x, this.y), new ye(this.x2, this.y), new ye(this.x, this.y2), new ye(this.x2, this.y2)].forEach(function(n) {
      n = n.transform(e), t = Math.min(t, n.x), i = Math.max(i, n.x), s = Math.min(s, n.y), a = Math.max(a, n.y);
    }), new Oe(t, s, i - t, a - s);
  }
}
function Ya(r, e, t) {
  let i;
  try {
    if (i = e(r.node), Qn(i) && (s = r.node) !== be.document && !(be.document.documentElement.contains || function(a) {
      for (; a.parentNode; ) a = a.parentNode;
      return a === be.document;
    }).call(be.document.documentElement, s)) throw new Error("Element not in the dom");
  } catch {
    i = t(r);
  }
  var s;
  return i;
}
ge({ viewbox: { viewbox(r, e, t, i) {
  return r == null ? new Oe(this.attr("viewBox")) : this.attr("viewBox", new Oe(r, e, t, i));
}, zoom(r, e) {
  let { width: t, height: i } = this.attr(["width", "height"]);
  if ((t || i) && typeof t != "string" && typeof i != "string" || (t = this.node.clientWidth, i = this.node.clientHeight), !t || !i) throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
  const s = this.viewbox(), a = t / s.width, n = i / s.height, o = Math.min(a, n);
  if (r == null) return o;
  let l = o / r;
  l === 1 / 0 && (l = Number.MAX_SAFE_INTEGER / 100), e = e || new ye(t / 2 / a + s.x, i / 2 / n + s.y);
  const c = new Oe(s).transform(new ne({ scale: l, origin: e }));
  return this.viewbox(c);
} } }), ve(Oe, "Box");
class Yt extends Array {
  constructor(e = [], ...t) {
    if (super(e, ...t), typeof e == "number") return this;
    this.length = 0, this.push(...e);
  }
}
oe([Yt], { each(r, ...e) {
  return typeof r == "function" ? this.map((t, i, s) => r.call(t, t, i, s)) : this.map((t) => t[r](...e));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
const Sh = ["toArray", "constructor", "each"];
function Xt(r, e) {
  return new Yt(Hr((e || be.document).querySelectorAll(r), function(t) {
    return at(t);
  }));
}
Yt.extend = function(r) {
  r = r.reduce((e, t) => (Sh.includes(t) || t[0] === "_" || (t in Array.prototype && (e["$" + t] = Array.prototype[t]), e[t] = function(...i) {
    return this.each(t, ...i);
  }), e), {}), oe([Yt], r);
};
let kh = 0;
const eo = {};
function to(r) {
  let e = r.getEventHolder();
  return e === be.window && (e = eo), e.events || (e.events = {}), e.events;
}
function Wr(r) {
  return r.getEventTarget();
}
function bt(r, e, t, i, s) {
  const a = t.bind(i || r), n = Ge(r), o = to(n), l = Wr(n);
  e = Array.isArray(e) ? e : e.split(yt), t._svgjsListenerId || (t._svgjsListenerId = ++kh), e.forEach(function(c) {
    const h = c.split(".")[0], d = c.split(".")[1] || "*";
    o[h] = o[h] || {}, o[h][d] = o[h][d] || {}, o[h][d][t._svgjsListenerId] = a, l.addEventListener(h, a, s || !1);
  });
}
function nt(r, e, t, i) {
  const s = Ge(r), a = to(s), n = Wr(s);
  (typeof t != "function" || (t = t._svgjsListenerId)) && (e = Array.isArray(e) ? e : (e || "").split(yt)).forEach(function(o) {
    const l = o && o.split(".")[0], c = o && o.split(".")[1];
    let h, d;
    if (t) a[l] && a[l][c || "*"] && (n.removeEventListener(l, a[l][c || "*"][t], i || !1), delete a[l][c || "*"][t]);
    else if (l && c) {
      if (a[l] && a[l][c]) {
        for (d in a[l][c]) nt(n, [l, c].join("."), d);
        delete a[l][c];
      }
    } else if (c) for (o in a) for (h in a[o]) c === h && nt(n, [o, c].join("."));
    else if (l) {
      if (a[l]) {
        for (h in a[l]) nt(n, [l, h].join("."));
        delete a[l];
      }
    } else {
      for (o in a) nt(n, o);
      (function(u) {
        let g = u.getEventHolder();
        g === be.window && (g = eo), g.events && (g.events = {});
      })(s);
    }
  });
}
class Ii extends jr {
  addEventListener() {
  }
  dispatch(e, t, i) {
    return function(s, a, n, o) {
      const l = Wr(s);
      return a instanceof be.window.Event || (a = new be.window.CustomEvent(a, { detail: n, cancelable: !0, ...o })), l.dispatchEvent(a), a;
    }(this, e, t, i);
  }
  dispatchEvent(e) {
    const t = this.getEventHolder().events;
    if (!t) return !0;
    const i = t[e.type];
    for (const s in i) for (const a in i[s]) i[s][a](e);
    return !e.defaultPrevented;
  }
  fire(e, t, i) {
    return this.dispatch(e, t, i), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(e, t, i) {
    return nt(this, e, t, i), this;
  }
  on(e, t, i, s) {
    return bt(this, e, t, i, s), this;
  }
  removeEventListener() {
  }
}
function ja() {
}
ve(Ii, "EventTarget");
const ws = 400, Ch = ">", Ah = 0, Mh = { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "text-anchor": "start" };
class jt extends Array {
  constructor(...e) {
    super(...e), this.init(...e);
  }
  clone() {
    return new this.constructor(this);
  }
  init(e) {
    return typeof e == "number" || (this.length = 0, this.push(...this.parse(e))), this;
  }
  parse(e = []) {
    return e instanceof Array ? e : e.trim().split(yt).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  valueOf() {
    const e = [];
    return e.push(...this), e;
  }
}
class de {
  constructor(...e) {
    this.init(...e);
  }
  convert(e) {
    return new de(this.value, e);
  }
  divide(e) {
    return e = new de(e), new de(this / e, this.unit || e.unit);
  }
  init(e, t) {
    return t = Array.isArray(e) ? e[1] : t, e = Array.isArray(e) ? e[0] : e, this.value = 0, this.unit = t || "", typeof e == "number" ? this.value = isNaN(e) ? 0 : isFinite(e) ? e : e < 0 ? -34e37 : 34e37 : typeof e == "string" ? (t = e.match(Kn)) && (this.value = parseFloat(t[1]), t[5] === "%" ? this.value /= 100 : t[5] === "s" && (this.value *= 1e3), this.unit = t[5]) : e instanceof de && (this.value = e.valueOf(), this.unit = e.unit), this;
  }
  minus(e) {
    return e = new de(e), new de(this - e, this.unit || e.unit);
  }
  plus(e) {
    return e = new de(e), new de(this + e, this.unit || e.unit);
  }
  times(e) {
    return e = new de(e), new de(this * e, this.unit || e.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (this.unit === "%" ? ~~(1e8 * this.value) / 1e6 : this.unit === "s" ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
}
const Rh = /* @__PURE__ */ new Set(["fill", "stroke", "color", "bgcolor", "stop-color", "flood-color", "lighting-color"]), io = [];
class Mt extends Ii {
  constructor(e, t) {
    super(), this.node = e, this.type = e.nodeName, t && e !== t && this.attr(t);
  }
  add(e, t) {
    return (e = Ge(e)).removeNamespace && this.node instanceof be.window.SVGElement && e.removeNamespace(), t == null ? this.node.appendChild(e.node) : e.node !== this.node.childNodes[t] && this.node.insertBefore(e.node, this.node.childNodes[t]), this;
  }
  addTo(e, t) {
    return Ge(e).put(this, t);
  }
  children() {
    return new Yt(Hr(this.node.children, function(e) {
      return at(e);
    }));
  }
  clear() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(e = !0, t = !0) {
    this.writeDataToDom();
    let i = this.node.cloneNode(e);
    return t && (i = Jn(i)), new this.constructor(i);
  }
  each(e, t) {
    const i = this.children();
    let s, a;
    for (s = 0, a = i.length; s < a; s++) e.apply(i[s], [s, i]), t && i[s].each(e, t);
    return this;
  }
  element(e, t) {
    return this.put(new Mt(wi(e), t));
  }
  first() {
    return at(this.node.firstChild);
  }
  get(e) {
    return at(this.node.childNodes[e]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(e) {
    return this.index(e) >= 0;
  }
  html(e, t) {
    return this.xml(e, t, "http://www.w3.org/1999/xhtml");
  }
  id(e) {
    return e !== void 0 || this.node.id || (this.node.id = Zn(this.type)), this.attr("id", e);
  }
  index(e) {
    return [].slice.call(this.node.childNodes).indexOf(e.node);
  }
  last() {
    return at(this.node.lastChild);
  }
  matches(e) {
    const t = this.node, i = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return i && i.call(t, e);
  }
  parent(e) {
    let t = this;
    if (!t.node.parentNode) return null;
    if (t = at(t.node.parentNode), !e) return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e) return t;
    while (t = at(t.node.parentNode));
    return t;
  }
  put(e, t) {
    return e = Ge(e), this.add(e, t), e;
  }
  putIn(e, t) {
    return Ge(e).add(this, t);
  }
  remove() {
    return this.parent() && this.parent().removeElement(this), this;
  }
  removeElement(e) {
    return this.node.removeChild(e.node), this;
  }
  replace(e) {
    return e = Ge(e), this.node.parentNode && this.node.parentNode.replaceChild(e.node, this.node), e;
  }
  round(e = 2, t = null) {
    const i = 10 ** e, s = this.attr(t);
    for (const a in s) typeof s[a] == "number" && (s[a] = Math.round(s[a] * i) / i);
    return this.attr(s), this;
  }
  svg(e, t) {
    return this.xml(e, t, Yr);
  }
  toString() {
    return this.id();
  }
  words(e) {
    return this.node.textContent = e, this;
  }
  wrap(e) {
    const t = this.parent();
    if (!t) return this.addTo(e);
    const i = t.index(this);
    return t.put(e, i).put(this);
  }
  writeDataToDom() {
    return this.each(function() {
      this.writeDataToDom();
    }), this;
  }
  xml(e, t, i) {
    if (typeof e == "boolean" && (i = t, t = e, e = null), e == null || typeof e == "function") {
      t = t == null || t, this.writeDataToDom();
      let o = this;
      if (e != null) {
        if (o = at(o.node.cloneNode(!0)), t) {
          const l = e(o);
          if (o = l || o, l === !1) return "";
        }
        o.each(function() {
          const l = e(this), c = l || this;
          l === !1 ? this.remove() : l && this !== c && this.replace(c);
        }, !0);
      }
      return t ? o.node.outerHTML : o.node.innerHTML;
    }
    t = t != null && t;
    const s = wi("wrapper", i), a = be.document.createDocumentFragment();
    s.innerHTML = e;
    for (let o = s.children.length; o--; ) a.appendChild(s.firstElementChild);
    const n = this.parent();
    return t ? this.replace(a) && n : this.add(a);
  }
}
oe(Mt, { attr: function(r, e, t) {
  if (r == null) {
    r = {}, e = this.node.attributes;
    for (const i of e) r[i.nodeName] = Ha.test(i.nodeValue) ? parseFloat(i.nodeValue) : i.nodeValue;
    return r;
  }
  if (r instanceof Array) return r.reduce((i, s) => (i[s] = this.attr(s), i), {});
  if (typeof r == "object" && r.constructor === Object) for (e in r) this.attr(e, r[e]);
  else if (e === null) this.node.removeAttribute(r);
  else {
    if (e == null) return (e = this.node.getAttribute(r)) == null ? Mh[r] : Ha.test(e) ? parseFloat(e) : e;
    typeof (e = io.reduce((i, s) => s(r, i, this), e)) == "number" ? e = new de(e) : Rh.has(r) && Ae.isColor(e) ? e = new Ae(e) : e.constructor === Array && (e = new jt(e)), r === "leading" ? this.leading && this.leading(e) : typeof t == "string" ? this.node.setAttributeNS(t, r, e.toString()) : this.node.setAttribute(r, e.toString()), !this.rebuild || r !== "font-size" && r !== "x" || this.rebuild();
  }
  return this;
}, find: function(r) {
  return Xt(r, this.node);
}, findOne: function(r) {
  return at(this.node.querySelector(r));
} }), ve(Mt, "Dom");
let Be = class extends Mt {
  constructor(r, e) {
    super(r, e), this.dom = {}, this.node.instance = this, (r.hasAttribute("data-svgjs") || r.hasAttribute("svgjs:data")) && this.setData(JSON.parse(r.getAttribute("data-svgjs")) ?? JSON.parse(r.getAttribute("svgjs:data")) ?? {});
  }
  center(r, e) {
    return this.cx(r).cy(e);
  }
  cx(r) {
    return r == null ? this.x() + this.width() / 2 : this.x(r - this.width() / 2);
  }
  cy(r) {
    return r == null ? this.y() + this.height() / 2 : this.y(r - this.height() / 2);
  }
  defs() {
    const r = this.root();
    return r && r.defs();
  }
  dmove(r, e) {
    return this.dx(r).dy(e);
  }
  dx(r = 0) {
    return this.x(new de(r).plus(this.x()));
  }
  dy(r = 0) {
    return this.y(new de(r).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(r) {
    return this.attr("height", r);
  }
  move(r, e) {
    return this.x(r).y(e);
  }
  parents(r = this.root()) {
    const e = typeof r == "string";
    e || (r = Ge(r));
    const t = new Yt();
    let i = this;
    for (; (i = i.parent()) && i.node !== be.document && i.nodeName !== "#document-fragment" && (t.push(i), e || i.node !== r.node) && (!e || !i.matches(r)); ) if (i.node === this.root().node) return null;
    return t;
  }
  reference(r) {
    if (!(r = this.attr(r))) return null;
    const e = (r + "").match(mh);
    return e ? Ge(e[1]) : null;
  }
  root() {
    const r = this.parent(function(e) {
      return Nt[e];
    }(Xr));
    return r && r.root();
  }
  setData(r) {
    return this.dom = r, this;
  }
  size(r, e) {
    const t = si(this, r, e);
    return this.width(new de(t.width)).height(new de(t.height));
  }
  width(r) {
    return this.attr("width", r);
  }
  writeDataToDom() {
    return qn(this, this.dom), super.writeDataToDom();
  }
  x(r) {
    return this.attr("x", r);
  }
  y(r) {
    return this.attr("y", r);
  }
};
oe(Be, { bbox: function() {
  const r = Ya(this, (e) => e.getBBox(), (e) => {
    try {
      const t = e.clone().addTo(kt().svg).show(), i = t.node.getBBox();
      return t.remove(), i;
    } catch (t) {
      throw new Error(`Getting bbox of element "${e.node.nodeName}" is not possible: ${t.toString()}`);
    }
  });
  return new Oe(r);
}, rbox: function(r) {
  const e = Ya(this, (i) => i.getBoundingClientRect(), (i) => {
    throw new Error(`Getting rbox of element "${i.node.nodeName}" is not possible`);
  }), t = new Oe(e);
  return r ? t.transform(r.screenCTM().inverseO()) : t.addOffset();
}, inside: function(r, e) {
  const t = this.bbox();
  return r > t.x && e > t.y && r < t.x + t.width && e < t.y + t.height;
}, point: function(r, e) {
  return new ye(r, e).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new ne(this.node.getCTM());
}, screenCTM: function() {
  try {
    if (typeof this.isRoot == "function" && !this.isRoot()) {
      const r = this.rect(1, 1), e = r.node.getScreenCTM();
      return r.remove(), new ne(e);
    }
    return new ne(this.node.getScreenCTM());
  } catch {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new ne();
  }
} }), ve(Be, "Element");
const di = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(r, e) {
  return e === "color" ? r : r + "-" + e;
} };
["fill", "stroke"].forEach(function(r) {
  const e = {};
  let t;
  e[r] = function(i) {
    if (i === void 0) return this.attr(r);
    if (typeof i == "string" || i instanceof Ae || Ae.isRgb(i) || i instanceof Be) this.attr(r, i);
    else for (t = di[r].length - 1; t >= 0; t--) i[di[r][t]] != null && this.attr(di.prefix(r, di[r][t]), i[di[r][t]]);
    return this;
  }, ge(["Element", "Runner"], e);
}), ge(["Element", "Runner"], { matrix: function(r, e, t, i, s, a) {
  return r == null ? new ne(this) : this.attr("transform", new ne(r, e, t, i, s, a));
}, rotate: function(r, e, t) {
  return this.transform({ rotate: r, ox: e, oy: t }, !0);
}, skew: function(r, e, t, i) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ skew: r, ox: e, oy: t }, !0) : this.transform({ skew: [r, e], ox: t, oy: i }, !0);
}, shear: function(r, e, t) {
  return this.transform({ shear: r, ox: e, oy: t }, !0);
}, scale: function(r, e, t, i) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ scale: r, ox: e, oy: t }, !0) : this.transform({ scale: [r, e], ox: t, oy: i }, !0);
}, translate: function(r, e) {
  return this.transform({ translate: [r, e] }, !0);
}, relative: function(r, e) {
  return this.transform({ relative: [r, e] }, !0);
}, flip: function(r = "both", e = "center") {
  return "xybothtrue".indexOf(r) === -1 && (e = r, r = "both"), this.transform({ flip: r, origin: e }, !0);
}, opacity: function(r) {
  return this.attr("opacity", r);
} }), ge("radius", { radius: function(r, e = r) {
  return (this._element || this).type === "radialGradient" ? this.attr("r", new de(r)) : this.rx(r).ry(e);
} }), ge("Path", { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(r) {
  return new ye(this.node.getPointAtLength(r));
} }), ge(["Element", "Runner"], { font: function(r, e) {
  if (typeof r == "object") {
    for (e in r) this.font(e, r[e]);
    return this;
  }
  return r === "leading" ? this.leading(e) : r === "anchor" ? this.attr("text-anchor", e) : r === "size" || r === "family" || r === "weight" || r === "stretch" || r === "variant" || r === "style" ? this.attr("font-" + r, e) : this.attr(r, e);
} });
ge("Element", ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel", "contextmenu", "wheel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel"].reduce(function(r, e) {
  return r[e] = function(t) {
    return t === null ? this.off(e) : this.on(e, t), this;
  }, r;
}, {})), ge("Element", { untransform: function() {
  return this.attr("transform", null);
}, matrixify: function() {
  return (this.attr("transform") || "").split(bh).slice(0, -1).map(function(e) {
    const t = e.trim().split("(");
    return [t[0], t[1].split(yt).map(function(i) {
      return parseFloat(i);
    })];
  }).reverse().reduce(function(e, t) {
    return t[0] === "matrix" ? e.lmultiply(ne.fromArray(t[1])) : e[t[0]].apply(e, t[1]);
  }, new ne());
}, toParent: function(r, e) {
  if (this === r) return this;
  if (cr(this.node)) return this.addTo(r, e);
  const t = this.screenCTM(), i = r.screenCTM().inverse();
  return this.addTo(r, e).untransform().transform(i.multiply(t)), this;
}, toRoot: function(r) {
  return this.toParent(this.root(), r);
}, transform: function(r, e) {
  if (r == null || typeof r == "string") {
    const i = new ne(this).decompose();
    return r == null ? i : i[r];
  }
  ne.isMatrixLike(r) || (r = { ...r, origin: lr(r, this) });
  const t = new ne(e === !0 ? this : e || !1).transform(r);
  return this.attr("transform", t);
} });
class qe extends Be {
  flatten() {
    return this.each(function() {
      if (this instanceof qe) return this.flatten().ungroup();
    }), this;
  }
  ungroup(e = this.parent(), t = e.index(this)) {
    return t = t === -1 ? e.children().length : t, this.each(function(i, s) {
      return s[s.length - i - 1].toParent(e, t);
    }), this.remove();
  }
}
ve(qe, "Container");
class rs extends qe {
  constructor(e, t = e) {
    super(Re("defs", e), t);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
}
ve(rs, "Defs");
class tt extends Be {
}
function Vr(r) {
  return this.attr("rx", r);
}
function Gr(r) {
  return this.attr("ry", r);
}
function so(r) {
  return r == null ? this.cx() - this.rx() : this.cx(r + this.rx());
}
function ro(r) {
  return r == null ? this.cy() - this.ry() : this.cy(r + this.ry());
}
function ao(r) {
  return this.attr("cx", r);
}
function no(r) {
  return this.attr("cy", r);
}
function oo(r) {
  return r == null ? 2 * this.rx() : this.rx(new de(r).divide(2));
}
function lo(r) {
  return r == null ? 2 * this.ry() : this.ry(new de(r).divide(2));
}
ve(tt, "Shape");
var Ph = Object.freeze({ __proto__: null, cx: ao, cy: no, height: lo, rx: Vr, ry: Gr, width: oo, x: so, y: ro });
class Wi extends tt {
  constructor(e, t = e) {
    super(Re("ellipse", e), t);
  }
  size(e, t) {
    const i = si(this, e, t);
    return this.rx(new de(i.width).divide(2)).ry(new de(i.height).divide(2));
  }
}
oe(Wi, Ph), ge("Container", { ellipse: Me(function(r = 0, e = r) {
  return this.put(new Wi()).size(r, e).move(0, 0);
}) }), ve(Wi, "Ellipse");
class co extends Mt {
  constructor(e = be.document.createDocumentFragment()) {
    super(e);
  }
  xml(e, t, i) {
    if (typeof e == "boolean" && (i = t, t = e, e = null), e == null || typeof e == "function") {
      const s = new Mt(wi("wrapper", i));
      return s.add(this.node.cloneNode(!0)), s.xml(!1, i);
    }
    return super.xml(e, !1, i);
  }
}
function ho(r, e) {
  return (this._element || this).type === "radialGradient" ? this.attr({ fx: new de(r), fy: new de(e) }) : this.attr({ x1: new de(r), y1: new de(e) });
}
function uo(r, e) {
  return (this._element || this).type === "radialGradient" ? this.attr({ cx: new de(r), cy: new de(e) }) : this.attr({ x2: new de(r), y2: new de(e) });
}
ve(co, "Fragment");
var Lh = Object.freeze({ __proto__: null, from: ho, to: uo });
class xi extends qe {
  constructor(e, t) {
    super(Re(e + "Gradient", typeof e == "string" ? null : e), t);
  }
  attr(e, t, i) {
    return e === "transform" && (e = "gradientTransform"), super.attr(e, t, i);
  }
  bbox() {
    return new Oe();
  }
  targets() {
    return Xt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(e) {
    return this.clear(), typeof e == "function" && e.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
oe(xi, Lh), ge({ Container: { gradient(...r) {
  return this.defs().gradient(...r);
} }, Defs: { gradient: Me(function(r, e) {
  return this.put(new xi(r)).update(e);
}) } }), ve(xi, "Gradient");
class Si extends qe {
  constructor(e, t = e) {
    super(Re("pattern", e), t);
  }
  attr(e, t, i) {
    return e === "transform" && (e = "patternTransform"), super.attr(e, t, i);
  }
  bbox() {
    return new Oe();
  }
  targets() {
    return Xt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(e) {
    return this.clear(), typeof e == "function" && e.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
ge({ Container: { pattern(...r) {
  return this.defs().pattern(...r);
} }, Defs: { pattern: Me(function(r, e, t) {
  return this.put(new Si()).update(t).attr({ x: 0, y: 0, width: r, height: e, patternUnits: "userSpaceOnUse" });
}) } }), ve(Si, "Pattern");
let Vi = class extends tt {
  constructor(r, e = r) {
    super(Re("image", r), e);
  }
  load(r, e) {
    if (!r) return this;
    const t = new be.window.Image();
    return bt(t, "load", function(i) {
      const s = this.parent(Si);
      this.width() === 0 && this.height() === 0 && this.size(t.width, t.height), s instanceof Si && s.width() === 0 && s.height() === 0 && s.size(this.width(), this.height()), typeof e == "function" && e.call(this, i);
    }, this), bt(t, "load error", function() {
      nt(t);
    }), this.attr("href", t.src = r, ri);
  }
};
var Xa;
Xa = function(r, e, t) {
  return r !== "fill" && r !== "stroke" || yh.test(e) && (e = t.root().defs().image(e)), e instanceof Vi && (e = t.root().defs().pattern(0, 0, (i) => {
    i.add(e);
  })), e;
}, io.push(Xa), ge({ Container: { image: Me(function(r, e) {
  return this.put(new Vi()).size(0, 0).load(r, e);
}) } }), ve(Vi, "Image");
class Rt extends jt {
  bbox() {
    let e = -1 / 0, t = -1 / 0, i = 1 / 0, s = 1 / 0;
    return this.forEach(function(a) {
      e = Math.max(a[0], e), t = Math.max(a[1], t), i = Math.min(a[0], i), s = Math.min(a[1], s);
    }), new Oe(i, s, e - i, t - s);
  }
  move(e, t) {
    const i = this.bbox();
    if (e -= i.x, t -= i.y, !isNaN(e) && !isNaN(t)) for (let s = this.length - 1; s >= 0; s--) this[s] = [this[s][0] + e, this[s][1] + t];
    return this;
  }
  parse(e = [0, 0]) {
    const t = [];
    (e = e instanceof Array ? Array.prototype.concat.apply([], e) : e.trim().split(yt).map(parseFloat)).length % 2 != 0 && e.pop();
    for (let i = 0, s = e.length; i < s; i += 2) t.push([e[i], e[i + 1]]);
    return t;
  }
  size(e, t) {
    let i;
    const s = this.bbox();
    for (i = this.length - 1; i >= 0; i--) s.width && (this[i][0] = (this[i][0] - s.x) * e / s.width + s.x), s.height && (this[i][1] = (this[i][1] - s.y) * t / s.height + s.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const e = [];
    for (let t = 0, i = this.length; t < i; t++) e.push(this[t].join(","));
    return e.join(" ");
  }
  transform(e) {
    return this.clone().transformO(e);
  }
  transformO(e) {
    ne.isMatrixLike(e) || (e = new ne(e));
    for (let t = this.length; t--; ) {
      const [i, s] = this[t];
      this[t][0] = e.a * i + e.c * s + e.e, this[t][1] = e.b * i + e.d * s + e.f;
    }
    return this;
  }
}
const Ih = Rt;
var $r = Object.freeze({ __proto__: null, MorphArray: Ih, height: function(r) {
  const e = this.bbox();
  return r == null ? e.height : this.size(e.width, r);
}, width: function(r) {
  const e = this.bbox();
  return r == null ? e.width : this.size(r, e.height);
}, x: function(r) {
  return r == null ? this.bbox().x : this.move(r, this.bbox().y);
}, y: function(r) {
  return r == null ? this.bbox().y : this.move(this.bbox().x, r);
} });
let Ot = class extends tt {
  constructor(r, e = r) {
    super(Re("line", r), e);
  }
  array() {
    return new Rt([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  move(r, e) {
    return this.attr(this.array().move(r, e).toLine());
  }
  plot(r, e, t, i) {
    return r == null ? this.array() : (r = e !== void 0 ? { x1: r, y1: e, x2: t, y2: i } : new Rt(r).toLine(), this.attr(r));
  }
  size(r, e) {
    const t = si(this, r, e);
    return this.attr(this.array().size(t.width, t.height).toLine());
  }
};
oe(Ot, $r), ge({ Container: { line: Me(function(...r) {
  return Ot.prototype.plot.apply(this.put(new Ot()), r[0] != null ? r : [0, 0, 0, 0]);
}) } }), ve(Ot, "Line");
let Gi = class extends qe {
  constructor(r, e = r) {
    super(Re("marker", r), e);
  }
  height(r) {
    return this.attr("markerHeight", r);
  }
  orient(r) {
    return this.attr("orient", r);
  }
  ref(r, e) {
    return this.attr("refX", r).attr("refY", e);
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
  update(r) {
    return this.clear(), typeof r == "function" && r.call(this, this), this;
  }
  width(r) {
    return this.attr("markerWidth", r);
  }
};
function $t(r, e) {
  return function(t) {
    return t == null ? this[r] : (this[r] = t, e && e.call(this), this);
  };
}
ge({ Container: { marker(...r) {
  return this.defs().marker(...r);
} }, Defs: { marker: Me(function(r, e, t) {
  return this.put(new Gi()).size(r, e).ref(r / 2, e / 2).viewbox(0, 0, r, e).attr("orient", "auto").update(t);
}) }, marker: { marker(r, e, t, i) {
  let s = ["marker"];
  return r !== "all" && s.push(r), s = s.join("-"), r = arguments[1] instanceof Gi ? arguments[1] : this.defs().marker(e, t, i), this.attr(s, r);
} } }), ve(Gi, "Marker");
const Eh = { "-": function(r) {
  return r;
}, "<>": function(r) {
  return -Math.cos(r * Math.PI) / 2 + 0.5;
}, ">": function(r) {
  return Math.sin(r * Math.PI / 2);
}, "<": function(r) {
  return 1 - Math.cos(r * Math.PI / 2);
}, bezier: function(r, e, t, i) {
  return function(s) {
    return s < 0 ? r > 0 ? e / r * s : t > 0 ? i / t * s : 0 : s > 1 ? t < 1 ? (1 - i) / (1 - t) * s + (i - t) / (1 - t) : r < 1 ? (1 - e) / (1 - r) * s + (e - r) / (1 - r) : 1 : 3 * s * (1 - s) ** 2 * e + 3 * s ** 2 * (1 - s) * i + s ** 3;
  };
}, steps: function(r, e = "end") {
  e = e.split("-").reverse()[0];
  let t = r;
  return e === "none" ? --t : e === "both" && ++t, (i, s = !1) => {
    let a = Math.floor(i * r);
    const n = i * a % 1 == 0;
    return e !== "start" && e !== "both" || ++a, s && n && --a, i >= 0 && a < 0 && (a = 0), i <= 1 && a > t && (a = t), a / t;
  };
} };
class Ur {
  done() {
    return !1;
  }
}
class hr extends Ur {
  constructor(e = Ch) {
    super(), this.ease = Eh[e] || e;
  }
  step(e, t, i) {
    return typeof e != "number" ? i < 1 ? e : t : e + (t - e) * this.ease(i);
  }
}
class Ki extends Ur {
  constructor(e) {
    super(), this.stepper = e;
  }
  done(e) {
    return e.done;
  }
  step(e, t, i, s) {
    return this.stepper(e, t, i, s);
  }
}
function Ba() {
  const r = (this._duration || 500) / 1e3, e = this._overshoot || 0, t = Math.PI, i = Math.log(e / 100 + 1e-10), s = -i / Math.sqrt(t * t + i * i), a = 3.9 / (s * r);
  this.d = 2 * s * a, this.k = a * a;
}
oe(class extends Ki {
  constructor(r = 500, e = 0) {
    super(), this.duration(r).overshoot(e);
  }
  step(r, e, t, i) {
    if (typeof r == "string") return r;
    if (i.done = t === 1 / 0, t === 1 / 0) return e;
    if (t === 0) return r;
    t > 100 && (t = 16), t /= 1e3;
    const s = i.velocity || 0, a = -this.d * s - this.k * (r - e), n = r + s * t + a * t * t / 2;
    return i.velocity = s + a * t, i.done = Math.abs(e - n) + Math.abs(s) < 2e-3, i.done ? e : n;
  }
}, { duration: $t("_duration", Ba), overshoot: $t("_overshoot", Ba) });
oe(class extends Ki {
  constructor(r = 0.1, e = 0.01, t = 0, i = 1e3) {
    super(), this.p(r).i(e).d(t).windup(i);
  }
  step(r, e, t, i) {
    if (typeof r == "string") return r;
    if (i.done = t === 1 / 0, t === 1 / 0) return e;
    if (t === 0) return r;
    const s = e - r;
    let a = (i.integral || 0) + s * t;
    const n = (s - (i.error || 0)) / t, o = this._windup;
    return o !== !1 && (a = Math.max(-o, Math.min(a, o))), i.error = s, i.integral = a, i.done = Math.abs(s) < 1e-3, i.done ? e : r + (this.P * s + this.I * a + this.D * n);
  }
}, { windup: $t("_windup"), p: $t("P"), i: $t("I"), d: $t("D") });
const Th = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 }, dr = { M: function(r, e, t) {
  return e.x = t.x = r[0], e.y = t.y = r[1], ["M", e.x, e.y];
}, L: function(r, e) {
  return e.x = r[0], e.y = r[1], ["L", r[0], r[1]];
}, H: function(r, e) {
  return e.x = r[0], ["H", r[0]];
}, V: function(r, e) {
  return e.y = r[0], ["V", r[0]];
}, C: function(r, e) {
  return e.x = r[4], e.y = r[5], ["C", r[0], r[1], r[2], r[3], r[4], r[5]];
}, S: function(r, e) {
  return e.x = r[2], e.y = r[3], ["S", r[0], r[1], r[2], r[3]];
}, Q: function(r, e) {
  return e.x = r[2], e.y = r[3], ["Q", r[0], r[1], r[2], r[3]];
}, T: function(r, e) {
  return e.x = r[0], e.y = r[1], ["T", r[0], r[1]];
}, Z: function(r, e, t) {
  return e.x = t.x, e.y = t.y, ["Z"];
}, A: function(r, e) {
  return e.x = r[5], e.y = r[6], ["A", r[0], r[1], r[2], r[3], r[4], r[5], r[6]];
} }, Ss = "mlhvqtcsaz".split("");
for (let r = 0, e = Ss.length; r < e; ++r) dr[Ss[r]] = /* @__PURE__ */ function(t) {
  return function(i, s, a) {
    if (t === "H") i[0] = i[0] + s.x;
    else if (t === "V") i[0] = i[0] + s.y;
    else if (t === "A") i[5] = i[5] + s.x, i[6] = i[6] + s.y;
    else for (let n = 0, o = i.length; n < o; ++n) i[n] = i[n] + (n % 2 ? s.y : s.x);
    return dr[t](i, s, a);
  };
}(Ss[r].toUpperCase());
function ur(r) {
  return r.segment.length && r.segment.length - 1 === Th[r.segment[0].toUpperCase()];
}
function _h(r, e) {
  r.inNumber && Et(r, !1);
  const t = Br.test(e);
  if (t) r.segment = [e];
  else {
    const i = r.lastCommand, s = i.toLowerCase(), a = i === s;
    r.segment = [s === "m" ? a ? "l" : "L" : i];
  }
  return r.inSegment = !0, r.lastCommand = r.segment[0], t;
}
function Et(r, e) {
  if (!r.inNumber) throw new Error("Parser Error");
  r.number && r.segment.push(parseFloat(r.number)), r.inNumber = e, r.number = "", r.pointSeen = !1, r.hasExponent = !1, ur(r) && gr(r);
}
function gr(r) {
  r.inSegment = !1, r.absolute && (r.segment = function(e) {
    const t = e.segment[0];
    return dr[t](e.segment.slice(1), e.p, e.p0);
  }(r)), r.segments.push(r.segment);
}
function Oh(r) {
  if (!r.segment.length) return !1;
  const e = r.segment[0].toUpperCase() === "A", t = r.segment.length;
  return e && (t === 4 || t === 5);
}
function zh(r) {
  return r.lastToken.toUpperCase() === "E";
}
const Fh = /* @__PURE__ */ new Set([" ", ",", "	", `
`, "\r", "\f"]);
class lt extends jt {
  bbox() {
    return kt().path.setAttribute("d", this.toString()), new Oe(kt.nodes.path.getBBox());
  }
  move(e, t) {
    const i = this.bbox();
    if (e -= i.x, t -= i.y, !isNaN(e) && !isNaN(t)) for (let s, a = this.length - 1; a >= 0; a--) s = this[a][0], s === "M" || s === "L" || s === "T" ? (this[a][1] += e, this[a][2] += t) : s === "H" ? this[a][1] += e : s === "V" ? this[a][1] += t : s === "C" || s === "S" || s === "Q" ? (this[a][1] += e, this[a][2] += t, this[a][3] += e, this[a][4] += t, s === "C" && (this[a][5] += e, this[a][6] += t)) : s === "A" && (this[a][6] += e, this[a][7] += t);
    return this;
  }
  parse(e = "M0 0") {
    return Array.isArray(e) && (e = Array.prototype.concat.apply([], e).toString()), function(t, i = !0) {
      let s = 0, a = "";
      const n = { segment: [], inNumber: !1, number: "", lastToken: "", inSegment: !1, segments: [], pointSeen: !1, hasExponent: !1, absolute: i, p0: new ye(), p: new ye() };
      for (; n.lastToken = a, a = t.charAt(s++); ) if (n.inSegment || !_h(n, a)) if (a !== ".") if (isNaN(parseInt(a))) if (Fh.has(a)) n.inNumber && Et(n, !1);
      else if (a !== "-" && a !== "+") if (a.toUpperCase() !== "E") {
        if (Br.test(a)) {
          if (n.inNumber) Et(n, !1);
          else {
            if (!ur(n)) throw new Error("parser Error");
            gr(n);
          }
          --s;
        }
      } else n.number += a, n.hasExponent = !0;
      else {
        if (n.inNumber && !zh(n)) {
          Et(n, !1), --s;
          continue;
        }
        n.number += a, n.inNumber = !0;
      }
      else {
        if (n.number === "0" || Oh(n)) {
          n.inNumber = !0, n.number = a, Et(n, !0);
          continue;
        }
        n.inNumber = !0, n.number += a;
      }
      else {
        if (n.pointSeen || n.hasExponent) {
          Et(n, !1), --s;
          continue;
        }
        n.inNumber = !0, n.pointSeen = !0, n.number += a;
      }
      return n.inNumber && Et(n, !1), n.inSegment && ur(n) && gr(n), n.segments;
    }(e);
  }
  size(e, t) {
    const i = this.bbox();
    let s, a;
    for (i.width = i.width === 0 ? 1 : i.width, i.height = i.height === 0 ? 1 : i.height, s = this.length - 1; s >= 0; s--) a = this[s][0], a === "M" || a === "L" || a === "T" ? (this[s][1] = (this[s][1] - i.x) * e / i.width + i.x, this[s][2] = (this[s][2] - i.y) * t / i.height + i.y) : a === "H" ? this[s][1] = (this[s][1] - i.x) * e / i.width + i.x : a === "V" ? this[s][1] = (this[s][1] - i.y) * t / i.height + i.y : a === "C" || a === "S" || a === "Q" ? (this[s][1] = (this[s][1] - i.x) * e / i.width + i.x, this[s][2] = (this[s][2] - i.y) * t / i.height + i.y, this[s][3] = (this[s][3] - i.x) * e / i.width + i.x, this[s][4] = (this[s][4] - i.y) * t / i.height + i.y, a === "C" && (this[s][5] = (this[s][5] - i.x) * e / i.width + i.x, this[s][6] = (this[s][6] - i.y) * t / i.height + i.y)) : a === "A" && (this[s][1] = this[s][1] * e / i.width, this[s][2] = this[s][2] * t / i.height, this[s][6] = (this[s][6] - i.x) * e / i.width + i.x, this[s][7] = (this[s][7] - i.y) * t / i.height + i.y);
    return this;
  }
  toString() {
    return function(e) {
      let t = "";
      for (let i = 0, s = e.length; i < s; i++) t += e[i][0], e[i][1] != null && (t += e[i][1], e[i][2] != null && (t += " ", t += e[i][2], e[i][3] != null && (t += " ", t += e[i][3], t += " ", t += e[i][4], e[i][5] != null && (t += " ", t += e[i][5], t += " ", t += e[i][6], e[i][7] != null && (t += " ", t += e[i][7])))));
      return t + " ";
    }(this);
  }
}
const go = (r) => {
  const e = typeof r;
  return e === "number" ? de : e === "string" ? Ae.isColor(r) ? Ae : yt.test(r) ? Br.test(r) ? lt : jt : Kn.test(r) ? de : fr : pr.indexOf(r.constructor) > -1 ? r.constructor : Array.isArray(r) ? jt : e === "object" ? ki : fr;
};
class Tt {
  constructor(e) {
    this._stepper = e || new hr("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(e) {
    return this._morphObj.morph(this._from, this._to, e, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce(function(e, t) {
      return e && t;
    }, !0);
  }
  from(e) {
    return e == null ? this._from : (this._from = this._set(e), this);
  }
  stepper(e) {
    return e == null ? this._stepper : (this._stepper = e, this);
  }
  to(e) {
    return e == null ? this._to : (this._to = this._set(e), this);
  }
  type(e) {
    return e == null ? this._type : (this._type = e, this);
  }
  _set(e) {
    this._type || this.type(go(e));
    let t = new this._type(e);
    return this._type === Ae && (t = this._to ? t[this._to[4]]() : this._from ? t[this._from[4]]() : t), this._type === ki && (t = this._to ? t.align(this._to) : this._from ? t.align(this._from) : t), t = t.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(t.length)).map(Object).map(function(i) {
      return i.done = !0, i;
    }), t;
  }
}
class fr {
  constructor(...e) {
    this.init(...e);
  }
  init(e) {
    return e = Array.isArray(e) ? e[0] : e, this.value = e, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
}
class Ei {
  constructor(...e) {
    this.init(...e);
  }
  init(e) {
    return Array.isArray(e) && (e = { scaleX: e[0], scaleY: e[1], shear: e[2], rotate: e[3], translateX: e[4], translateY: e[5], originX: e[6], originY: e[7] }), Object.assign(this, Ei.defaults, e), this;
  }
  toArray() {
    const e = this;
    return [e.scaleX, e.scaleY, e.shear, e.rotate, e.translateX, e.translateY, e.originX, e.originY];
  }
}
Ei.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
const Nh = (r, e) => r[0] < e[0] ? -1 : r[0] > e[0] ? 1 : 0;
class ki {
  constructor(...e) {
    this.init(...e);
  }
  align(e) {
    const t = this.values;
    for (let i = 0, s = t.length; i < s; ++i) {
      if (t[i + 1] === e[i + 1]) {
        if (t[i + 1] === Ae && e[i + 7] !== t[i + 7]) {
          const o = e[i + 7], l = new Ae(this.values.splice(i + 3, 5))[o]().toArray();
          this.values.splice(i + 3, 0, ...l);
        }
        i += t[i + 2] + 2;
        continue;
      }
      if (!e[i + 1]) return this;
      const a = new e[i + 1]().toArray(), n = t[i + 2] + 3;
      t.splice(i, n, e[i], e[i + 1], e[i + 2], ...a), i += t[i + 2] + 2;
    }
    return this;
  }
  init(e) {
    if (this.values = [], Array.isArray(e)) return void (this.values = e.slice());
    e = e || {};
    const t = [];
    for (const i in e) {
      const s = go(e[i]), a = new s(e[i]).toArray();
      t.push([i, s, a.length, ...a]);
    }
    return t.sort(Nh), this.values = t.reduce((i, s) => i.concat(s), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const e = {}, t = this.values;
    for (; t.length; ) {
      const i = t.shift(), s = t.shift(), a = t.shift(), n = t.splice(0, a);
      e[i] = new s(n);
    }
    return e;
  }
}
const pr = [fr, Ei, ki];
class qt extends tt {
  constructor(e, t = e) {
    super(Re("path", e), t);
  }
  array() {
    return this._array || (this._array = new lt(this.attr("d")));
  }
  clear() {
    return delete this._array, this;
  }
  height(e) {
    return e == null ? this.bbox().height : this.size(this.bbox().width, e);
  }
  move(e, t) {
    return this.attr("d", this.array().move(e, t));
  }
  plot(e) {
    return e == null ? this.array() : this.clear().attr("d", typeof e == "string" ? e : this._array = new lt(e));
  }
  size(e, t) {
    const i = si(this, e, t);
    return this.attr("d", this.array().size(i.width, i.height));
  }
  width(e) {
    return e == null ? this.bbox().width : this.size(e, this.bbox().height);
  }
  x(e) {
    return e == null ? this.bbox().x : this.move(e, this.bbox().y);
  }
  y(e) {
    return e == null ? this.bbox().y : this.move(this.bbox().x, e);
  }
}
qt.prototype.MorphArray = lt, ge({ Container: { path: Me(function(r) {
  return this.put(new qt()).plot(r || new lt());
}) } }), ve(qt, "Path");
var fo = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new Rt(this.attr("points")));
}, clear: function() {
  return delete this._array, this;
}, move: function(r, e) {
  return this.attr("points", this.array().move(r, e));
}, plot: function(r) {
  return r == null ? this.array() : this.clear().attr("points", typeof r == "string" ? r : this._array = new Rt(r));
}, size: function(r, e) {
  const t = si(this, r, e);
  return this.attr("points", this.array().size(t.width, t.height));
} });
class zt extends tt {
  constructor(e, t = e) {
    super(Re("polygon", e), t);
  }
}
ge({ Container: { polygon: Me(function(r) {
  return this.put(new zt()).plot(r || new Rt());
}) } }), oe(zt, $r), oe(zt, fo), ve(zt, "Polygon");
class Ft extends tt {
  constructor(e, t = e) {
    super(Re("polyline", e), t);
  }
}
ge({ Container: { polyline: Me(function(r) {
  return this.put(new Ft()).plot(r || new Rt());
}) } }), oe(Ft, $r), oe(Ft, fo), ve(Ft, "Polyline");
class $i extends tt {
  constructor(e, t = e) {
    super(Re("rect", e), t);
  }
}
oe($i, { rx: Vr, ry: Gr }), ge({ Container: { rect: Me(function(r, e) {
  return this.put(new $i()).size(r, e);
}) } }), ve($i, "Rect");
class ks {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  push(e) {
    const t = e.next !== void 0 ? e : { value: e, next: null, prev: null };
    return this._last ? (t.prev = this._last, this._last.next = t, this._last = t) : (this._last = t, this._first = t), t;
  }
  remove(e) {
    e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this._last && (this._last = e.prev), e === this._first && (this._first = e.next), e.prev = null, e.next = null;
  }
  shift() {
    const e = this._first;
    return e ? (this._first = e.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, e.value) : null;
  }
}
const Ce = { nextDraw: null, frames: new ks(), timeouts: new ks(), immediates: new ks(), timer: () => be.window.performance || be.window.Date, transforms: [], frame(r) {
  const e = Ce.frames.push({ run: r });
  return Ce.nextDraw === null && (Ce.nextDraw = be.window.requestAnimationFrame(Ce._draw)), e;
}, timeout(r, e) {
  e = e || 0;
  const t = Ce.timer().now() + e, i = Ce.timeouts.push({ run: r, time: t });
  return Ce.nextDraw === null && (Ce.nextDraw = be.window.requestAnimationFrame(Ce._draw)), i;
}, immediate(r) {
  const e = Ce.immediates.push(r);
  return Ce.nextDraw === null && (Ce.nextDraw = be.window.requestAnimationFrame(Ce._draw)), e;
}, cancelFrame(r) {
  r != null && Ce.frames.remove(r);
}, clearTimeout(r) {
  r != null && Ce.timeouts.remove(r);
}, cancelImmediate(r) {
  r != null && Ce.immediates.remove(r);
}, _draw(r) {
  let e = null;
  const t = Ce.timeouts.last();
  for (; (e = Ce.timeouts.shift()) && (r >= e.time ? e.run() : Ce.timeouts.push(e), e !== t); ) ;
  let i = null;
  const s = Ce.frames.last();
  for (; i !== s && (i = Ce.frames.shift()); ) i.run(r);
  let a = null;
  for (; a = Ce.immediates.shift(); ) a();
  Ce.nextDraw = Ce.timeouts.first() || Ce.frames.first() ? be.window.requestAnimationFrame(Ce._draw) : null;
} }, Dh = function(r) {
  const e = r.start, t = r.runner.duration();
  return { start: e, duration: t, end: e + t, runner: r.runner };
}, Hh = function() {
  const r = be.window;
  return (r.performance || r.Date).now();
};
class po extends Ii {
  constructor(e = Hh) {
    super(), this._timeSource = e, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const e = this.getLastRunnerInfo(), t = e ? e.runner.duration() : 0;
    return (e ? e.start : this._time) + t;
  }
  getEndTimeOfTimeline() {
    const e = this._runners.map((t) => t.start + t.runner.duration());
    return Math.max(0, ...e);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(e) {
    return this._runners[this._runnerIds.indexOf(e)] || null;
  }
  pause() {
    return this._paused = !0, this._continue();
  }
  persist(e) {
    return e == null ? this._persist : (this._persist = e, this);
  }
  play() {
    return this._paused = !1, this.updateTime()._continue();
  }
  reverse(e) {
    const t = this.speed();
    if (e == null) return this.speed(-t);
    const i = Math.abs(t);
    return this.speed(e ? -i : i);
  }
  schedule(e, t, i) {
    if (e == null) return this._runners.map(Dh);
    let s = 0;
    const a = this.getEndTime();
    if (t = t || 0, i == null || i === "last" || i === "after") s = a;
    else if (i === "absolute" || i === "start") s = t, t = 0;
    else if (i === "now") s = this._time;
    else if (i === "relative") {
      const l = this.getRunnerInfoById(e.id);
      l && (s = l.start + t, t = 0);
    } else {
      if (i !== "with-last") throw new Error('Invalid value for the "when" parameter');
      {
        const l = this.getLastRunnerInfo();
        s = l ? l.start : this._time;
      }
    }
    e.unschedule(), e.timeline(this);
    const n = e.persist(), o = { persist: n === null ? this._persist : n, start: s + t, runner: e };
    return this._lastRunnerId = e.id, this._runners.push(o), this._runners.sort((l, c) => l.start - c.start), this._runnerIds = this._runners.map((l) => l.runner.id), this.updateTime()._continue(), this;
  }
  seek(e) {
    return this.time(this._time + e);
  }
  source(e) {
    return e == null ? this._timeSource : (this._timeSource = e, this);
  }
  speed(e) {
    return e == null ? this._speed : (this._speed = e, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(e) {
    return e == null ? this._time : (this._time = e, this._continue(!0));
  }
  unschedule(e) {
    const t = this._runnerIds.indexOf(e.id);
    return t < 0 || (this._runners.splice(t, 1), this._runnerIds.splice(t, 1), e.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(e = !1) {
    return Ce.cancelFrame(this._nextFrame), this._nextFrame = null, e ? this._stepImmediate() : (this._paused || (this._nextFrame = Ce.frame(this._step)), this);
  }
  _stepFn(e = !1) {
    const t = this._timeSource();
    let i = t - this._lastSourceTime;
    e && (i = 0);
    const s = this._speed * i + (this._time - this._lastStepTime);
    this._lastSourceTime = t, e || (this._time += s, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
    for (let n = this._runners.length; n--; ) {
      const o = this._runners[n], l = o.runner;
      this._time - o.start <= 0 && l.reset();
    }
    let a = !1;
    for (let n = 0, o = this._runners.length; n < o; n++) {
      const l = this._runners[n], c = l.runner;
      let h = s;
      const d = this._time - l.start;
      if (d <= 0) {
        a = !0;
        continue;
      }
      d < h && (h = d), c.active() && (c.step(h).done ? l.persist !== !0 && c.duration() - c.time() + this._time + l.persist < this._time && (c.unschedule(), --n, --o) : a = !0);
    }
    return a && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = !0, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, !1), this._stepImmediate = this._stepFn.bind(this, !0);
  }
}
ge({ Element: { timeline: function(r) {
  return r == null ? (this._timeline = this._timeline || new po(), this._timeline) : (this._timeline = r, this);
} } });
class Qe extends Ii {
  constructor(e) {
    super(), this.id = Qe.id++, e = typeof (e = e ?? ws) == "function" ? new Ki(e) : e, this._element = null, this._timeline = null, this.done = !1, this._queue = [], this._duration = typeof e == "number" && e, this._isDeclarative = e instanceof Ki, this._stepper = this._isDeclarative ? e : new hr(), this._history = {}, this.enabled = !0, this._time = 0, this._lastTime = 0, this._reseted = !0, this.transforms = new ne(), this.transformId = 1, this._haveReversed = !1, this._reverse = !1, this._loopsDone = 0, this._swing = !1, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(e, t, i) {
    let s = 1, a = !1, n = 0;
    return t = t ?? Ah, i = i || "last", typeof (e = e ?? ws) != "object" || e instanceof Ur || (t = e.delay ?? t, i = e.when ?? i, a = e.swing || a, s = e.times ?? s, n = e.wait ?? n, e = e.duration ?? ws), { duration: e, delay: t, swing: a, times: s, wait: n, when: i };
  }
  active(e) {
    return e == null ? this.enabled : (this.enabled = e, this);
  }
  addTransform(e) {
    return this.transforms.lmultiplyO(e), this;
  }
  after(e) {
    return this.on("finished", e);
  }
  animate(e, t, i) {
    const s = Qe.sanitise(e, t, i), a = new Qe(s.duration);
    return this._timeline && a.timeline(this._timeline), this._element && a.element(this._element), a.loop(s).schedule(s.delay, s.when);
  }
  clearTransform() {
    return this.transforms = new ne(), this;
  }
  clearTransformsFromQueue() {
    this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter((e) => !e.isTransform));
  }
  delay(e) {
    return this.animate(0, e);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(e) {
    return this.queue(null, e);
  }
  ease(e) {
    return this._stepper = new hr(e), this;
  }
  element(e) {
    return e == null ? this._element : (this._element = e, e._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(e, t, i) {
    return typeof e == "object" && (t = e.swing, i = e.wait, e = e.times), this._times = e || 1 / 0, this._swing = t || !1, this._wait = i || 0, this._times === !0 && (this._times = 1 / 0), this;
  }
  loops(e) {
    const t = this._duration + this._wait;
    if (e == null) {
      const a = Math.floor(this._time / t), n = (this._time - a * t) / this._duration;
      return Math.min(a + n, this._times);
    }
    const i = e % 1, s = t * Math.floor(e) + this._duration * i;
    return this.time(s);
  }
  persist(e) {
    return e == null ? this._persist : (this._persist = e, this);
  }
  position(e) {
    const t = this._time, i = this._duration, s = this._wait, a = this._times, n = this._swing, o = this._reverse;
    let l;
    if (e == null) {
      const d = function(g) {
        const p = n * Math.floor(g % (2 * (s + i)) / (s + i)), f = p && !o || !p && o, x = Math.pow(-1, f) * (g % (s + i)) / i + f;
        return Math.max(Math.min(x, 1), 0);
      }, u = a * (s + i) - s;
      return l = t <= 0 ? Math.round(d(1e-5)) : t < u ? d(t) : Math.round(d(u - 1e-5)), l;
    }
    const c = Math.floor(this.loops()), h = n && c % 2 == 0;
    return l = c + (h && !o || o && h ? e : 1 - e), this.loops(l);
  }
  progress(e) {
    return e == null ? Math.min(1, this._time / this.duration()) : this.time(e * this.duration());
  }
  queue(e, t, i, s) {
    return this._queue.push({ initialiser: e || ja, runner: t || ja, retarget: i, isTransform: s, initialised: !1, finished: !1 }), this.timeline() && this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = !0), this;
  }
  reverse(e) {
    return this._reverse = e ?? !this._reverse, this;
  }
  schedule(e, t, i) {
    if (e instanceof po || (i = t, t = e, e = this.timeline()), !e) throw Error("Runner cannot be scheduled without timeline");
    return e.schedule(this, t, i), this;
  }
  step(e) {
    if (!this.enabled) return this;
    e = e ?? 16, this._time += e;
    const t = this.position(), i = this._lastPosition !== t && this._time >= 0;
    this._lastPosition = t;
    const s = this.duration(), a = this._lastTime <= 0 && this._time > 0, n = this._lastTime < s && this._time >= s;
    this._lastTime = this._time, a && this.fire("start", this);
    const o = this._isDeclarative;
    this.done = !o && !n && this._time >= s, this._reseted = !1;
    let l = !1;
    return (i || o) && (this._initialise(i), this.transforms = new ne(), l = this._run(o ? e : t), this.fire("step", this)), this.done = this.done || l && o, n && this.fire("finished", this), this;
  }
  time(e) {
    if (e == null) return this._time;
    const t = e - this._time;
    return this.step(t), this;
  }
  timeline(e) {
    return e === void 0 ? this._timeline : (this._timeline = e, this);
  }
  unschedule() {
    const e = this.timeline();
    return e && e.unschedule(this), this;
  }
  _initialise(e) {
    if (e || this._isDeclarative) for (let t = 0, i = this._queue.length; t < i; ++t) {
      const s = this._queue[t], a = this._isDeclarative || !s.initialised && e;
      e = !s.finished, a && e && (s.initialiser.call(this), s.initialised = !0);
    }
  }
  _rememberMorpher(e, t) {
    if (this._history[e] = { morpher: t, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const i = this.timeline();
      i && i.play();
    }
  }
  _run(e) {
    let t = !0;
    for (let i = 0, s = this._queue.length; i < s; ++i) {
      const a = this._queue[i], n = a.runner.call(this, e);
      a.finished = a.finished || n === !0, t = t && a.finished;
    }
    return t;
  }
  _tryRetarget(e, t, i) {
    if (this._history[e]) {
      if (!this._history[e].caller.initialised) {
        const a = this._queue.indexOf(this._history[e].caller);
        return this._queue.splice(a, 1), !1;
      }
      this._history[e].caller.retarget ? this._history[e].caller.retarget.call(this, t, i) : this._history[e].morpher.to(t), this._history[e].caller.finished = !1;
      const s = this.timeline();
      return s && s.play(), !0;
    }
    return !1;
  }
}
Qe.id = 0;
class Qi {
  constructor(e = new ne(), t = -1, i = !0) {
    this.transforms = e, this.id = t, this.done = i;
  }
  clearTransformsFromQueue() {
  }
}
oe([Qe, Qi], { mergeWith(r) {
  return new Qi(r.transforms.lmultiply(this.transforms), r.id);
} });
const xo = (r, e) => r.lmultiplyO(e), mo = (r) => r.transforms;
function Yh() {
  const r = this._transformationRunners.runners.map(mo).reduce(xo, new ne());
  this.transform(r), this._transformationRunners.merge(), this._transformationRunners.length() === 1 && (this._frameId = null);
}
class jh {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(e) {
    if (this.runners.includes(e)) return;
    const t = e.id + 1;
    return this.runners.push(e), this.ids.push(t), this;
  }
  clearBefore(e) {
    const t = this.ids.indexOf(e + 1) || 1;
    return this.ids.splice(0, t, 0), this.runners.splice(0, t, new Qi()).forEach((i) => i.clearTransformsFromQueue()), this;
  }
  edit(e, t) {
    const i = this.ids.indexOf(e + 1);
    return this.ids.splice(i, 1, e + 1), this.runners.splice(i, 1, t), this;
  }
  getByID(e) {
    return this.runners[this.ids.indexOf(e + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let e = null;
    for (let t = 0; t < this.runners.length; ++t) {
      const i = this.runners[t];
      if (e && i.done && e.done && (!i._timeline || !i._timeline._runnerIds.includes(i.id)) && (!e._timeline || !e._timeline._runnerIds.includes(e.id))) {
        this.remove(i.id);
        const s = i.mergeWith(e);
        this.edit(e.id, s), e = s, --t;
      } else e = i;
    }
    return this;
  }
  remove(e) {
    const t = this.ids.indexOf(e + 1);
    return this.ids.splice(t, 1), this.runners.splice(t, 1), this;
  }
}
ge({ Element: { animate(r, e, t) {
  const i = Qe.sanitise(r, e, t), s = this.timeline();
  return new Qe(i.duration).loop(i).element(this).timeline(s.play()).schedule(i.delay, i.when);
}, delay(r, e) {
  return this.animate(0, r, e);
}, _clearTransformRunnersBefore(r) {
  this._transformationRunners.clearBefore(r.id);
}, _currentTransform(r) {
  return this._transformationRunners.runners.filter((e) => e.id <= r.id).map(mo).reduce(xo, new ne());
}, _addRunner(r) {
  this._transformationRunners.add(r), Ce.cancelImmediate(this._frameId), this._frameId = Ce.immediate(Yh.bind(this));
}, _prepareRunner() {
  this._frameId == null && (this._transformationRunners = new jh().add(new Qi(new ne(this))));
} } });
oe(Qe, { attr(r, e) {
  return this.styleAttr("attr", r, e);
}, css(r, e) {
  return this.styleAttr("css", r, e);
}, styleAttr(r, e, t) {
  if (typeof e == "string") return this.styleAttr(r, { [e]: t });
  let i = e;
  if (this._tryRetarget(r, i)) return this;
  let s = new Tt(this._stepper).to(i), a = Object.keys(i);
  return this.queue(function() {
    s = s.from(this.element()[r](a));
  }, function(n) {
    return this.element()[r](s.at(n).valueOf()), s.done();
  }, function(n) {
    const o = Object.keys(n), l = (c = a, o.filter((d) => !c.includes(d)));
    var c;
    if (l.length) {
      const d = this.element()[r](l), u = new ki(s.from()).valueOf();
      Object.assign(u, d), s.from(u);
    }
    const h = new ki(s.to()).valueOf();
    Object.assign(h, n), s.to(h), a = o, i = n;
  }), this._rememberMorpher(r, s), this;
}, zoom(r, e) {
  if (this._tryRetarget("zoom", r, e)) return this;
  let t = new Tt(this._stepper).to(new de(r));
  return this.queue(function() {
    t = t.from(this.element().zoom());
  }, function(i) {
    return this.element().zoom(t.at(i), e), t.done();
  }, function(i, s) {
    e = s, t.to(i);
  }), this._rememberMorpher("zoom", t), this;
}, transform(r, e, t) {
  if (e = r.relative || e, this._isDeclarative && !e && this._tryRetarget("transform", r)) return this;
  const i = ne.isMatrixLike(r);
  t = r.affine != null ? r.affine : t ?? !i;
  const s = new Tt(this._stepper).type(t ? Ei : ne);
  let a, n, o, l, c;
  return this.queue(function() {
    n = n || this.element(), a = a || lr(r, n), c = new ne(e ? void 0 : n), n._addRunner(this), e || n._clearTransformRunnersBefore(this);
  }, function(h) {
    e || this.clearTransform();
    const { x: d, y: u } = new ye(a).transform(n._currentTransform(this));
    let g = new ne({ ...r, origin: [d, u] }), p = this._isDeclarative && o ? o : c;
    if (t) {
      g = g.decompose(d, u), p = p.decompose(d, u);
      const x = g.rotate, m = p.rotate, b = [x - 360, x, x + 360], w = b.map((S) => Math.abs(S - m)), y = Math.min(...w), v = w.indexOf(y);
      g.rotate = b[v];
    }
    e && (i || (g.rotate = r.rotate || 0), this._isDeclarative && l && (p.rotate = l)), s.from(p), s.to(g);
    const f = s.at(h);
    return l = f.rotate, o = new ne(f), this.addTransform(o), n._addRunner(this), s.done();
  }, function(h) {
    (h.origin || "center").toString() !== (r.origin || "center").toString() && (a = lr(h, n)), r = { ...h, origin: a };
  }, !0), this._isDeclarative && this._rememberMorpher("transform", s), this;
}, x(r) {
  return this._queueNumber("x", r);
}, y(r) {
  return this._queueNumber("y", r);
}, ax(r) {
  return this._queueNumber("ax", r);
}, ay(r) {
  return this._queueNumber("ay", r);
}, dx(r = 0) {
  return this._queueNumberDelta("x", r);
}, dy(r = 0) {
  return this._queueNumberDelta("y", r);
}, dmove(r, e) {
  return this.dx(r).dy(e);
}, _queueNumberDelta(r, e) {
  if (e = new de(e), this._tryRetarget(r, e)) return this;
  const t = new Tt(this._stepper).to(e);
  let i = null;
  return this.queue(function() {
    i = this.element()[r](), t.from(i), t.to(i + e);
  }, function(s) {
    return this.element()[r](t.at(s)), t.done();
  }, function(s) {
    t.to(i + new de(s));
  }), this._rememberMorpher(r, t), this;
}, _queueObject(r, e) {
  if (this._tryRetarget(r, e)) return this;
  const t = new Tt(this._stepper).to(e);
  return this.queue(function() {
    t.from(this.element()[r]());
  }, function(i) {
    return this.element()[r](t.at(i)), t.done();
  }), this._rememberMorpher(r, t), this;
}, _queueNumber(r, e) {
  return this._queueObject(r, new de(e));
}, cx(r) {
  return this._queueNumber("cx", r);
}, cy(r) {
  return this._queueNumber("cy", r);
}, move(r, e) {
  return this.x(r).y(e);
}, amove(r, e) {
  return this.ax(r).ay(e);
}, center(r, e) {
  return this.cx(r).cy(e);
}, size(r, e) {
  let t;
  return r && e || (t = this._element.bbox()), r || (r = t.width / t.height * e), e || (e = t.height / t.width * r), this.width(r).height(e);
}, width(r) {
  return this._queueNumber("width", r);
}, height(r) {
  return this._queueNumber("height", r);
}, plot(r, e, t, i) {
  if (arguments.length === 4) return this.plot([r, e, t, i]);
  if (this._tryRetarget("plot", r)) return this;
  const s = new Tt(this._stepper).type(this._element.MorphArray).to(r);
  return this.queue(function() {
    s.from(this._element.array());
  }, function(a) {
    return this._element.plot(s.at(a)), s.done();
  }), this._rememberMorpher("plot", s), this;
}, leading(r) {
  return this._queueNumber("leading", r);
}, viewbox(r, e, t, i) {
  return this._queueObject("viewbox", new Oe(r, e, t, i));
}, update(r) {
  return typeof r != "object" ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (r.opacity != null && this.attr("stop-opacity", r.opacity), r.color != null && this.attr("stop-color", r.color), r.offset != null && this.attr("offset", r.offset), this);
} }), oe(Qe, { rx: Vr, ry: Gr, from: ho, to: uo }), ve(Qe, "Runner");
class xr extends qe {
  constructor(e, t = e) {
    super(Re("svg", e), t), this.namespace();
  }
  defs() {
    return this.isRoot() ? at(this.node.querySelector("defs")) || this.put(new rs()) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof be.window.SVGElement) && this.node.parentNode.nodeName !== "#document-fragment";
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: Yr, version: "1.1" }).attr("xmlns:xlink", ri, bs) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr("xmlns:xlink", null, bs).attr("xmlns:svgjs", null, bs);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
}
ge({ Container: { nested: Me(function() {
  return this.put(new xr());
}) } }), ve(xr, "Svg", !0);
let mr = class extends qe {
  constructor(r, e = r) {
    super(Re("symbol", r), e);
  }
};
ge({ Container: { symbol: Me(function() {
  return this.put(new mr());
}) } }), ve(mr, "Symbol");
var bo = Object.freeze({ __proto__: null, amove: function(r, e) {
  return this.ax(r).ay(e);
}, ax: function(r) {
  return this.attr("x", r);
}, ay: function(r) {
  return this.attr("y", r);
}, build: function(r) {
  return this._build = !!r, this;
}, center: function(r, e, t = this.bbox()) {
  return this.cx(r, t).cy(e, t);
}, cx: function(r, e = this.bbox()) {
  return r == null ? e.cx : this.attr("x", this.attr("x") + r - e.cx);
}, cy: function(r, e = this.bbox()) {
  return r == null ? e.cy : this.attr("y", this.attr("y") + r - e.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(r, e, t = this.bbox()) {
  return this.x(r, t).y(e, t);
}, plain: function(r) {
  return this._build === !1 && this.clear(), this.node.appendChild(be.document.createTextNode(r)), this;
}, x: function(r, e = this.bbox()) {
  return r == null ? e.x : this.attr("x", this.attr("x") + r - e.x);
}, y: function(r, e = this.bbox()) {
  return r == null ? e.y : this.attr("y", this.attr("y") + r - e.y);
} });
class ct extends tt {
  constructor(e, t = e) {
    super(Re("text", e), t), this.dom.leading = this.dom.leading ?? new de(1.3), this._rebuild = !0, this._build = !1;
  }
  leading(e) {
    return e == null ? this.dom.leading : (this.dom.leading = new de(e), this.rebuild());
  }
  rebuild(e) {
    if (typeof e == "boolean" && (this._rebuild = e), this._rebuild) {
      const t = this;
      let i = 0;
      const s = this.dom.leading;
      this.each(function(a) {
        if (cr(this.node)) return;
        const n = be.window.getComputedStyle(this.node).getPropertyValue("font-size"), o = s * new de(n);
        this.dom.newLined && (this.attr("x", t.attr("x")), this.text() === `
` ? i += o : (this.attr("dy", a ? o + i : 0), i = 0));
      }), this.fire("rebuild");
    }
    return this;
  }
  setData(e) {
    return this.dom = e, this.dom.leading = new de(e.leading || 1.3), this;
  }
  writeDataToDom() {
    return qn(this, this.dom, { leading: 1.3 }), this;
  }
  text(e) {
    if (e === void 0) {
      const t = this.node.childNodes;
      let i = 0;
      e = "";
      for (let s = 0, a = t.length; s < a; ++s) t[s].nodeName === "textPath" || cr(t[s]) ? s === 0 && (i = s + 1) : (s !== i && t[s].nodeType !== 3 && at(t[s]).dom.newLined === !0 && (e += `
`), e += t[s].textContent);
      return e;
    }
    if (this.clear().build(!0), typeof e == "function") e.call(this, this);
    else for (let t = 0, i = (e = (e + "").split(`
`)).length; t < i; t++) this.newLine(e[t]);
    return this.build(!1).rebuild();
  }
}
oe(ct, bo), ge({ Container: { text: Me(function(r = "") {
  return this.put(new ct()).text(r);
}), plain: Me(function(r = "") {
  return this.put(new ct()).plain(r);
}) } }), ve(ct, "Text");
class Ui extends tt {
  constructor(e, t = e) {
    super(Re("tspan", e), t), this._build = !1;
  }
  dx(e) {
    return this.attr("dx", e);
  }
  dy(e) {
    return this.attr("dy", e);
  }
  newLine() {
    this.dom.newLined = !0;
    const e = this.parent();
    if (!(e instanceof ct)) return this;
    const t = e.index(this), i = be.window.getComputedStyle(this.node).getPropertyValue("font-size"), s = e.dom.leading * new de(i);
    return this.dy(t ? s : 0).attr("x", e.x());
  }
  text(e) {
    return e == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof e == "function" ? (this.clear().build(!0), e.call(this, this), this.build(!1)) : this.plain(e), this);
  }
}
oe(Ui, bo), ge({ Tspan: { tspan: Me(function(r = "") {
  const e = new Ui();
  return this._build || this.clear(), this.put(e).text(r);
}) }, Text: { newLine: function(r = "") {
  return this.tspan(r).newLine();
} } }), ve(Ui, "Tspan");
class Cs extends tt {
  constructor(e, t = e) {
    super(Re("circle", e), t);
  }
  radius(e) {
    return this.attr("r", e);
  }
  rx(e) {
    return this.attr("r", e);
  }
  ry(e) {
    return this.rx(e);
  }
  size(e) {
    return this.radius(new de(e).divide(2));
  }
}
oe(Cs, { x: so, y: ro, cx: ao, cy: no, width: oo, height: lo }), ge({ Container: { circle: Me(function(r = 0) {
  return this.put(new Cs()).size(r).move(0, 0);
}) } }), ve(Cs, "Circle");
class As extends qe {
  constructor(e, t = e) {
    super(Re("clipPath", e), t);
  }
  remove() {
    return this.targets().forEach(function(e) {
      e.unclip();
    }), super.remove();
  }
  targets() {
    return Xt("svg [clip-path*=" + this.id() + "]");
  }
}
ge({ Container: { clip: Me(function() {
  return this.defs().put(new As());
}) }, Element: { clipper() {
  return this.reference("clip-path");
}, clipWith(r) {
  const e = r instanceof As ? r : this.parent().clip().add(r);
  return this.attr("clip-path", "url(#" + e.id() + ")");
}, unclip() {
  return this.attr("clip-path", null);
} } }), ve(As, "ClipPath");
class Wa extends Be {
  constructor(e, t = e) {
    super(Re("foreignObject", e), t);
  }
}
ge({ Container: { foreignObject: Me(function(r, e) {
  return this.put(new Wa()).size(r, e);
}) } }), ve(Wa, "ForeignObject");
var vo = Object.freeze({ __proto__: null, dmove: function(r, e) {
  return this.children().forEach((t) => {
    let i;
    try {
      i = t.node instanceof Li().SVGSVGElement ? new Oe(t.attr(["x", "y", "width", "height"])) : t.bbox();
    } catch {
      return;
    }
    const s = new ne(t), a = s.translate(r, e).transform(s.inverse()), n = new ye(i.x, i.y).transform(a);
    t.move(n.x, n.y);
  }), this;
}, dx: function(r) {
  return this.dmove(r, 0);
}, dy: function(r) {
  return this.dmove(0, r);
}, height: function(r, e = this.bbox()) {
  return r == null ? e.height : this.size(e.width, r, e);
}, move: function(r = 0, e = 0, t = this.bbox()) {
  const i = r - t.x, s = e - t.y;
  return this.dmove(i, s);
}, size: function(r, e, t = this.bbox()) {
  const i = si(this, r, e, t), s = i.width / t.width, a = i.height / t.height;
  return this.children().forEach((n) => {
    const o = new ye(t).transform(new ne(n).inverse());
    n.scale(s, a, o.x, o.y);
  }), this;
}, width: function(r, e = this.bbox()) {
  return r == null ? e.width : this.size(r, e.height, e);
}, x: function(r, e = this.bbox()) {
  return r == null ? e.x : this.move(r, e.y, e);
}, y: function(r, e = this.bbox()) {
  return r == null ? e.y : this.move(e.x, r, e);
} });
class At extends qe {
  constructor(e, t = e) {
    super(Re("g", e), t);
  }
}
oe(At, vo), ge({ Container: { group: Me(function() {
  return this.put(new At());
}) } }), ve(At, "G");
class Fi extends qe {
  constructor(e, t = e) {
    super(Re("a", e), t);
  }
  target(e) {
    return this.attr("target", e);
  }
  to(e) {
    return this.attr("href", e, ri);
  }
}
oe(Fi, vo), ge({ Container: { link: Me(function(r) {
  return this.put(new Fi()).to(r);
}) }, Element: { unlink() {
  const r = this.linker();
  if (!r) return this;
  const e = r.parent();
  if (!e) return this.remove();
  const t = e.index(r);
  return e.add(this, t), r.remove(), this;
}, linkTo(r) {
  let e = this.linker();
  return e || (e = new Fi(), this.wrap(e)), typeof r == "function" ? r.call(e, e) : e.to(r), this;
}, linker() {
  const r = this.parent();
  return r && r.node.nodeName.toLowerCase() === "a" ? r : null;
} } }), ve(Fi, "A");
class Ms extends qe {
  constructor(e, t = e) {
    super(Re("mask", e), t);
  }
  remove() {
    return this.targets().forEach(function(e) {
      e.unmask();
    }), super.remove();
  }
  targets() {
    return Xt("svg [mask*=" + this.id() + "]");
  }
}
ge({ Container: { mask: Me(function() {
  return this.defs().put(new Ms());
}) }, Element: { masker() {
  return this.reference("mask");
}, maskWith(r) {
  const e = r instanceof Ms ? r : this.parent().mask().add(r);
  return this.attr("mask", "url(#" + e.id() + ")");
}, unmask() {
  return this.attr("mask", null);
} } }), ve(Ms, "Mask");
class Va extends Be {
  constructor(e, t = e) {
    super(Re("stop", e), t);
  }
  update(e) {
    return (typeof e == "number" || e instanceof de) && (e = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), e.opacity != null && this.attr("stop-opacity", e.opacity), e.color != null && this.attr("stop-color", e.color), e.offset != null && this.attr("offset", new de(e.offset)), this;
  }
}
ge({ Gradient: { stop: function(r, e, t) {
  return this.put(new Va()).update(r, e, t);
} } }), ve(Va, "Stop");
class Rs extends Be {
  constructor(e, t = e) {
    super(Re("style", e), t);
  }
  addText(e = "") {
    return this.node.textContent += e, this;
  }
  font(e, t, i = {}) {
    return this.rule("@font-face", { fontFamily: e, src: t, ...i });
  }
  rule(e, t) {
    return this.addText(function(i, s) {
      if (!i) return "";
      if (!s) return i;
      let a = i + "{";
      for (const n in s) a += n.replace(/([A-Z])/g, function(o, l) {
        return "-" + l.toLowerCase();
      }) + ":" + s[n] + ";";
      return a += "}", a;
    }(e, t));
  }
}
ge("Dom", { style(r, e) {
  return this.put(new Rs()).rule(r, e);
}, fontface(r, e, t) {
  return this.put(new Rs()).font(r, e, t);
} }), ve(Rs, "Style");
class Ps extends ct {
  constructor(e, t = e) {
    super(Re("textPath", e), t);
  }
  array() {
    const e = this.track();
    return e ? e.array() : null;
  }
  plot(e) {
    const t = this.track();
    let i = null;
    return t && (i = t.plot(e)), e == null ? i : this;
  }
  track() {
    return this.reference("href");
  }
}
ge({ Container: { textPath: Me(function(r, e) {
  return r instanceof ct || (r = this.text(r)), r.path(e);
}) }, Text: { path: Me(function(r, e = !0) {
  const t = new Ps();
  let i;
  if (r instanceof qt || (r = this.defs().path(r)), t.attr("href", "#" + r, ri), e) for (; i = this.node.firstChild; ) t.node.appendChild(i);
  return this.put(t);
}), textPath() {
  return this.findOne("textPath");
} }, Path: { text: Me(function(r) {
  return r instanceof ct || (r = new ct().addTo(this.parent()).text(r)), r.path(this);
}), targets() {
  return Xt("svg textPath").filter((r) => (r.attr("href") || "").includes(this.id()));
} } }), Ps.prototype.MorphArray = lt, ve(Ps, "TextPath");
class Ga extends tt {
  constructor(e, t = e) {
    super(Re("use", e), t);
  }
  use(e, t) {
    return this.attr("href", (t || "") + "#" + e, ri);
  }
}
ge({ Container: { use: Me(function(r, e) {
  return this.put(new Ga()).use(r, e);
}) } }), ve(Ga, "Use");
const Xh = Ge;
oe([xr, mr, Vi, Si, Gi], Je("viewbox")), oe([Ot, Ft, zt, qt], Je("marker")), oe(ct, Je("Text")), oe(qt, Je("Path")), oe(rs, Je("Defs")), oe([ct, Ui], Je("Tspan")), oe([$i, Wi, xi, Qe], Je("radius")), oe(Ii, Je("EventTarget")), oe(Mt, Je("Dom")), oe(Be, Je("Element")), oe(tt, Je("Shape")), oe([qe, co], Je("Container")), oe(xi, Je("Gradient")), oe(Qe, Je("Runner")), Yt.extend([...new Set($n)]), function(r = []) {
  pr.push(...[].concat(r));
}([de, Ae, Oe, ne, jt, Rt, lt, ye]), oe(pr, { to(r) {
  return new Tt().type(this.constructor).from(this.toArray()).to(r);
}, fromArray(r) {
  return this.init(r), this;
}, toConsumable() {
  return this.toArray();
}, morph(r, e, t, i, s) {
  return this.fromArray(r.map(function(a, n) {
    return i.step(a, e[n], t, s[n], s);
  }));
} });
class Le extends Be {
  constructor(e) {
    super(Re("filter", e), e), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = !0;
  }
  put(e, t) {
    return !(e = super.put(e, t)).attr("in") && this.$autoSetIn && e.attr("in", this.$source), e.attr("result") || e.attr("result", e.id()), e;
  }
  remove() {
    return this.targets().each("unfilter"), super.remove();
  }
  targets() {
    return Xt('svg [filter*="' + this.id() + '"]');
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
}
class qr extends Be {
  constructor(e, t) {
    super(e, t), this.result(this.id());
  }
  in(e) {
    if (e == null) {
      const t = this.attr("in");
      return this.parent() && this.parent().find(`[result="${t}"]`)[0] || t;
    }
    return this.attr("in", e);
  }
  result(e) {
    return this.attr("result", e);
  }
  toString() {
    return this.result();
  }
}
const rt = (r) => function(...e) {
  for (let t = r.length; t--; ) e[t] != null && this.attr(r[t], e[t]);
}, Bh = { blend: rt(["in", "in2", "mode"]), colorMatrix: rt(["type", "values"]), composite: rt(["in", "in2", "operator"]), convolveMatrix: function(r) {
  r = new jt(r).toString(), this.attr({ order: Math.sqrt(r.split(" ").length), kernelMatrix: r });
}, diffuseLighting: rt(["surfaceScale", "lightingColor", "diffuseConstant", "kernelUnitLength"]), displacementMap: rt(["in", "in2", "scale", "xChannelSelector", "yChannelSelector"]), dropShadow: rt(["in", "dx", "dy", "stdDeviation"]), flood: rt(["flood-color", "flood-opacity"]), gaussianBlur: function(r = 0, e = r) {
  this.attr("stdDeviation", r + " " + e);
}, image: function(r) {
  this.attr("href", r, ri);
}, morphology: rt(["operator", "radius"]), offset: rt(["dx", "dy"]), specularLighting: rt(["surfaceScale", "lightingColor", "diffuseConstant", "specularExponent", "kernelUnitLength"]), tile: rt([]), turbulence: rt(["baseFrequency", "numOctaves", "seed", "stitchTiles", "type"]) };
["blend", "colorMatrix", "componentTransfer", "composite", "convolveMatrix", "diffuseLighting", "displacementMap", "dropShadow", "flood", "gaussianBlur", "image", "merge", "morphology", "offset", "specularLighting", "tile", "turbulence"].forEach((r) => {
  const e = ii(r), t = Bh[r];
  Le[e + "Effect"] = class extends qr {
    constructor(i) {
      super(Re("fe" + e, i), i);
    }
    update(i) {
      return t.apply(this, i), this;
    }
  }, Le.prototype[r] = Me(function(i, ...s) {
    const a = new Le[e + "Effect"]();
    return i == null ? this.put(a) : (typeof i == "function" ? i.call(a, a) : s.unshift(i), this.put(a).update(s));
  });
}), oe(Le, { merge(r) {
  const e = this.put(new Le.MergeEffect());
  return typeof r == "function" ? (r.call(e, e), e) : ((r instanceof Array ? r : [...arguments]).forEach((t) => {
    t instanceof Le.MergeNode ? e.put(t) : e.mergeNode(t);
  }), e);
}, componentTransfer(r = {}) {
  const e = this.put(new Le.ComponentTransferEffect());
  if (typeof r == "function") return r.call(e, e), e;
  r.r || r.g || r.b || r.a || (r = { r, g: r, b: r, a: r });
  for (const t in r) e.add(new Le["Func" + t.toUpperCase()](r[t]));
  return e;
} });
["distantLight", "pointLight", "spotLight", "mergeNode", "FuncR", "FuncG", "FuncB", "FuncA"].forEach((r) => {
  const e = ii(r);
  Le[e] = class extends qr {
    constructor(t) {
      super(Re("fe" + e, t), t);
    }
  };
});
["funcR", "funcG", "funcB", "funcA"].forEach(function(r) {
  const e = Le[ii(r)], t = Me(function() {
    return this.put(new e());
  });
  Le.ComponentTransferEffect.prototype[r] = t;
});
["distantLight", "pointLight", "spotLight"].forEach((r) => {
  const e = Le[ii(r)], t = Me(function() {
    return this.put(new e());
  });
  Le.DiffuseLightingEffect.prototype[r] = t, Le.SpecularLightingEffect.prototype[r] = t;
}), oe(Le.MergeEffect, { mergeNode(r) {
  return this.put(new Le.MergeNode()).attr("in", r);
} }), oe(rs, { filter: function(r) {
  const e = this.put(new Le());
  return typeof r == "function" && r.call(e, e), e;
} }), oe(qe, { filter: function(r) {
  return this.defs().filter(r);
} }), oe(Be, { filterWith: function(r) {
  const e = r instanceof Le ? r : this.defs().filter(r);
  return this.attr("filter", e);
}, unfilter: function(r) {
  return this.attr("filter", null);
}, filterer() {
  return this.reference("filter");
} });
const Wh = { blend: function(r, e) {
  return this.parent() && this.parent().blend(this, r, e);
}, colorMatrix: function(r, e) {
  return this.parent() && this.parent().colorMatrix(r, e).in(this);
}, componentTransfer: function(r) {
  return this.parent() && this.parent().componentTransfer(r).in(this);
}, composite: function(r, e) {
  return this.parent() && this.parent().composite(this, r, e);
}, convolveMatrix: function(r) {
  return this.parent() && this.parent().convolveMatrix(r).in(this);
}, diffuseLighting: function(r, e, t, i) {
  return this.parent() && this.parent().diffuseLighting(r, t, i).in(this);
}, displacementMap: function(r, e, t, i) {
  return this.parent() && this.parent().displacementMap(this, r, e, t, i);
}, dropShadow: function(r, e, t) {
  return this.parent() && this.parent().dropShadow(this, r, e, t).in(this);
}, flood: function(r, e) {
  return this.parent() && this.parent().flood(r, e);
}, gaussianBlur: function(r, e) {
  return this.parent() && this.parent().gaussianBlur(r, e).in(this);
}, image: function(r) {
  return this.parent() && this.parent().image(r);
}, merge: function(r) {
  return r = r instanceof Array ? r : [...r], this.parent() && this.parent().merge(this, ...r);
}, morphology: function(r, e) {
  return this.parent() && this.parent().morphology(r, e).in(this);
}, offset: function(r, e) {
  return this.parent() && this.parent().offset(r, e).in(this);
}, specularLighting: function(r, e, t, i, s) {
  return this.parent() && this.parent().specularLighting(r, t, i, s).in(this);
}, tile: function() {
  return this.parent() && this.parent().tile().in(this);
}, turbulence: function(r, e, t, i, s) {
  return this.parent() && this.parent().turbulence(r, e, t, i, s).in(this);
} };
oe(qr, Wh), oe(Le.MergeEffect, { in: function(r) {
  return r instanceof Le.MergeNode ? this.add(r, 0) : this.add(new Le.MergeNode().in(r), 0), this;
} }), oe([Le.CompositeEffect, Le.BlendEffect, Le.DisplacementMapEffect], { in2: function(r) {
  if (r == null) {
    const e = this.attr("in2");
    return this.parent() && this.parent().find(`[result="${e}"]`)[0] || e;
  }
  return this.attr("in2", r);
} }), Le.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var je = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "getDefaultFilter", value: function(e, t) {
    var i = this.w;
    e.unfilter(!0), new Le().size("120%", "180%", "-5%", "-40%"), i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t);
  } }, { key: "applyFilter", value: function(e, t, i) {
    var s, a = this, n = this.w;
    if (e.unfilter(!0), i !== "none") {
      var o, l, c = n.config.chart.dropShadow, h = i === "lighten" ? 2 : 0.3;
      e.filterWith(function(d) {
        d.colorMatrix({ type: "matrix", values: `
          `.concat(h, ` 0 0 0 0
          0 `).concat(h, ` 0 0 0
          0 0 `).concat(h, ` 0 0
          0 0 0 1 0
        `), in: "SourceGraphic", result: "brightness" }), c.enabled && a.addShadow(d, t, c, "brightness");
      }), !c.noUserSpaceOnUse && ((o = e.filterer()) === null || o === void 0 || (l = o.node) === null || l === void 0 || l.setAttribute("filterUnits", "userSpaceOnUse")), this._scaleFilterSize((s = e.filterer()) === null || s === void 0 ? void 0 : s.node);
    } else this.getDefaultFilter(e, t);
  } }, { key: "addShadow", value: function(e, t, i, s) {
    var a, n = this.w, o = i.blur, l = i.top, c = i.left, h = i.color, d = i.opacity;
    if (h = Array.isArray(h) ? h[t] : h, ((a = n.config.chart.dropShadow.enabledOnSeries) === null || a === void 0 ? void 0 : a.length) > 0 && n.config.chart.dropShadow.enabledOnSeries.indexOf(t) === -1) return e;
    e.offset({ in: s, dx: c, dy: l, result: "offset" }), e.gaussianBlur({ in: "offset", stdDeviation: o, result: "blur" }), e.flood({ "flood-color": h, "flood-opacity": d, result: "flood" }), e.composite({ in: "flood", in2: "blur", operator: "in", result: "shadow" }), e.merge(["shadow", s]);
  } }, { key: "dropShadow", value: function(e, t) {
    var i, s, a, n, o, l = this, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, h = this.w;
    return e.unfilter(!0), z.isMsEdge() && h.config.chart.type === "radialBar" || ((i = h.config.chart.dropShadow.enabledOnSeries) === null || i === void 0 ? void 0 : i.length) > 0 && ((a = h.config.chart.dropShadow.enabledOnSeries) === null || a === void 0 ? void 0 : a.indexOf(c)) === -1 ? e : (e.filterWith(function(d) {
      l.addShadow(d, c, t, "SourceGraphic");
    }), t.noUserSpaceOnUse || (n = e.filterer()) === null || n === void 0 || (o = n.node) === null || o === void 0 || o.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize((s = e.filterer()) === null || s === void 0 ? void 0 : s.node), e);
  } }, { key: "setSelectionFilter", value: function(e, t, i) {
    var s = this.w;
    if (s.globals.selectedDataPoints[t] !== void 0 && s.globals.selectedDataPoints[t].indexOf(i) > -1) {
      e.node.setAttribute("selected", !0);
      var a = s.config.states.active.filter;
      a !== "none" && this.applyFilter(e, t, a.type);
    }
  } }, { key: "_scaleFilterSize", value: function(e) {
    e && function(t) {
      for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
    }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
  } }]), r;
}(), B = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "roundPathCorners", value: function(e, t) {
    function i(C, R, P) {
      var A = R.x - C.x, E = R.y - C.y, N = Math.sqrt(A * A + E * E);
      return s(C, R, Math.min(1, P / N));
    }
    function s(C, R, P) {
      return { x: C.x + (R.x - C.x) * P, y: C.y + (R.y - C.y) * P };
    }
    function a(C, R) {
      C.length > 2 && (C[C.length - 2] = R.x, C[C.length - 1] = R.y);
    }
    function n(C) {
      return { x: parseFloat(C[C.length - 2]), y: parseFloat(C[C.length - 1]) };
    }
    e.indexOf("NaN") > -1 && (e = "");
    var o = e.split(/[,\s]/).reduce(function(C, R) {
      var P = R.match(/^([a-zA-Z])(.+)/);
      return P ? (C.push(P[1]), C.push(P[2])) : C.push(R), C;
    }, []).reduce(function(C, R) {
      return parseFloat(R) == R && C.length ? C[C.length - 1].push(R) : C.push([R]), C;
    }, []), l = [];
    if (o.length > 1) {
      var c = n(o[0]), h = null;
      o[o.length - 1][0] == "Z" && o[0].length > 2 && (h = ["L", c.x, c.y], o[o.length - 1] = h), l.push(o[0]);
      for (var d = 1; d < o.length; d++) {
        var u = l[l.length - 1], g = o[d], p = g == h ? o[1] : o[d + 1];
        if (p && u && u.length > 2 && g[0] == "L" && p.length > 2 && p[0] == "L") {
          var f, x, m = n(u), b = n(g), w = n(p);
          f = i(b, m, t), x = i(b, w, t), a(g, f), g.origPoint = b, l.push(g);
          var y = s(f, b, 0.5), v = s(b, x, 0.5), S = ["C", y.x, y.y, v.x, v.y, x.x, x.y];
          S.origPoint = b, l.push(S);
        } else l.push(g);
      }
      if (h) {
        var k = n(l[l.length - 1]);
        l.push(["Z"]), a(l[0], k);
      }
    } else l = o;
    return l.reduce(function(C, R) {
      return C + R.join(" ") + " ";
    }, "");
  } }, { key: "drawLine", value: function(e, t, i, s) {
    var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
    return this.w.globals.dom.Paper.line().attr({ x1: e, y1: t, x2: i, y2: s, stroke: a, "stroke-dasharray": n, "stroke-width": o, "stroke-linecap": l });
  } }, { key: "drawRect", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, c = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, h = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, d = this.w.globals.dom.Paper.rect();
    return d.attr({ x: e, y: t, width: i > 0 ? i : 0, height: s > 0 ? s : 0, rx: a, ry: a, opacity: o, "stroke-width": l !== null ? l : 0, stroke: c !== null ? c : "none", "stroke-dasharray": h }), d.node.setAttribute("fill", n), d;
  } }, { key: "drawPolygon", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
    return this.w.globals.dom.Paper.polygon(e).attr({ fill: s, stroke: t, "stroke-width": i });
  } }, { key: "drawCircle", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    e < 0 && (e = 0);
    var i = this.w.globals.dom.Paper.circle(2 * e);
    return t !== null && i.attr(t), i;
  } }, { key: "drawPath", value: function(e) {
    var t = e.d, i = t === void 0 ? "" : t, s = e.stroke, a = s === void 0 ? "#a8a8a8" : s, n = e.strokeWidth, o = n === void 0 ? 1 : n, l = e.fill, c = e.fillOpacity, h = c === void 0 ? 1 : c, d = e.strokeOpacity, u = d === void 0 ? 1 : d, g = e.classes, p = e.strokeLinecap, f = p === void 0 ? null : p, x = e.strokeDashArray, m = x === void 0 ? 0 : x, b = this.w;
    return f === null && (f = b.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({ fill: l, "fill-opacity": h, stroke: a, "stroke-opacity": u, "stroke-linecap": f, "stroke-width": o, "stroke-dasharray": m, class: g });
  } }, { key: "group", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = this.w.globals.dom.Paper.group();
    return e !== null && t.attr(e), t;
  } }, { key: "move", value: function(e, t) {
    var i = ["M", e, t].join(" ");
    return i;
  } }, { key: "line", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, s = null;
    return i === null ? s = [" L", e, t].join(" ") : i === "H" ? s = [" H", e].join(" ") : i === "V" && (s = [" V", t].join(" ")), s;
  } }, { key: "curve", value: function(e, t, i, s, a, n) {
    var o = ["C", e, t, i, s, a, n].join(" ");
    return o;
  } }, { key: "quadraticCurve", value: function(e, t, i, s) {
    return ["Q", e, t, i, s].join(" ");
  } }, { key: "arc", value: function(e, t, i, s, a, n, o) {
    var l = "A";
    arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (l = "a");
    var c = [l, e, t, i, s, a, n, o].join(" ");
    return c;
  } }, { key: "renderPaths", value: function(e) {
    var t, i = e.j, s = e.realIndex, a = e.pathFrom, n = e.pathTo, o = e.stroke, l = e.strokeWidth, c = e.strokeLinecap, h = e.fill, d = e.animationDelay, u = e.initialSpeed, g = e.dataChangeSpeed, p = e.className, f = e.chartType, x = e.shouldClipToGrid, m = x === void 0 || x, b = e.bindEventsOnPaths, w = b === void 0 || b, y = e.drawShadow, v = y === void 0 || y, S = this.w, k = new je(this.ctx), C = new ti(this.ctx), R = this.w.config.chart.animations.enabled, P = R && this.w.config.chart.animations.dynamicAnimation.enabled;
    if (a && a.startsWith("M 0 0") && n) {
      var A = n.match(/^M\s+[\d.-]+\s+[\d.-]+/);
      A && (a = a.replace(/^M\s+0\s+0/, A[0]));
    }
    var E = !!(R && !S.globals.resized || P && S.globals.dataChanged && S.globals.shouldAnimate);
    E ? t = a : (t = n, S.globals.animationEnded = !0);
    var N = S.config.stroke.dashArray, O = 0;
    O = Array.isArray(N) ? N[s] : S.config.stroke.dashArray;
    var L = this.drawPath({ d: t, stroke: o, strokeWidth: l, fill: h, fillOpacity: 1, classes: p, strokeLinecap: c, strokeDashArray: O });
    L.attr("index", s), m && (f === "bar" && !S.globals.isHorizontal || S.globals.comboCharts ? L.attr({ "clip-path": "url(#gridRectBarMask".concat(S.globals.cuid, ")") }) : L.attr({ "clip-path": "url(#gridRectMask".concat(S.globals.cuid, ")") })), S.config.chart.dropShadow.enabled && v && k.dropShadow(L, S.config.chart.dropShadow, s), w && (L.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, L)), L.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, L)), L.node.addEventListener("mousedown", this.pathMouseDown.bind(this, L))), L.attr({ pathTo: n, pathFrom: a });
    var I = { el: L, j: i, realIndex: s, pathFrom: a, pathTo: n, fill: h, strokeWidth: l, delay: d };
    return !R || S.globals.resized || S.globals.dataChanged ? !S.globals.resized && S.globals.dataChanged || C.showDelayedElements() : C.animatePathsGradually(q(q({}, I), {}, { speed: u })), S.globals.dataChanged && P && E && C.animatePathsGradually(q(q({}, I), {}, { speed: g })), L;
  } }, { key: "drawPattern", value: function(e, t, i) {
    var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(t, i, function(n) {
      e === "horizontalLines" ? n.line(0, 0, i, 0).stroke({ color: s, width: a + 1 }) : e === "verticalLines" ? n.line(0, 0, 0, t).stroke({ color: s, width: a + 1 }) : e === "slantedLines" ? n.line(0, 0, t, i).stroke({ color: s, width: a }) : e === "squares" ? n.rect(t, i).fill("none").stroke({ color: s, width: a }) : e === "circles" && n.circle(t).fill("none").stroke({ color: s, width: a });
    });
  } }, { key: "drawGradient", value: function(e, t, i, s, a) {
    var n, o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, c = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [], h = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, d = this.w;
    t.length < 9 && t.indexOf("#") === 0 && (t = z.hexToRgba(t, s)), i.length < 9 && i.indexOf("#") === 0 && (i = z.hexToRgba(i, a));
    var u = 0, g = 1, p = 1, f = null;
    l !== null && (u = l[0] !== void 0 ? l[0] / 100 : 0, g = l[1] !== void 0 ? l[1] / 100 : 1, p = l[2] !== void 0 ? l[2] / 100 : 1, f = l[3] !== void 0 ? l[3] / 100 : null);
    var x = !(d.config.chart.type !== "donut" && d.config.chart.type !== "pie" && d.config.chart.type !== "polarArea" && d.config.chart.type !== "bubble");
    if (n = c && c.length !== 0 ? d.globals.dom.Paper.gradient(x ? "radial" : "linear", function(w) {
      (Array.isArray(c[h]) ? c[h] : c).forEach(function(y) {
        w.stop(y.offset / 100, y.color, y.opacity);
      });
    }) : d.globals.dom.Paper.gradient(x ? "radial" : "linear", function(w) {
      w.stop(u, t, s), w.stop(g, i, a), w.stop(p, i, a), f !== null && w.stop(f, t, s);
    }), x) {
      var m = d.globals.gridWidth / 2, b = d.globals.gridHeight / 2;
      d.config.chart.type !== "bubble" ? n.attr({ gradientUnits: "userSpaceOnUse", cx: m, cy: b, r: o }) : n.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else e === "vertical" ? n.from(0, 0).to(0, 1) : e === "diagonal" ? n.from(0, 0).to(1, 1) : e === "horizontal" ? n.from(0, 1).to(1, 1) : e === "diagonal2" && n.from(1, 0).to(0, 1);
    return n;
  } }, { key: "getTextBasedOnMaxWidth", value: function(e) {
    var t = e.text, i = e.maxWidth, s = e.fontSize, a = e.fontFamily, n = this.getTextRects(t, s, a), o = n.width / t.length, l = Math.floor(i / o);
    return i < n.width ? t.slice(0, l - 3) + "..." : t;
  } }, { key: "drawText", value: function(e) {
    var t = this, i = e.x, s = e.y, a = e.text, n = e.textAnchor, o = e.fontSize, l = e.fontFamily, c = e.fontWeight, h = e.foreColor, d = e.opacity, u = e.maxWidth, g = e.cssClass, p = g === void 0 ? "" : g, f = e.isPlainText, x = f === void 0 || f, m = e.dominantBaseline, b = m === void 0 ? "auto" : m, w = this.w;
    a === void 0 && (a = "");
    var y = a;
    n || (n = "start"), h && h.length || (h = w.config.chart.foreColor), l = l || w.config.chart.fontFamily, c = c || "regular";
    var v, S = { maxWidth: u, fontSize: o = o || "11px", fontFamily: l };
    return Array.isArray(a) ? v = w.globals.dom.Paper.text(function(k) {
      for (var C = 0; C < a.length; C++) y = a[C], u && (y = t.getTextBasedOnMaxWidth(q({ text: a[C] }, S))), C === 0 ? k.tspan(y) : k.tspan(y).newLine();
    }) : (u && (y = this.getTextBasedOnMaxWidth(q({ text: a }, S))), v = x ? w.globals.dom.Paper.plain(a) : w.globals.dom.Paper.text(function(k) {
      return k.tspan(y);
    })), v.attr({ x: i, y: s, "text-anchor": n, "dominant-baseline": b, "font-size": o, "font-family": l, "font-weight": c, fill: h, class: "apexcharts-text " + p }), v.node.style.fontFamily = l, v.node.style.opacity = d, v;
  } }, { key: "getMarkerPath", value: function(e, t, i, s) {
    var a = "";
    switch (i) {
      case "cross":
        a = "M ".concat(e - (s /= 1.4), " ").concat(t - s, " L ").concat(e + s, " ").concat(t + s, "  M ").concat(e - s, " ").concat(t + s, " L ").concat(e + s, " ").concat(t - s);
        break;
      case "plus":
        a = "M ".concat(e - (s /= 1.12), " ").concat(t, " L ").concat(e + s, " ").concat(t, "  M ").concat(e, " ").concat(t - s, " L ").concat(e, " ").concat(t + s);
        break;
      case "star":
      case "sparkle":
        var n = 5;
        s *= 1.15, i === "sparkle" && (s /= 1.1, n = 4);
        for (var o = Math.PI / n, l = 0; l <= 2 * n; l++) {
          var c = l * o, h = l % 2 == 0 ? s : s / 2;
          a += (l === 0 ? "M" : "L") + (e + h * Math.sin(c)) + "," + (t - h * Math.cos(c));
        }
        a += "Z";
        break;
      case "triangle":
        a = "M ".concat(e, " ").concat(t - s, ` 
             L `).concat(e + s, " ").concat(t + s, ` 
             L `).concat(e - s, " ").concat(t + s, ` 
             Z`);
        break;
      case "square":
      case "rect":
        a = "M ".concat(e - (s /= 1.125), " ").concat(t - s, ` 
           L `).concat(e + s, " ").concat(t - s, ` 
           L `).concat(e + s, " ").concat(t + s, ` 
           L `).concat(e - s, " ").concat(t + s, ` 
           Z`);
        break;
      case "diamond":
        s *= 1.05, a = "M ".concat(e, " ").concat(t - s, ` 
             L `).concat(e + s, " ").concat(t, ` 
             L `).concat(e, " ").concat(t + s, ` 
             L `).concat(e - s, " ").concat(t, ` 
            Z`);
        break;
      case "line":
        a = "M ".concat(e - (s /= 1.1), " ").concat(t, ` 
           L `).concat(e + s, " ").concat(t);
        break;
      default:
        s *= 2, a = "M ".concat(e, ", ").concat(t, ` 
           m -`).concat(s / 2, `, 0 
           a `).concat(s / 2, ",").concat(s / 2, " 0 1,0 ").concat(s, `,0 
           a `).concat(s / 2, ",").concat(s / 2, " 0 1,0 -").concat(s, ",0");
    }
    return a;
  } }, { key: "drawMarkerShape", value: function(e, t, i, s, a) {
    var n = this.drawPath({ d: this.getMarkerPath(e, t, i, s, a), stroke: a.pointStrokeColor, strokeDashArray: a.pointStrokeDashArray, strokeWidth: a.pointStrokeWidth, fill: a.pointFillColor, fillOpacity: a.pointFillOpacity, strokeOpacity: a.pointStrokeOpacity });
    return n.attr({ cx: e, cy: t, shape: a.shape, class: a.class ? a.class : "" }), n;
  } }, { key: "drawMarker", value: function(e, t, i) {
    e = e || 0;
    var s = i.pSize || 0;
    return z.isNumber(t) || (s = 0, t = 0), this.drawMarkerShape(e, t, i == null ? void 0 : i.shape, s, q(q({}, i), i.shape === "line" || i.shape === "plus" || i.shape === "cross" ? { pointStrokeColor: i.pointFillColor, pointStrokeOpacity: i.pointFillOpacity } : {}));
  } }, { key: "pathMouseEnter", value: function(e, t) {
    var i = this.w, s = new je(this.ctx), a = parseInt(e.node.getAttribute("index"), 10), n = parseInt(e.node.getAttribute("j"), 10);
    if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }]), (i.config.states.active.filter.type === "none" || e.node.getAttribute("selected") !== "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
      var o = i.config.states.hover.filter;
      s.applyFilter(e, a, o.type);
    }
  } }, { key: "pathMouseLeave", value: function(e, t) {
    var i = this.w, s = new je(this.ctx), a = parseInt(e.node.getAttribute("index"), 10), n = parseInt(e.node.getAttribute("j"), 10);
    typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }]), i.config.states.active.filter.type !== "none" && e.node.getAttribute("selected") === "true" || i.config.states.hover.filter.type !== "none" && s.getDefaultFilter(e, a);
  } }, { key: "pathMouseDown", value: function(e, t) {
    var i = this.w, s = new je(this.ctx), a = parseInt(e.node.getAttribute("index"), 10), n = parseInt(e.node.getAttribute("j"), 10), o = "false";
    if (e.node.getAttribute("selected") === "true") {
      if (e.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[a].indexOf(n) > -1) {
        var l = i.globals.selectedDataPoints[a].indexOf(n);
        i.globals.selectedDataPoints[a].splice(l, 1);
      }
    } else {
      if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
        i.globals.selectedDataPoints = [];
        var c = i.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h = i.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), d = function(p) {
          Array.prototype.forEach.call(p, function(f) {
            f.node.setAttribute("selected", "false"), s.getDefaultFilter(f, a);
          });
        };
        d(c), d(h);
      }
      e.node.setAttribute("selected", "true"), o = "true", i.globals.selectedDataPoints[a] === void 0 && (i.globals.selectedDataPoints[a] = []), i.globals.selectedDataPoints[a].push(n);
    }
    if (o === "true") {
      var u = i.config.states.active.filter;
      if (u !== "none") s.applyFilter(e, a, u.type);
      else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
        var g = i.config.states.hover.filter;
        s.applyFilter(e, a, g.type);
      }
    } else i.config.states.active.filter.type !== "none" && (i.config.states.hover.filter.type === "none" || i.globals.isTouchDevice ? s.getDefaultFilter(e, a) : (g = i.config.states.hover.filter, s.applyFilter(e, a, g.type)));
    typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(t, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: n, w: i }), t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: n, w: i }]);
  } }, { key: "rotateAroundCenter", value: function(e) {
    var t = {};
    return e && typeof e.getBBox == "function" && (t = e.getBBox()), { x: t.x + t.width / 2, y: t.y + t.height / 2 };
  } }, { key: "getTextRects", value: function(e, t, i, s) {
    var a = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], n = this.w, o = this.drawText({ x: -200, y: -200, text: e, textAnchor: "start", fontSize: t, fontFamily: i, foreColor: "#fff", opacity: 0 });
    s && o.attr("transform", s), n.globals.dom.Paper.add(o);
    var l = o.bbox();
    return a || (l = o.node.getBoundingClientRect()), o.remove(), { width: l.width, height: l.height };
  } }, { key: "placeTextWithEllipsis", value: function(e, t, i) {
    if (typeof e.getComputedTextLength == "function" && (e.textContent = t, t.length > 0 && e.getComputedTextLength() >= i / 1.1)) {
      for (var s = t.length - 3; s > 0; s -= 3) if (e.getSubStringLength(0, s) <= i / 1.1) return void (e.textContent = t.substring(0, s) + "...");
      e.textContent = ".";
    }
  } }], [{ key: "setAttrs", value: function(e, t) {
    for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
  } }]), r;
}(), ze = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "getStackedSeriesTotals", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = this.w, i = [];
    if (t.globals.series.length === 0) return i;
    for (var s = 0; s < t.globals.series[t.globals.maxValsInArrayIndex].length; s++) {
      for (var a = 0, n = 0; n < t.globals.series.length; n++) t.globals.series[n][s] !== void 0 && e.indexOf(n) === -1 && (a += t.globals.series[n][s]);
      i.push(a);
    }
    return i;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return e === null ? this.w.config.series.reduce(function(t, i) {
      return t + i;
    }, 0) : this.w.globals.series[e].reduce(function(t, i) {
      return t + i;
    }, 0);
  } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
    var e = this, t = this.w, i = [];
    return t.globals.seriesGroups.forEach(function(s) {
      var a = [];
      t.config.series.forEach(function(o, l) {
        s.indexOf(t.globals.seriesNames[l]) > -1 && a.push(l);
      });
      var n = t.globals.series.map(function(o, l) {
        return a.indexOf(l) === -1 ? l : -1;
      }).filter(function(o) {
        return o !== -1;
      });
      i.push(e.getStackedSeriesTotals(n));
    }), i;
  } }, { key: "setSeriesYAxisMappings", value: function() {
    var e = this.w.globals, t = this.w.config, i = [], s = [], a = [], n = e.series.length > t.yaxis.length || t.yaxis.some(function(d) {
      return Array.isArray(d.seriesName);
    });
    t.series.forEach(function(d, u) {
      a.push(u), s.push(null);
    }), t.yaxis.forEach(function(d, u) {
      i[u] = [];
    });
    var o = [];
    t.yaxis.forEach(function(d, u) {
      var g = !1;
      if (d.seriesName) {
        var p = [];
        Array.isArray(d.seriesName) ? p = d.seriesName : p.push(d.seriesName), p.forEach(function(f) {
          t.series.forEach(function(x, m) {
            if (x.name === f) {
              var b = m;
              u === m || n ? !n || a.indexOf(m) > -1 ? i[u].push([u, m]) : console.warn("Series '" + x.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i[m].push([m, u]), b = u), g = !0, (b = a.indexOf(b)) !== -1 && a.splice(b, 1);
            }
          });
        });
      }
      g || o.push(u);
    }), i = i.map(function(d, u) {
      var g = [];
      return d.forEach(function(p) {
        s[p[1]] = p[0], g.push(p[1]);
      }), g;
    });
    for (var l = t.yaxis.length - 1, c = 0; c < o.length && (l = o[c], i[l] = [], a); c++) {
      var h = a[0];
      a.shift(), i[l].push(h), s[h] = l;
    }
    a.forEach(function(d) {
      i[l].push(d), s[d] = l;
    }), e.seriesYAxisMap = i.map(function(d) {
      return d;
    }), e.seriesYAxisReverseMap = s.map(function(d) {
      return d;
    }), e.seriesYAxisMap.forEach(function(d, u) {
      d.forEach(function(g) {
        t.series[g] && t.series[g].group === void 0 && (t.series[g].group = "apexcharts-axis-".concat(u.toString()));
      });
    });
  } }, { key: "isSeriesNull", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return (e === null ? this.w.config.series.filter(function(t) {
      return t !== null;
    }) : this.w.config.series[e].data.filter(function(t) {
      return t !== null;
    })).length === 0;
  } }, { key: "seriesHaveSameValues", value: function(e) {
    return this.w.globals.series[e].every(function(t, i, s) {
      return t === s[0];
    });
  } }, { key: "getCategoryLabels", value: function(e) {
    var t = this.w, i = e.slice();
    return t.config.xaxis.convertedCatToNumeric && (i = e.map(function(s, a) {
      return t.config.xaxis.labels.formatter(s - t.globals.minX + 1);
    })), i;
  } }, { key: "getLargestSeries", value: function() {
    var e = this.w;
    e.globals.maxValsInArrayIndex = e.globals.series.map(function(t) {
      return t.length;
    }).indexOf(Math.max.apply(Math, e.globals.series.map(function(t) {
      return t.length;
    })));
  } }, { key: "getLargestMarkerSize", value: function() {
    var e = this.w, t = 0;
    return e.globals.markers.size.forEach(function(i) {
      t = Math.max(t, i);
    }), e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach(function(i) {
      t = Math.max(t, i.size);
    }), t > 0 && (e.config.markers.hover.size > 0 ? t = e.config.markers.hover.size : t += e.config.markers.hover.sizeOffset), e.globals.markers.largestSize = t, t;
  } }, { key: "getSeriesTotals", value: function() {
    var e = this.w;
    e.globals.seriesTotals = e.globals.series.map(function(t, i) {
      var s = 0;
      if (Array.isArray(t)) for (var a = 0; a < t.length; a++) s += t[a];
      else s += t;
      return s;
    });
  } }, { key: "getSeriesTotalsXRange", value: function(e, t) {
    var i = this.w;
    return i.globals.series.map(function(s, a) {
      for (var n = 0, o = 0; o < s.length; o++) i.globals.seriesX[a][o] > e && i.globals.seriesX[a][o] < t && (n += s[o]);
      return n;
    });
  } }, { key: "getPercentSeries", value: function() {
    var e = this.w;
    e.globals.seriesPercent = e.globals.series.map(function(t, i) {
      var s = [];
      if (Array.isArray(t)) for (var a = 0; a < t.length; a++) {
        var n = e.globals.stackedSeriesTotals[a], o = 0;
        n && (o = 100 * t[a] / n), s.push(o);
      }
      else {
        var l = 100 * t / e.globals.seriesTotals.reduce(function(c, h) {
          return c + h;
        }, 0);
        s.push(l);
      }
      return s;
    });
  } }, { key: "getCalculatedRatios", value: function() {
    var e, t, i, s = this, a = this.w, n = a.globals, o = [], l = 0, c = [], h = 0.1, d = 0;
    if (n.yRange = [], n.isMultipleYAxis) for (var u = 0; u < n.minYArr.length; u++) n.yRange.push(Math.abs(n.minYArr[u] - n.maxYArr[u])), c.push(0);
    else n.yRange.push(Math.abs(n.minY - n.maxY));
    n.xRange = Math.abs(n.maxX - n.minX), n.zRange = Math.abs(n.maxZ - n.minZ);
    for (var g = 0; g < n.yRange.length; g++) o.push(n.yRange[g] / n.gridHeight);
    if (t = n.xRange / n.gridWidth, e = n.yRange / n.gridWidth, i = n.xRange / n.gridHeight, (l = n.zRange / n.gridHeight * 16) || (l = 1), n.minY !== Number.MIN_VALUE && Math.abs(n.minY) !== 0 && (n.hasNegs = !0), a.globals.seriesYAxisReverseMap.length > 0) {
      var p = function(x, m) {
        var b = a.config.yaxis[a.globals.seriesYAxisReverseMap[m]], w = x < 0 ? -1 : 1;
        return x = Math.abs(x), b.logarithmic && (x = s.getBaseLog(b.logBase, x)), -w * x / o[m];
      };
      if (n.isMultipleYAxis) {
        c = [];
        for (var f = 0; f < o.length; f++) c.push(p(n.minYArr[f], f));
      } else (c = []).push(p(n.minY, 0)), n.minY !== Number.MIN_VALUE && Math.abs(n.minY) !== 0 && (h = -n.minY / e, d = n.minX / t);
    } else (c = []).push(0), h = 0, d = 0;
    return { yRatio: o, invertedYRatio: e, zRatio: l, xRatio: t, invertedXRatio: i, baseLineInvertedY: h, baseLineY: c, baseLineX: d };
  } }, { key: "getLogSeries", value: function(e) {
    var t = this, i = this.w;
    return i.globals.seriesLog = e.map(function(s, a) {
      var n = i.globals.seriesYAxisReverseMap[a];
      return i.config.yaxis[n] && i.config.yaxis[n].logarithmic ? s.map(function(o) {
        return o === null ? null : t.getLogVal(i.config.yaxis[n].logBase, o, a);
      }) : s;
    }), i.globals.invalidLogScale ? e : i.globals.seriesLog;
  } }, { key: "getLogValAtSeriesIndex", value: function(e, t) {
    if (e === null) return null;
    var i = this.w, s = i.globals.seriesYAxisReverseMap[t];
    return i.config.yaxis[s] && i.config.yaxis[s].logarithmic ? this.getLogVal(i.config.yaxis[s].logBase, e, t) : e;
  } }, { key: "getBaseLog", value: function(e, t) {
    return Math.log(t) / Math.log(e);
  } }, { key: "getLogVal", value: function(e, t, i) {
    if (t <= 0) return 0;
    var s = this.w, a = s.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(e, s.globals.minYArr[i]), n = (s.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(e, s.globals.maxYArr[i])) - a;
    return t < 1 ? t / n : (this.getBaseLog(e, t) - a) / n;
  } }, { key: "getLogYRatios", value: function(e) {
    var t = this, i = this.w, s = this.w.globals;
    return s.yLogRatio = e.slice(), s.logYRange = s.yRange.map(function(a, n) {
      var o = i.globals.seriesYAxisReverseMap[n];
      if (i.config.yaxis[o] && t.w.config.yaxis[o].logarithmic) {
        var l, c = -Number.MAX_VALUE, h = Number.MIN_VALUE;
        return s.seriesLog.forEach(function(d, u) {
          d.forEach(function(g) {
            i.config.yaxis[u] && i.config.yaxis[u].logarithmic && (c = Math.max(g, c), h = Math.min(g, h));
          });
        }), l = Math.pow(s.yRange[n], Math.abs(h - c) / s.yRange[n]), s.yLogRatio[n] = l / s.gridHeight, l;
      }
    }), s.invalidLogScale ? e.slice() : s.yLogRatio;
  } }, { key: "drawSeriesByGroup", value: function(e, t, i, s) {
    var a = this.w, n = [];
    return e.series.length > 0 && t.forEach(function(o) {
      var l = [], c = [];
      e.i.forEach(function(h, d) {
        a.config.series[h].group === o && (l.push(e.series[d]), c.push(h));
      }), l.length > 0 && n.push(s.draw(l, i, c));
    }), n;
  } }], [{ key: "checkComboSeries", value: function(e, t) {
    var i = !1, s = 0, a = 0;
    return t === void 0 && (t = "line"), e.length && e[0].type !== void 0 && e.forEach(function(n) {
      n.type !== "bar" && n.type !== "column" && n.type !== "candlestick" && n.type !== "boxPlot" || s++, n.type !== void 0 && n.type !== t && a++;
    }), a > 0 && (i = !0), { comboBarCount: s, comboCharts: i };
  } }, { key: "extendArrayProps", value: function(e, t, i) {
    var s, a, n, o, l, c;
    return (s = t) !== null && s !== void 0 && s.yaxis && (t = e.extendYAxis(t, i)), (a = t) !== null && a !== void 0 && a.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)), (n = t) !== null && n !== void 0 && (o = n.annotations) !== null && o !== void 0 && o.xaxis && (t = e.extendXAxisAnnotations(t)), (l = t) !== null && l !== void 0 && (c = l.annotations) !== null && c !== void 0 && c.points && (t = e.extendPointAnnotations(t))), t;
  } }]), r;
}(), as = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.annoCtx = e;
  }
  return te(r, [{ key: "setOrientations", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.w;
    if (e.label.orientation === "vertical") {
      var s = t !== null ? t : 0, a = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(s, "']"));
      if (a !== null) {
        var n = a.getBoundingClientRect();
        a.setAttribute("x", parseFloat(a.getAttribute("x")) - n.height + 4);
        var o = e.label.position === "top" ? n.width : -n.width;
        a.setAttribute("y", parseFloat(a.getAttribute("y")) + o);
        var l = this.annoCtx.graphics.rotateAroundCenter(a), c = l.x, h = l.y;
        a.setAttribute("transform", "rotate(-90 ".concat(c, " ").concat(h, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(e, t) {
    var i = this.w;
    if (!e || !t.label.text || !String(t.label.text).trim()) return null;
    var s = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), a = e.getBoundingClientRect(), n = t.label.style.padding, o = n.left, l = n.right, c = n.top, h = n.bottom;
    if (t.label.orientation === "vertical") {
      var d = [o, l, c, h];
      c = d[0], h = d[1], o = d[2], l = d[3];
    }
    var u = a.left - s.left - o, g = a.top - s.top - c, p = this.annoCtx.graphics.drawRect(u - i.globals.barPadForNumericAxis, g, a.width + o + l, a.height + c + h, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0);
    return t.id && p.node.classList.add(t.id), p;
  } }, { key: "annotationsBackground", value: function() {
    var e = this, t = this.w, i = function(s, a, n) {
      var o = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(n, "-annotations .apexcharts-").concat(n, "-annotation-label[rel='").concat(a, "']"));
      if (o) {
        var l = o.parentNode, c = e.addBackgroundToAnno(o, s);
        c && (l.insertBefore(c.node, o), s.label.mouseEnter && c.node.addEventListener("mouseenter", s.label.mouseEnter.bind(e, s)), s.label.mouseLeave && c.node.addEventListener("mouseleave", s.label.mouseLeave.bind(e, s)), s.label.click && c.node.addEventListener("click", s.label.click.bind(e, s)));
      }
    };
    t.config.annotations.xaxis.forEach(function(s, a) {
      return i(s, a, "xaxis");
    }), t.config.annotations.yaxis.forEach(function(s, a) {
      return i(s, a, "yaxis");
    }), t.config.annotations.points.forEach(function(s, a) {
      return i(s, a, "point");
    });
  } }, { key: "getY1Y2", value: function(e, t) {
    var i, s = this.w, a = e === "y1" ? t.y : t.y2, n = !1;
    if (this.annoCtx.invertAxis) {
      var o = s.config.xaxis.convertedCatToNumeric ? s.globals.categoryLabels : s.globals.labels, l = o.indexOf(a), c = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(l + 1, ")"));
      i = c ? parseFloat(c.getAttribute("y")) : (s.globals.gridHeight / o.length - 1) * (l + 1) - s.globals.barHeight, t.seriesIndex !== void 0 && s.globals.barHeight && (i -= s.globals.barHeight / 2 * (s.globals.series.length - 1) - s.globals.barHeight * t.seriesIndex);
    } else {
      var h, d = s.globals.seriesYAxisMap[t.yAxisIndex][0], u = s.config.yaxis[t.yAxisIndex].logarithmic ? new ze(this.annoCtx.ctx).getLogVal(s.config.yaxis[t.yAxisIndex].logBase, a, d) / s.globals.yLogRatio[d] : (a - s.globals.minYArr[d]) / (s.globals.yRange[d] / s.globals.gridHeight);
      i = s.globals.gridHeight - Math.min(Math.max(u, 0), s.globals.gridHeight), n = u > s.globals.gridHeight || u < 0, !t.marker || t.y !== void 0 && t.y !== null || (i = 0), (h = s.config.yaxis[t.yAxisIndex]) !== null && h !== void 0 && h.reversed && (i = u);
    }
    return typeof a == "string" && a.includes("px") && (i = parseFloat(a)), { yP: i, clipped: n };
  } }, { key: "getX1X2", value: function(e, t) {
    var i = this.w, s = e === "x1" ? t.x : t.x2, a = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, n = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, o = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, l = !1, c = this.annoCtx.inversedReversedAxis ? (n - s) / (o / i.globals.gridWidth) : (s - a) / (o / i.globals.gridWidth);
    return i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || i.config.chart.sparkline.enabled || (c = this.getStringX(s)), typeof s == "string" && s.includes("px") && (c = parseFloat(s)), s == null && t.marker && (c = i.globals.gridWidth), t.seriesIndex !== void 0 && i.globals.barWidth && !this.annoCtx.invertAxis && (c -= i.globals.barWidth / 2 * (i.globals.series.length - 1) - i.globals.barWidth * t.seriesIndex), typeof c != "number" && (c = 0, l = !0), parseFloat(c.toFixed(10)) > parseFloat(i.globals.gridWidth.toFixed(10)) ? (c = i.globals.gridWidth, l = !0) : c < 0 && (c = 0, l = !0), { x: c, clipped: l };
  } }, { key: "getStringX", value: function(e) {
    var t = this.w, i = e;
    t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
    var s = t.globals.labels.map(function(n) {
      return Array.isArray(n) ? n.join(" ") : n;
    }).indexOf(e), a = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(s + 1, ")"));
    return a && (i = parseFloat(a.getAttribute("x"))), i;
  } }]), r;
}(), Vh = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new as(this.annoCtx);
  }
  return te(r, [{ key: "addXaxisAnnotation", value: function(e, t, i) {
    var s, a = this.w, n = this.helpers.getX1X2("x1", e), o = n.x, l = n.clipped, c = !0, h = e.label.text, d = e.strokeDashArray;
    if (z.isNumber(o)) {
      if (e.x2 === null || e.x2 === void 0) {
        if (!l) {
          var u = this.annoCtx.graphics.drawLine(o + e.offsetX, 0 + e.offsetY, o + e.offsetX, a.globals.gridHeight + e.offsetY, e.borderColor, d, e.borderWidth);
          t.appendChild(u.node), e.id && u.node.classList.add(e.id);
        }
      } else {
        var g = this.helpers.getX1X2("x2", e);
        if (s = g.x, c = g.clipped, s < o) {
          var p = o;
          o = s, s = p;
        }
        var f = this.annoCtx.graphics.drawRect(o + e.offsetX, 0 + e.offsetY, s - o, a.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, d);
        f.node.classList.add("apexcharts-annotation-rect"), f.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), t.appendChild(f.node), e.id && f.node.classList.add(e.id);
      }
      if (!l || !c) {
        var x = this.annoCtx.graphics.getTextRects(h, parseFloat(e.label.style.fontSize)), m = e.label.position === "top" ? 4 : e.label.position === "center" ? a.globals.gridHeight / 2 + (e.label.orientation === "vertical" ? x.width / 2 : 0) : a.globals.gridHeight, b = this.annoCtx.graphics.drawText({ x: o + e.label.offsetX, y: m + e.label.offsetY - (e.label.orientation === "vertical" ? e.label.position === "top" ? x.width / 2 - 12 : -x.width / 2 : 0), text: h, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
        b.attr({ rel: i }), t.appendChild(b.node), this.annoCtx.helpers.setOrientations(e, i);
      }
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return t.config.annotations.xaxis.map(function(s, a) {
      e.addXaxisAnnotation(s, i.node, a);
    }), i;
  } }]), r;
}(), Ye = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return te(r, [{ key: "isValidDate", value: function(e) {
    return typeof e != "number" && !isNaN(this.parseDate(e));
  } }, { key: "getTimeStamp", value: function(e) {
    return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e;
  } }, { key: "getDate", value: function(e) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e);
  } }, { key: "parseDate", value: function(e) {
    var t = Date.parse(e);
    if (!isNaN(t)) return this.getTimeStamp(e);
    var i = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i = this.getTimeStamp(i);
  } }, { key: "parseDateWithTimezone", value: function(e) {
    return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  } }, { key: "formatDate", value: function(e, t) {
    var i = this.w.globals.locale, s = this.w.config.xaxis.labels.datetimeUTC, a = ["\0"].concat(De(i.months)), n = [""].concat(De(i.shortMonths)), o = [""].concat(De(i.days)), l = [""].concat(De(i.shortDays));
    function c(C, R) {
      var P = C + "";
      for (R = R || 2; P.length < R; ) P = "0" + P;
      return P;
    }
    var h = s ? e.getUTCFullYear() : e.getFullYear();
    t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + h)).replace(/(^|[^\\])yy/g, "$1" + h.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h);
    var d = (s ? e.getUTCMonth() : e.getMonth()) + 1;
    t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + a[0])).replace(/(^|[^\\])MMM/g, "$1" + n[0])).replace(/(^|[^\\])MM/g, "$1" + c(d))).replace(/(^|[^\\])M/g, "$1" + d);
    var u = s ? e.getUTCDate() : e.getDate();
    t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + o[0])).replace(/(^|[^\\])ddd/g, "$1" + l[0])).replace(/(^|[^\\])dd/g, "$1" + c(u))).replace(/(^|[^\\])d/g, "$1" + u);
    var g = s ? e.getUTCHours() : e.getHours(), p = g > 12 ? g - 12 : g === 0 ? 12 : g;
    t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + c(g))).replace(/(^|[^\\])H/g, "$1" + g)).replace(/(^|[^\\])hh+/g, "$1" + c(p))).replace(/(^|[^\\])h/g, "$1" + p);
    var f = s ? e.getUTCMinutes() : e.getMinutes();
    t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + c(f))).replace(/(^|[^\\])m/g, "$1" + f);
    var x = s ? e.getUTCSeconds() : e.getSeconds();
    t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + c(x))).replace(/(^|[^\\])s/g, "$1" + x);
    var m = s ? e.getUTCMilliseconds() : e.getMilliseconds();
    t = t.replace(/(^|[^\\])fff+/g, "$1" + c(m, 3)), m = Math.round(m / 10), t = t.replace(/(^|[^\\])ff/g, "$1" + c(m)), m = Math.round(m / 10);
    var b = g < 12 ? "AM" : "PM";
    t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + m)).replace(/(^|[^\\])TT+/g, "$1" + b)).replace(/(^|[^\\])T/g, "$1" + b.charAt(0));
    var w = b.toLowerCase();
    t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + w)).replace(/(^|[^\\])t/g, "$1" + w.charAt(0));
    var y = -e.getTimezoneOffset(), v = s || !y ? "Z" : y > 0 ? "+" : "-";
    if (!s) {
      var S = (y = Math.abs(y)) % 60;
      v += c(Math.floor(y / 60)) + ":" + c(S);
    }
    t = t.replace(/(^|[^\\])K/g, "$1" + v);
    var k = (s ? e.getUTCDay() : e.getDay()) + 1;
    return t = (t = (t = (t = (t = t.replace(new RegExp(o[0], "g"), o[k])).replace(new RegExp(l[0], "g"), l[k])).replace(new RegExp(a[0], "g"), a[d])).replace(new RegExp(n[0], "g"), n[d])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(e, t, i) {
    var s = this.w;
    s.config.xaxis.min !== void 0 && (e = s.config.xaxis.min), s.config.xaxis.max !== void 0 && (t = s.config.xaxis.max);
    var a = this.getDate(e), n = this.getDate(t), o = this.formatDate(a, "yyyy MM dd HH mm ss fff").split(" "), l = this.formatDate(n, "yyyy MM dd HH mm ss fff").split(" ");
    return { minMillisecond: parseInt(o[6], 10), maxMillisecond: parseInt(l[6], 10), minSecond: parseInt(o[5], 10), maxSecond: parseInt(l[5], 10), minMinute: parseInt(o[4], 10), maxMinute: parseInt(l[4], 10), minHour: parseInt(o[3], 10), maxHour: parseInt(l[3], 10), minDate: parseInt(o[2], 10), maxDate: parseInt(l[2], 10), minMonth: parseInt(o[1], 10) - 1, maxMonth: parseInt(l[1], 10) - 1, minYear: parseInt(o[0], 10), maxYear: parseInt(l[0], 10) };
  } }, { key: "isLeapYear", value: function(e) {
    return e % 4 == 0 && e % 100 != 0 || e % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(e, t, i) {
    return this.determineDaysOfMonths(e, t) - i;
  } }, { key: "determineDaysOfYear", value: function(e) {
    var t = 365;
    return this.isLeapYear(e) && (t = 366), t;
  } }, { key: "determineRemainingDaysOfYear", value: function(e, t, i) {
    var s = this.daysCntOfYear[t] + i;
    return t > 1 && this.isLeapYear() && s++, s;
  } }, { key: "determineDaysOfMonths", value: function(e, t) {
    var i = 30;
    switch (e = z.monthMod(e), !0) {
      case this.months30.indexOf(e) > -1:
        e === 2 && (i = this.isLeapYear(t) ? 29 : 28);
        break;
      case this.months31.indexOf(e) > -1:
      default:
        i = 31;
    }
    return i;
  } }]), r;
}(), Ti = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM";
  }
  return te(r, [{ key: "xLabelFormat", value: function(e, t, i, s) {
    var a = this.w;
    if (a.config.xaxis.type === "datetime" && a.config.xaxis.labels.formatter === void 0 && a.config.tooltip.x.formatter === void 0) {
      var n = new Ye(this.ctx);
      return n.formatDate(n.getDate(t), a.config.tooltip.x.format);
    }
    return e(t, i, s);
  } }, { key: "defaultGeneralFormatter", value: function(e) {
    return Array.isArray(e) ? e.map(function(t) {
      return t;
    }) : e;
  } }, { key: "defaultYFormatter", value: function(e, t, i) {
    var s = this.w;
    if (z.isNumber(e)) if (s.globals.yValueDecimal !== 0) e = e.toFixed(t.decimalsInFloat !== void 0 ? t.decimalsInFloat : s.globals.yValueDecimal);
    else {
      var a = e.toFixed(0);
      e = e == a ? a : e.toFixed(1);
    }
    return e;
  } }, { key: "setLabelFormatters", value: function() {
    var e = this, t = this.w;
    return t.globals.xaxisTooltipFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.globals.ttKeyFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.globals.ttZFormatter = function(i) {
      return i;
    }, t.globals.legendFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.config.xaxis.labels.formatter !== void 0 ? t.globals.xLabelFormatter = t.config.xaxis.labels.formatter : t.globals.xLabelFormatter = function(i) {
      if (z.isNumber(i)) {
        if (!t.config.xaxis.convertedCatToNumeric && t.config.xaxis.type === "numeric") {
          if (z.isNumber(t.config.xaxis.decimalsInFloat)) return i.toFixed(t.config.xaxis.decimalsInFloat);
          var s = t.globals.maxX - t.globals.minX;
          return s > 0 && s < 100 ? i.toFixed(1) : i.toFixed(0);
        }
        return t.globals.isBarHorizontal && t.globals.maxY - t.globals.minYArr < 4 ? i.toFixed(1) : i.toFixed(0);
      }
      return i;
    }, typeof t.config.tooltip.x.formatter == "function" ? t.globals.ttKeyFormatter = t.config.tooltip.x.formatter : t.globals.ttKeyFormatter = t.globals.xLabelFormatter, typeof t.config.xaxis.tooltip.formatter == "function" && (t.globals.xaxisTooltipFormatter = t.config.xaxis.tooltip.formatter), (Array.isArray(t.config.tooltip.y) || t.config.tooltip.y.formatter !== void 0) && (t.globals.ttVal = t.config.tooltip.y), t.config.tooltip.z.formatter !== void 0 && (t.globals.ttZFormatter = t.config.tooltip.z.formatter), t.config.legend.formatter !== void 0 && (t.globals.legendFormatter = t.config.legend.formatter), t.config.yaxis.forEach(function(i, s) {
      i.labels.formatter !== void 0 ? t.globals.yLabelFormatters[s] = i.labels.formatter : t.globals.yLabelFormatters[s] = function(a) {
        return t.globals.xyCharts ? Array.isArray(a) ? a.map(function(n) {
          return e.defaultYFormatter(n, i, s);
        }) : e.defaultYFormatter(a, i, s) : a;
      };
    }), t.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var e = this.w;
    if (e.config.chart.type === "heatmap") {
      e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
      var t = e.globals.seriesNames.reduce(function(i, s) {
        return i.length > s.length ? i : s;
      }, 0);
      e.globals.yAxisScale[0].niceMax = t, e.globals.yAxisScale[0].niceMin = t;
    }
  } }]), r;
}(), Pt = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "getLabel", value: function(e, t, i, s) {
    var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", o = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], l = this.w, c = e[s] === void 0 ? "" : e[s], h = c, d = l.globals.xLabelFormatter, u = l.config.xaxis.labels.formatter, g = !1, p = new Ti(this.ctx), f = c;
    o && (h = p.xLabelFormat(d, c, f, { i: s, dateFormatter: new Ye(this.ctx).formatDate, w: l }), u !== void 0 && (h = u(c, e[s], { i: s, dateFormatter: new Ye(this.ctx).formatDate, w: l })));
    var x, m;
    t.length > 0 ? (x = t[s].unit, m = null, t.forEach(function(v) {
      v.unit === "month" ? m = "year" : v.unit === "day" ? m = "month" : v.unit === "hour" ? m = "day" : v.unit === "minute" && (m = "hour");
    }), g = m === x, i = t[s].position, h = t[s].value) : l.config.xaxis.type === "datetime" && u === void 0 && (h = ""), h === void 0 && (h = ""), h = Array.isArray(h) ? h : h.toString();
    var b = new B(this.ctx), w = {};
    w = l.globals.rotateXLabels && o ? b.getTextRects(h, parseInt(n, 10), null, "rotate(".concat(l.config.xaxis.labels.rotate, " 0 0)"), !1) : b.getTextRects(h, parseInt(n, 10));
    var y = !l.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(h) && (String(h) === "NaN" || a.indexOf(h) >= 0 && y) && (h = ""), { x: i, text: h, textRect: w, isBold: g };
  } }, { key: "checkLabelBasedOnTickamount", value: function(e, t, i) {
    var s = this.w, a = s.config.xaxis.tickAmount;
    return a === "dataPoints" && (a = Math.round(s.globals.gridWidth / 120)), a > i || e % Math.round(i / (a + 1)) == 0 || (t.text = ""), t;
  } }, { key: "checkForOverflowingLabels", value: function(e, t, i, s, a) {
    var n = this.w;
    if (e === 0 && n.globals.skipFirstTimelinelabel && (t.text = ""), e === i - 1 && n.globals.skipLastTimelinelabel && (t.text = ""), n.config.xaxis.labels.hideOverlappingLabels && s.length > 0) {
      var o = a[a.length - 1];
      t.x < o.textRect.width / (n.globals.rotateXLabels ? Math.abs(n.config.xaxis.labels.rotate) / 12 : 1.01) + o.x && (t.text = "");
    }
    return t;
  } }, { key: "checkForReversedLabels", value: function(e, t) {
    var i = this.w;
    return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(), t;
  } }, { key: "yAxisAllSeriesCollapsed", value: function(e) {
    var t = this.w.globals;
    return !t.seriesYAxisMap[e].some(function(i) {
      return t.collapsedSeriesIndices.indexOf(i) === -1;
    });
  } }, { key: "translateYAxisIndex", value: function(e) {
    var t = this.w, i = t.globals, s = t.config.yaxis;
    return i.series.length > s.length || s.some(function(a) {
      return Array.isArray(a.seriesName);
    }) ? e : i.seriesYAxisReverseMap[e];
  } }, { key: "isYAxisHidden", value: function(e) {
    var t = this.w, i = t.config.yaxis[e];
    if (!i.show || this.yAxisAllSeriesCollapsed(e)) return !0;
    if (!i.showForNullSeries) {
      var s = t.globals.seriesYAxisMap[e], a = new ze(this.ctx);
      return s.every(function(n) {
        return a.isSeriesNull(n);
      });
    }
    return !1;
  } }, { key: "getYAxisForeColor", value: function(e, t) {
    var i = this.w;
    return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, i.globals.yAxisScale[t].result.length, !1), e;
  } }, { key: "drawYAxisTicks", value: function(e, t, i, s, a, n, o) {
    var l = this.w, c = new B(this.ctx), h = l.globals.translateY + l.config.yaxis[a].labels.offsetY;
    if (l.globals.isBarHorizontal ? h = 0 : l.config.chart.type === "heatmap" && (h += n / 2), s.show && t > 0) {
      l.config.yaxis[a].opposite === !0 && (e += s.width);
      for (var d = t; d >= 0; d--) {
        var u = c.drawLine(e + i.offsetX - s.width + s.offsetX, h + s.offsetY, e + i.offsetX + s.offsetX, h + s.offsetY, s.color);
        o.add(u), h += n;
      }
    }
  } }]), r;
}(), Gh = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.annoCtx = e, this.helpers = new as(this.annoCtx), this.axesUtils = new Pt(this.annoCtx);
  }
  return te(r, [{ key: "addYaxisAnnotation", value: function(e, t, i) {
    var s, a = this.w, n = e.strokeDashArray, o = this.helpers.getY1Y2("y1", e), l = o.yP, c = o.clipped, h = !0, d = !1, u = e.label.text;
    if (e.y2 === null || e.y2 === void 0) {
      if (!c) {
        d = !0;
        var g = this.annoCtx.graphics.drawLine(0 + e.offsetX, l + e.offsetY, this._getYAxisAnnotationWidth(e), l + e.offsetY, e.borderColor, n, e.borderWidth);
        t.appendChild(g.node), e.id && g.node.classList.add(e.id);
      }
    } else {
      if (s = (o = this.helpers.getY1Y2("y2", e)).yP, h = o.clipped, s > l) {
        var p = l;
        l = s, s = p;
      }
      if (!c || !h) {
        d = !0;
        var f = this.annoCtx.graphics.drawRect(0 + e.offsetX, s + e.offsetY, this._getYAxisAnnotationWidth(e), l - s, 0, e.fillColor, e.opacity, 1, e.borderColor, n);
        f.node.classList.add("apexcharts-annotation-rect"), f.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), t.appendChild(f.node), e.id && f.node.classList.add(e.id);
      }
    }
    if (d) {
      var x = e.label.position === "right" ? a.globals.gridWidth : e.label.position === "center" ? a.globals.gridWidth / 2 : 0, m = this.annoCtx.graphics.drawText({ x: x + e.label.offsetX, y: (s ?? l) + e.label.offsetY - 3, text: u, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
      m.attr({ rel: i }), t.appendChild(m.node);
    }
  } }, { key: "_getYAxisAnnotationWidth", value: function(e) {
    var t = this.w;
    return t.globals.gridWidth, (e.width.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX;
  } }, { key: "drawYAxisAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return t.config.annotations.yaxis.forEach(function(s, a) {
      s.yAxisIndex = e.axesUtils.translateYAxisIndex(s.yAxisIndex), e.axesUtils.isYAxisHidden(s.yAxisIndex) && e.axesUtils.yAxisAllSeriesCollapsed(s.yAxisIndex) || e.addYaxisAnnotation(s, i.node, a);
    }), i;
  } }]), r;
}(), $h = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.annoCtx = e, this.helpers = new as(this.annoCtx);
  }
  return te(r, [{ key: "addPointAnnotation", value: function(e, t, i) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(e.seriesIndex) > -1)) {
      var s = this.helpers.getX1X2("x1", e), a = s.x, n = s.clipped, o = (s = this.helpers.getY1Y2("y1", e)).yP, l = s.clipped;
      if (z.isNumber(a) && !l && !n) {
        var c = { pSize: e.marker.size, pointStrokeWidth: e.marker.strokeWidth, pointFillColor: e.marker.fillColor, pointStrokeColor: e.marker.strokeColor, shape: e.marker.shape, pRadius: e.marker.radius, class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id ? e.id : "") }, h = this.annoCtx.graphics.drawMarker(a + e.marker.offsetX, o + e.marker.offsetY, c);
        t.appendChild(h.node);
        var d = e.label.text ? e.label.text : "", u = this.annoCtx.graphics.drawText({ x: a + e.label.offsetX, y: o + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6, text: d, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
        if (u.attr({ rel: i }), t.appendChild(u.node), e.customSVG.SVG) {
          var g = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass });
          g.attr({ transform: "translate(".concat(a + e.customSVG.offsetX, ", ").concat(o + e.customSVG.offsetY, ")") }), g.node.innerHTML = e.customSVG.SVG, t.appendChild(g.node);
        }
        if (e.image.path) {
          var p = e.image.width ? e.image.width : 20, f = e.image.height ? e.image.height : 20;
          h = this.annoCtx.addImage({ x: a + e.image.offsetX - p / 2, y: o + e.image.offsetY - f / 2, width: p, height: f, path: e.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        e.mouseEnter && h.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)), e.mouseLeave && h.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e)), e.click && h.node.addEventListener("click", e.click.bind(this, e));
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
    return t.config.annotations.points.map(function(s, a) {
      e.addPointAnnotation(s, i.node, a);
    }), i;
  } }]), r;
}(), yo = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, _t = function() {
  function r() {
    ee(this, r), this.yAxis = { show: !0, showAlways: !1, showForNullSeries: !0, seriesName: void 0, opposite: !1, reversed: !1, logarithmic: !1, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: !1, max: void 0, min: void 0, floating: !1, decimalsInFloat: void 0, labels: { show: !0, showDuplicates: !1, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: !1, offsetX: 0 }, crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return te(r, [{ key: "init", value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: !0, speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 } }, background: "", locales: [yo], defaultLocale: "en", dropShadow: { enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.7 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: !0, redrawOnWindowResize: !0, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: !1, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: !1 }, brush: { enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0 }, stacked: !1, stackOnlyBar: !0, stackType: "normal", toolbar: { show: !0, offsetX: 0, offsetY: 0, tools: { download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: !0, type: "x", autoScaleYaxis: !1, allowMouseWheelZoom: !0, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: !1, colors: { threshold: 0, colorAboveThreshold: void 0, colorBelowThreshold: void 0 } }, area: { fillTo: "origin" }, bar: { horizontal: !1, columnWidth: "70%", barHeight: "70%", distributed: !1, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: !0, rangeBarGroupRows: !1, hideZeroBarsWhenGrouped: !1, isDumbbell: !1, dumbbellColors: void 0, isFunnel: !1, isFunnel3d: !0, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: !0, orientation: "horizontal", total: { enabled: !1, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: !0, shadeIntensity: 0.5, reverseNegativeShade: !1, distributed: !1, useFillColorAsStroke: !1, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: !0, shadeIntensity: 0.5, distributed: !1, reverseNegativeShade: !1, useFillColorAsStroke: !1, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 }, seriesTitle: { show: !0, offsetY: 1, offsetX: 1, borderColor: "#000", borderWidth: 1, borderRadius: 2, style: { background: "rgba(0, 0, 0, 0.6)", color: "#fff", fontSize: "12px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: !1, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: !0, position: "front", dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: !0, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: !0, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(e) {
      return e;
    } }, value: { show: !0, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(e) {
      return e + "%";
    } }, total: { show: !1, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(e) {
      return e.globals.seriesTotals.reduce(function(t, i) {
        return t + i;
      }, 0) / e.globals.series.length + "%";
    } } }, barLabels: { enabled: !1, offsetX: 0, offsetY: 0, useSeriesColors: !0, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(e) {
      return e;
    }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: !0, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: !1, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(e) {
      return e;
    } }, value: { show: !0, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(e) {
      return e;
    } }, total: { show: !1, showAlways: !1, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(e) {
      return e.globals.seriesTotals.reduce(function(t, i) {
        return t + i;
      }, 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: !0, enabledOnSeries: void 0, formatter: function(e) {
      return e !== null ? e : "";
    }, textAnchor: "middle", distributed: !1, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: !0, foreColor: "#fff", backgroundColor: void 0, borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: !0, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: !1 } }, yaxis: { lines: { show: !0 } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: !0, showForSingleSeries: !1, showForNullSeries: !0, showForZeroSeries: !0, floating: !1, position: "bottom", horizontalAlign: "center", inverseOrder: !1, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: !0, clusterGroupedSeriesOrientation: "vertical", labels: { colors: void 0, useSeriesColors: !1 }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: !0 }, onItemHover: { highlightDataSeries: !0 } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: !0, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { hover: { filter: { type: "lighten" } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken" } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: !0, enabledOnSeries: void 0, shared: !0, hideEmptySeries: !1, followCursor: !1, intersect: !1, inverseOrder: !1, custom: void 0, fillSeriesColor: !1, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: !1 }, x: { show: !0, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(e) {
      return e ? e + ": " : "";
    } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: !0, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: !1, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: !0, rotate: -45, rotateAlways: !1, hideOverlappingLabels: !0, trim: !1, minHeight: void 0, maxHeight: 120, showDuplicates: !0, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: !0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: !1, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: !0, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), r;
}(), Uh = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.graphics = new B(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new as(this), this.xAxisAnnotations = new Vh(this), this.yAxisAnnotations = new Gh(this), this.pointsAnnotations = new $h(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return te(r, [{ key: "drawAxesAnnotations", value: function() {
    var e = this.w;
    if (e.globals.axisCharts && e.globals.dataPoints) {
      for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), s = this.pointsAnnotations.drawPointAnnotations(), a = e.config.chart.animations.enabled, n = [t, i, s], o = [i.node, t.node, s.node], l = 0; l < 3; l++) e.globals.dom.elGraphical.add(n[l]), !a || e.globals.resized || e.globals.dataChanged || e.config.chart.type !== "scatter" && e.config.chart.type !== "bubble" && e.globals.dataPoints > 1 && o[l].classList.add("apexcharts-element-hidden"), e.globals.delayedElements.push({ el: o[l], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: "drawImageAnnos", value: function() {
    var e = this;
    this.w.config.annotations.images.map(function(t, i) {
      e.addImage(t, i);
    });
  } }, { key: "drawTextAnnos", value: function() {
    var e = this;
    this.w.config.annotations.texts.map(function(t, i) {
      e.addText(t, i);
    });
  } }, { key: "addXaxisAnnotation", value: function(e, t, i) {
    this.xAxisAnnotations.addXaxisAnnotation(e, t, i);
  } }, { key: "addYaxisAnnotation", value: function(e, t, i) {
    this.yAxisAnnotations.addYaxisAnnotation(e, t, i);
  } }, { key: "addPointAnnotation", value: function(e, t, i) {
    this.pointsAnnotations.addPointAnnotation(e, t, i);
  } }, { key: "addText", value: function(e, t) {
    var i = e.x, s = e.y, a = e.text, n = e.textAnchor, o = e.foreColor, l = e.fontSize, c = e.fontFamily, h = e.fontWeight, d = e.cssClass, u = e.backgroundColor, g = e.borderWidth, p = e.strokeDashArray, f = e.borderRadius, x = e.borderColor, m = e.appendTo, b = m === void 0 ? ".apexcharts-svg" : m, w = e.paddingLeft, y = w === void 0 ? 4 : w, v = e.paddingRight, S = v === void 0 ? 4 : v, k = e.paddingBottom, C = k === void 0 ? 2 : k, R = e.paddingTop, P = R === void 0 ? 2 : R, A = this.w, E = this.graphics.drawText({ x: i, y: s, text: a, textAnchor: n || "start", fontSize: l || "12px", fontWeight: h || "regular", fontFamily: c || A.config.chart.fontFamily, foreColor: o || A.config.chart.foreColor, cssClass: d }), N = A.globals.dom.baseEl.querySelector(b);
    N && N.appendChild(E.node);
    var O = E.bbox();
    if (a) {
      var L = this.graphics.drawRect(O.x - y, O.y - P, O.width + y + S, O.height + C + P, f, u || "transparent", 1, g, x, p);
      N.insertBefore(L.node, E.node);
    }
  } }, { key: "addImage", value: function(e, t) {
    var i = this.w, s = e.path, a = e.x, n = a === void 0 ? 0 : a, o = e.y, l = o === void 0 ? 0 : o, c = e.width, h = c === void 0 ? 20 : c, d = e.height, u = d === void 0 ? 20 : d, g = e.appendTo, p = g === void 0 ? ".apexcharts-svg" : g, f = i.globals.dom.Paper.image(s);
    f.size(h, u).move(n, l);
    var x = i.globals.dom.baseEl.querySelector(p);
    return x && x.appendChild(f.node), f;
  } }, { key: "addXaxisAnnotationExternal", value: function(e, t, i) {
    return this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
  } }, { key: "addYaxisAnnotationExternal", value: function(e, t, i) {
    return this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
  } }, { key: "addPointAnnotationExternal", value: function(e, t, i) {
    return this.invertAxis === void 0 && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
  } }, { key: "addAnnotationExternal", value: function(e) {
    var t = e.params, i = e.pushToMemory, s = e.context, a = e.type, n = e.contextMethod, o = s, l = o.w, c = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations")), h = c.childNodes.length + 1, d = new _t(), u = Object.assign({}, a === "xaxis" ? d.xAxisAnnotation : a === "yaxis" ? d.yAxisAnnotation : d.pointAnnotation), g = z.extend(u, t);
    switch (a) {
      case "xaxis":
        this.addXaxisAnnotation(g, c, h);
        break;
      case "yaxis":
        this.addYaxisAnnotation(g, c, h);
        break;
      case "point":
        this.addPointAnnotation(g, c, h);
    }
    var p = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(h, "']")), f = this.helpers.addBackgroundToAnno(p, g);
    return f && c.insertBefore(f.node, p), i && l.globals.memory.methodsToExec.push({ context: o, id: g.id ? g.id : z.randomId(), method: n, label: "addAnnotation", params: t }), s;
  } }, { key: "clearAnnotations", value: function(e) {
    for (var t = e.w, i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), s = t.globals.memory.methodsToExec.length - 1; s >= 0; s--) t.globals.memory.methodsToExec[s].label !== "addText" && t.globals.memory.methodsToExec[s].label !== "addAnnotation" || t.globals.memory.methodsToExec.splice(s, 1);
    i = z.listToArray(i), Array.prototype.forEach.call(i, function(a) {
      for (; a.firstChild; ) a.removeChild(a.firstChild);
    });
  } }, { key: "removeAnnotation", value: function(e, t) {
    var i = e.w, s = i.globals.dom.baseEl.querySelectorAll(".".concat(t));
    s && (i.globals.memory.methodsToExec.map(function(a, n) {
      a.id === t && i.globals.memory.methodsToExec.splice(n, 1);
    }), Object.keys(i.config.annotations).forEach(function(a) {
      var n = i.config.annotations[a];
      Array.isArray(n) && (i.config.annotations[a] = n.filter(function(o) {
        return o.id !== t;
      }));
    }), Array.prototype.forEach.call(s, function(a) {
      a.parentElement.removeChild(a);
    }));
  } }]), r;
}(), Ls = function(r) {
  var e, t = r.isTimeline, i = r.ctx, s = r.seriesIndex, a = r.dataPointIndex, n = r.y1, o = r.y2, l = r.w, c = l.globals.seriesRangeStart[s][a], h = l.globals.seriesRangeEnd[s][a], d = l.globals.labels[a], u = l.config.series[s].name ? l.config.series[s].name : "", g = l.globals.ttKeyFormatter, p = l.config.tooltip.y.title.formatter, f = { w: l, seriesIndex: s, dataPointIndex: a, start: c, end: h };
  typeof p == "function" && (u = p(u, f)), (e = l.config.series[s].data[a]) !== null && e !== void 0 && e.x && (d = l.config.series[s].data[a].x), t || l.config.xaxis.type === "datetime" && (d = new Ti(i).xLabelFormat(l.globals.ttKeyFormatter, d, d, { i: void 0, dateFormatter: new Ye(i).formatDate, w: l })), typeof g == "function" && (d = g(d, f)), Number.isFinite(n) && Number.isFinite(o) && (c = n, h = o);
  var x = "", m = "", b = l.globals.colors[s];
  if (l.config.tooltip.x.formatter === void 0) if (l.config.xaxis.type === "datetime") {
    var w = new Ye(i);
    x = w.formatDate(w.getDate(c), l.config.tooltip.x.format), m = w.formatDate(w.getDate(h), l.config.tooltip.x.format);
  } else x = c, m = h;
  else x = l.config.tooltip.x.formatter(c), m = l.config.tooltip.x.formatter(h);
  return { start: c, end: h, startVal: x, endVal: m, ylabel: d, color: b, seriesName: u };
}, Is = function(r) {
  var e = r.color, t = r.seriesName, i = r.ylabel, s = r.start, a = r.end, n = r.seriesIndex, o = r.dataPointIndex, l = r.ctx.tooltip.tooltipLabels.getFormatters(n);
  s = l.yLbFormatter(s), a = l.yLbFormatter(a);
  var c = l.yLbFormatter(r.w.globals.series[n][o]), h = `<span class="value start-value">
  `.concat(s, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(a, `
  </span>`);
  return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (t || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (r.w.globals.comboCharts ? r.w.config.series[n].type === "rangeArea" || r.w.config.series[n].type === "rangeBar" ? h : "<span>".concat(c, "</span>") : h) + " </div></div>";
}, Ci = function() {
  function r(e) {
    ee(this, r), this.opts = e;
  }
  return te(r, [{ key: "hideYAxis", value: function() {
    this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
  } }, { key: "line", value: function() {
    return { dataLabels: { enabled: !1 }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(e) {
    return this.hideYAxis(), z.extend(e, { grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: !1 }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } }, chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 } });
  } }, { key: "slope", value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !0, formatter: function(e, t) {
      var i = t.w.config.series[t.seriesIndex].name;
      return e !== null ? i + ": " + e : "";
    }, background: { enabled: !1 }, offsetX: -5 }, grid: { xaxis: { lines: { show: !0 } }, yaxis: { lines: { show: !1 } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: !1 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, stroke: { width: 5, curve: "straight" } };
  } }, { key: "bar", value: function() {
    return { chart: { stacked: !1 }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } }, stroke: { width: 0, lineCap: "square" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { tooltip: { enabled: !1 }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: !1 }, stroke: { width: 0 } } } };
  } }, { key: "funnel", value: function() {
    return this.hideYAxis(), q(q({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: !1 } } }, plotOptions: { bar: { horizontal: !0, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: !1, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } } });
  } }, { key: "candlestick", value: function() {
    var e = this;
    return { stroke: { width: 1 }, fill: { opacity: 1 }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(t) {
      var i = t.seriesIndex, s = t.dataPointIndex, a = t.w;
      return e._getBoxTooltip(a, i, s, ["Open", "High", "", "Low", "Close"], "candlestick");
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "boxPlot", value: function() {
    var e = this;
    return { chart: { animations: { dynamicAnimation: { enabled: !1 } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(t) {
      var i = t.seriesIndex, s = t.dataPointIndex, a = t.w;
      return e._getBoxTooltip(a, i, s, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { chart: { animations: { animateGradually: !1 } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: !1, formatter: function(e, t) {
      t.ctx;
      var i = t.seriesIndex, s = t.dataPointIndex, a = t.w, n = function() {
        var o = a.globals.seriesRangeStart[i][s];
        return a.globals.seriesRangeEnd[i][s] - o;
      };
      return a.globals.comboCharts ? a.config.series[i].type === "rangeBar" || a.config.series[i].type === "rangeArea" ? n() : e : n();
    }, background: { enabled: !1 }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: !1, followCursor: !0, custom: function(e) {
      return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? function(t) {
        var i = Ls(q(q({}, t), {}, { isTimeline: !0 })), s = i.color, a = i.seriesName, n = i.ylabel, o = i.startVal, l = i.endVal;
        return Is(q(q({}, t), {}, { color: s, seriesName: a, ylabel: n, start: o, end: l }));
      }(e) : function(t) {
        var i = Ls(t), s = i.color, a = i.seriesName, n = i.ylabel, o = i.start, l = i.end;
        return Is(q(q({}, t), {}, { color: s, seriesName: a, ylabel: n, start: o, end: l }));
      }(e);
    } }, xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "dumbbell", value: function(e) {
    var t, i;
    return (t = e.plotOptions.bar) !== null && t !== void 0 && t.barHeight || (e.plotOptions.bar.barHeight = 2), (i = e.plotOptions.bar) !== null && i !== void 0 && i.columnWidth || (e.plotOptions.bar.columnWidth = 2), e;
  } }, { key: "area", value: function() {
    return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: !1 } };
  } }, { key: "rangeArea", value: function() {
    return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: !1, shared: !0, followCursor: !0, custom: function(e) {
      return function(t) {
        var i = Ls(t), s = i.color, a = i.seriesName, n = i.ylabel, o = i.start, l = i.end;
        return Is(q(q({}, t), {}, { color: s, seriesName: a, ylabel: n, start: o, end: l }));
      }(e);
    } } };
  } }, { key: "brush", value: function(e) {
    return z.extend(e, { chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } } });
  } }, { key: "stacked100", value: function(e) {
    e.dataLabels = e.dataLabels || {}, e.dataLabels.formatter = e.dataLabels.formatter || void 0;
    var t = e.dataLabels.formatter;
    return e.yaxis.forEach(function(i, s) {
      e.yaxis[s].min = 0, e.yaxis[s].max = 100;
    }), e.chart.type === "bar" && (e.dataLabels.formatter = t || function(i) {
      return typeof i == "number" && i ? i.toFixed(0) + "%" : i;
    }), e;
  } }, { key: "stackedBars", value: function() {
    var e = this.bar();
    return q(q({}, e), {}, { plotOptions: q(q({}, e.plotOptions), {}, { bar: q(q({}, e.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
  } }, { key: "convertCatToNumeric", value: function(e) {
    return e.xaxis.convertedCatToNumeric = !0, e;
  } }, { key: "convertCatToNumericXaxis", value: function(e, t, i) {
    e.xaxis.type = "numeric", e.xaxis.labels = e.xaxis.labels || {}, e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(n) {
      return z.isNumber(n) ? Math.floor(n) : n;
    };
    var s = e.xaxis.labels.formatter, a = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
    return i && i.length && (a = i.map(function(n) {
      return Array.isArray(n) ? n : String(n);
    })), a && a.length && (e.xaxis.labels.formatter = function(n) {
      return z.isNumber(n) ? s(a[Math.floor(n) - 1]) : s(n);
    }), e.xaxis.categories = [], e.labels = [], e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints", e;
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
  } }, { key: "treemap", value: function() {
    return { chart: { zoom: { enabled: !1 } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: !0, width: 2, colors: ["#fff"] }, legend: { show: !1 }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: !0, x: { show: !1 } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: !1 } }, plotOptions: { pie: { donut: { labels: { show: !1 } } } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "polarArea", value: function() {
    return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, enabled: !1 }, stroke: { show: !0, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: !1, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(e) {
      return e;
    }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: !1, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: !1, position: "right" }, tooltip: { enabled: !1, fillSeriesColor: !0 }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "_getBoxTooltip", value: function(e, t, i, s, a) {
    var n = e.globals.seriesCandleO[t][i], o = e.globals.seriesCandleH[t][i], l = e.globals.seriesCandleM[t][i], c = e.globals.seriesCandleL[t][i], h = e.globals.seriesCandleC[t][i];
    return e.config.series[t].type && e.config.series[t].type !== a ? `<div class="apexcharts-custom-tooltip">
          `.concat(e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][i], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(s[0], ': <span class="value">') + n + "</span></div>" + "<div>".concat(s[1], ': <span class="value">') + o + "</span></div>" + (l ? "<div>".concat(s[2], ': <span class="value">') + l + "</span></div>" : "") + "<div>".concat(s[3], ': <span class="value">') + c + "</span></div>" + "<div>".concat(s[4], ': <span class="value">') + h + "</span></div></div>";
  } }]), r;
}(), Ai = function() {
  function r(e) {
    ee(this, r), this.opts = e;
  }
  return te(r, [{ key: "init", value: function(e) {
    var t = e.responsiveOverride, i = this.opts, s = new _t(), a = new Ci(i);
    this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
    var n = s.init(), o = {};
    if (i && Zt(i) === "object") {
      var l, c, h, d, u, g, p, f, x, m, b = {};
      b = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) !== -1 ? a[i.chart.type]() : a.line(), (l = i.plotOptions) !== null && l !== void 0 && (c = l.bar) !== null && c !== void 0 && c.isFunnel && (b = a.funnel()), i.chart.stacked && i.chart.type === "bar" && (b = a.stackedBars()), (h = i.chart.brush) !== null && h !== void 0 && h.enabled && (b = a.brush(b)), (d = i.plotOptions) !== null && d !== void 0 && (u = d.line) !== null && u !== void 0 && u.isSlopeChart && (b = a.slope()), i.chart.stacked && i.chart.stackType === "100%" && (i = a.stacked100(i)), (g = i.plotOptions) !== null && g !== void 0 && (p = g.bar) !== null && p !== void 0 && p.isDumbbell && (i = a.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, t || (i.xaxis.convertedCatToNumeric = !1), ((f = (i = this.checkForCatToNumericXAxis(this.chartType, b, i)).chart.sparkline) !== null && f !== void 0 && f.enabled || (x = window.Apex.chart) !== null && x !== void 0 && (m = x.sparkline) !== null && m !== void 0 && m.enabled) && (b = a.sparkline(b)), o = z.extend(n, b);
    }
    var w = z.extend(o, window.Apex);
    return n = z.extend(w, i), n = this.handleUserInputErrors(n);
  } }, { key: "checkForCatToNumericXAxis", value: function(e, t, i) {
    var s, a, n = new Ci(i), o = (e === "bar" || e === "boxPlot") && ((s = i.plotOptions) === null || s === void 0 || (a = s.bar) === null || a === void 0 ? void 0 : a.horizontal), l = e === "pie" || e === "polarArea" || e === "donut" || e === "radar" || e === "radialBar" || e === "heatmap", c = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric", h = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement;
    return o || l || !c || h === "between" || (i = n.convertCatToNumeric(i)), i;
  } }, { key: "extendYAxis", value: function(e, t) {
    var i = new _t();
    (e.yaxis === void 0 || !e.yaxis || Array.isArray(e.yaxis) && e.yaxis.length === 0) && (e.yaxis = {}), e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = z.extend(e.yaxis, window.Apex.yaxis)), e.yaxis.constructor !== Array ? e.yaxis = [z.extend(i.yAxis, e.yaxis)] : e.yaxis = z.extendArray(e.yaxis, i.yAxis);
    var s = !1;
    e.yaxis.forEach(function(n) {
      n.logarithmic && (s = !0);
    });
    var a = e.series;
    return t && !a && (a = t.config.series), s && a.length !== e.yaxis.length && a.length && (e.yaxis = a.map(function(n, o) {
      if (n.name || (a[o].name = "series-".concat(o + 1)), e.yaxis[o]) return e.yaxis[o].seriesName = a[o].name, e.yaxis[o];
      var l = z.extend(i.yAxis, e.yaxis[0]);
      return l.show = !1, l;
    })), s && a.length > 1 && a.length !== e.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), e;
  } }, { key: "extendAnnotations", value: function(e) {
    return e.annotations === void 0 && (e.annotations = {}, e.annotations.yaxis = [], e.annotations.xaxis = [], e.annotations.points = []), e = this.extendYAxisAnnotations(e), e = this.extendXAxisAnnotations(e), e = this.extendPointAnnotations(e);
  } }, { key: "extendYAxisAnnotations", value: function(e) {
    var t = new _t();
    return e.annotations.yaxis = z.extendArray(e.annotations.yaxis !== void 0 ? e.annotations.yaxis : [], t.yAxisAnnotation), e;
  } }, { key: "extendXAxisAnnotations", value: function(e) {
    var t = new _t();
    return e.annotations.xaxis = z.extendArray(e.annotations.xaxis !== void 0 ? e.annotations.xaxis : [], t.xAxisAnnotation), e;
  } }, { key: "extendPointAnnotations", value: function(e) {
    var t = new _t();
    return e.annotations.points = z.extendArray(e.annotations.points !== void 0 ? e.annotations.points : [], t.pointAnnotation), e;
  } }, { key: "checkForDarkTheme", value: function(e) {
    e.theme && e.theme.mode === "dark" && (e.tooltip || (e.tooltip = {}), e.tooltip.theme !== "light" && (e.tooltip.theme = "dark"), e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"), e.theme.palette || (e.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(e) {
    var t = e;
    if (t.tooltip.shared && t.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if (t.chart.type === "bar" && t.plotOptions.bar.horizontal) {
      if (t.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      t.yaxis[0].reversed && (t.yaxis[0].opposite = !0), t.xaxis.tooltip.enabled = !1, t.yaxis[0].tooltip.enabled = !1, t.chart.zoom.enabled = !1;
    }
    return t.chart.type !== "bar" && t.chart.type !== "rangeBar" || t.tooltip.shared && t.xaxis.crosshairs.width === "barWidth" && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"), t.chart.type !== "candlestick" && t.chart.type !== "boxPlot" || t.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(t.chart.type, " chart is not supported.")), t.yaxis[0].reversed = !1), t;
  } }]), r;
}(), wo = function() {
  function r() {
    ee(this, r);
  }
  return te(r, [{ key: "initGlobalVars", value: function(e) {
    e.series = [], e.seriesCandleO = [], e.seriesCandleH = [], e.seriesCandleM = [], e.seriesCandleL = [], e.seriesCandleC = [], e.seriesRangeStart = [], e.seriesRangeEnd = [], e.seriesRange = [], e.seriesPercent = [], e.seriesGoals = [], e.seriesX = [], e.seriesZ = [], e.seriesNames = [], e.seriesTotals = [], e.seriesLog = [], e.seriesColors = [], e.stackedSeriesTotals = [], e.seriesXvalues = [], e.seriesYvalues = [], e.labels = [], e.hasXaxisGroups = !1, e.groups = [], e.barGroups = [], e.lineGroups = [], e.areaGroups = [], e.hasSeriesGroups = !1, e.seriesGroups = [], e.categoryLabels = [], e.timescaleLabels = [], e.noLabelsProvided = !1, e.resizeTimer = null, e.selectionResizeTimer = null, e.lastWheelExecution = 0, e.delayedElements = [], e.pointsArray = [], e.dataLabelsRects = [], e.isXNumeric = !1, e.skipLastTimelinelabel = !1, e.skipFirstTimelinelabel = !1, e.isDataXYZ = !1, e.isMultiLineX = !1, e.isMultipleYAxis = !1, e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE, e.minYArr = [], e.maxYArr = [], e.maxX = -Number.MAX_VALUE, e.minX = Number.MAX_VALUE, e.initialMaxX = -Number.MAX_VALUE, e.initialMinX = Number.MAX_VALUE, e.maxDate = 0, e.minDate = Number.MAX_VALUE, e.minZ = Number.MAX_VALUE, e.maxZ = -Number.MAX_VALUE, e.minXDiff = Number.MAX_VALUE, e.yAxisScale = [], e.xAxisScale = null, e.xAxisTicksPositions = [], e.yLabelsCoords = [], e.yTitleCoords = [], e.barPadForNumericAxis = 0, e.padHorizontal = 0, e.xRange = 0, e.yRange = [], e.zRange = 0, e.dataPoints = 0, e.xTickAmount = 0, e.multiAxisTickAmount = 0;
  } }, { key: "globalVars", value: function(e) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: e.markers.size, largestSize: 0 }, animationEnded: !1, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: !1, isExecCalled: !1, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: !1, allSeriesCollapsed: !1, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: !1, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: !1, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: e.chart.toolbar.autoSelected === "zoom" && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled, panEnabled: e.chart.toolbar.autoSelected === "pan" && e.chart.toolbar.tools.pan, selectionEnabled: e.chart.toolbar.autoSelected === "selection" && e.chart.toolbar.tools.selection, yaxis: null, mousedown: !1, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: !1, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: !0, skipLastTimelinelabel: !1, skipFirstTimelinelabel: !1, delayedElements: [], axisCharts: !0, isDataXYZ: !1, isSlopeChart: e.plotOptions.line.isSlopeChart, resized: !1, resizeTimer: null, comboCharts: !1, dataChanged: !1, previousPaths: [], allSeriesHasEqualX: !0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: !1, zoomed: !1, gridWidth: 0, gridHeight: 0, rotateXLabels: !1, defaultLabels: !1, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: "init", value: function(e) {
    var t = this.globalVars(e);
    return this.initGlobalVars(t), t.initialConfig = z.extend({}, e), t.initialSeries = z.clone(e.series), t.lastXAxis = z.clone(t.initialConfig.xaxis), t.lastYAxis = z.clone(t.initialConfig.yaxis), t;
  } }]), r;
}(), qh = function() {
  function r(e) {
    ee(this, r), this.opts = e;
  }
  return te(r, [{ key: "init", value: function() {
    var e = new Ai(this.opts).init({ responsiveOverride: !1 });
    return { config: e, globals: new wo().init(e) };
  } }]), r;
}(), ht = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return te(r, [{ key: "clippedImgArea", value: function(e) {
    var t = this.w, i = t.config, s = parseInt(t.globals.gridWidth, 10), a = parseInt(t.globals.gridHeight, 10), n = s > a ? s : a, o = e.image, l = 0, c = 0;
    e.width === void 0 && e.height === void 0 ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (l = i.fill.image.width + 1, c = i.fill.image.height) : (l = n + 1, c = n) : (l = e.width, c = e.height);
    var h = document.createElementNS(t.globals.SVGNS, "pattern");
    B.setAttrs(h, { id: e.patternID, patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse", width: l + "px", height: c + "px" });
    var d = document.createElementNS(t.globals.SVGNS, "image");
    h.appendChild(d), d.setAttributeNS(window.SVG.xlink, "href", o), B.setAttrs(d, { x: 0, y: 0, preserveAspectRatio: "none", width: l + "px", height: c + "px" }), d.style.opacity = e.opacity, t.globals.dom.elDefs.node.appendChild(h);
  } }, { key: "getSeriesIndex", value: function(e) {
    var t = this.w, i = t.config.chart.type;
    return (i === "bar" || i === "rangeBar") && t.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = e.seriesNumber : this.seriesIndex = e.seriesNumber % t.globals.series.length, this.seriesIndex;
  } }, { key: "computeColorStops", value: function(e, t) {
    var i, s = this.w, a = null, n = null, o = gi(e);
    try {
      for (o.s(); !(i = o.n()).done; ) {
        var l = i.value;
        l >= t.threshold ? (a === null || l > a) && (a = l) : (n === null || l < n) && (n = l);
      }
    } catch (d) {
      o.e(d);
    } finally {
      o.f();
    }
    a === null && (a = t.threshold), n === null && (n = t.threshold);
    var c = a - t.threshold + (t.threshold - n);
    c === 0 && (c = 1);
    var h = 100 - (t.threshold - n) / c * 100;
    return [{ offset: h = Math.max(0, Math.min(h, 100)), color: t.colorAboveThreshold, opacity: s.config.fill.opacity }, { offset: 0, color: t.colorBelowThreshold, opacity: s.config.fill.opacity }];
  } }, { key: "fillPath", value: function(e) {
    var t, i, s, a = this.w;
    this.opts = e;
    var n, o, l, c = this.w.config;
    this.seriesIndex = this.getSeriesIndex(e);
    var h = c.plotOptions.line.colors.colorAboveThreshold && c.plotOptions.line.colors.colorBelowThreshold, d = this.getFillColors()[this.seriesIndex];
    a.globals.seriesColors[this.seriesIndex] !== void 0 && (d = a.globals.seriesColors[this.seriesIndex]), typeof d == "function" && (d = d({ seriesIndex: this.seriesIndex, dataPointIndex: e.dataPointIndex, value: e.value, w: a }));
    var u, g, p, f = e.fillType ? e.fillType : this.getFillType(this.seriesIndex), x = Array.isArray(c.fill.opacity) ? c.fill.opacity[this.seriesIndex] : c.fill.opacity, m = f === "gradient" || h;
    e.color && (d = e.color), (t = a.config.series[this.seriesIndex]) !== null && t !== void 0 && (i = t.data) !== null && i !== void 0 && (s = i[e.dataPointIndex]) !== null && s !== void 0 && s.fillColor && (d = (u = a.config.series[this.seriesIndex]) === null || u === void 0 || (g = u.data) === null || g === void 0 || (p = g[e.dataPointIndex]) === null || p === void 0 ? void 0 : p.fillColor), d || (d = "#fff", console.warn("undefined color - ApexCharts"));
    var b = d;
    if (d.indexOf("rgb") === -1 ? d.indexOf("#") === -1 ? b = d : d.length < 9 && (b = z.hexToRgba(d, x)) : d.indexOf("rgba") > -1 ? x = z.getOpacityFromRGBA(d) : b = z.hexToRgba(z.rgb2hex(d), x), e.opacity && (x = e.opacity), f === "pattern" && (o = this.handlePatternFill({ fillConfig: e.fillConfig, patternFill: o, fillColor: d, fillOpacity: x, defaultColor: b })), m) {
      var w = De(c.fill.gradient.colorStops) || [], y = c.fill.gradient.type;
      h && (w[this.seriesIndex] = this.computeColorStops(a.globals.series[this.seriesIndex], c.plotOptions.line.colors), y = "vertical"), l = this.handleGradientFill({ type: y, fillConfig: e.fillConfig, fillColor: d, fillOpacity: x, colorStops: w, i: this.seriesIndex });
    }
    if (f === "image") {
      var v = c.fill.image.src, S = e.patternID ? e.patternID : "", k = "pattern".concat(a.globals.cuid).concat(e.seriesNumber + 1).concat(S);
      this.patternIDs.indexOf(k) === -1 && (this.clippedImgArea({ opacity: x, image: Array.isArray(v) ? e.seriesNumber < v.length ? v[e.seriesNumber] : v[0] : v, width: e.width ? e.width : void 0, height: e.height ? e.height : void 0, patternUnits: e.patternUnits, patternID: k }), this.patternIDs.push(k)), n = "url(#".concat(k, ")");
    } else n = m ? l : f === "pattern" ? o : b;
    return e.solid && (n = b), n;
  } }, { key: "getFillType", value: function(e) {
    var t = this.w;
    return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var e = this.w, t = e.config, i = this.opts, s = [];
    return e.globals.comboCharts ? e.config.series[this.seriesIndex].type === "line" ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors) : t.chart.type === "line" ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors), i.fillColors !== void 0 && (s = [], Array.isArray(i.fillColors) ? s = i.fillColors.slice() : s.push(i.fillColors)), s;
  } }, { key: "handlePatternFill", value: function(e) {
    var t = e.fillConfig, i = e.patternFill, s = e.fillColor, a = e.fillOpacity, n = e.defaultColor, o = this.w.config.fill;
    t && (o = t);
    var l = this.opts, c = new B(this.ctx), h = Array.isArray(o.pattern.strokeWidth) ? o.pattern.strokeWidth[this.seriesIndex] : o.pattern.strokeWidth, d = s;
    return Array.isArray(o.pattern.style) ? i = o.pattern.style[l.seriesNumber] !== void 0 ? c.drawPattern(o.pattern.style[l.seriesNumber], o.pattern.width, o.pattern.height, d, h, a) : n : i = c.drawPattern(o.pattern.style, o.pattern.width, o.pattern.height, d, h, a), i;
  } }, { key: "handleGradientFill", value: function(e) {
    var t = e.type, i = e.fillColor, s = e.fillOpacity, a = e.fillConfig, n = e.colorStops, o = e.i, l = this.w.config.fill;
    a && (l = q(q({}, l), a));
    var c = this.opts, h = new B(this.ctx), d = new z();
    t = t || l.gradient.type;
    var u, g = i, p = l.gradient.opacityFrom === void 0 ? s : Array.isArray(l.gradient.opacityFrom) ? l.gradient.opacityFrom[o] : l.gradient.opacityFrom;
    g.indexOf("rgba") > -1 && (p = z.getOpacityFromRGBA(g));
    var f = l.gradient.opacityTo === void 0 ? s : Array.isArray(l.gradient.opacityTo) ? l.gradient.opacityTo[o] : l.gradient.opacityTo;
    if (l.gradient.gradientToColors === void 0 || l.gradient.gradientToColors.length === 0) u = l.gradient.shade === "dark" ? d.shadeColor(-1 * parseFloat(l.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? z.rgb2hex(i) : i) : d.shadeColor(parseFloat(l.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? z.rgb2hex(i) : i);
    else if (l.gradient.gradientToColors[c.seriesNumber]) {
      var x = l.gradient.gradientToColors[c.seriesNumber];
      u = x, x.indexOf("rgba") > -1 && (f = z.getOpacityFromRGBA(x));
    } else u = i;
    if (l.gradient.gradientFrom && (g = l.gradient.gradientFrom), l.gradient.gradientTo && (u = l.gradient.gradientTo), l.gradient.inverseColors) {
      var m = g;
      g = u, u = m;
    }
    return g.indexOf("rgb") > -1 && (g = z.rgb2hex(g)), u.indexOf("rgb") > -1 && (u = z.rgb2hex(u)), h.drawGradient(t, g, u, p, f, c.size, l.gradient.stops, n, o);
  } }]), r;
}(), ai = function() {
  function r(e, t) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "setGlobalMarkerSize", value: function() {
    var e = this.w;
    if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size], e.globals.markers.size.length > 0) {
      if (e.globals.markers.size.length < e.globals.series.length + 1) for (var t = 0; t <= e.globals.series.length; t++) e.globals.markers.size[t] === void 0 && e.globals.markers.size.push(e.globals.markers.size[0]);
    } else e.globals.markers.size = e.config.series.map(function(i) {
      return e.config.markers.size;
    });
  } }, { key: "plotChartMarkers", value: function(e) {
    var t = e.pointsPos, i = e.seriesIndex, s = e.j, a = e.pSize, n = e.alwaysDrawMarker, o = n !== void 0 && n, l = e.isVirtualPoint, c = l !== void 0 && l, h = this.w, d = i, u = t, g = null, p = new B(this.ctx), f = h.config.markers.discrete && h.config.markers.discrete.length;
    if (Array.isArray(u.x)) for (var x = 0; x < u.x.length; x++) {
      var m = void 0, b = s, w = !z.isNumber(u.y[x]);
      h.globals.markers.largestSize === 0 && h.globals.hasNullValues && h.globals.series[d][s + 1] !== null && !c && (w = !0), s === 1 && x === 0 && (b = 0), s === 1 && x === 1 && (b = 1);
      var y = "apexcharts-marker";
      if (h.config.chart.type !== "line" && h.config.chart.type !== "area" || h.globals.comboCharts || h.config.tooltip.intersect || (y += " no-pointer-events"), (Array.isArray(h.config.markers.size) ? h.globals.markers.size[i] > 0 : h.config.markers.size > 0) || o || f) {
        w || (y += " w".concat(z.randomId()));
        var v = this.getMarkerConfig({ cssClass: y, seriesIndex: i, dataPointIndex: b });
        h.config.series[d].data[b] && (h.config.series[d].data[b].fillColor && (v.pointFillColor = h.config.series[d].data[b].fillColor), h.config.series[d].data[b].strokeColor && (v.pointStrokeColor = h.config.series[d].data[b].strokeColor)), a !== void 0 && (v.pSize = a), (u.x[x] < -h.globals.markers.largestSize || u.x[x] > h.globals.gridWidth + h.globals.markers.largestSize || u.y[x] < -h.globals.markers.largestSize || u.y[x] > h.globals.gridHeight + h.globals.markers.largestSize) && (v.pSize = 0), !w && ((h.globals.markers.size[i] > 0 || o || f) && !g && (g = p.group({ class: o || f ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h.globals.cuid, ")")), (m = p.drawMarker(u.x[x], u.y[x], v)).attr("rel", b), m.attr("j", b), m.attr("index", i), m.node.setAttribute("default-marker-size", v.pSize), new je(this.ctx).setSelectionFilter(m, i, b), this.addEvents(m), g && g.add(m));
      } else h.globals.pointsArray[i] === void 0 && (h.globals.pointsArray[i] = []), h.globals.pointsArray[i].push([u.x[x], u.y[x]]);
    }
    return g;
  } }, { key: "getMarkerConfig", value: function(e) {
    var t = e.cssClass, i = e.seriesIndex, s = e.dataPointIndex, a = s === void 0 ? null : s, n = e.radius, o = n === void 0 ? null : n, l = e.size, c = l === void 0 ? null : l, h = e.strokeWidth, d = h === void 0 ? null : h, u = this.w, g = this.getMarkerStyle(i), p = c === null ? u.globals.markers.size[i] : c, f = u.config.markers;
    return a !== null && f.discrete.length && f.discrete.map(function(x) {
      x.seriesIndex === i && x.dataPointIndex === a && (g.pointStrokeColor = x.strokeColor, g.pointFillColor = x.fillColor, p = x.size, g.pointShape = x.shape);
    }), { pSize: o === null ? p : o, pRadius: o !== null ? o : f.radius, pointStrokeWidth: d !== null ? d : Array.isArray(f.strokeWidth) ? f.strokeWidth[i] : f.strokeWidth, pointStrokeColor: g.pointStrokeColor, pointFillColor: g.pointFillColor, shape: g.pointShape || (Array.isArray(f.shape) ? f.shape[i] : f.shape), class: t, pointStrokeOpacity: Array.isArray(f.strokeOpacity) ? f.strokeOpacity[i] : f.strokeOpacity, pointStrokeDashArray: Array.isArray(f.strokeDashArray) ? f.strokeDashArray[i] : f.strokeDashArray, pointFillOpacity: Array.isArray(f.fillOpacity) ? f.fillOpacity[i] : f.fillOpacity, seriesIndex: i };
  } }, { key: "addEvents", value: function(e) {
    var t = this.w, i = new B(this.ctx);
    e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e)), e.node.addEventListener("click", t.config.markers.onClick), e.node.addEventListener("dblclick", t.config.markers.onDblClick), e.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e), { passive: !0 });
  } }, { key: "getMarkerStyle", value: function(e) {
    var t = this.w, i = t.globals.markers.colors, s = t.config.markers.strokeColor || t.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(s) ? s[e] : s, pointFillColor: Array.isArray(i) ? i[e] : i };
  } }]), r;
}(), So = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return te(r, [{ key: "draw", value: function(e, t, i) {
    var s = this.w, a = new B(this.ctx), n = i.realIndex, o = i.pointsPos, l = i.zRatio, c = i.elParent, h = a.group({ class: "apexcharts-series-markers apexcharts-series-".concat(s.config.chart.type) });
    if (h.attr("clip-path", "url(#gridRectMarkerMask".concat(s.globals.cuid, ")")), Array.isArray(o.x)) for (var d = 0; d < o.x.length; d++) {
      var u = t + 1, g = !0;
      t === 0 && d === 0 && (u = 0), t === 0 && d === 1 && (u = 1);
      var p = s.globals.markers.size[n];
      if (l !== 1 / 0) {
        var f = s.config.plotOptions.bubble;
        p = s.globals.seriesZ[n][u], f.zScaling && (p /= l), f.minBubbleRadius && p < f.minBubbleRadius && (p = f.minBubbleRadius), f.maxBubbleRadius && p > f.maxBubbleRadius && (p = f.maxBubbleRadius);
      }
      var x = o.x[d], m = o.y[d];
      if (p = p || 0, m !== null && s.globals.series[n][u] !== void 0 || (g = !1), g) {
        var b = this.drawPoint(x, m, p, n, u, t);
        h.add(b);
      }
      c.add(h);
    }
  } }, { key: "drawPoint", value: function(e, t, i, s, a, n) {
    var o = this.w, l = s, c = new ti(this.ctx), h = new je(this.ctx), d = new ht(this.ctx), u = new ai(this.ctx), g = new B(this.ctx), p = u.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l, dataPointIndex: a, radius: o.config.chart.type === "bubble" || o.globals.comboCharts && o.config.series[s] && o.config.series[s].type === "bubble" ? i : null }), f = d.fillPath({ seriesNumber: s, dataPointIndex: a, color: p.pointFillColor, patternUnits: "objectBoundingBox", value: o.globals.series[s][n] }), x = g.drawMarker(e, t, p);
    if (o.config.series[l].data[a] && o.config.series[l].data[a].fillColor && (f = o.config.series[l].data[a].fillColor), x.attr({ fill: f }), o.config.chart.dropShadow.enabled) {
      var m = o.config.chart.dropShadow;
      h.dropShadow(x, m, s);
    }
    if (!this.initialAnim || o.globals.dataChanged || o.globals.resized) o.globals.animationEnded = !0;
    else {
      var b = o.config.chart.animations.speed;
      c.animateMarker(x, b, o.globals.easing, function() {
        window.setTimeout(function() {
          c.animationCompleted(x);
        }, 100);
      });
    }
    return x.attr({ rel: a, j: a, index: s, "default-marker-size": p.pSize }), h.setSelectionFilter(x, s, a), u.addEvents(x), x.node.classList.add("apexcharts-marker"), x;
  } }, { key: "centerTextInBubble", value: function(e) {
    var t = this.w;
    return { y: e += parseInt(t.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), r;
}(), Jt = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "dataLabelsCorrection", value: function(e, t, i, s, a, n, o) {
    var l = this.w, c = !1, h = new B(this.ctx).getTextRects(i, o), d = h.width, u = h.height;
    t < 0 && (t = 0), t > l.globals.gridHeight + u && (t = l.globals.gridHeight + u / 2), l.globals.dataLabelsRects[s] === void 0 && (l.globals.dataLabelsRects[s] = []), l.globals.dataLabelsRects[s].push({ x: e, y: t, width: d, height: u });
    var g = l.globals.dataLabelsRects[s].length - 2, p = l.globals.lastDrawnDataLabelsIndexes[s] !== void 0 ? l.globals.lastDrawnDataLabelsIndexes[s][l.globals.lastDrawnDataLabelsIndexes[s].length - 1] : 0;
    if (l.globals.dataLabelsRects[s][g] !== void 0) {
      var f = l.globals.dataLabelsRects[s][p];
      (e > f.x + f.width || t > f.y + f.height || t + u < f.y || e + d < f.x) && (c = !0);
    }
    return (a === 0 || n) && (c = !0), { x: e, y: t, textRects: h, drawnextLabel: c };
  } }, { key: "drawDataLabel", value: function(e) {
    var t = this, i = e.type, s = e.pos, a = e.i, n = e.j, o = e.isRangeStart, l = e.strokeWidth, c = l === void 0 ? 2 : l, h = this.w, d = new B(this.ctx), u = h.config.dataLabels, g = 0, p = 0, f = n, x = null;
    if (h.globals.collapsedSeriesIndices.indexOf(a) !== -1 || !u.enabled || !Array.isArray(s.x)) return x;
    x = d.group({ class: "apexcharts-data-labels" });
    for (var m = 0; m < s.x.length; m++) if (g = s.x[m] + u.offsetX, p = s.y[m] + u.offsetY + c, !isNaN(g)) {
      n === 1 && m === 0 && (f = 0), n === 1 && m === 1 && (f = 1);
      var b = h.globals.series[a][f];
      i === "rangeArea" && (b = o ? h.globals.seriesRangeStart[a][f] : h.globals.seriesRangeEnd[a][f]);
      var w = "", y = function(S) {
        return h.config.dataLabels.formatter(S, { ctx: t.ctx, seriesIndex: a, dataPointIndex: f, w: h });
      };
      h.config.chart.type === "bubble" ? (w = y(b = h.globals.seriesZ[a][f]), p = s.y[m], p = new So(this.ctx).centerTextInBubble(p, a, f).y) : b !== void 0 && (w = y(b));
      var v = h.config.dataLabels.textAnchor;
      h.globals.isSlopeChart && (v = f === 0 ? "end" : f === h.config.series[a].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: g, y: p, text: w, i: a, j: f, parent: x, offsetCorrection: !0, dataLabelsConfig: h.config.dataLabels, textAnchor: v });
    }
    return x;
  } }, { key: "plotDataLabelsText", value: function(e) {
    var t = this.w, i = new B(this.ctx), s = e.x, a = e.y, n = e.i, o = e.j, l = e.text, c = e.textAnchor, h = e.fontSize, d = e.parent, u = e.dataLabelsConfig, g = e.color, p = e.alwaysDrawDataLabel, f = e.offsetCorrection, x = e.className, m = null;
    if (Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(n) < 0) return m;
    var b = { x: s, y: a, drawnextLabel: !0, textRects: null };
    f && (b = this.dataLabelsCorrection(s, a, l, n, o, p, parseInt(u.style.fontSize, 10))), t.globals.zoomed || (s = b.x, a = b.y), b.textRects && (s < -20 - b.textRects.width || s > t.globals.gridWidth + b.textRects.width + 30) && (l = "");
    var w = t.globals.dataLabels.style.colors[n];
    ((t.config.chart.type === "bar" || t.config.chart.type === "rangeBar") && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (w = t.globals.dataLabels.style.colors[o]), typeof w == "function" && (w = w({ series: t.globals.series, seriesIndex: n, dataPointIndex: o, w: t })), g && (w = g);
    var y = u.offsetX, v = u.offsetY;
    if (t.config.chart.type !== "bar" && t.config.chart.type !== "rangeBar" || (y = 0, v = 0), t.globals.isSlopeChart && (o !== 0 && (y = -2 * u.offsetX + 5), o !== 0 && o !== t.config.series[n].data.length - 1 && (y = 0)), b.drawnextLabel) {
      if ((m = i.drawText({ width: 100, height: parseInt(u.style.fontSize, 10), x: s + y, y: a + v, foreColor: w, textAnchor: c || u.textAnchor, text: l, fontSize: h || u.style.fontSize, fontFamily: u.style.fontFamily, fontWeight: u.style.fontWeight || "normal" })).attr({ class: x || "apexcharts-datalabel", cx: s, cy: a }), u.dropShadow.enabled) {
        var S = u.dropShadow;
        new je(this.ctx).dropShadow(m, S);
      }
      d.add(m), t.globals.lastDrawnDataLabelsIndexes[n] === void 0 && (t.globals.lastDrawnDataLabelsIndexes[n] = []), t.globals.lastDrawnDataLabelsIndexes[n].push(o);
    }
    return m;
  } }, { key: "addBackgroundToDataLabel", value: function(e, t) {
    var i = this.w, s = i.config.dataLabels.background, a = s.padding, n = s.padding / 2, o = t.width, l = t.height, c = new B(this.ctx).drawRect(t.x - a, t.y - n / 2, o + 2 * a, l + n, s.borderRadius, i.config.chart.background !== "transparent" && i.config.chart.background ? i.config.chart.background : "#fff", s.opacity, s.borderWidth, s.borderColor);
    return s.dropShadow.enabled && new je(this.ctx).dropShadow(c, s.dropShadow), c;
  } }, { key: "dataLabelsBackground", value: function() {
    var e = this.w;
    if (e.config.chart.type !== "bubble") for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t.length; i++) {
      var s = t[i], a = s.getBBox(), n = null;
      if (a.width && a.height && (n = this.addBackgroundToDataLabel(s, a)), n) {
        s.parentNode.insertBefore(n.node, s);
        var o = e.config.dataLabels.background.backgroundColor || s.getAttribute("fill");
        e.config.chart.animations.enabled && !e.globals.resized && !e.globals.dataChanged ? n.animate().attr({ fill: o }) : n.attr({ fill: o }), s.setAttribute("fill", e.config.dataLabels.background.foreColor);
      }
    }
  } }, { key: "bringForward", value: function() {
    for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), s = 0; s < t.length; s++) i && i.insertBefore(t[s], i.nextSibling);
  } }]), r;
}(), ot = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  return te(r, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  } }, { key: "getSeriesByName", value: function(e) {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(z.escapeString(e), "']"));
  } }, { key: "isSeriesHidden", value: function(e) {
    var t = this.getSeriesByName(e), i = parseInt(t.getAttribute("data:realIndex"), 10);
    return { isHidden: t.classList.contains("apexcharts-series-collapsed"), realIndex: i };
  } }, { key: "addCollapsedClassToSeries", value: function(e, t) {
    var i = this.w;
    function s(a) {
      for (var n = 0; n < a.length; n++) a[n].index === t && e.node.classList.add("apexcharts-series-collapsed");
    }
    s(i.globals.collapsedSeries), s(i.globals.ancillaryCollapsedSeries);
  } }, { key: "toggleSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    return this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, t.isHidden), t.isHidden;
  } }, { key: "showSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !0);
  } }, { key: "hideSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !1);
  } }, { key: "resetSeries", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], s = this.w, a = z.clone(s.globals.initialSeries);
    s.globals.previousPaths = [], i ? (s.globals.collapsedSeries = [], s.globals.ancillaryCollapsedSeries = [], s.globals.collapsedSeriesIndices = [], s.globals.ancillaryCollapsedSeriesIndices = []) : a = this.emptyCollapsedSeries(a), s.config.series = a, e && (t && (s.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: "emptyCollapsedSeries", value: function(e) {
    for (var t = this.w, i = 0; i < e.length; i++) t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = []);
    return e;
  } }, { key: "highlightSeries", value: function(e) {
    var t = this.w, i = this.getSeriesByName(e), s = parseInt(i == null ? void 0 : i.getAttribute("data:realIndex"), 10), a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), n = null, o = null, l = null;
    if (t.globals.axisCharts || t.config.chart.type === "radialBar") if (t.globals.axisCharts) {
      n = t.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")), o = t.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"));
      var c = t.globals.seriesYAxisReverseMap[s];
      l = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(c, "']"));
    } else n = t.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']"));
    else n = t.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path"));
    for (var h = 0; h < a.length; h++) a[h].classList.add(this.legendInactiveClass);
    if (n) t.globals.axisCharts || n.parentNode.classList.remove(this.legendInactiveClass), n.classList.remove(this.legendInactiveClass), o !== null && o.classList.remove(this.legendInactiveClass), l !== null && l.classList.remove(this.legendInactiveClass);
    else for (var d = 0; d < a.length; d++) a[d].classList.remove(this.legendInactiveClass);
  } }, { key: "toggleSeriesOnHover", value: function(e, t) {
    var i = this.w;
    t || (t = e.target);
    var s = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
    if (e.type === "mousemove") {
      var a = parseInt(t.getAttribute("rel"), 10) - 1;
      this.highlightSeries(i.globals.seriesNames[a]);
    } else if (e.type === "mouseout") for (var n = 0; n < s.length; n++) s[n].classList.remove(this.legendInactiveClass);
  } }, { key: "highlightRangeInSeries", value: function(e, t) {
    var i = this, s = this.w, a = s.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), n = function(c) {
      for (var h = 0; h < a.length; h++) a[h].classList[c](i.legendInactiveClass);
    };
    if (e.type === "mousemove") {
      var o = parseInt(t.getAttribute("rel"), 10) - 1;
      n("add");
      var l = s.config.plotOptions.heatmap.colorScale.ranges;
      (function(c, h) {
        for (var d = 0; d < a.length; d++) {
          var u = Number(a[d].getAttribute("val"));
          u >= c.from && (u < c.to || c.to === h && u === h) && a[d].classList.remove(i.legendInactiveClass);
        }
      })(l[o], l.reduce(function(c, h) {
        return Math.max(c, h.to);
      }, 0));
    } else e.type === "mouseout" && n("remove");
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = this.w, s = 0;
    if (i.config.series.length > 1) {
      for (var a = i.config.series.map(function(o, l) {
        return o.data && o.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(l) === -1 && (!i.globals.comboCharts || t.length === 0 || t.length && t.indexOf(i.config.series[l].type) > -1) ? l : -1;
      }), n = e === "asc" ? 0 : a.length - 1; e === "asc" ? n < a.length : n >= 0; e === "asc" ? n++ : n--) if (a[n] !== -1) {
        s = a[n];
        break;
      }
    }
    return s;
  } }, { key: "getBarSeriesIndices", value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map(function(e, t) {
      return e.type === "bar" || e.type === "column" ? t : -1;
    }).filter(function(e) {
      return e !== -1;
    }) : this.w.config.series.map(function(e, t) {
      return t;
    });
  } }, { key: "getPreviousPaths", value: function() {
    var e = this.w;
    function t(n, o, l) {
      for (var c = n[o].childNodes, h = { type: l, paths: [], realIndex: n[o].getAttribute("data:realIndex") }, d = 0; d < c.length; d++) if (c[d].hasAttribute("pathTo")) {
        var u = c[d].getAttribute("pathTo");
        h.paths.push({ d: u });
      }
      e.globals.previousPaths.push(h);
    }
    e.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(n) {
      for (var o, l = (o = n, e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(o, "-series .apexcharts-series"))), c = 0; c < l.length; c++) t(l, c, n);
    });
    var i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series"));
    if (i.length > 0) for (var s = function(n) {
      for (var o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(n, "'] rect")), l = [], c = function(d) {
        var u = function(p) {
          return o[d].getAttribute(p);
        }, g = { x: parseFloat(u("x")), y: parseFloat(u("y")), width: parseFloat(u("width")), height: parseFloat(u("height")) };
        l.push({ rect: g, color: o[d].getAttribute("color") });
      }, h = 0; h < o.length; h++) c(h);
      e.globals.previousPaths.push(l);
    }, a = 0; a < i.length; a++) s(a);
    e.globals.axisCharts || (e.globals.previousPaths = e.globals.series);
  } }, { key: "clearPreviousPaths", value: function() {
    var e = this.w;
    e.globals.previousPaths = [], e.globals.allSeriesCollapsed = !1;
  } }, { key: "handleNoData", value: function() {
    var e = this.w, t = e.config.noData, i = new B(this.ctx), s = e.globals.svgWidth / 2, a = e.globals.svgHeight / 2, n = "middle";
    if (e.globals.noData = !0, e.globals.animationEnded = !0, t.align === "left" ? (s = 10, n = "start") : t.align === "right" && (s = e.globals.svgWidth - 10, n = "end"), t.verticalAlign === "top" ? a = 50 : t.verticalAlign === "bottom" && (a = e.globals.svgHeight - 50), s += t.offsetX, a = a + parseInt(t.style.fontSize, 10) + 2 + t.offsetY, t.text !== void 0 && t.text !== "") {
      var o = i.drawText({ x: s, y: a, text: t.text, textAnchor: n, fontSize: t.style.fontSize, fontFamily: t.style.fontFamily, foreColor: t.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      e.globals.dom.Paper.add(o);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(e) {
    for (var t = this.w, i = 0; i < e.length; i++) if (e[i].length === 0) for (var s = 0; s < e[t.globals.maxValsInArrayIndex].length; s++) e[i].push(0);
    return e;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var e = !0, t = this.w, i = this.filteredSeriesX(), s = 0; s < i.length - 1; s++) if (i[s][0] !== i[s + 1][0]) {
      e = !1;
      break;
    }
    return t.globals.allSeriesHasEqualX = e, e;
  } }, { key: "filteredSeriesX", value: function() {
    var e = this.w.globals.seriesX.map(function(t) {
      return t.length > 0 ? t : [];
    });
    return e;
  } }]), r;
}(), Zr = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new ze(this.ctx);
  }
  return te(r, [{ key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var e = this.w.config.series.slice(), t = new ot(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), e[this.activeSeriesIndex].data !== void 0 && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].x !== void 0 && e[this.activeSeriesIndex].data[0] !== null) return !0;
  } }, { key: "isFormat2DArray", value: function() {
    var e = this.w.config.series.slice(), t = new ot(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), e[this.activeSeriesIndex].data !== void 0 && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== void 0 && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].constructor === Array) return !0;
  } }, { key: "handleFormat2DArray", value: function(e, t) {
    for (var i = this.w.config, s = this.w.globals, a = i.chart.type === "boxPlot" || i.series[t].type === "boxPlot", n = 0; n < e[t].data.length; n++) if (e[t].data[n][1] !== void 0 && (Array.isArray(e[t].data[n][1]) && e[t].data[n][1].length === 4 && !a ? this.twoDSeries.push(z.parseNumber(e[t].data[n][1][3])) : e[t].data[n].length >= 5 ? this.twoDSeries.push(z.parseNumber(e[t].data[n][4])) : this.twoDSeries.push(z.parseNumber(e[t].data[n][1])), s.dataFormatXNumeric = !0), i.xaxis.type === "datetime") {
      var o = new Date(e[t].data[n][0]);
      o = new Date(o).getTime(), this.twoDSeriesX.push(o);
    } else this.twoDSeriesX.push(e[t].data[n][0]);
    for (var l = 0; l < e[t].data.length; l++) e[t].data[l][2] !== void 0 && (this.threeDSeries.push(e[t].data[l][2]), s.isDataXYZ = !0);
  } }, { key: "handleFormatXY", value: function(e, t) {
    var i = this.w.config, s = this.w.globals, a = new Ye(this.ctx), n = t;
    s.collapsedSeriesIndices.indexOf(t) > -1 && (n = this.activeSeriesIndex);
    for (var o = 0; o < e[t].data.length; o++) e[t].data[o].y !== void 0 && (Array.isArray(e[t].data[o].y) ? this.twoDSeries.push(z.parseNumber(e[t].data[o].y[e[t].data[o].y.length - 1])) : this.twoDSeries.push(z.parseNumber(e[t].data[o].y))), e[t].data[o].goals !== void 0 && Array.isArray(e[t].data[o].goals) ? (this.seriesGoals[t] === void 0 && (this.seriesGoals[t] = []), this.seriesGoals[t].push(e[t].data[o].goals)) : (this.seriesGoals[t] === void 0 && (this.seriesGoals[t] = []), this.seriesGoals[t].push(null));
    for (var l = 0; l < e[n].data.length; l++) {
      var c = typeof e[n].data[l].x == "string", h = Array.isArray(e[n].data[l].x), d = !h && !!a.isValidDate(e[n].data[l].x);
      if (c || d) if (c || i.xaxis.convertedCatToNumeric) {
        var u = s.isBarHorizontal && s.isRangeData;
        i.xaxis.type !== "datetime" || u ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[n].data[l].x), isNaN(e[n].data[l].x) || this.w.config.xaxis.type === "category" || typeof e[n].data[l].x == "string" || (s.isXNumeric = !0)) : this.twoDSeriesX.push(a.parseDate(e[n].data[l].x));
      } else i.xaxis.type === "datetime" ? this.twoDSeriesX.push(a.parseDate(e[n].data[l].x.toString())) : (s.dataFormatXNumeric = !0, s.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(e[n].data[l].x)));
      else h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[n].data[l].x)) : (s.isXNumeric = !0, s.dataFormatXNumeric = !0, this.twoDSeriesX.push(e[n].data[l].x));
    }
    if (e[t].data[0] && e[t].data[0].z !== void 0) {
      for (var g = 0; g < e[t].data.length; g++) this.threeDSeries.push(e[t].data[g].z);
      s.isDataXYZ = !0;
    }
  } }, { key: "handleRangeData", value: function(e, t) {
    var i = this.w.globals, s = {};
    return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", e, t)), i.seriesRangeStart[t] = s.start === void 0 ? [] : s.start, i.seriesRangeEnd[t] = s.end === void 0 ? [] : s.end, i.seriesRange[t] = s.rangeUniques, i.seriesRange.forEach(function(a, n) {
      a && a.forEach(function(o, l) {
        o.y.forEach(function(c, h) {
          for (var d = 0; d < o.y.length; d++) if (h !== d) {
            var u = c.y1, g = c.y2, p = o.y[d].y1;
            u <= o.y[d].y2 && p <= g && (o.overlaps.indexOf(c.rangeName) < 0 && o.overlaps.push(c.rangeName), o.overlaps.indexOf(o.y[d].rangeName) < 0 && o.overlaps.push(o.y[d].rangeName));
          }
        });
      });
    }), s;
  } }, { key: "handleCandleStickBoxData", value: function(e, t) {
    var i = this.w.globals, s = {};
    return this.isFormat2DArray() ? s = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleCandleStickBoxDataFormat("xy", e, t)), i.seriesCandleO[t] = s.o, i.seriesCandleH[t] = s.h, i.seriesCandleM[t] = s.m, i.seriesCandleL[t] = s.l, i.seriesCandleC[t] = s.c, s;
  } }, { key: "handleRangeDataFormat", value: function(e, t, i) {
    var s = [], a = [], n = t[i].data.filter(function(h, d, u) {
      return d === u.findIndex(function(g) {
        return g.x === h.x;
      });
    }).map(function(h, d) {
      return { x: h.x, overlaps: [], y: [] };
    });
    if (e === "array") for (var o = 0; o < t[i].data.length; o++) Array.isArray(t[i].data[o]) ? (s.push(t[i].data[o][1][0]), a.push(t[i].data[o][1][1])) : (s.push(t[i].data[o]), a.push(t[i].data[o]));
    else if (e === "xy") for (var l = function(h) {
      var d = Array.isArray(t[i].data[h].y), u = z.randomId(), g = t[i].data[h].x, p = { y1: d ? t[i].data[h].y[0] : t[i].data[h].y, y2: d ? t[i].data[h].y[1] : t[i].data[h].y, rangeName: u };
      t[i].data[h].rangeName = u;
      var f = n.findIndex(function(x) {
        return x.x === g;
      });
      n[f].y.push(p), s.push(p.y1), a.push(p.y2);
    }, c = 0; c < t[i].data.length; c++) l(c);
    return { start: s, end: a, rangeUniques: n };
  } }, { key: "handleCandleStickBoxDataFormat", value: function(e, t, i) {
    var s = this.w, a = s.config.chart.type === "boxPlot" || s.config.series[i].type === "boxPlot", n = [], o = [], l = [], c = [], h = [];
    if (e === "array") if (a && t[i].data[0].length === 6 || !a && t[i].data[0].length === 5) for (var d = 0; d < t[i].data.length; d++) n.push(t[i].data[d][1]), o.push(t[i].data[d][2]), a ? (l.push(t[i].data[d][3]), c.push(t[i].data[d][4]), h.push(t[i].data[d][5])) : (c.push(t[i].data[d][3]), h.push(t[i].data[d][4]));
    else for (var u = 0; u < t[i].data.length; u++) Array.isArray(t[i].data[u][1]) && (n.push(t[i].data[u][1][0]), o.push(t[i].data[u][1][1]), a ? (l.push(t[i].data[u][1][2]), c.push(t[i].data[u][1][3]), h.push(t[i].data[u][1][4])) : (c.push(t[i].data[u][1][2]), h.push(t[i].data[u][1][3])));
    else if (e === "xy") for (var g = 0; g < t[i].data.length; g++) Array.isArray(t[i].data[g].y) && (n.push(t[i].data[g].y[0]), o.push(t[i].data[g].y[1]), a ? (l.push(t[i].data[g].y[2]), c.push(t[i].data[g].y[3]), h.push(t[i].data[g].y[4])) : (c.push(t[i].data[g].y[2]), h.push(t[i].data[g].y[3])));
    return { o: n, h: o, m: l, l: c, c: h };
  } }, { key: "parseDataAxisCharts", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, s = this.w.config, a = this.w.globals, n = new Ye(i), o = s.labels.length > 0 ? s.labels.slice() : s.xaxis.categories.slice();
    a.isRangeBar = s.chart.type === "rangeBar" && a.isBarHorizontal, a.hasXaxisGroups = s.xaxis.type === "category" && s.xaxis.group.groups.length > 0, a.hasXaxisGroups && (a.groups = s.xaxis.group.groups), e.forEach(function(g, p) {
      g.name !== void 0 ? a.seriesNames.push(g.name) : a.seriesNames.push("series-" + parseInt(p + 1, 10));
    }), this.coreUtils.setSeriesYAxisMappings();
    var l = [], c = De(new Set(s.series.map(function(g) {
      return g.group;
    })));
    s.series.forEach(function(g, p) {
      var f = c.indexOf(g.group);
      l[f] || (l[f] = []), l[f].push(a.seriesNames[p]);
    }), a.seriesGroups = l;
    for (var h = function() {
      for (var g = 0; g < o.length; g++) if (typeof o[g] == "string") {
        if (!n.isValidDate(o[g])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
        t.twoDSeriesX.push(n.parseDate(o[g]));
      } else t.twoDSeriesX.push(o[g]);
    }, d = 0; d < e.length; d++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], e[d].data === void 0) return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if (s.chart.type !== "rangeBar" && s.chart.type !== "rangeArea" && e[d].type !== "rangeBar" && e[d].type !== "rangeArea" || (a.isRangeData = !0, this.handleRangeData(e, d)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(e, d) : this.isFormatXY() && this.handleFormatXY(e, d), s.chart.type !== "candlestick" && e[d].type !== "candlestick" && s.chart.type !== "boxPlot" && e[d].type !== "boxPlot" || this.handleCandleStickBoxData(e, d), a.series.push(this.twoDSeries), a.labels.push(this.twoDSeriesX), a.seriesX.push(this.twoDSeriesX), a.seriesGoals = this.seriesGoals, d !== this.activeSeriesIndex || this.fallbackToCategory || (a.isXNumeric = !0);
      else {
        s.xaxis.type === "datetime" ? (a.isXNumeric = !0, h(), a.seriesX.push(this.twoDSeriesX)) : s.xaxis.type === "numeric" && (a.isXNumeric = !0, o.length > 0 && (this.twoDSeriesX = o, a.seriesX.push(this.twoDSeriesX))), a.labels.push(this.twoDSeriesX);
        var u = e[d].data.map(function(g) {
          return z.parseNumber(g);
        });
        a.series.push(u);
      }
      a.seriesZ.push(this.threeDSeries), e[d].color !== void 0 ? a.seriesColors.push(e[d].color) : a.seriesColors.push(void 0);
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(e) {
    var t = this.w.globals, i = this.w.config;
    t.series = e.slice(), t.seriesNames = i.labels.slice();
    for (var s = 0; s < t.series.length; s++) t.seriesNames[s] === void 0 && t.seriesNames.push("series-" + (s + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(e) {
    var t = this.w.config, i = this.w.globals;
    t.xaxis.categories.length > 0 ? i.labels = t.xaxis.categories : t.labels.length > 0 ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(s) {
      s.forEach(function(a) {
        i.labels.indexOf(a.x) < 0 && a.x && i.labels.push(a.x);
      });
    }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), t.xaxis.convertedCatToNumeric && (new Ci(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]), this._generateExternalLabels(e))) : this._generateExternalLabels(e);
  } }, { key: "_generateExternalLabels", value: function(e) {
    var t = this.w.globals, i = this.w.config, s = [];
    if (t.axisCharts) {
      if (t.series.length > 0) if (this.isFormatXY()) for (var a = i.series.map(function(d, u) {
        return d.data.filter(function(g, p, f) {
          return f.findIndex(function(x) {
            return x.x === g.x;
          }) === p;
        });
      }), n = a.reduce(function(d, u, g, p) {
        return p[d].length > u.length ? d : g;
      }, 0), o = 0; o < a[n].length; o++) s.push(o + 1);
      else for (var l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) s.push(l + 1);
      t.seriesX = [];
      for (var c = 0; c < e.length; c++) t.seriesX.push(s);
      this.w.globals.isBarHorizontal || (t.isXNumeric = !0);
    }
    if (s.length === 0) {
      s = t.axisCharts ? [] : t.series.map(function(d, u) {
        return u + 1;
      });
      for (var h = 0; h < e.length; h++) t.seriesX.push(s);
    }
    t.labels = s, i.xaxis.convertedCatToNumeric && (t.categoryLabels = s.map(function(d) {
      return i.xaxis.labels.formatter(d);
    })), t.noLabelsProvided = !0;
  } }, { key: "parseData", value: function(e) {
    var t = this.w, i = t.config, s = t.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), s.axisCharts ? (this.parseDataAxisCharts(e), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e), i.chart.stacked) {
      var a = new ot(this.ctx);
      s.series = a.setNullSeriesToZeroValues(s.series);
    }
    this.coreUtils.getSeriesTotals(), s.axisCharts && (s.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), s.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), s.dataFormatXNumeric || s.isXNumeric && (i.xaxis.type !== "numeric" || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(e);
    for (var n = this.coreUtils.getCategoryLabels(s.labels), o = 0; o < n.length; o++) if (Array.isArray(n[o])) {
      s.isMultiLineX = !0;
      break;
    }
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var e = this.w, t = [];
    e.globals.seriesYAxisMap.forEach(function(i, s) {
      var a = 0;
      i.forEach(function(n) {
        e.globals.collapsedSeriesIndices.indexOf(n) !== -1 && a++;
      }), a > 0 && a == i.length && t.push(s);
    }), e.globals.ignoreYAxisIndexes = t.map(function(i) {
      return i;
    });
  } }]), r;
}(), mi = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "svgStringToNode", value: function(e) {
    return new DOMParser().parseFromString(e, "image/svg+xml").documentElement;
  } }, { key: "scaleSvgNode", value: function(e, t) {
    var i = parseFloat(e.getAttributeNS(null, "width")), s = parseFloat(e.getAttributeNS(null, "height"));
    e.setAttributeNS(null, "width", i * t), e.setAttributeNS(null, "height", s * t), e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + s);
  } }, { key: "getSvgString", value: function(e) {
    var t = this;
    return new Promise(function(i) {
      var s = t.w, a = e || s.config.chart.toolbar.export.scale || s.config.chart.toolbar.export.width / s.globals.svgWidth;
      a || (a = 1);
      var n = s.globals.svgWidth * a, o = s.globals.svgHeight * a, l = s.globals.dom.elWrap.cloneNode(!0);
      l.style.width = n + "px", l.style.height = o + "px";
      var c = new XMLSerializer().serializeToString(l), h = `
        <svg xmlns="http://www.w3.org/2000/svg"
          version="1.1"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          class="apexcharts-svg"
          xmlns:data="ApexChartsNS"
          transform="translate(0, 0)"
          width="`.concat(s.globals.svgWidth, 'px" height="').concat(s.globals.svgHeight, `px">
          <foreignObject width="100%" height="100%">
            <div xmlns="http://www.w3.org/1999/xhtml" style="width:`).concat(n, "px; height:").concat(o, `px;">
            <style type="text/css">
              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {
                display: none;
              }
            </style>
              `).concat(c, `
            </div>
          </foreignObject>
        </svg>
      `), d = t.svgStringToNode(h);
      a !== 1 && t.scaleSvgNode(d, a), t.convertImagesToBase64(d).then(function() {
        h = new XMLSerializer().serializeToString(d), i(h.replace(/&nbsp;/g, "&#160;"));
      });
    });
  } }, { key: "convertImagesToBase64", value: function(e) {
    var t = this, i = e.getElementsByTagName("image"), s = Array.from(i).map(function(a) {
      var n = a.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      return n && !n.startsWith("data:") ? t.getBase64FromUrl(n).then(function(o) {
        a.setAttributeNS("http://www.w3.org/1999/xlink", "href", o);
      }).catch(function(o) {
        console.error("Error converting image to base64:", o);
      }) : Promise.resolve();
    });
    return Promise.all(s);
  } }, { key: "getBase64FromUrl", value: function(e) {
    return new Promise(function(t, i) {
      var s = new Image();
      s.crossOrigin = "Anonymous", s.onload = function() {
        var a = document.createElement("canvas");
        a.width = s.width, a.height = s.height, a.getContext("2d").drawImage(s, 0, 0), t(a.toDataURL());
      }, s.onerror = i, s.src = e;
    });
  } }, { key: "svgUrl", value: function() {
    var e = this;
    return new Promise(function(t) {
      e.getSvgString().then(function(i) {
        var s = new Blob([i], { type: "image/svg+xml;charset=utf-8" });
        t(URL.createObjectURL(s));
      });
    });
  } }, { key: "dataURI", value: function(e) {
    var t = this;
    return new Promise(function(i) {
      var s = t.w, a = e ? e.scale || e.width / s.globals.svgWidth : 1, n = document.createElement("canvas");
      n.width = s.globals.svgWidth * a, n.height = parseInt(s.globals.dom.elWrap.style.height, 10) * a;
      var o = s.config.chart.background !== "transparent" && s.config.chart.background ? s.config.chart.background : "#fff", l = n.getContext("2d");
      l.fillStyle = o, l.fillRect(0, 0, n.width * a, n.height * a), t.getSvgString(a).then(function(c) {
        var h = "data:image/svg+xml," + encodeURIComponent(c), d = new Image();
        d.crossOrigin = "anonymous", d.onload = function() {
          if (l.drawImage(d, 0, 0), n.msToBlob) {
            var u = n.msToBlob();
            i({ blob: u });
          } else {
            var g = n.toDataURL("image/png");
            i({ imgURI: g });
          }
        }, d.src = h;
      });
    });
  } }, { key: "exportToSVG", value: function() {
    var e = this;
    this.svgUrl().then(function(t) {
      e.triggerDownload(t, e.w.config.chart.toolbar.export.svg.filename, ".svg");
    });
  } }, { key: "exportToPng", value: function() {
    var e = this, t = this.w.config.chart.toolbar.export.scale, i = this.w.config.chart.toolbar.export.width, s = t ? { scale: t } : i ? { width: i } : void 0;
    this.dataURI(s).then(function(a) {
      var n = a.imgURI, o = a.blob;
      o ? navigator.msSaveOrOpenBlob(o, e.w.globals.chartID + ".png") : e.triggerDownload(n, e.w.config.chart.toolbar.export.png.filename, ".png");
    });
  } }, { key: "exportToCSV", value: function(e) {
    var t = this, i = e.series, s = e.fileName, a = e.columnDelimiter, n = a === void 0 ? "," : a, o = e.lineDelimiter, l = o === void 0 ? `
` : o, c = this.w;
    i || (i = c.config.series);
    var h = [], d = [], u = "", g = c.globals.series.map(function(v, S) {
      return c.globals.collapsedSeriesIndices.indexOf(S) === -1 ? v : [];
    }), p = function(v) {
      return typeof c.config.chart.toolbar.export.csv.categoryFormatter == "function" ? c.config.chart.toolbar.export.csv.categoryFormatter(v) : c.config.xaxis.type === "datetime" && String(v).length >= 10 ? new Date(v).toDateString() : z.isNumber(v) ? v : v.split(n).join("");
    }, f = function(v) {
      return typeof c.config.chart.toolbar.export.csv.valueFormatter == "function" ? c.config.chart.toolbar.export.csv.valueFormatter(v) : v;
    }, x = Math.max.apply(Math, De(i.map(function(v) {
      return v.data ? v.data.length : 0;
    }))), m = new Zr(this.ctx), b = new Pt(this.ctx), w = function(v) {
      var S = "";
      if (c.globals.axisCharts) {
        if (c.config.xaxis.type === "category" || c.config.xaxis.convertedCatToNumeric) if (c.globals.isBarHorizontal) {
          var k = c.globals.yLabelFormatters[0], C = new ot(t.ctx).getActiveConfigSeriesIndex();
          S = k(c.globals.labels[v], { seriesIndex: C, dataPointIndex: v, w: c });
        } else S = b.getLabel(c.globals.labels, c.globals.timescaleLabels, 0, v).text;
        c.config.xaxis.type === "datetime" && (c.config.xaxis.categories.length ? S = c.config.xaxis.categories[v] : c.config.labels.length && (S = c.config.labels[v]));
      } else S = c.config.labels[v];
      return S === null ? "nullvalue" : (Array.isArray(S) && (S = S.join(" ")), z.isNumber(S) ? S : S.split(n).join(""));
    }, y = function(v, S) {
      if (h.length && S === 0 && d.push(h.join(n)), v.data) {
        v.data = v.data.length && v.data || De(Array(x)).map(function() {
          return "";
        });
        for (var k = 0; k < v.data.length; k++) {
          h = [];
          var C = w(k);
          if (C !== "nullvalue") {
            if (C || (m.isFormatXY() ? C = i[S].data[k].x : m.isFormat2DArray() && (C = i[S].data[k] ? i[S].data[k][0] : "")), S === 0) {
              h.push(p(C));
              for (var R = 0; R < c.globals.series.length; R++) {
                var P, A = m.isFormatXY() ? (P = i[R].data[k]) === null || P === void 0 ? void 0 : P.y : g[R][k];
                h.push(f(A));
              }
            }
            (c.config.chart.type === "candlestick" || v.type && v.type === "candlestick") && (h.pop(), h.push(c.globals.seriesCandleO[S][k]), h.push(c.globals.seriesCandleH[S][k]), h.push(c.globals.seriesCandleL[S][k]), h.push(c.globals.seriesCandleC[S][k])), (c.config.chart.type === "boxPlot" || v.type && v.type === "boxPlot") && (h.pop(), h.push(c.globals.seriesCandleO[S][k]), h.push(c.globals.seriesCandleH[S][k]), h.push(c.globals.seriesCandleM[S][k]), h.push(c.globals.seriesCandleL[S][k]), h.push(c.globals.seriesCandleC[S][k])), c.config.chart.type === "rangeBar" && (h.pop(), h.push(c.globals.seriesRangeStart[S][k]), h.push(c.globals.seriesRangeEnd[S][k])), h.length && d.push(h.join(n));
          }
        }
      }
    };
    h.push(c.config.chart.toolbar.export.csv.headerCategory), c.config.chart.type === "boxPlot" ? (h.push("minimum"), h.push("q1"), h.push("median"), h.push("q3"), h.push("maximum")) : c.config.chart.type === "candlestick" ? (h.push("open"), h.push("high"), h.push("low"), h.push("close")) : c.config.chart.type === "rangeBar" ? (h.push("minimum"), h.push("maximum")) : i.map(function(v, S) {
      var k = (v.name ? v.name : "series-".concat(S)) + "";
      c.globals.axisCharts && h.push(k.split(n).join("") ? k.split(n).join("") : "series-".concat(S));
    }), c.globals.axisCharts || (h.push(c.config.chart.toolbar.export.csv.headerValue), d.push(h.join(n))), c.globals.allSeriesHasEqualX || !c.globals.axisCharts || c.config.xaxis.categories.length || c.config.labels.length ? i.map(function(v, S) {
      c.globals.axisCharts ? y(v, S) : ((h = []).push(p(c.globals.labels[S])), h.push(f(g[S])), d.push(h.join(n)));
    }) : function() {
      var v = /* @__PURE__ */ new Set(), S = {};
      i.forEach(function(k, C) {
        k == null || k.data.forEach(function(R) {
          var P, A;
          if (m.isFormatXY()) P = R.x, A = R.y;
          else {
            if (!m.isFormat2DArray()) return;
            P = R[0], A = R[1];
          }
          S[P] || (S[P] = Array(i.length).fill("")), S[P][C] = f(A), v.add(P);
        });
      }), h.length && d.push(h.join(n)), Array.from(v).sort().forEach(function(k) {
        d.push([p(k), S[k].join(n)]);
      });
    }(), u += d.join(l), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + u), s || c.config.chart.toolbar.export.csv.filename, ".csv");
  } }, { key: "triggerDownload", value: function(e, t, i) {
    var s = document.createElement("a");
    s.href = e, s.download = (t || this.w.globals.chartID) + i, document.body.appendChild(s), s.click(), document.body.removeChild(s);
  } }]), r;
}(), Mi = function() {
  function r(e, t) {
    ee(this, r), this.ctx = e, this.elgrid = t, this.w = e.w;
    var i = this.w;
    this.axesUtils = new Pt(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
  }
  return te(r, [{ key: "drawXaxis", value: function() {
    var e = this.w, t = new B(this.ctx), i = t.group({ class: "apexcharts-xaxis", transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")") }), s = t.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")") });
    i.add(s);
    for (var a = [], n = 0; n < this.xaxisLabels.length; n++) a.push(this.xaxisLabels[n]);
    if (this.drawXAxisLabelAndGroup(!0, t, s, a, e.globals.isXNumeric, function(p, f) {
      return f;
    }), e.globals.hasXaxisGroups) {
      var o = e.globals.groups;
      a = [];
      for (var l = 0; l < o.length; l++) a.push(o[l].title);
      var c = {};
      e.config.xaxis.group.style && (c.xaxisFontSize = e.config.xaxis.group.style.fontSize, c.xaxisFontFamily = e.config.xaxis.group.style.fontFamily, c.xaxisForeColors = e.config.xaxis.group.style.colors, c.fontWeight = e.config.xaxis.group.style.fontWeight, c.cssClass = e.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, t, s, a, !1, function(p, f) {
        return o[p].cols * f;
      }, c);
    }
    if (e.config.xaxis.title.text !== void 0) {
      var h = t.group({ class: "apexcharts-xaxis-title" }), d = t.drawText({ x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (e.config.xaxis.position === "bottom" ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY, text: e.config.xaxis.title.text, textAnchor: "middle", fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, fontWeight: e.config.xaxis.title.style.fontWeight, foreColor: e.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass });
      h.add(d), i.add(h);
    }
    if (e.config.xaxis.axisBorder.show) {
      var u = e.globals.barPadForNumericAxis, g = t.drawLine(e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - u, this.offY, this.xaxisBorderWidth + u, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(g) : i.add(g);
    }
    return i;
  } }, { key: "drawXAxisLabelAndGroup", value: function(e, t, i, s, a, n) {
    var o, l = this, c = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, h = [], d = [], u = this.w, g = c.xaxisFontSize || this.xaxisFontSize, p = c.xaxisFontFamily || this.xaxisFontFamily, f = c.xaxisForeColors || this.xaxisForeColors, x = c.fontWeight || u.config.xaxis.labels.style.fontWeight, m = c.cssClass || u.config.xaxis.labels.style.cssClass, b = u.globals.padHorizontal, w = s.length, y = u.config.xaxis.type === "category" ? u.globals.dataPoints : w;
    if (y === 0 && w > y && (y = w), a) {
      var v = Math.max(Number(u.config.xaxis.tickAmount) || 1, y > 1 ? y - 1 : y);
      o = u.globals.gridWidth / Math.min(v, w - 1), b = b + n(0, o) / 2 + u.config.xaxis.labels.offsetX;
    } else o = u.globals.gridWidth / y, b = b + n(0, o) + u.config.xaxis.labels.offsetX;
    for (var S = function(C) {
      var R = b - n(C, o) / 2 + u.config.xaxis.labels.offsetX;
      C === 0 && w === 1 && o / 2 === b && y === 1 && (R = u.globals.gridWidth / 2);
      var P = l.axesUtils.getLabel(s, u.globals.timescaleLabels, R, C, h, g, e), A = 28;
      if (u.globals.rotateXLabels && e && (A = 22), u.config.xaxis.title.text && u.config.xaxis.position === "top" && (A += parseFloat(u.config.xaxis.title.style.fontSize) + 2), e || (A = A + parseFloat(g) + (u.globals.xAxisLabelsHeight - u.globals.xAxisGroupLabelsHeight) + (u.globals.rotateXLabels ? 10 : 0)), P = u.config.xaxis.tickAmount !== void 0 && u.config.xaxis.tickAmount !== "dataPoints" && u.config.xaxis.type !== "datetime" ? l.axesUtils.checkLabelBasedOnTickamount(C, P, w) : l.axesUtils.checkForOverflowingLabels(C, P, w, h, d), u.config.xaxis.labels.show) {
        var E = t.drawText({ x: P.x, y: l.offY + u.config.xaxis.labels.offsetY + A - (u.config.xaxis.position === "top" ? u.globals.xAxisHeight + u.config.xaxis.axisTicks.height - 2 : 0), text: P.text, textAnchor: "middle", fontWeight: P.isBold ? 600 : x, fontSize: g, fontFamily: p, foreColor: Array.isArray(f) ? e && u.config.xaxis.convertedCatToNumeric ? f[u.globals.minX + C - 1] : f[C] : f, isPlainText: !1, cssClass: (e ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + m });
        if (i.add(E), E.on("click", function(O) {
          if (typeof u.config.chart.events.xAxisLabelClick == "function") {
            var L = Object.assign({}, u, { labelIndex: C });
            u.config.chart.events.xAxisLabelClick(O, l.ctx, L);
          }
        }), e) {
          var N = document.createElementNS(u.globals.SVGNS, "title");
          N.textContent = Array.isArray(P.text) ? P.text.join(" ") : P.text, E.node.appendChild(N), P.text !== "" && (h.push(P.text), d.push(P));
        }
      }
      C < w - 1 && (b += n(C + 1, o));
    }, k = 0; k <= w - 1; k++) S(k);
  } }, { key: "drawXaxisInversed", value: function(e) {
    var t, i, s = this, a = this.w, n = new B(this.ctx), o = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[e] : 0, l = n.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: e }), c = n.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o + ", 0)" });
    l.add(c);
    var h = [];
    if (a.config.yaxis[e].show) for (var d = 0; d < this.xaxisLabels.length; d++) h.push(this.xaxisLabels[d]);
    t = a.globals.gridHeight / h.length, i = -t / 2.2;
    var u = a.globals.yLabelFormatters[0], g = a.config.yaxis[0].labels;
    if (g.show) for (var p = function(v) {
      var S = h[v] === void 0 ? "" : h[v];
      S = u(S, { seriesIndex: e, dataPointIndex: v, w: a });
      var k = s.axesUtils.getYAxisForeColor(g.style.colors, e), C = 0;
      Array.isArray(S) && (C = S.length / 2 * parseInt(g.style.fontSize, 10));
      var R = g.offsetX - 15, P = "end";
      s.yaxis.opposite && (P = "start"), a.config.yaxis[0].labels.align === "left" ? (R = g.offsetX, P = "start") : a.config.yaxis[0].labels.align === "center" ? (R = g.offsetX, P = "middle") : a.config.yaxis[0].labels.align === "right" && (P = "end");
      var A = n.drawText({ x: R, y: i + t + g.offsetY - C, text: S, textAnchor: P, foreColor: Array.isArray(k) ? k[v] : k, fontSize: g.style.fontSize, fontFamily: g.style.fontFamily, fontWeight: g.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + g.style.cssClass, maxWidth: g.maxWidth });
      c.add(A), A.on("click", function(O) {
        if (typeof a.config.chart.events.xAxisLabelClick == "function") {
          var L = Object.assign({}, a, { labelIndex: v });
          a.config.chart.events.xAxisLabelClick(O, s.ctx, L);
        }
      });
      var E = document.createElementNS(a.globals.SVGNS, "title");
      if (E.textContent = Array.isArray(S) ? S.join(" ") : S, A.node.appendChild(E), a.config.yaxis[e].labels.rotate !== 0) {
        var N = n.rotateAroundCenter(A.node);
        A.node.setAttribute("transform", "rotate(".concat(a.config.yaxis[e].labels.rotate, " 0 ").concat(N.y, ")"));
      }
      i += t;
    }, f = 0; f <= h.length - 1; f++) p(f);
    if (a.config.yaxis[0].title.text !== void 0) {
      var x = n.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o + ", 0)" }), m = n.drawText({ x: a.config.yaxis[0].title.offsetX, y: a.globals.gridHeight / 2 + a.config.yaxis[0].title.offsetY, text: a.config.yaxis[0].title.text, textAnchor: "middle", foreColor: a.config.yaxis[0].title.style.color, fontSize: a.config.yaxis[0].title.style.fontSize, fontWeight: a.config.yaxis[0].title.style.fontWeight, fontFamily: a.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[0].title.style.cssClass });
      x.add(m), l.add(x);
    }
    var b = 0;
    this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (b = a.globals.gridWidth);
    var w = a.config.xaxis.axisBorder;
    if (w.show) {
      var y = n.drawLine(a.globals.padHorizontal + w.offsetX + b, 1 + w.offsetY, a.globals.padHorizontal + w.offsetX + b, a.globals.gridHeight + w.offsetY, w.color, 0);
      this.elgrid && this.elgrid.elGridBorders && a.config.grid.show ? this.elgrid.elGridBorders.add(y) : l.add(y);
    }
    return a.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b, h.length, a.config.yaxis[0].axisBorder, a.config.yaxis[0].axisTicks, 0, t, l), l;
  } }, { key: "drawXaxisTicks", value: function(e, t, i) {
    var s = this.w, a = e;
    if (!(e < 0 || e - 2 > s.globals.gridWidth)) {
      var n = this.offY + s.config.xaxis.axisTicks.offsetY;
      if (t = t + n + s.config.xaxis.axisTicks.height, s.config.xaxis.position === "top" && (t = n - s.config.xaxis.axisTicks.height), s.config.xaxis.axisTicks.show) {
        var o = new B(this.ctx).drawLine(e + s.config.xaxis.axisTicks.offsetX, n + s.config.xaxis.offsetY, a + s.config.xaxis.axisTicks.offsetX, t + s.config.xaxis.offsetY, s.config.xaxis.axisTicks.color);
        i.add(o), o.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var e = this.w, t = [], i = this.xaxisLabels.length, s = e.globals.padHorizontal;
    if (e.globals.timescaleLabels.length > 0) for (var a = 0; a < i; a++) s = this.xaxisLabels[a].position, t.push(s);
    else for (var n = i, o = 0; o < n; o++) {
      var l = n;
      e.globals.isXNumeric && e.config.chart.type !== "bar" && (l -= 1), s += e.globals.gridWidth / l, t.push(s);
    }
    return t;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var e = this.w, t = new B(this.ctx), i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
    if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways) for (var o = 0; o < s.length; o++) {
      var l = t.rotateAroundCenter(s[o]);
      l.y = l.y - 1, l.x = l.x + 1, s[o].setAttribute("transform", "rotate(".concat(e.config.xaxis.labels.rotate, " ").concat(l.x, " ").concat(l.y, ")")), s[o].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
      var c = s[o].childNodes;
      e.config.xaxis.labels.trim && Array.prototype.forEach.call(c, function(g) {
        t.placeTextWithEllipsis(g, g.textContent, e.globals.xAxisLabelsHeight - (e.config.legend.position === "bottom" ? 20 : 10));
      });
    }
    else (function() {
      for (var g = e.globals.gridWidth / (e.globals.labels.length + 1), p = 0; p < s.length; p++) {
        var f = s[p].childNodes;
        e.config.xaxis.labels.trim && e.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(f, function(x) {
          t.placeTextWithEllipsis(x, x.textContent, g);
        });
      }
    })();
    if (a.length > 0) {
      var h = a[a.length - 1].getBBox(), d = a[0].getBBox();
      h.x < -20 && a[a.length - 1].parentNode.removeChild(a[a.length - 1]), d.x + d.width > e.globals.gridWidth && !e.globals.isBarHorizontal && a[0].parentNode.removeChild(a[0]);
      for (var u = 0; u < n.length; u++) t.placeTextWithEllipsis(n[u], n[u].textContent, e.config.yaxis[0].labels.maxWidth - (e.config.yaxis[0].title.text ? 2 * parseFloat(e.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), r;
}(), ko = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.xaxisLabels = t.globals.labels.slice(), this.axesUtils = new Pt(e), this.isRangeBar = t.globals.seriesRange.length && t.globals.isBarHorizontal, t.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t.globals.timescaleLabels.slice());
  }
  return te(r, [{ key: "drawGridArea", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = this.w, i = new B(this.ctx);
    e || (e = i.group({ class: "apexcharts-grid" }));
    var s = i.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent"), a = i.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
    return e.add(a), e.add(s), e;
  } }, { key: "drawGrid", value: function() {
    if (this.w.globals.axisCharts) {
      var e = this.renderGrid();
      return this.drawGridArea(e.el), e;
    }
    return null;
  } }, { key: "createGridMask", value: function() {
    var e = this.w, t = e.globals, i = new B(this.ctx), s = Array.isArray(e.config.stroke.width) ? Math.max.apply(Math, De(e.config.stroke.width)) : e.config.stroke.width, a = function(h) {
      var d = document.createElementNS(t.SVGNS, "clipPath");
      return d.setAttribute("id", h), d;
    };
    t.dom.elGridRectMask = a("gridRectMask".concat(t.cuid)), t.dom.elGridRectBarMask = a("gridRectBarMask".concat(t.cuid)), t.dom.elGridRectMarkerMask = a("gridRectMarkerMask".concat(t.cuid)), t.dom.elForecastMask = a("forecastMask".concat(t.cuid)), t.dom.elNonForecastMask = a("nonForecastMask".concat(t.cuid));
    var n = 0, o = 0;
    (["bar", "rangeBar", "candlestick", "boxPlot"].includes(e.config.chart.type) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (n = Math.max(e.config.grid.padding.left, t.barPadForNumericAxis), o = Math.max(e.config.grid.padding.right, t.barPadForNumericAxis)), t.dom.elGridRect = i.drawRect(-s / 2 - 2, -s / 2 - 2, t.gridWidth + s + 4, t.gridHeight + s + 4, 0, "#fff"), t.dom.elGridRectBar = i.drawRect(-s / 2 - n - 2, -s / 2 - 2, t.gridWidth + s + o + n + 4, t.gridHeight + s + 4, 0, "#fff");
    var l = e.globals.markers.largestSize;
    t.dom.elGridRectMarker = i.drawRect(-l, -l, t.gridWidth + 2 * l, t.gridHeight + 2 * l, 0, "#fff"), t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node), t.dom.elGridRectBarMask.appendChild(t.dom.elGridRectBar.node), t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
    var c = t.dom.baseEl.querySelector("defs");
    c.appendChild(t.dom.elGridRectMask), c.appendChild(t.dom.elGridRectBarMask), c.appendChild(t.dom.elGridRectMarkerMask), c.appendChild(t.dom.elForecastMask), c.appendChild(t.dom.elNonForecastMask);
  } }, { key: "_drawGridLines", value: function(e) {
    var t = e.i, i = e.x1, s = e.y1, a = e.x2, n = e.y2, o = e.xCount, l = e.parent, c = this.w;
    if (!(t === 0 && c.globals.skipFirstTimelinelabel || t === o - 1 && c.globals.skipLastTimelinelabel && !c.config.xaxis.labels.formatter || c.config.chart.type === "radar")) {
      c.config.grid.xaxis.lines.show && this._drawGridLine({ i: t, x1: i, y1: s, x2: a, y2: n, xCount: o, parent: l });
      var h = 0;
      if (c.globals.hasXaxisGroups && c.config.xaxis.tickPlacement === "between") {
        var d = c.globals.groups;
        if (d) {
          for (var u = 0, g = 0; u < t && g < d.length; g++) u += d[g].cols;
          u === t && (h = 0.6 * c.globals.xAxisLabelsHeight);
        }
      }
      new Mi(this.ctx).drawXaxisTicks(i, h, c.globals.dom.elGraphical);
    }
  } }, { key: "_drawGridLine", value: function(e) {
    var t = e.i, i = e.x1, s = e.y1, a = e.x2, n = e.y2, o = e.xCount, l = e.parent, c = this.w, h = l.node.classList.contains("apexcharts-gridlines-horizontal"), d = c.globals.barPadForNumericAxis, u = s === 0 && n === 0 || i === 0 && a === 0 || s === c.globals.gridHeight && n === c.globals.gridHeight || c.globals.isBarHorizontal && (t === 0 || t === o - 1), g = new B(this).drawLine(i - (h ? d : 0), s, a + (h ? d : 0), n, c.config.grid.borderColor, c.config.grid.strokeDashArray);
    g.node.classList.add("apexcharts-gridline"), u && c.config.grid.show ? this.elGridBorders.add(g) : l.add(g);
  } }, { key: "_drawGridBandRect", value: function(e) {
    var t = e.c, i = e.x1, s = e.y1, a = e.x2, n = e.y2, o = e.type, l = this.w, c = new B(this.ctx), h = l.globals.barPadForNumericAxis, d = l.config.grid[o].colors[t], u = c.drawRect(i - (o === "row" ? h : 0), s, a + (o === "row" ? 2 * h : 0), n, 0, d, l.config.grid[o].opacity);
    this.elg.add(u), u.attr("clip-path", "url(#gridRectMask".concat(l.globals.cuid, ")")), u.node.classList.add("apexcharts-grid-".concat(o));
  } }, { key: "_drawXYLines", value: function(e) {
    var t = this, i = e.xCount, s = e.tickAmount, a = this.w;
    if (a.config.grid.xaxis.lines.show || a.config.xaxis.axisTicks.show) {
      var n, o = a.globals.padHorizontal, l = a.globals.gridHeight;
      a.globals.timescaleLabels.length ? function(p) {
        for (var f = p.xC, x = p.x1, m = p.y1, b = p.x2, w = p.y2, y = 0; y < f; y++) x = t.xaxisLabels[y].position, b = t.xaxisLabels[y].position, t._drawGridLines({ i: y, x1: x, y1: m, x2: b, y2: w, xCount: i, parent: t.elgridLinesV });
      }({ xC: i, x1: o, y1: 0, x2: n, y2: l }) : (a.globals.isXNumeric && (i = a.globals.xAxisScale.result.length), function(p) {
        for (var f = p.xC, x = p.x1, m = p.y1, b = p.x2, w = p.y2, y = 0; y < f + (a.globals.isXNumeric ? 0 : 1); y++) y === 0 && f === 1 && a.globals.dataPoints === 1 && (b = x = a.globals.gridWidth / 2), t._drawGridLines({ i: y, x1: x, y1: m, x2: b, y2: w, xCount: i, parent: t.elgridLinesV }), b = x += a.globals.gridWidth / (a.globals.isXNumeric ? f - 1 : f);
      }({ xC: i, x1: o, y1: 0, x2: n, y2: l }));
    }
    if (a.config.grid.yaxis.lines.show) {
      var c = 0, h = 0, d = a.globals.gridWidth, u = s + 1;
      this.isRangeBar && (u = a.globals.labels.length);
      for (var g = 0; g < u + (this.isRangeBar ? 1 : 0); g++) this._drawGridLine({ i: g, xCount: u + (this.isRangeBar ? 1 : 0), x1: 0, y1: c, x2: d, y2: h, parent: this.elgridLinesH }), h = c += a.globals.gridHeight / (this.isRangeBar ? u : s);
    }
  } }, { key: "_drawInvertedXYLines", value: function(e) {
    var t = e.xCount, i = this.w;
    if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) for (var s, a = i.globals.padHorizontal, n = i.globals.gridHeight, o = 0; o < t + 1; o++)
      i.config.grid.xaxis.lines.show && this._drawGridLine({ i: o, xCount: t + 1, x1: a, y1: 0, x2: s, y2: n, parent: this.elgridLinesV }), new Mi(this.ctx).drawXaxisTicks(a, 0, i.globals.dom.elGraphical), s = a += i.globals.gridWidth / t;
    if (i.config.grid.yaxis.lines.show) for (var l = 0, c = 0, h = i.globals.gridWidth, d = 0; d < i.globals.dataPoints + 1; d++) this._drawGridLine({ i: d, xCount: i.globals.dataPoints + 1, x1: 0, y1: l, x2: h, y2: c, parent: this.elgridLinesH }), c = l += i.globals.gridHeight / i.globals.dataPoints;
  } }, { key: "renderGrid", value: function() {
    var e = this.w, t = e.globals, i = new B(this.ctx);
    this.elg = i.group({ class: "apexcharts-grid" }), this.elgridLinesH = i.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), e.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var s = 0; s < t.seriesYAxisMap.length && t.ignoreYAxisIndexes.includes(s); ) s++;
    s === t.seriesYAxisMap.length && (s = 0);
    var a, n = t.yAxisScale[s].result.length - 1;
    if (!t.isBarHorizontal || this.isRangeBar) {
      var o, l, c;
      a = this.xaxisLabels.length, this.isRangeBar && (n = t.labels.length, e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (a = e.config.xaxis.tickAmount), ((o = t.yAxisScale) === null || o === void 0 || (l = o[s]) === null || l === void 0 || (c = l.result) === null || c === void 0 ? void 0 : c.length) > 0 && e.config.xaxis.type !== "datetime" && (a = t.yAxisScale[s].result.length - 1)), this._drawXYLines({ xCount: a, tickAmount: n });
    } else a = n, n = t.xTickAmount, this._drawInvertedXYLines({ xCount: a, tickAmount: n });
    return this.drawGridBands(a, n), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.gridWidth / a };
  } }, { key: "drawGridBands", value: function(e, t) {
    var i, s, a = this, n = this.w;
    if (((i = n.config.grid.row.colors) === null || i === void 0 ? void 0 : i.length) > 0 && function(p, f, x, m, b, w) {
      for (var y = 0, v = 0; y < f; y++, v++) v >= n.config.grid[p].colors.length && (v = 0), a._drawGridBandRect({ c: v, x1: x, y1: m, x2: b, y2: w, type: p }), m += n.globals.gridHeight / t;
    }("row", t, 0, 0, n.globals.gridWidth, n.globals.gridHeight / t), ((s = n.config.grid.column.colors) === null || s === void 0 ? void 0 : s.length) > 0) {
      var o = n.globals.isBarHorizontal || n.config.xaxis.tickPlacement !== "on" || n.config.xaxis.type !== "category" && !n.config.xaxis.convertedCatToNumeric ? e : e - 1;
      n.globals.isXNumeric && (o = n.globals.xAxisScale.result.length - 1);
      for (var l = n.globals.padHorizontal, c = n.globals.padHorizontal + n.globals.gridWidth / o, h = n.globals.gridHeight, d = 0, u = 0; d < e; d++, u++) {
        var g;
        u >= n.config.grid.column.colors.length && (u = 0), n.config.xaxis.type === "datetime" && (l = this.xaxisLabels[d].position, c = (((g = this.xaxisLabels[d + 1]) === null || g === void 0 ? void 0 : g.position) || n.globals.gridWidth) - this.xaxisLabels[d].position), this._drawGridBandRect({ c: u, x1: l, y1: 0, x2: c, y2: h, type: "column" }), l += n.globals.gridWidth / o;
      }
    }
  } }]), r;
}(), Co = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.coreUtils = new ze(this.ctx);
  }
  return te(r, [{ key: "niceScale", value: function(e, t) {
    var i, s, a, n, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, l = 1e-11, c = this.w, h = c.globals;
    h.isBarHorizontal ? (i = c.config.xaxis, s = Math.max((h.svgWidth - 100) / 25, 2)) : (i = c.config.yaxis[o], s = Math.max((h.svgHeight - 100) / 15, 2)), z.isNumber(s) || (s = 10), a = i.min !== void 0 && i.min !== null, n = i.max !== void 0 && i.min !== null;
    var d = i.stepSize !== void 0 && i.stepSize !== null, u = i.tickAmount !== void 0 && i.tickAmount !== null, g = u ? i.tickAmount : h.niceScaleDefaultTicks[Math.min(Math.round(s / 2), h.niceScaleDefaultTicks.length - 1)];
    if (h.isMultipleYAxis && !u && h.multiAxisTickAmount > 0 && (g = h.multiAxisTickAmount, u = !0), g = g === "dataPoints" ? h.dataPoints - 1 : Math.abs(Math.round(g)), (e === Number.MIN_VALUE && t === 0 || !z.isNumber(e) && !z.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE) && (e = z.isNumber(i.min) ? i.min : 0, t = z.isNumber(i.max) ? i.max : e + g, h.allSeriesCollapsed = !1), e > t) {
      console.warn("axis.min cannot be greater than axis.max: swapping min and max");
      var p = t;
      t = e, e = p;
    } else e === t && (e = e === 0 ? 0 : e - 1, t = t === 0 ? 2 : t + 1);
    var f = [];
    g < 1 && (g = 1);
    var x = g, m = Math.abs(t - e);
    !a && e > 0 && e / m < 0.15 && (e = 0, a = !0), !n && t < 0 && -t / m < 0.15 && (t = 0, n = !0);
    var b = (m = Math.abs(t - e)) / x, w = b, y = Math.floor(Math.log10(w)), v = Math.pow(10, y), S = Math.ceil(w / v);
    if (b = w = (S = h.niceScaleAllowedMagMsd[h.yValueDecimal === 0 ? 0 : 1][S]) * v, h.isBarHorizontal && i.stepSize && i.type !== "datetime" ? (b = i.stepSize, d = !0) : d && (b = i.stepSize), d && i.forceNiceScale) {
      var k = Math.floor(Math.log10(b));
      b *= Math.pow(10, y - k);
    }
    if (a && n) {
      var C = m / x;
      if (u) if (d) if (z.mod(m, b) != 0) {
        var R = z.getGCD(b, C);
        b = C / R < 10 ? R : C;
      } else z.mod(b, C) == 0 ? b = C : (C = b, u = !1);
      else b = C;
      else if (d) z.mod(m, b) == 0 ? C = b : b = C;
      else if (z.mod(m, b) == 0) C = b;
      else {
        C = m / (x = Math.ceil(m / b));
        var P = z.getGCD(m, b);
        m / P < s && (C = P), b = C;
      }
      x = Math.round(m / b);
    } else {
      if (a || n) {
        if (n) if (u) e = t - b * x;
        else {
          var A = e;
          e = b * Math.floor(e / b), Math.abs(t - e) / z.getGCD(m, b) > s && (e = t - b * g, e += b * Math.floor((A - e) / b));
        }
        else if (a) if (u) t = e + b * x;
        else {
          var E = t;
          t = b * Math.ceil(t / b), Math.abs(t - e) / z.getGCD(m, b) > s && (t = e + b * g, t += b * Math.ceil((E - t) / b));
        }
      } else if (h.isMultipleYAxis && u) {
        var N = b * Math.floor(e / b), O = N + b * x;
        O < t && (b *= 2), O = t, t = (e = N) + b * x, m = Math.abs(t - e), e > 0 && e < Math.abs(O - t) && (e = 0, t = b * x), t < 0 && -t < Math.abs(N - e) && (t = 0, e = -b * x);
      } else e = b * Math.floor(e / b), t = b * Math.ceil(t / b);
      m = Math.abs(t - e), b = z.getGCD(m, b), x = Math.round(m / b);
    }
    if (u || a || n || (x = Math.ceil((m - l) / (b + l))) > 16 && z.getPrimeFactors(x).length < 2 && x++, !u && i.forceNiceScale && h.yValueDecimal === 0 && x > m && (x = m, b = Math.round(m / x)), x > s && (!u && !d || i.forceNiceScale)) {
      var L = z.getPrimeFactors(x), I = L.length - 1, F = x;
      e: for (var D = 0; D < I; D++) for (var Y = 0; Y <= I - D; Y++) {
        for (var _ = Math.min(Y + D, I), H = F, V = 1, Z = Y; Z <= _; Z++) V *= L[Z];
        if ((H /= V) < s) {
          F = H;
          break e;
        }
      }
      b = F === x ? m : m / F, x = Math.round(m / b);
    }
    h.isMultipleYAxis && h.multiAxisTickAmount == 0 && h.ignoreYAxisIndexes.indexOf(o) < 0 && (h.multiAxisTickAmount = x);
    var X = e - b, J = b * l;
    do
      X += b, f.push(z.stripNumber(X, 7));
    while (t - X > J);
    return { result: f, niceMin: f[0], niceMax: f[f.length - 1] };
  } }, { key: "linearScale", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0, n = Math.abs(t - e), o = [];
    if (e === t) return { result: o = [e], niceMin: o[0], niceMax: o[o.length - 1] };
    (i = this._adjustTicksForSmallRange(i, s, n)) === "dataPoints" && (i = this.w.globals.dataPoints - 1), a || (a = n / i), a = Math.round(100 * (a + Number.EPSILON)) / 100, i === Number.MAX_VALUE && (i = 5, a = 1);
    for (var l = e; i >= 0; ) o.push(l), l = z.preciseAddition(l, a), i -= 1;
    return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
  } }, { key: "logarithmicScaleNice", value: function(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    for (var s = [], a = Math.ceil(Math.log(t) / Math.log(i) + 1), n = Math.floor(Math.log(e) / Math.log(i)); n < a; n++) s.push(Math.pow(i, n));
    return { result: s, niceMin: s[0], niceMax: s[s.length - 1] };
  } }, { key: "logarithmicScale", value: function(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    for (var s = [], a = Math.log(t) / Math.log(i), n = Math.log(e) / Math.log(i), o = a - n, l = Math.round(o), c = o / l, h = 0, d = n; h < l; h++, d += c) s.push(Math.pow(i, d));
    return s.push(Math.pow(i, a)), { result: s, niceMin: e, niceMax: t };
  } }, { key: "_adjustTicksForSmallRange", value: function(e, t, i) {
    var s = e;
    if (t !== void 0 && this.w.config.yaxis[t].labels.formatter && this.w.config.yaxis[t].tickAmount === void 0) {
      var a = Number(this.w.config.yaxis[t].labels.formatter(1));
      z.isNumber(a) && this.w.globals.yValueDecimal === 0 && (s = Math.ceil(i));
    }
    return s < e ? s : e;
  } }, { key: "setYScaleForIndex", value: function(e, t, i) {
    var s = this.w.globals, a = this.w.config, n = s.isBarHorizontal ? a.xaxis : a.yaxis[e];
    s.yAxisScale[e] === void 0 && (s.yAxisScale[e] = []);
    var o = Math.abs(i - t);
    n.logarithmic && o <= 5 && (s.invalidLogScale = !0), n.logarithmic && o > 5 ? (s.allSeriesCollapsed = !1, s.yAxisScale[e] = n.forceNiceScale ? this.logarithmicScaleNice(t, i, n.logBase) : this.logarithmicScale(t, i, n.logBase)) : i !== -Number.MAX_VALUE && z.isNumber(i) && t !== Number.MAX_VALUE && z.isNumber(t) ? (s.allSeriesCollapsed = !1, s.yAxisScale[e] = this.niceScale(t, i, e)) : s.yAxisScale[e] = this.niceScale(Number.MIN_VALUE, 0, e);
  } }, { key: "setXScale", value: function(e, t) {
    var i = this.w, s = i.globals;
    if (t !== -Number.MAX_VALUE && z.isNumber(t)) {
      var a = s.xTickAmount;
      s.xAxisScale = this.linearScale(e, t, a, 0, i.config.xaxis.stepSize);
    } else s.xAxisScale = this.linearScale(0, 10, 10);
    return s.xAxisScale;
  } }, { key: "scaleMultipleYAxes", value: function() {
    var e = this, t = this.w.config, i = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var s = i.seriesYAxisMap, a = i.minYArr, n = i.maxYArr;
    i.allSeriesCollapsed = !0, i.barGroups = [], s.forEach(function(o, l) {
      var c = [];
      o.forEach(function(h) {
        var d, u = (d = t.series[h]) === null || d === void 0 ? void 0 : d.group;
        c.indexOf(u) < 0 && c.push(u);
      }), o.length > 0 ? function() {
        var h, d, u = Number.MAX_VALUE, g = -Number.MAX_VALUE, p = u, f = g;
        if (t.chart.stacked) (function() {
          var b = new Array(i.dataPoints).fill(0), w = [], y = [], v = [];
          c.forEach(function() {
            w.push(b.map(function() {
              return Number.MIN_VALUE;
            })), y.push(b.map(function() {
              return Number.MIN_VALUE;
            })), v.push(b.map(function() {
              return Number.MIN_VALUE;
            }));
          });
          for (var S = function(C) {
            !h && t.series[o[C]].type && (h = t.series[o[C]].type);
            var R = o[C];
            d = t.series[R].group ? t.series[R].group : "axis-".concat(l), !(i.collapsedSeriesIndices.indexOf(R) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(R) < 0) || (i.allSeriesCollapsed = !1, c.forEach(function(P, A) {
              if (t.series[R].group === P) for (var E = 0; E < i.series[R].length; E++) {
                var N = i.series[R][E];
                N >= 0 ? y[A][E] += N : v[A][E] += N, w[A][E] += N, p = Math.min(p, N), f = Math.max(f, N);
              }
            })), h !== "bar" && h !== "column" || i.barGroups.push(d);
          }, k = 0; k < o.length; k++) S(k);
          h || (h = t.chart.type), h === "bar" || h === "column" ? c.forEach(function(C, R) {
            u = Math.min(u, Math.min.apply(null, v[R])), g = Math.max(g, Math.max.apply(null, y[R]));
          }) : (c.forEach(function(C, R) {
            p = Math.min(p, Math.min.apply(null, w[R])), f = Math.max(f, Math.max.apply(null, w[R]));
          }), u = p, g = f), u === Number.MIN_VALUE && g === Number.MIN_VALUE && (g = -Number.MAX_VALUE);
        })();
        else for (var x = 0; x < o.length; x++) {
          var m = o[x];
          u = Math.min(u, a[m]), g = Math.max(g, n[m]), !(i.collapsedSeriesIndices.indexOf(m) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(m) < 0) || (i.allSeriesCollapsed = !1);
        }
        t.yaxis[l].min !== void 0 && (u = typeof t.yaxis[l].min == "function" ? t.yaxis[l].min(u) : t.yaxis[l].min), t.yaxis[l].max !== void 0 && (g = typeof t.yaxis[l].max == "function" ? t.yaxis[l].max(g) : t.yaxis[l].max), i.barGroups = i.barGroups.filter(function(b, w, y) {
          return y.indexOf(b) === w;
        }), e.setYScaleForIndex(l, u, g), o.forEach(function(b) {
          a[b] = i.yAxisScale[l].niceMin, n[b] = i.yAxisScale[l].niceMax;
        });
      }() : e.setYScaleForIndex(l, 0, -Number.MAX_VALUE);
    });
  } }]), r;
}(), br = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.scales = new Co(e);
  }
  return te(r, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, a = this.w.config, n = this.w.globals, o = -Number.MAX_VALUE, l = Number.MIN_VALUE;
    s === null && (s = e + 1);
    var c = n.series, h = c, d = c;
    a.chart.type === "candlestick" ? (h = n.seriesCandleL, d = n.seriesCandleH) : a.chart.type === "boxPlot" ? (h = n.seriesCandleO, d = n.seriesCandleC) : n.isRangeData && (h = n.seriesRangeStart, d = n.seriesRangeEnd);
    var u = !1;
    if (n.seriesX.length >= s) {
      var g, p = (g = n.brushSource) === null || g === void 0 ? void 0 : g.w.config.chart.brush;
      (a.chart.zoom.enabled && a.chart.zoom.autoScaleYaxis || p != null && p.enabled && p != null && p.autoScaleYaxis) && (u = !0);
    }
    for (var f = e; f < s; f++) {
      n.dataPoints = Math.max(n.dataPoints, c[f].length);
      var x = a.series[f].type;
      n.categoryLabels.length && (n.dataPoints = n.categoryLabels.filter(function(R) {
        return R !== void 0;
      }).length), n.labels.length && a.xaxis.type !== "datetime" && n.series.reduce(function(R, P) {
        return R + P.length;
      }, 0) !== 0 && (n.dataPoints = Math.max(n.dataPoints, n.labels.length));
      var m = 0, b = c[f].length - 1;
      if (u) {
        if (a.xaxis.min) for (; m < b && n.seriesX[f][m] < a.xaxis.min; m++) ;
        if (a.xaxis.max) for (; b > m && n.seriesX[f][b] > a.xaxis.max; b--) ;
      }
      for (var w = m; w <= b && w < n.series[f].length; w++) {
        var y = c[f][w];
        if (y !== null && z.isNumber(y)) {
          var v, S, k, C;
          switch (((v = d[f]) === null || v === void 0 ? void 0 : v[w]) !== void 0 && (o = Math.max(o, d[f][w]), t = Math.min(t, d[f][w])), ((S = h[f]) === null || S === void 0 ? void 0 : S[w]) !== void 0 && (t = Math.min(t, h[f][w]), i = Math.max(i, h[f][w])), x) {
            case "candlestick":
              n.seriesCandleC[f][w] !== void 0 && (o = Math.max(o, n.seriesCandleH[f][w]), t = Math.min(t, n.seriesCandleL[f][w]));
              break;
            case "boxPlot":
              n.seriesCandleC[f][w] !== void 0 && (o = Math.max(o, n.seriesCandleC[f][w]), t = Math.min(t, n.seriesCandleO[f][w]));
          }
          x && x !== "candlestick" && x !== "boxPlot" && x !== "rangeArea" && x !== "rangeBar" && (o = Math.max(o, n.series[f][w]), t = Math.min(t, n.series[f][w])), n.seriesGoals[f] && n.seriesGoals[f][w] && Array.isArray(n.seriesGoals[f][w]) && n.seriesGoals[f][w].forEach(function(R) {
            o = Math.max(o, R.value), t = Math.min(t, R.value);
          }), i = o, y = z.noExponents(y), z.isFloat(y) && (n.yValueDecimal = Math.max(n.yValueDecimal, y.toString().split(".")[1].length)), l > ((k = h[f]) === null || k === void 0 ? void 0 : k[w]) && ((C = h[f]) === null || C === void 0 ? void 0 : C[w]) < 0 && (l = h[f][w]);
        } else n.hasNullValues = !0;
      }
      x !== "bar" && x !== "column" || (l < 0 && o < 0 && (o = 0, i = Math.max(i, 0)), l === Number.MIN_VALUE && (l = 0, t = Math.min(t, 0)));
    }
    return a.chart.type === "rangeBar" && n.seriesRangeStart.length && n.isBarHorizontal && (l = t), a.chart.type === "bar" && (l < 0 && o < 0 && (o = 0), l === Number.MIN_VALUE && (l = 0)), { minY: l, maxY: o, lowestY: t, highestY: i };
  } }, { key: "setYRange", value: function() {
    var e = this.w.globals, t = this.w.config;
    e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE;
    var i, s = Number.MAX_VALUE;
    if (e.isMultipleYAxis) {
      s = Number.MAX_VALUE;
      for (var a = 0; a < e.series.length; a++) i = this.getMinYMaxY(a), e.minYArr[a] = i.lowestY, e.maxYArr[a] = i.highestY, s = Math.min(s, i.lowestY);
    }
    return i = this.getMinYMaxY(0, s, null, e.series.length), t.chart.type === "bar" ? (e.minY = i.minY, e.maxY = i.maxY) : (e.minY = i.lowestY, e.maxY = i.highestY), s = i.lowestY, t.chart.stacked && this._setStackedMinMax(), t.chart.type === "line" || t.chart.type === "area" || t.chart.type === "scatter" || t.chart.type === "candlestick" || t.chart.type === "boxPlot" || t.chart.type === "rangeBar" && !e.isBarHorizontal ? e.minY === Number.MIN_VALUE && s !== -Number.MAX_VALUE && s !== e.maxY && (e.minY = s) : e.minY = e.minY !== Number.MIN_VALUE ? Math.min(i.minY, e.minY) : i.minY, t.yaxis.forEach(function(n, o) {
      n.max !== void 0 && (typeof n.max == "number" ? e.maxYArr[o] = n.max : typeof n.max == "function" && (e.maxYArr[o] = n.max(e.isMultipleYAxis ? e.maxYArr[o] : e.maxY)), e.maxY = e.maxYArr[o]), n.min !== void 0 && (typeof n.min == "number" ? e.minYArr[o] = n.min : typeof n.min == "function" && (e.minYArr[o] = n.min(e.isMultipleYAxis ? e.minYArr[o] === Number.MIN_VALUE ? 0 : e.minYArr[o] : e.minY)), e.minY = e.minYArr[o]);
    }), e.isBarHorizontal && ["min", "max"].forEach(function(n) {
      t.xaxis[n] !== void 0 && typeof t.xaxis[n] == "number" && (n === "min" ? e.minY = t.xaxis[n] : e.maxY = t.xaxis[n]);
    }), e.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), e.minY = s) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY), e.minY = e.yAxisScale[0].niceMin, e.maxY = e.yAxisScale[0].niceMax, e.minYArr[0] = e.minY, e.maxYArr[0] = e.maxY), e.barGroups = [], e.lineGroups = [], e.areaGroups = [], t.series.forEach(function(n) {
      switch (n.type || t.chart.type) {
        case "bar":
        case "column":
          e.barGroups.push(n.group);
          break;
        case "line":
          e.lineGroups.push(n.group);
          break;
        case "area":
          e.areaGroups.push(n.group);
      }
    }), e.barGroups = e.barGroups.filter(function(n, o, l) {
      return l.indexOf(n) === o;
    }), e.lineGroups = e.lineGroups.filter(function(n, o, l) {
      return l.indexOf(n) === o;
    }), e.areaGroups = e.areaGroups.filter(function(n, o, l) {
      return l.indexOf(n) === o;
    }), { minY: e.minY, maxY: e.maxY, minYArr: e.minYArr, maxYArr: e.maxYArr, yAxisScale: e.yAxisScale };
  } }, { key: "setXRange", value: function() {
    var e = this.w.globals, t = this.w.config, i = t.xaxis.type === "numeric" || t.xaxis.type === "datetime" || t.xaxis.type === "category" && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
    if (e.isXNumeric && function() {
      for (var l = 0; l < e.series.length; l++) if (e.labels[l]) for (var c = 0; c < e.labels[l].length; c++) e.labels[l][c] !== null && z.isNumber(e.labels[l][c]) && (e.maxX = Math.max(e.maxX, e.labels[l][c]), e.initialMaxX = Math.max(e.maxX, e.labels[l][c]), e.minX = Math.min(e.minX, e.labels[l][c]), e.initialMinX = Math.min(e.minX, e.labels[l][c]));
    }(), e.noLabelsProvided && t.xaxis.categories.length === 0 && (e.maxX = e.labels[e.labels.length - 1], e.initialMaxX = e.labels[e.labels.length - 1], e.minX = 1, e.initialMinX = 1), e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
      var s = 10;
      if (t.xaxis.tickAmount === void 0) s = Math.round(e.svgWidth / 150), t.xaxis.type === "numeric" && e.dataPoints < 30 && (s = e.dataPoints - 1), s > e.dataPoints && e.dataPoints !== 0 && (s = e.dataPoints - 1);
      else if (t.xaxis.tickAmount === "dataPoints") {
        if (e.series.length > 1 && (s = e.series[e.maxValsInArrayIndex].length - 1), e.isXNumeric) {
          var a = Math.round(e.maxX - e.minX);
          a < 30 && (s = a - 1);
        }
      } else s = t.xaxis.tickAmount;
      if (e.xTickAmount = s, t.xaxis.max !== void 0 && typeof t.xaxis.max == "number" && (e.maxX = t.xaxis.max), t.xaxis.min !== void 0 && typeof t.xaxis.min == "number" && (e.minX = t.xaxis.min), t.xaxis.range !== void 0 && (e.minX = e.maxX - t.xaxis.range), e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE) if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
        for (var n = [], o = e.minX - 1; o < e.maxX; o++) n.push(o + 1);
        e.xAxisScale = { result: n, niceMin: n[0], niceMax: n[n.length - 1] };
      } else e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
      else e.xAxisScale = this.scales.linearScale(0, s, s, 0, t.xaxis.stepSize), e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, s - 1, 0, t.xaxis.stepSize), e.seriesX = e.labels.slice());
      i && (e.labels = e.xAxisScale.result.slice());
    }
    return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: e.minX, maxX: e.maxX };
  } }, { key: "setZRange", value: function() {
    var e = this.w.globals;
    if (e.isDataXYZ) {
      for (var t = 0; t < e.series.length; t++) if (e.seriesZ[t] !== void 0) for (var i = 0; i < e.seriesZ[t].length; i++) e.seriesZ[t][i] !== null && z.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]), e.minZ = Math.min(e.minZ, e.seriesZ[t][i]));
    }
  } }, { key: "_handleSingleDataPoint", value: function() {
    var e = this.w.globals, t = this.w.config;
    if (e.minX === e.maxX) {
      var i = new Ye(this.ctx);
      if (t.xaxis.type === "datetime") {
        var s = i.getDate(e.minX);
        t.xaxis.labels.datetimeUTC ? s.setUTCDate(s.getUTCDate() - 2) : s.setDate(s.getDate() - 2), e.minX = new Date(s).getTime();
        var a = i.getDate(e.maxX);
        t.xaxis.labels.datetimeUTC ? a.setUTCDate(a.getUTCDate() + 2) : a.setDate(a.getDate() + 2), e.maxX = new Date(a).getTime();
      } else (t.xaxis.type === "numeric" || t.xaxis.type === "category" && !e.noLabelsProvided) && (e.minX = e.minX - 2, e.initialMinX = e.minX, e.maxX = e.maxX + 2, e.initialMaxX = e.maxX);
    }
  } }, { key: "_getMinXDiff", value: function() {
    var e = this.w.globals;
    e.isXNumeric && e.seriesX.forEach(function(t, i) {
      if (t.length) {
        t.length === 1 && t.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]);
        var s = t.slice();
        s.sort(function(a, n) {
          return a - n;
        }), s.forEach(function(a, n) {
          if (n > 0) {
            var o = a - s[n - 1];
            o > 0 && (e.minXDiff = Math.min(o, e.minXDiff));
          }
        }), e.dataPoints !== 1 && e.minXDiff !== Number.MAX_VALUE || (e.minXDiff = 0.5);
      }
    });
  } }, { key: "_setStackedMinMax", value: function() {
    var e = this, t = this.w.globals;
    if (t.series.length) {
      var i = t.seriesGroups;
      i.length || (i = [this.w.globals.seriesNames.map(function(n) {
        return n;
      })]);
      var s = {}, a = {};
      i.forEach(function(n) {
        s[n] = [], a[n] = [], e.w.config.series.map(function(o, l) {
          return n.indexOf(t.seriesNames[l]) > -1 ? l : null;
        }).filter(function(o) {
          return o !== null;
        }).forEach(function(o) {
          for (var l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) {
            var c, h, d, u;
            s[n][l] === void 0 && (s[n][l] = 0, a[n][l] = 0), (e.w.config.chart.stacked && !t.comboCharts || e.w.config.chart.stacked && t.comboCharts && (!e.w.config.chart.stackOnlyBar || ((c = e.w.config.series) === null || c === void 0 || (h = c[o]) === null || h === void 0 ? void 0 : h.type) === "bar" || ((d = e.w.config.series) === null || d === void 0 || (u = d[o]) === null || u === void 0 ? void 0 : u.type) === "column")) && t.series[o][l] !== null && z.isNumber(t.series[o][l]) && (t.series[o][l] > 0 ? s[n][l] += parseFloat(t.series[o][l]) + 1e-4 : a[n][l] += parseFloat(t.series[o][l]));
          }
        });
      }), Object.entries(s).forEach(function(n) {
        var o = Vn(n, 1)[0];
        s[o].forEach(function(l, c) {
          t.maxY = Math.max(t.maxY, s[o][c]), t.minY = Math.min(t.minY, a[o][c]);
        });
      });
    }
  } }]), r;
}(), Jr = function() {
  function r(e, t) {
    ee(this, r), this.ctx = e, this.elgrid = t, this.w = e.w;
    var i = this.w;
    this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = i.config.xaxis.position === "bottom" ? i.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Pt(e);
  }
  return te(r, [{ key: "drawYaxis", value: function(e) {
    var t = this.w, i = new B(this.ctx), s = t.config.yaxis[e].labels.style, a = s.fontSize, n = s.fontFamily, o = s.fontWeight, l = i.group({ class: "apexcharts-yaxis", rel: e, transform: "translate(".concat(t.globals.translateYAxisX[e], ", 0)") });
    if (this.axesUtils.isYAxisHidden(e)) return l;
    var c = i.group({ class: "apexcharts-yaxis-texts-g" });
    l.add(c);
    var h = t.globals.yAxisScale[e].result.length - 1, d = t.globals.gridHeight / h, u = t.globals.yLabelFormatters[e], g = this.axesUtils.checkForReversedLabels(e, t.globals.yAxisScale[e].result.slice());
    if (t.config.yaxis[e].labels.show) {
      var p = t.globals.translateY + t.config.yaxis[e].labels.offsetY;
      t.globals.isBarHorizontal ? p = 0 : t.config.chart.type === "heatmap" && (p -= d / 2), p += parseInt(a, 10) / 3;
      for (var f = h; f >= 0; f--) {
        var x = u(g[f], f, t), m = t.config.yaxis[e].labels.padding;
        t.config.yaxis[e].opposite && t.config.yaxis.length !== 0 && (m *= -1);
        var b = this.getTextAnchor(t.config.yaxis[e].labels.align, t.config.yaxis[e].opposite), w = this.axesUtils.getYAxisForeColor(s.colors, e), y = Array.isArray(w) ? w[f] : w, v = z.listToArray(t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-label tspan"))).map(function(k) {
          return k.textContent;
        }), S = i.drawText({ x: m, y: p, text: v.includes(x) && !t.config.yaxis[e].labels.showDuplicates ? "" : x, textAnchor: b, fontSize: a, fontFamily: n, fontWeight: o, maxWidth: t.config.yaxis[e].labels.maxWidth, foreColor: y, isPlainText: !1, cssClass: "apexcharts-yaxis-label ".concat(s.cssClass) });
        c.add(S), this.addTooltip(S, x), t.config.yaxis[e].labels.rotate !== 0 && this.rotateLabel(i, S, firstLabel, t.config.yaxis[e].labels.rotate), p += d;
      }
    }
    return this.addYAxisTitle(i, l, e), this.addAxisBorder(i, l, e, h, d), l;
  } }, { key: "getTextAnchor", value: function(e, t) {
    return e === "left" ? "start" : e === "center" ? "middle" : e === "right" ? "end" : t ? "start" : "end";
  } }, { key: "addTooltip", value: function(e, t) {
    var i = document.createElementNS(this.w.globals.SVGNS, "title");
    i.textContent = Array.isArray(t) ? t.join(" ") : t, e.node.appendChild(i);
  } }, { key: "rotateLabel", value: function(e, t, i, s) {
    var a = e.rotateAroundCenter(i.node), n = e.rotateAroundCenter(t.node);
    t.node.setAttribute("transform", "rotate(".concat(s, " ").concat(a.x, " ").concat(n.y, ")"));
  } }, { key: "addYAxisTitle", value: function(e, t, i) {
    var s = this.w;
    if (s.config.yaxis[i].title.text !== void 0) {
      var a = e.group({ class: "apexcharts-yaxis-title" }), n = s.config.yaxis[i].opposite ? s.globals.translateYAxisX[i] : 0, o = e.drawText({ x: n, y: s.globals.gridHeight / 2 + s.globals.translateY + s.config.yaxis[i].title.offsetY, text: s.config.yaxis[i].title.text, textAnchor: "end", foreColor: s.config.yaxis[i].title.style.color, fontSize: s.config.yaxis[i].title.style.fontSize, fontWeight: s.config.yaxis[i].title.style.fontWeight, fontFamily: s.config.yaxis[i].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(s.config.yaxis[i].title.style.cssClass) });
      a.add(o), t.add(a);
    }
  } }, { key: "addAxisBorder", value: function(e, t, i, s, a) {
    var n = this.w, o = n.config.yaxis[i].axisBorder, l = 31 + o.offsetX;
    if (n.config.yaxis[i].opposite && (l = -31 - o.offsetX), o.show) {
      var c = e.drawLine(l, n.globals.translateY + o.offsetY - 2, l, n.globals.gridHeight + n.globals.translateY + o.offsetY + 2, o.color, 0, o.width);
      t.add(c);
    }
    n.config.yaxis[i].axisTicks.show && this.axesUtils.drawYAxisTicks(l, s, o, n.config.yaxis[i].axisTicks, i, a, t);
  } }, { key: "drawYaxisInversed", value: function(e) {
    var t = this.w, i = new B(this.ctx), s = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), a = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")") });
    s.add(a);
    var n = t.globals.yAxisScale[e].result.length - 1, o = t.globals.gridWidth / n + 0.1, l = o + t.config.xaxis.labels.offsetX, c = t.globals.xLabelFormatter, h = this.axesUtils.checkForReversedLabels(e, t.globals.yAxisScale[e].result.slice()), d = t.globals.timescaleLabels;
    if (d.length > 0 && (this.xaxisLabels = d.slice(), n = (h = d.slice()).length), t.config.xaxis.labels.show) for (var u = d.length ? 0 : n; d.length ? u < d.length : u >= 0; d.length ? u++ : u--) {
      var g = c(h[u], u, t), p = t.globals.gridWidth + t.globals.padHorizontal - (l - o + t.config.xaxis.labels.offsetX);
      if (d.length) {
        var f = this.axesUtils.getLabel(h, d, p, u, this.drawnLabels, this.xaxisFontSize);
        p = f.x, g = f.text, this.drawnLabels.push(f.text), u === 0 && t.globals.skipFirstTimelinelabel && (g = ""), u === h.length - 1 && t.globals.skipLastTimelinelabel && (g = "");
      }
      var x = i.drawText({ x: p, y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - (t.config.xaxis.position === "top" ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0), text: g, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: t.config.xaxis.labels.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-xaxis-label ".concat(t.config.xaxis.labels.style.cssClass) });
      a.add(x), x.tspan(g), this.addTooltip(x, g), l += o;
    }
    return this.inversedYAxisTitleText(s), this.inversedYAxisBorder(s), s;
  } }, { key: "inversedYAxisBorder", value: function(e) {
    var t = this.w, i = new B(this.ctx), s = t.config.xaxis.axisBorder;
    if (s.show) {
      var a = 0;
      t.config.chart.type === "bar" && t.globals.isXNumeric && (a -= 15);
      var n = i.drawLine(t.globals.padHorizontal + a + s.offsetX, this.xAxisoffX, t.globals.gridWidth, this.xAxisoffX, s.color, 0, s.height);
      this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(n) : e.add(n);
    }
  } }, { key: "inversedYAxisTitleText", value: function(e) {
    var t = this.w, i = new B(this.ctx);
    if (t.config.xaxis.title.text !== void 0) {
      var s = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), a = i.drawText({ x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20, text: t.config.xaxis.title.text, textAnchor: "middle", fontSize: t.config.xaxis.title.style.fontSize, fontFamily: t.config.xaxis.title.style.fontFamily, fontWeight: t.config.xaxis.title.style.fontWeight, foreColor: t.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(t.config.xaxis.title.style.cssClass) });
      s.add(a), e.add(s);
    }
  } }, { key: "yAxisTitleRotate", value: function(e, t) {
    var i = this.w, s = new B(this.ctx), a = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g")), n = a ? a.getBoundingClientRect() : { width: 0, height: 0 }, o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text")), l = o ? o.getBoundingClientRect() : { width: 0, height: 0 };
    if (o) {
      var c = this.xPaddingForYAxisTitle(e, n, l, t);
      o.setAttribute("x", c.xPos - (t ? 10 : 0));
      var h = s.rotateAroundCenter(o);
      o.setAttribute("transform", "rotate(".concat(t ? -1 * i.config.yaxis[e].title.rotate : i.config.yaxis[e].title.rotate, " ").concat(h.x, " ").concat(h.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(e, t, i, s) {
    var a = this.w, n = 0, o = 10;
    return a.config.yaxis[e].title.text === void 0 || e < 0 ? { xPos: n, padd: 0 } : (s ? n = t.width + a.config.yaxis[e].title.offsetX + i.width / 2 + o / 2 : (n = -1 * t.width + a.config.yaxis[e].title.offsetX + o / 2 + i.width / 2, a.globals.isBarHorizontal && (o = 25, n = -1 * t.width - a.config.yaxis[e].title.offsetX - o)), { xPos: n, padd: o });
  } }, { key: "setYAxisXPosition", value: function(e, t) {
    var i = this.w, s = 0, a = 0, n = 18, o = 1;
    i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.forEach(function(l, c) {
      var h = i.globals.ignoreYAxisIndexes.includes(c) || !l.show || l.floating || e[c].width === 0, d = e[c].width + t[c].width;
      l.opposite ? i.globals.isBarHorizontal ? (a = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[c] = a - l.labels.offsetX) : (a = i.globals.gridWidth + i.globals.translateX + o, h || (o += d + 20), i.globals.translateYAxisX[c] = a - l.labels.offsetX + 20) : (s = i.globals.translateX - n, h || (n += d + 20), i.globals.translateYAxisX[c] = s + l.labels.offsetX);
    });
  } }, { key: "setYAxisTextAlignments", value: function() {
    var e = this.w;
    z.listToArray(e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach(function(t, i) {
      var s = e.config.yaxis[i];
      if (s && !s.floating && s.labels.align !== void 0) {
        var a = e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")), n = z.listToArray(e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"))), o = a.getBoundingClientRect();
        n.forEach(function(l) {
          l.setAttribute("text-anchor", s.labels.align);
        }), s.labels.align !== "left" || s.opposite ? s.labels.align === "center" ? a.setAttribute("transform", "translate(".concat(o.width / 2 * (s.opposite ? 1 : -1), ", 0)")) : s.labels.align === "right" && s.opposite && a.setAttribute("transform", "translate(".concat(o.width, ", 0)")) : a.setAttribute("transform", "translate(-".concat(o.width, ", 0)"));
      }
    });
  } }]), r;
}(), Zh = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.documentEvent = z.bind(this.documentEvent, this);
  }
  return te(r, [{ key: "addEventListener", value: function(e, t) {
    var i = this.w;
    i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t];
  } }, { key: "removeEventListener", value: function(e, t) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(e)) {
      var s = i.globals.events[e].indexOf(t);
      s !== -1 && i.globals.events[e].splice(s, 1);
    }
  } }, { key: "fireEvent", value: function(e, t) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(e)) {
      t && t.length || (t = []);
      for (var s = i.globals.events[e], a = s.length, n = 0; n < a; n++) s[n].apply(null, t);
    }
  } }, { key: "setupEventHandlers", value: function() {
    var e = this, t = this.w, i = this.ctx, s = t.globals.dom.baseEl.querySelector(t.globals.chartClass);
    this.ctx.eventList.forEach(function(a) {
      s.addEventListener(a, function(n) {
        var o = n.target.getAttribute("i") === null && t.globals.capturedSeriesIndex !== -1 ? t.globals.capturedSeriesIndex : n.target.getAttribute("i"), l = n.target.getAttribute("j") === null && t.globals.capturedDataPointIndex !== -1 ? t.globals.capturedDataPointIndex : n.target.getAttribute("j"), c = Object.assign({}, t, { seriesIndex: t.globals.axisCharts ? o : 0, dataPointIndex: l });
        n.type === "mousemove" || n.type === "touchmove" ? typeof t.config.chart.events.mouseMove == "function" && t.config.chart.events.mouseMove(n, i, c) : n.type === "mouseleave" || n.type === "touchleave" ? typeof t.config.chart.events.mouseLeave == "function" && t.config.chart.events.mouseLeave(n, i, c) : (n.type === "mouseup" && n.which === 1 || n.type === "touchend") && (typeof t.config.chart.events.click == "function" && t.config.chart.events.click(n, i, c), i.ctx.events.fireEvent("click", [n, i, c]));
      }, { capture: !1, passive: !0 });
    }), this.ctx.eventList.forEach(function(a) {
      t.globals.dom.baseEl.addEventListener(a, e.documentEvent, { passive: !0 });
    }), this.ctx.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(e) {
    var t = this.w, i = e.target.className;
    if (e.type === "click") {
      var s = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
      s && s.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && s.classList.remove("apexcharts-menu-open");
    }
    t.globals.clientX = e.type === "touchmove" ? e.touches[0].clientX : e.clientX, t.globals.clientY = e.type === "touchmove" ? e.touches[0].clientY : e.clientY;
  } }]), r;
}(), Jh = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "setCurrentLocaleValues", value: function(e) {
    var t = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i = t.filter(function(a) {
      return a.name === e;
    })[0];
    if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var s = z.extend(yo, i);
    this.w.globals.locale = s.options;
  } }]), r;
}(), Kh = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "drawAxis", value: function(e, t) {
    var i, s, a = this, n = this.w.globals, o = this.w.config, l = new Mi(this.ctx, t), c = new Jr(this.ctx, t);
    n.axisCharts && e !== "radar" && (n.isBarHorizontal ? (s = c.drawYaxisInversed(0), i = l.drawXaxisInversed(0), n.dom.elGraphical.add(i), n.dom.elGraphical.add(s)) : (i = l.drawXaxis(), n.dom.elGraphical.add(i), o.yaxis.map(function(h, d) {
      if (n.ignoreYAxisIndexes.indexOf(d) === -1 && (s = c.drawYaxis(d), n.dom.Paper.add(s), a.w.config.grid.position === "back")) {
        var u = n.dom.Paper.children()[1];
        u.remove(), n.dom.Paper.add(u);
      }
    })));
  } }]), r;
}(), vr = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "drawXCrosshairs", value: function() {
    var e = this.w, t = new B(this.ctx), i = new je(this.ctx), s = e.config.xaxis.crosshairs.fill.gradient, a = e.config.xaxis.crosshairs.dropShadow, n = e.config.xaxis.crosshairs.fill.type, o = s.colorFrom, l = s.colorTo, c = s.opacityFrom, h = s.opacityTo, d = s.stops, u = a.enabled, g = a.left, p = a.top, f = a.blur, x = a.color, m = a.opacity, b = e.config.xaxis.crosshairs.fill.color;
    if (e.config.xaxis.crosshairs.show) {
      n === "gradient" && (b = t.drawGradient("vertical", o, l, c, h, null, d, null));
      var w = t.drawRect();
      e.config.xaxis.crosshairs.width === 1 && (w = t.drawLine());
      var y = e.globals.gridHeight;
      (!z.isNumber(y) || y < 0) && (y = 0);
      var v = e.config.xaxis.crosshairs.width;
      (!z.isNumber(v) || v < 0) && (v = 0), w.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: y, width: v, height: y, fill: b, filter: "none", "fill-opacity": e.config.xaxis.crosshairs.opacity, stroke: e.config.xaxis.crosshairs.stroke.color, "stroke-width": e.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray }), u && (w = i.dropShadow(w, { left: g, top: p, blur: f, color: x, opacity: m })), e.globals.dom.elGraphical.add(w);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var e = this.w, t = new B(this.ctx), i = e.config.yaxis[0].crosshairs, s = e.globals.barPadForNumericAxis;
    if (e.config.yaxis[0].crosshairs.show) {
      var a = t.drawLine(-s, 0, e.globals.gridWidth + s, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
      a.attr({ class: "apexcharts-ycrosshairs" }), e.globals.dom.elGraphical.add(a);
    }
    var n = t.drawLine(-s, 0, e.globals.gridWidth + s, 0, i.stroke.color, 0, 0);
    n.attr({ class: "apexcharts-ycrosshairs-hidden" }), e.globals.dom.elGraphical.add(n);
  } }]), r;
}(), Qh = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "checkResponsiveConfig", value: function(e) {
    var t = this, i = this.w, s = i.config;
    if (s.responsive.length !== 0) {
      var a = s.responsive.slice();
      a.sort(function(c, h) {
        return c.breakpoint > h.breakpoint ? 1 : h.breakpoint > c.breakpoint ? -1 : 0;
      }).reverse();
      var n = new Ai({}), o = function() {
        var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = a[0].breakpoint, d = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (d > h) {
          var u = z.clone(i.globals.initialConfig);
          u.series = z.clone(i.config.series);
          var g = ze.extendArrayProps(n, u, i);
          c = z.extend(g, c), c = z.extend(i.config, c), t.overrideResponsiveOptions(c);
        } else for (var p = 0; p < a.length; p++) d < a[p].breakpoint && (c = ze.extendArrayProps(n, a[p].options, i), c = z.extend(i.config, c), t.overrideResponsiveOptions(c));
      };
      if (e) {
        var l = ze.extendArrayProps(n, e, i);
        l = z.extend(i.config, l), o(l = z.extend(l, e));
      } else o({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(e) {
    var t = new Ai(e).init({ responsiveOverride: !0 });
    this.w.config = t;
  } }]), r;
}(), ed = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.colors = [], this.isColorFn = !1, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return te(r, [{ key: "checkHeatmapDistributed", value: function() {
    var e = this.w.config, t = e.chart, i = e.plotOptions;
    return t.type === "treemap" && i.treemap && i.treemap.distributed || t.type === "heatmap" && i.heatmap && i.heatmap.distributed;
  } }, { key: "checkBarDistributed", value: function() {
    var e = this.w.config, t = e.chart, i = e.plotOptions;
    return i.bar && i.bar.distributed && (t.type === "bar" || t.type === "rangeBar");
  } }, { key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var e = this.w, t = new z();
    e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode || "light"));
    var i = De(e.config.colors || e.config.fill.colors || []);
    e.globals.colors = this.getColors(i), this.applySeriesColors(e.globals.seriesColors, e.globals.colors), e.config.theme.monochrome.enabled && (e.globals.colors = this.getMonochromeColors(e.config.theme.monochrome, e.globals.series, t));
    var s = e.globals.colors.slice();
    this.pushExtraColors(e.globals.colors), this.applyColorTypes(["fill", "stroke"], s), this.applyDataLabelsColors(s), this.applyRadarPolygonsColors(), this.applyMarkersColors(s);
  } }, { key: "getColors", value: function(e) {
    var t = this, i = this.w;
    return e && e.length !== 0 ? Array.isArray(e) && e.length > 0 && typeof e[0] == "function" ? (this.isColorFn = !0, i.config.series.map(function(s, a) {
      var n = e[a] || e[0];
      return typeof n == "function" ? n({ value: i.globals.axisCharts ? i.globals.series[a][0] || 0 : i.globals.series[a], seriesIndex: a, dataPointIndex: a, w: t.w }) : n;
    })) : e : this.predefined();
  } }, { key: "applySeriesColors", value: function(e, t) {
    e.forEach(function(i, s) {
      i && (t[s] = i);
    });
  } }, { key: "getMonochromeColors", value: function(e, t, i) {
    var s = e.color, a = e.shadeIntensity, n = e.shadeTo, o = this.isBarDistributed || this.isHeatmapDistributed ? t[0].length * t.length : t.length, l = 1 / (o / a), c = 0;
    return Array.from({ length: o }, function() {
      var h = n === "dark" ? i.shadeColor(-1 * c, s) : i.shadeColor(c, s);
      return c += l, h;
    });
  } }, { key: "applyColorTypes", value: function(e, t) {
    var i = this, s = this.w;
    e.forEach(function(a) {
      s.globals[a].colors = s.config[a].colors === void 0 ? i.isColorFn ? s.config.colors : t : s.config[a].colors.slice(), i.pushExtraColors(s.globals[a].colors);
    });
  } }, { key: "applyDataLabelsColors", value: function(e) {
    var t = this.w;
    t.globals.dataLabels.style.colors = t.config.dataLabels.style.colors === void 0 ? e : t.config.dataLabels.style.colors.slice(), this.pushExtraColors(t.globals.dataLabels.style.colors, 50);
  } }, { key: "applyRadarPolygonsColors", value: function() {
    var e = this.w;
    e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors === void 0 ? [e.config.theme.mode === "dark" ? "#343A3F" : "none"] : e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20);
  } }, { key: "applyMarkersColors", value: function(e) {
    var t = this.w;
    t.globals.markers.colors = t.config.markers.colors === void 0 ? e : t.config.markers.colors.slice(), this.pushExtraColors(t.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, s = this.w, a = t || s.globals.series.length;
    if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || s.config.chart.type === "heatmap" && s.config.plotOptions.heatmap && s.config.plotOptions.heatmap.colorScale.inverse), i && s.globals.series.length && (a = s.globals.series[s.globals.maxValsInArrayIndex].length * s.globals.series.length), e.length < a) for (var n = a - e.length, o = 0; o < n; o++) e.push(e[o]);
  } }, { key: "updateThemeOptions", value: function(e) {
    e.chart = e.chart || {}, e.tooltip = e.tooltip || {};
    var t = e.theme.mode, i = t === "dark" ? "palette4" : t === "light" ? "palette1" : e.theme.palette || "palette1", s = t === "dark" ? "#f6f7f8" : t === "light" ? "#373d3f" : e.chart.foreColor || "#373d3f";
    return e.tooltip.theme = t || "light", e.chart.foreColor = s, e.theme.palette = i, e;
  } }, { key: "predefined", value: function() {
    var e = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
    return e[this.w.config.theme.palette] || e.default;
  } }]), r;
}(), td = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(e) {
    var t = this.w, i = e === "title" ? t.config.title : t.config.subtitle, s = t.globals.svgWidth / 2, a = i.offsetY, n = "middle";
    if (i.align === "left" ? (s = 10, n = "start") : i.align === "right" && (s = t.globals.svgWidth - 10, n = "end"), s += i.offsetX, a = a + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
      var o = new B(this.ctx).drawText({ x: s, y: a, text: i.text, textAnchor: n, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
      o.node.setAttribute("class", "apexcharts-".concat(e, "-text")), t.globals.dom.Paper.add(o);
    }
  } }]), r;
}(), id = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.dCtx = e;
  }
  return te(r, [{ key: "getTitleSubtitleCoords", value: function(e) {
    var t = this.w, i = 0, s = 0, a = e === "title" ? t.config.title.floating : t.config.subtitle.floating, n = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
    if (n !== null && !a) {
      var o = n.getBoundingClientRect();
      i = o.width, s = t.globals.axisCharts ? o.height + 5 : o.height;
    }
    return { width: i, height: s };
  } }, { key: "getLegendsRect", value: function() {
    var e = this.w, t = e.globals.dom.elLegendWrap;
    e.config.legend.height || e.config.legend.position !== "top" && e.config.legend.position !== "bottom" || (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
    var i = Object.assign({}, z.getBoundingClientRect(t));
    return t !== null && !e.config.legend.floating && e.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, e.config.legend.position !== "left" && e.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: "getDatalabelsRect", value: function() {
    var e = this, t = this.w, i = [];
    t.config.series.forEach(function(l, c) {
      l.data.forEach(function(h, d) {
        var u;
        u = t.globals.series[c][d], s = t.config.dataLabels.formatter(u, { ctx: e.dCtx.ctx, seriesIndex: c, dataPointIndex: d, w: t }), i.push(s);
      });
    });
    var s = z.getLargestStringFromArr(i), a = new B(this.dCtx.ctx), n = t.config.dataLabels.style, o = a.getTextRects(s, parseInt(n.fontSize), n.fontFamily);
    return { width: 1.05 * o.width, height: o.height };
  } }, { key: "getLargestStringFromMultiArr", value: function(e, t) {
    var i = e;
    if (this.w.globals.isMultiLineX) {
      var s = t.map(function(n, o) {
        return Array.isArray(n) ? n.length : 1;
      }), a = Math.max.apply(Math, De(s));
      i = t[s.indexOf(a)];
    }
    return i;
  } }]), r;
}(), sd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.dCtx = e;
  }
  return te(r, [{ key: "getxAxisLabelsCoords", value: function() {
    var e, t = this.w, i = t.globals.labels.slice();
    if (t.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = t.globals.categoryLabels), t.globals.timescaleLabels.length > 0) {
      var s = this.getxAxisTimeScaleLabelsCoords();
      e = { width: s.width, height: s.height }, t.globals.rotateXLabels = !1;
    } else {
      this.dCtx.lgWidthForSideLegends = t.config.legend.position !== "left" && t.config.legend.position !== "right" || t.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var a = t.globals.xLabelFormatter, n = z.getLargestStringFromArr(i), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, i);
      t.globals.isBarHorizontal && (o = n = t.globals.yAxisScale[0].result.reduce(function(p, f) {
        return p.length > f.length ? p : f;
      }, 0));
      var l = new Ti(this.dCtx.ctx), c = n;
      n = l.xLabelFormat(a, n, c, { i: void 0, dateFormatter: new Ye(this.dCtx.ctx).formatDate, w: t }), o = l.xLabelFormat(a, o, c, { i: void 0, dateFormatter: new Ye(this.dCtx.ctx).formatDate, w: t }), (t.config.xaxis.convertedCatToNumeric && n === void 0 || String(n).trim() === "") && (o = n = "1");
      var h = new B(this.dCtx.ctx), d = h.getTextRects(n, t.config.xaxis.labels.style.fontSize), u = d;
      if (n !== o && (u = h.getTextRects(o, t.config.xaxis.labels.style.fontSize)), (e = { width: d.width >= u.width ? d.width : u.width, height: d.height >= u.height ? d.height : u.height }).width * i.length > t.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && t.config.xaxis.labels.rotate !== 0 || t.config.xaxis.labels.rotateAlways) {
        if (!t.globals.isBarHorizontal) {
          t.globals.rotateXLabels = !0;
          var g = function(p) {
            return h.getTextRects(p, t.config.xaxis.labels.style.fontSize, t.config.xaxis.labels.style.fontFamily, "rotate(".concat(t.config.xaxis.labels.rotate, " 0 0)"), !1);
          };
          d = g(n), n !== o && (u = g(o)), e.height = (d.height > u.height ? d.height : u.height) / 1.5, e.width = d.width > u.width ? d.width : u.width;
        }
      } else t.globals.rotateXLabels = !1;
    }
    return t.config.xaxis.labels.show || (e = { width: 0, height: 0 }), { width: e.width, height: e.height };
  } }, { key: "getxAxisGroupLabelsCoords", value: function() {
    var e, t = this.w;
    if (!t.globals.hasXaxisGroups) return { width: 0, height: 0 };
    var i, s = ((e = t.config.xaxis.group.style) === null || e === void 0 ? void 0 : e.fontSize) || t.config.xaxis.labels.style.fontSize, a = t.globals.groups.map(function(d) {
      return d.title;
    }), n = z.getLargestStringFromArr(a), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, a), l = new B(this.dCtx.ctx), c = l.getTextRects(n, s), h = c;
    return n !== o && (h = l.getTextRects(o, s)), i = { width: c.width >= h.width ? c.width : h.width, height: c.height >= h.height ? c.height : h.height }, t.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
  } }, { key: "getxAxisTitleCoords", value: function() {
    var e = this.w, t = 0, i = 0;
    if (e.config.xaxis.title.text !== void 0) {
      var s = new B(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize);
      t = s.width, i = s.height;
    }
    return { width: t, height: i };
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var e, t = this.w;
    this.dCtx.timescaleLabels = t.globals.timescaleLabels.slice();
    var i = this.dCtx.timescaleLabels.map(function(a) {
      return a.value;
    }), s = i.reduce(function(a, n) {
      return a === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : a.length > n.length ? a : n;
    }, 0);
    return 1.05 * (e = new B(this.dCtx.ctx).getTextRects(s, t.config.xaxis.labels.style.fontSize)).width * i.length > t.globals.gridWidth && t.config.xaxis.labels.rotate !== 0 && (t.globals.overlappingXLabels = !0), e;
  } }, { key: "additionalPaddingXLabels", value: function(e) {
    var t = this, i = this.w, s = i.globals, a = i.config, n = a.xaxis.type, o = e.width;
    s.skipLastTimelinelabel = !1, s.skipFirstTimelinelabel = !1;
    var l = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, c = function(h, d) {
      a.yaxis.length > 1 && function(u) {
        return s.collapsedSeriesIndices.indexOf(u) !== -1;
      }(d) || function(u) {
        if (t.dCtx.timescaleLabels && t.dCtx.timescaleLabels.length) {
          var g = t.dCtx.timescaleLabels[0], p = t.dCtx.timescaleLabels[t.dCtx.timescaleLabels.length - 1].position + o / 1.75 - t.dCtx.yAxisWidthRight, f = g.position - o / 1.75 + t.dCtx.yAxisWidthLeft, x = i.config.legend.position === "right" && t.dCtx.lgRect.width > 0 ? t.dCtx.lgRect.width : 0;
          p > s.svgWidth - s.translateX - x && (s.skipLastTimelinelabel = !0), f < -(u.show && !u.floating || a.chart.type !== "bar" && a.chart.type !== "candlestick" && a.chart.type !== "rangeBar" && a.chart.type !== "boxPlot" ? 10 : o / 1.75) && (s.skipFirstTimelinelabel = !0);
        } else n === "datetime" ? t.dCtx.gridPad.right < o && !s.rotateXLabels && (s.skipLastTimelinelabel = !0) : n !== "datetime" && t.dCtx.gridPad.right < o / 2 - t.dCtx.yAxisWidthRight && !s.rotateXLabels && !i.config.xaxis.labels.trim && (t.dCtx.xPadRight = o / 2 + 1);
      }(h);
    };
    a.yaxis.forEach(function(h, d) {
      l ? (t.dCtx.gridPad.left < o && (t.dCtx.xPadLeft = o / 2 + 1), t.dCtx.xPadRight = o / 2 + 1) : c(h, d);
    });
  } }]), r;
}(), rd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.dCtx = e;
  }
  return te(r, [{ key: "getyAxisLabelsCoords", value: function() {
    var e = this, t = this.w, i = [], s = 10, a = new Pt(this.dCtx.ctx);
    return t.config.yaxis.map(function(n, o) {
      var l = { seriesIndex: o, dataPointIndex: -1, w: t }, c = t.globals.yAxisScale[o], h = 0;
      if (!a.isYAxisHidden(o) && n.labels.show && n.labels.minWidth !== void 0 && (h = n.labels.minWidth), !a.isYAxisHidden(o) && n.labels.show && c.result.length) {
        var d = t.globals.yLabelFormatters[o], u = c.niceMin === Number.MIN_VALUE ? 0 : c.niceMin, g = c.result.reduce(function(y, v) {
          var S, k;
          return ((S = String(d(y, l))) === null || S === void 0 ? void 0 : S.length) > ((k = String(d(v, l))) === null || k === void 0 ? void 0 : k.length) ? y : v;
        }, u), p = g = d(g, l);
        if (g !== void 0 && g.length !== 0 || (g = c.niceMax), t.globals.isBarHorizontal) {
          s = 0;
          var f = t.globals.labels.slice();
          g = z.getLargestStringFromArr(f), g = d(g, { seriesIndex: o, dataPointIndex: -1, w: t }), p = e.dCtx.dimHelpers.getLargestStringFromMultiArr(g, f);
        }
        var x = new B(e.dCtx.ctx), m = "rotate(".concat(n.labels.rotate, " 0 0)"), b = x.getTextRects(g, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1), w = b;
        g !== p && (w = x.getTextRects(p, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1)), i.push({ width: (h > w.width || h > b.width ? h : w.width > b.width ? w.width : b.width) + s, height: w.height > b.height ? w.height : b.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getyAxisTitleCoords", value: function() {
    var e = this, t = this.w, i = [];
    return t.config.yaxis.map(function(s, a) {
      if (s.show && s.title.text !== void 0) {
        var n = new B(e.dCtx.ctx), o = "rotate(".concat(s.title.rotate, " 0 0)"), l = n.getTextRects(s.title.text, s.title.style.fontSize, s.title.style.fontFamily, o, !1);
        i.push({ width: l.width, height: l.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var e = this.w, t = 0, i = 0, s = 0, a = e.globals.yAxisScale.length > 1 ? 10 : 0, n = new Pt(this.dCtx.ctx), o = function(l, c) {
      var h = e.config.yaxis[c].floating, d = 0;
      l.width > 0 && !h ? (d = l.width + a, function(u) {
        return e.globals.ignoreYAxisIndexes.indexOf(u) > -1;
      }(c) && (d = d - l.width - a)) : d = h || n.isYAxisHidden(c) ? 0 : 5, e.config.yaxis[c].opposite ? s += d : i += d, t += d;
    };
    return e.globals.yLabelsCoords.map(function(l, c) {
      o(l, c);
    }), e.globals.yTitleCoords.map(function(l, c) {
      o(l, c);
    }), e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = s, t;
  } }]), r;
}(), ad = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.dCtx = e;
  }
  return te(r, [{ key: "gridPadForColumnsInNumericAxis", value: function(e) {
    var t = this.w, i = t.config, s = t.globals;
    if (s.noData || s.collapsedSeries.length + s.ancillaryCollapsedSeries.length === i.series.length) return 0;
    var a = function(g) {
      return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(g);
    }, n = i.chart.type, o = 0, l = a(n) ? i.series.length : 1;
    s.comboBarCount > 0 && (l = s.comboBarCount), s.collapsedSeries.forEach(function(g) {
      a(g.type) && (l -= 1);
    }), i.chart.stacked && (l = 1);
    var c = a(n) || s.comboBarCount > 0, h = Math.abs(s.initialMaxX - s.initialMinX);
    if (c && s.isXNumeric && !s.isBarHorizontal && l > 0 && h !== 0) {
      h <= 3 && (h = s.dataPoints);
      var d = h / e, u = s.minXDiff && s.minXDiff / d > 0 ? s.minXDiff / d : 0;
      u > e / 2 && (u /= 2), (o = u * parseInt(i.plotOptions.bar.columnWidth, 10) / 100) < 1 && (o = 1), s.barPadForNumericAxis = o;
    }
    return o;
  } }, { key: "gridPadFortitleSubtitle", value: function() {
    var e = this, t = this.w, i = t.globals, s = this.dCtx.isSparkline || !i.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach(function(o) {
      t.config[o].text !== void 0 ? s += t.config[o].margin : s += e.dCtx.isSparkline || !i.axisCharts ? 0 : 5;
    }), !t.config.legend.show || t.config.legend.position !== "bottom" || t.config.legend.floating || i.axisCharts || (s += 10);
    var a = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), n = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    i.gridHeight -= a.height + n.height + s, i.translateY += a.height + n.height + s;
  } }, { key: "setGridXPosForDualYAxis", value: function(e, t) {
    var i = this.w, s = new Pt(this.dCtx.ctx);
    i.config.yaxis.forEach(function(a, n) {
      i.globals.ignoreYAxisIndexes.indexOf(n) !== -1 || a.floating || s.isYAxisHidden(n) || (a.opposite && (i.globals.translateX -= t[n].width + e[n].width + parseInt(a.labels.style.fontSize, 10) / 1.2 + 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
    });
  } }]), r;
}(), es = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new id(this), this.dimYAxis = new rd(this), this.dimXAxis = new sd(this), this.dimGrid = new ad(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return te(r, [{ key: "plotCoords", value: function() {
    var e = this, t = this.w, i = t.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var s = Array.isArray(t.config.stroke.width) ? Math.max.apply(Math, De(t.config.stroke.width)) : t.config.stroke.width;
    this.isSparkline && ((t.config.markers.discrete.length > 0 || t.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(n) {
      var o = Vn(n, 2), l = o[0], c = o[1];
      e.gridPad[l] = Math.max(c, e.w.globals.markers.largestSize / 1.5);
    }), this.gridPad.top = Math.max(s / 2, this.gridPad.top), this.gridPad.bottom = Math.max(s / 2, this.gridPad.bottom)), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var a = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
    i.gridWidth = i.gridWidth - 2 * a, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (a > 0 ? a : 0), i.translateY = i.translateY + this.gridPad.top;
  } }, { key: "setDimensionsForAxisCharts", value: function() {
    var e = this, t = this.w, i = t.globals, s = this.dimYAxis.getyAxisLabelsCoords(), a = this.dimYAxis.getyAxisTitleCoords();
    i.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), t.globals.yLabelsCoords = [], t.globals.yTitleCoords = [], t.config.yaxis.map(function(g, p) {
      t.globals.yLabelsCoords.push({ width: s[p].width, index: p }), t.globals.yTitleCoords.push({ width: a[p].width, index: p });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var n = this.dimXAxis.getxAxisLabelsCoords(), o = this.dimXAxis.getxAxisGroupLabelsCoords(), l = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(n, l, o), i.translateXAxisY = t.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = t.globals.rotateXLabels && t.globals.isXNumeric && t.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, t.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(t.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + t.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + t.config.xaxis.labels.offsetX;
    var c = this.yAxisWidth, h = this.xAxisHeight;
    i.xAxisLabelsHeight = this.xAxisHeight - l.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - n.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
    var d = 10;
    (t.config.chart.type === "radar" || this.isSparkline) && (c = 0, h = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || t.config.chart.type === "treemap") && (c = 0, h = 0, d = 0), this.isSparkline || t.config.chart.type === "treemap" || this.dimXAxis.additionalPaddingXLabels(n);
    var u = function() {
      i.translateX = c + e.datalabelsCoords.width, i.gridHeight = i.svgHeight - e.lgRect.height - h - (e.isSparkline || t.config.chart.type === "treemap" ? 0 : t.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - c - 2 * e.datalabelsCoords.width;
    };
    switch (t.config.xaxis.position === "top" && (d = i.xAxisHeight - t.config.xaxis.axisTicks.height - 5), t.config.legend.position) {
      case "bottom":
        i.translateY = d, u();
        break;
      case "top":
        i.translateY = this.lgRect.height + d, u();
        break;
      case "left":
        i.translateY = d, i.translateX = this.lgRect.width + c + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h - 12, i.gridWidth = i.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width;
        break;
      case "right":
        i.translateY = d, i.translateX = c + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h - 12, i.gridWidth = i.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(a, s), new Jr(this.ctx).setYAxisXPosition(s, a);
  } }, { key: "setDimensionsForNonAxisCharts", value: function() {
    var e = this.w, t = e.globals, i = e.config, s = 0;
    e.config.legend.show && !e.config.legend.floating && (s = 20);
    var a = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar", n = i.plotOptions[a].offsetY, o = i.plotOptions[a].offsetX;
    if (!i.legend.show || i.legend.floating) {
      t.gridHeight = t.svgHeight;
      var l = t.dom.elWrap.getBoundingClientRect().width;
      return t.gridWidth = Math.min(l, t.gridHeight), t.translateY = n, void (t.translateX = o + (t.svgWidth - t.gridWidth) / 2);
    }
    switch (i.legend.position) {
      case "bottom":
        t.gridHeight = t.svgHeight - this.lgRect.height, t.gridWidth = t.svgWidth, t.translateY = n - 10, t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "top":
        t.gridHeight = t.svgHeight - this.lgRect.height, t.gridWidth = t.svgWidth, t.translateY = this.lgRect.height + n + 10, t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "left":
        t.gridWidth = t.svgWidth - this.lgRect.width - s, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = n, t.translateX = o + this.lgRect.width + s;
        break;
      case "right":
        t.gridWidth = t.svgWidth - this.lgRect.width - s - 5, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = n, t.translateX = o + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "conditionalChecksForAxisCoords", value: function(e, t, i) {
    var s = this.w, a = s.globals.hasXaxisGroups ? 2 : 1, n = i.height + e.height + t.height, o = s.globals.isMultiLineX ? 1.2 : s.globals.LINE_HEIGHT_RATIO, l = s.globals.rotateXLabels ? 22 : 10, c = s.globals.rotateXLabels && s.config.legend.position === "bottom" ? 10 : 0;
    this.xAxisHeight = n * o + a * l + c, this.xAxisWidth = e.width, this.xAxisHeight - t.height > s.config.xaxis.labels.maxHeight && (this.xAxisHeight = s.config.xaxis.labels.maxHeight), s.config.xaxis.labels.minHeight && this.xAxisHeight < s.config.xaxis.labels.minHeight && (this.xAxisHeight = s.config.xaxis.labels.minHeight), s.config.xaxis.floating && (this.xAxisHeight = 0);
    var h = 0, d = 0;
    s.config.yaxis.forEach(function(u) {
      h += u.labels.minWidth, d += u.labels.maxWidth;
    }), this.yAxisWidth < h && (this.yAxisWidth = h), this.yAxisWidth > d && (this.yAxisWidth = d);
  } }]), r;
}(), nd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.lgCtx = e;
  }
  return te(r, [{ key: "getLegendStyles", value: function() {
    var e, t, i, s = document.createElement("style");
    s.setAttribute("type", "text/css");
    var a = ((e = this.lgCtx.ctx) === null || e === void 0 || (t = e.opts) === null || t === void 0 || (i = t.chart) === null || i === void 0 ? void 0 : i.nonce) || this.w.config.chart.nonce;
    a && s.setAttribute("nonce", a);
    var n = document.createTextNode(`
      .apexcharts-flip-y {
        transform: scaleY(-1) translateY(-100%);
        transform-origin: top;
        transform-box: fill-box;
      }
      .apexcharts-flip-x {
        transform: scaleX(-1);
        transform-origin: center;
        transform-box: fill-box;
      }
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apexcharts-legend-group-horizontal {
        flex-direction: column;
      }
      .apexcharts-legend-group {
        display: flex;
      }
      .apexcharts-legend-group-vertical {
        flex-direction: column-reverse;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
        align-items: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
        align-items: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
        align-items: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 1px;
      }

      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }

    `);
    return s.appendChild(n), s;
  } }, { key: "getLegendDimensions", value: function() {
    var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), t = e.width;
    return { clwh: e.height, clww: t };
  } }, { key: "appendToForeignObject", value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: "toggleDataSeries", value: function(e, t) {
    var i = this, s = this.w;
    if (s.globals.axisCharts || s.config.chart.type === "radialBar") {
      s.globals.resized = !0;
      var a = null, n = null;
      s.globals.risingSeries = [], s.globals.axisCharts ? (a = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")), n = parseInt(a.getAttribute("data:realIndex"), 10)) : (a = s.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")), n = parseInt(a.getAttribute("rel"), 10) - 1), t ? [{ cs: s.globals.collapsedSeries, csi: s.globals.collapsedSeriesIndices }, { cs: s.globals.ancillaryCollapsedSeries, csi: s.globals.ancillaryCollapsedSeriesIndices }].forEach(function(h) {
        i.riseCollapsedSeries(h.cs, h.csi, n);
      }) : this.hideSeries({ seriesEl: a, realIndex: n });
    } else {
      var o = s.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(e + 1, "'] path")), l = s.config.chart.type;
      if (l === "pie" || l === "polarArea" || l === "donut") {
        var c = s.config.plotOptions.pie.donut.labels;
        new B(this.lgCtx.ctx).pathMouseDown(o, null), this.lgCtx.ctx.pie.printDataLabelsInner(o.node, c);
      }
      o.fire("click");
    }
  } }, { key: "getSeriesAfterCollapsing", value: function(e) {
    var t = e.realIndex, i = this.w, s = i.globals, a = z.clone(i.config.series);
    if (s.axisCharts) {
      var n = i.config.yaxis[s.seriesYAxisReverseMap[t]], o = { index: t, data: a[t].data.slice(), type: a[t].type || i.config.chart.type };
      if (n && n.show && n.showAlways) s.ancillaryCollapsedSeriesIndices.indexOf(t) < 0 && (s.ancillaryCollapsedSeries.push(o), s.ancillaryCollapsedSeriesIndices.push(t));
      else if (s.collapsedSeriesIndices.indexOf(t) < 0) {
        s.collapsedSeries.push(o), s.collapsedSeriesIndices.push(t);
        var l = s.risingSeries.indexOf(t);
        s.risingSeries.splice(l, 1);
      }
    } else s.collapsedSeries.push({ index: t, data: a[t] }), s.collapsedSeriesIndices.push(t);
    return s.allSeriesCollapsed = s.collapsedSeries.length + s.ancillaryCollapsedSeries.length === i.config.series.length, this._getSeriesBasedOnCollapsedState(a);
  } }, { key: "hideSeries", value: function(e) {
    for (var t = e.seriesEl, i = e.realIndex, s = this.w, a = this.getSeriesAfterCollapsing({ realIndex: i }), n = t.childNodes, o = 0; o < n.length; o++) n[o].classList.contains("apexcharts-series-markers-wrap") && (n[o].classList.contains("apexcharts-hide") ? n[o].classList.remove("apexcharts-hide") : n[o].classList.add("apexcharts-hide"));
    this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "riseCollapsedSeries", value: function(e, t, i) {
    var s = this.w, a = z.clone(s.config.series);
    if (e.length > 0) {
      for (var n = 0; n < e.length; n++) e[n].index === i && (s.globals.axisCharts ? a[i].data = e[n].data.slice() : a[i] = e[n].data, typeof a[i] != "number" && (a[i].hidden = !1), e.splice(n, 1), t.splice(n, 1), s.globals.risingSeries.push(i));
      a = this._getSeriesBasedOnCollapsedState(a), this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: "_getSeriesBasedOnCollapsedState", value: function(e) {
    var t = this.w, i = 0;
    return t.globals.axisCharts ? e.forEach(function(s, a) {
      t.globals.collapsedSeriesIndices.indexOf(a) < 0 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(a) < 0 || (e[a].data = [], i++);
    }) : e.forEach(function(s, a) {
      !t.globals.collapsedSeriesIndices.indexOf(a) < 0 && (e[a] = 0, i++);
    }), t.globals.allSeriesCollapsed = i === e.length, e;
  } }]), r;
}(), Ao = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new nd(this);
  }
  return te(r, [{ key: "init", value: function() {
    var e = this.w, t = e.globals, i = e.config, s = i.legend.showForSingleSeries && t.series.length === 1 || this.isBarsDistributed || t.series.length > 1;
    if (this.legendHelpers.appendToForeignObject(), (s || !t.axisCharts) && i.legend.show) {
      for (; t.dom.elLegendWrap.firstChild; ) t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
      this.drawLegends(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : i.legend.position !== "right" && i.legend.position !== "left" || this.legendAlignVertical();
    }
  } }, { key: "createLegendMarker", value: function(e) {
    var t = e.i, i = e.fillcolor, s = this.w, a = document.createElement("span");
    a.classList.add("apexcharts-legend-marker");
    var n = s.config.legend.markers.shape || s.config.markers.shape, o = n;
    Array.isArray(n) && (o = n[t]);
    var l = Array.isArray(s.config.legend.markers.size) ? parseFloat(s.config.legend.markers.size[t]) : parseFloat(s.config.legend.markers.size), c = Array.isArray(s.config.legend.markers.offsetX) ? parseFloat(s.config.legend.markers.offsetX[t]) : parseFloat(s.config.legend.markers.offsetX), h = Array.isArray(s.config.legend.markers.offsetY) ? parseFloat(s.config.legend.markers.offsetY[t]) : parseFloat(s.config.legend.markers.offsetY), d = Array.isArray(s.config.legend.markers.strokeWidth) ? parseFloat(s.config.legend.markers.strokeWidth[t]) : parseFloat(s.config.legend.markers.strokeWidth), u = a.style;
    if (u.height = 2 * (l + d) + "px", u.width = 2 * (l + d) + "px", u.left = c + "px", u.top = h + "px", s.config.legend.markers.customHTML) u.background = "transparent", u.color = i[t], Array.isArray(s.config.legend.markers.customHTML) ? s.config.legend.markers.customHTML[t] && (a.innerHTML = s.config.legend.markers.customHTML[t]()) : a.innerHTML = s.config.legend.markers.customHTML();
    else {
      var g = new ai(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(o), seriesIndex: t, strokeWidth: d, size: l }), p = window.SVG().addTo(a).size("100%", "100%"), f = new B(this.ctx).drawMarker(0, 0, q(q({}, g), {}, { pointFillColor: Array.isArray(i) ? i[t] : g.pointFillColor, shape: o }));
      s.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach(function(x) {
        x.node.classList.contains("apexcharts-marker-triangle") ? x.node.style.transform = "translate(50%, 45%)" : x.node.style.transform = "translate(50%, 50%)";
      }), p.add(f);
    }
    return a;
  } }, { key: "drawLegends", value: function() {
    var e = this, t = this, i = this.w, s = i.config.legend.fontFamily, a = i.globals.seriesNames, n = i.config.legend.markers.fillColors ? i.config.legend.markers.fillColors.slice() : i.globals.colors.slice();
    if (i.config.chart.type === "heatmap") {
      var o = i.config.plotOptions.heatmap.colorScale.ranges;
      a = o.map(function(g) {
        return g.name ? g.name : g.from + " - " + g.to;
      }), n = o.map(function(g) {
        return g.color;
      });
    } else this.isBarsDistributed && (a = i.globals.labels.slice());
    i.config.legend.customLegendItems.length && (a = i.config.legend.customLegendItems);
    var l = i.globals.legendFormatter, c = i.config.legend.inverseOrder, h = [];
    i.globals.seriesGroups.length > 1 && i.config.legend.clusterGroupedSeries && i.globals.seriesGroups.forEach(function(g, p) {
      h[p] = document.createElement("div"), h[p].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(p)), i.config.legend.clusterGroupedSeriesOrientation === "horizontal" ? i.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h[p].classList.add("apexcharts-legend-group-vertical");
    });
    for (var d = function(g) {
      var p, f = l(a[g], { seriesIndex: g, w: i }), x = !1, m = !1;
      if (i.globals.collapsedSeries.length > 0) for (var b = 0; b < i.globals.collapsedSeries.length; b++) i.globals.collapsedSeries[b].index === g && (x = !0);
      if (i.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var w = 0; w < i.globals.ancillaryCollapsedSeriesIndices.length; w++) i.globals.ancillaryCollapsedSeriesIndices[w] === g && (m = !0);
      var y = e.createLegendMarker({ i: g, fillcolor: n });
      B.setAttrs(y, { rel: g + 1, "data:collapsed": x || m }), (x || m) && y.classList.add("apexcharts-inactive-legend");
      var v = document.createElement("div"), S = document.createElement("span");
      S.classList.add("apexcharts-legend-text"), S.innerHTML = Array.isArray(f) ? f.join(" ") : f;
      var k = i.config.legend.labels.useSeriesColors ? i.globals.colors[g] : Array.isArray(i.config.legend.labels.colors) ? (p = i.config.legend.labels.colors) === null || p === void 0 ? void 0 : p[g] : i.config.legend.labels.colors;
      k || (k = i.config.chart.foreColor), S.style.color = k, S.style.fontSize = parseFloat(i.config.legend.fontSize) + "px", S.style.fontWeight = i.config.legend.fontWeight, S.style.fontFamily = s || i.config.chart.fontFamily, B.setAttrs(S, { rel: g + 1, i: g, "data:default-text": encodeURIComponent(f), "data:collapsed": x || m }), v.appendChild(y), v.appendChild(S);
      var C = new ze(e.ctx);
      i.config.legend.showForZeroSeries || C.getSeriesTotalByIndex(g) === 0 && C.seriesHaveSameValues(g) && !C.isSeriesNull(g) && i.globals.collapsedSeriesIndices.indexOf(g) === -1 && i.globals.ancillaryCollapsedSeriesIndices.indexOf(g) === -1 && v.classList.add("apexcharts-hidden-zero-series"), i.config.legend.showForNullSeries || C.isSeriesNull(g) && i.globals.collapsedSeriesIndices.indexOf(g) === -1 && i.globals.ancillaryCollapsedSeriesIndices.indexOf(g) === -1 && v.classList.add("apexcharts-hidden-null-series"), h.length ? i.globals.seriesGroups.forEach(function(R, P) {
        var A;
        R.includes((A = i.config.series[g]) === null || A === void 0 ? void 0 : A.name) && (i.globals.dom.elLegendWrap.appendChild(h[P]), h[P].appendChild(v));
      }) : i.globals.dom.elLegendWrap.appendChild(v), i.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i.config.legend.horizontalAlign)), i.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i.config.legend.position), v.classList.add("apexcharts-legend-series"), v.style.margin = "".concat(i.config.legend.itemMargin.vertical, "px ").concat(i.config.legend.itemMargin.horizontal, "px"), i.globals.dom.elLegendWrap.style.width = i.config.legend.width ? i.config.legend.width + "px" : "", i.globals.dom.elLegendWrap.style.height = i.config.legend.height ? i.config.legend.height + "px" : "", B.setAttrs(v, { rel: g + 1, seriesName: z.escapeString(a[g]), "data:collapsed": x || m }), (x || m) && v.classList.add("apexcharts-inactive-legend"), i.config.legend.onItemClick.toggleDataSeries || v.classList.add("apexcharts-no-click");
    }, u = c ? a.length - 1 : 0; c ? u >= 0 : u <= a.length - 1; c ? u-- : u++) d(u);
    i.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), i.config.legend.onItemHover.highlightDataSeries && i.config.legend.customLegendItems.length === 0 && (i.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), i.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
  } }, { key: "setLegendWrapXY", value: function(e, t) {
    var i = this.w, s = i.globals.dom.elLegendWrap, a = s.clientHeight, n = 0, o = 0;
    if (i.config.legend.position === "bottom") o = i.globals.svgHeight - Math.min(a, i.globals.svgHeight / 2) - 5;
    else if (i.config.legend.position === "top") {
      var l = new es(this.ctx), c = l.dimHelpers.getTitleSubtitleCoords("title").height, h = l.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      o = (c > 0 ? c - 10 : 0) + (h > 0 ? h - 10 : 0);
    }
    s.style.position = "absolute", n = n + e + i.config.legend.offsetX, o = o + t + i.config.legend.offsetY, s.style.left = n + "px", s.style.top = o + "px", i.config.legend.position === "right" && (s.style.left = "auto", s.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(d) {
      s.style[d] && (s.style[d] = parseInt(i.config.legend[d], 10) + "px");
    });
  } }, { key: "legendAlignHorizontal", value: function() {
    var e = this.w;
    e.globals.dom.elLegendWrap.style.right = 0;
    var t = new es(this.ctx), i = t.dimHelpers.getTitleSubtitleCoords("title"), s = t.dimHelpers.getTitleSubtitleCoords("subtitle"), a = 0;
    e.config.legend.position === "top" && (a = i.height + s.height + e.config.title.margin + e.config.subtitle.margin - 10), this.setLegendWrapXY(20, a);
  } }, { key: "legendAlignVertical", value: function() {
    var e = this.w, t = this.legendHelpers.getLegendDimensions(), i = 0;
    e.config.legend.position === "left" && (i = 20), e.config.legend.position === "right" && (i = e.globals.svgWidth - t.clww - 10), this.setLegendWrapXY(i, 20);
  } }, { key: "onLegendHovered", value: function(e) {
    var t = this.w, i = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
    if (t.config.chart.type === "heatmap" || this.isBarsDistributed) {
      if (i) {
        var s = parseInt(e.target.getAttribute("rel"), 10) - 1;
        this.ctx.events.fireEvent("legendHover", [this.ctx, s, this.w]), new ot(this.ctx).highlightRangeInSeries(e, e.target);
      }
    } else !e.target.classList.contains("apexcharts-inactive-legend") && i && new ot(this.ctx).toggleSeriesOnHover(e, e.target);
  } }, { key: "onLegendClick", value: function(e) {
    var t = this.w;
    if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
      var i = parseInt(e.target.getAttribute("rel"), 10) - 1, s = e.target.getAttribute("data:collapsed") === "true", a = this.w.config.chart.events.legendClick;
      typeof a == "function" && a(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
      var n = this.w.config.legend.markers.onClick;
      typeof n == "function" && e.target.classList.contains("apexcharts-legend-marker") && (n(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), t.config.chart.type !== "treemap" && t.config.chart.type !== "heatmap" && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, s);
    }
  } }]), r;
}(), Mo = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = t.globals.minX, this.maxX = t.globals.maxX;
  }
  return te(r, [{ key: "createToolbar", value: function() {
    var e = this, t = this.w, i = function() {
      return document.createElement("div");
    }, s = i();
    if (s.setAttribute("class", "apexcharts-toolbar"), s.style.top = t.config.chart.toolbar.offsetY + "px", s.style.right = 3 - t.config.chart.toolbar.offsetX + "px", t.globals.dom.elWrap.appendChild(s), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = t.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var a = 0; a < this.t.customIcons.length; a++) this.elCustomIcons.push(i());
    var n = [], o = function(d, u, g) {
      var p = d.toLowerCase();
      e.t[p] && t.config.chart.zoom.enabled && n.push({ el: u, icon: typeof e.t[p] == "string" ? e.t[p] : g, title: e.localeValues[d], class: "apexcharts-".concat(p, "-icon") });
    };
    o("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), o("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
    var l = function(d) {
      e.t[d] && t.config.chart[d].enabled && n.push({ el: d === "zoom" ? e.elZoom : e.elSelection, icon: typeof e.t[d] == "string" ? e.t[d] : d === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: e.localeValues[d === "zoom" ? "selectionZoom" : "selection"], class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(d, "-icon") });
    };
    l("zoom"), l("selection"), this.t.pan && t.config.chart.zoom.enabled && n.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && n.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var c = 0; c < this.elCustomIcons.length; c++) n.push({ el: this.elCustomIcons[c], icon: this.t.customIcons[c].icon, title: this.t.customIcons[c].title, index: this.t.customIcons[c].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[c].class });
    n.forEach(function(d, u) {
      d.index && z.moveIndexInArray(n, u, d.index);
    });
    for (var h = 0; h < n.length; h++) B.setAttrs(n[h].el, { class: n[h].class, title: n[h].title }), n[h].el.innerHTML = n[h].icon, s.appendChild(n[h].el);
    this._createHamburgerMenu(s), t.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: "_createHamburgerMenu", value: function(e) {
    this.elMenuItems = [], e.appendChild(this.elMenu), B.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var t = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i = 0; i < t.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = t[i].title, B.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(t[i].name), title: t[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
  } }, { key: "addToolbarEventListeners", value: function() {
    var e = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
      i.classList.contains("exportSVG") ? i.addEventListener("click", e.handleDownload.bind(e, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", e.handleDownload.bind(e, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", e.handleDownload.bind(e, "csv"));
    });
    for (var t = 0; t < this.t.customIcons.length; t++) this.elCustomIcons[t].addEventListener("click", this.t.customIcons[t].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleZoomSelection", value: function(e) {
    this.ctx.getSyncedCharts().forEach(function(t) {
      t.ctx.toolbar.toggleOtherControls();
      var i = e === "selection" ? t.ctx.toolbar.elSelection : t.ctx.toolbar.elZoom, s = e === "selection" ? "selectionEnabled" : "zoomEnabled";
      t.w.globals[s] = !t.w.globals[s], i.classList.contains(t.ctx.toolbar.selectedClass) ? i.classList.remove(t.ctx.toolbar.selectedClass) : i.classList.add(t.ctx.toolbar.selectedClass);
    });
  } }, { key: "getToolbarIconsReference", value: function() {
    var e = this.w;
    this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZoomPanFromToolbar", value: function(e) {
    this.toggleOtherControls(), e === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
    var t = e === "pan" ? this.elPan : this.elZoom, i = e === "pan" ? this.elZoom : this.elPan;
    t && t.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
  } }, { key: "togglePanning", value: function() {
    this.ctx.getSyncedCharts().forEach(function(e) {
      e.ctx.toolbar.toggleOtherControls(), e.w.globals.panEnabled = !e.w.globals.panEnabled, e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass);
    });
  } }, { key: "toggleOtherControls", value: function() {
    var e = this, t = this.w;
    t.globals.panEnabled = !1, t.globals.zoomEnabled = !1, t.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
      i && i.classList.remove(e.selectedClass);
    });
  } }, { key: "handleZoomIn", value: function() {
    var e = this.w;
    e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY);
    var t = (this.minX + this.maxX) / 2, i = (this.minX + t) / 2, s = (this.maxX + t) / 2, a = this._getNewMinXMaxX(i, s);
    e.globals.disableZoomIn || this.zoomUpdateOptions(a.minX, a.maxX);
  } }, { key: "handleZoomOut", value: function() {
    var e = this.w;
    if (e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY), !(e.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
      var t = (this.minX + this.maxX) / 2, i = this.minX - (t - this.minX), s = this.maxX - (t - this.maxX), a = this._getNewMinXMaxX(i, s);
      e.globals.disableZoomOut || this.zoomUpdateOptions(a.minX, a.maxX);
    }
  } }, { key: "_getNewMinXMaxX", value: function(e, t) {
    var i = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i ? Math.floor(e) : e, maxX: i ? Math.floor(t) : t };
  } }, { key: "zoomUpdateOptions", value: function(e, t) {
    var i = this.w;
    if (e !== void 0 || t !== void 0) {
      if (!(i.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1, t = i.globals.dataPoints), t - e < 2))) {
        var s = { min: e, max: t }, a = this.getBeforeZoomRange(s);
        a && (s = a.xaxis);
        var n = { xaxis: s }, o = z.clone(i.globals.initialConfig.yaxis);
        i.config.chart.group || (n.yaxis = o), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(n, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(s, o);
      }
    } else this.handleZoomReset();
  } }, { key: "zoomCallback", value: function(e, t) {
    typeof this.ev.zoomed == "function" && (this.ev.zoomed(this.ctx, { xaxis: e, yaxis: t }), this.ctx.events.fireEvent("zoomed", { xaxis: e, yaxis: t }));
  } }, { key: "getBeforeZoomRange", value: function(e, t) {
    var i = null;
    return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: e, yaxis: t })), i;
  } }, { key: "toggleMenu", value: function() {
    var e = this;
    window.setTimeout(function() {
      e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open");
    }, 0);
  } }, { key: "handleDownload", value: function(e) {
    var t = this.w, i = new mi(this.ctx);
    switch (e) {
      case "svg":
        i.exportToSVG(this.ctx);
        break;
      case "png":
        i.exportToPng(this.ctx);
        break;
      case "csv":
        i.exportToCSV({ series: t.config.series, columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: "handleZoomReset", value: function(e) {
    this.ctx.getSyncedCharts().forEach(function(t) {
      var i = t.w;
      if (i.globals.lastXAxis.min = i.globals.initialConfig.xaxis.min, i.globals.lastXAxis.max = i.globals.initialConfig.xaxis.max, t.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.beforeResetZoom == "function") {
        var s = i.config.chart.events.beforeResetZoom(t, i);
        s && t.updateHelpers.revertDefaultAxisMinMax(s);
      }
      typeof i.config.chart.events.zoomed == "function" && t.ctx.toolbar.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1;
      var a = t.ctx.series.emptyCollapsedSeries(z.clone(i.globals.initialSeries));
      t.updateHelpers._updateSeries(a, i.config.chart.animations.dynamicAnimation.enabled);
    });
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), r;
}(), od = function(r) {
  Pi(t, Mo);
  var e = Ri(t);
  function t(i) {
    var s;
    return ee(this, t), (s = e.call(this, i)).ctx = i, s.w = i.w, s.dragged = !1, s.graphics = new B(s.ctx), s.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], s.clientX = 0, s.clientY = 0, s.startX = 0, s.endX = 0, s.dragX = 0, s.startY = 0, s.endY = 0, s.dragY = 0, s.moveDirection = "none", s.debounceTimer = null, s.debounceDelay = 100, s.wheelDelay = 400, s;
  }
  return te(t, [{ key: "init", value: function(i) {
    var s = this, a = i.xyRatios, n = this.w, o = this;
    this.xyRatios = a, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = n.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new Oe(0, 0, n.globals.gridWidth, n.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), n.globals.dom.Paper.add(this.zoomRect), n.globals.dom.Paper.add(this.selectionRect), n.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: n.globals.gridWidth, maxY: n.globals.gridHeight }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : n.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: n.globals.gridWidth }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = n.globals.dom.baseEl.querySelector("".concat(n.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(l) {
      s.hoverArea.addEventListener(l, o.svgMouseEvents.bind(o, a), { capture: !1, passive: !0 });
    }), n.config.chart.zoom.enabled && n.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", o.mouseWheelEvent.bind(o), { capture: !1, passive: !1 });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(i, s) {
    var a = this.w, n = this.ctx.toolbar, o = a.globals.zoomEnabled ? a.config.chart.zoom.type : a.config.chart.selection.type, l = a.config.chart.toolbar.autoSelected;
    if (s.shiftKey ? (this.shiftWasPressed = !0, n.enableZoomPanFromToolbar(l === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(l), this.shiftWasPressed = !1), s.target) {
      var c, h = s.target.classList;
      if (s.target.parentNode && s.target.parentNode !== null && (c = s.target.parentNode.classList), !(h.contains("apexcharts-legend-marker") || h.contains("apexcharts-legend-text") || c && c.contains("apexcharts-toolbar"))) {
        if (this.clientX = s.type === "touchmove" || s.type === "touchstart" ? s.touches[0].clientX : s.type === "touchend" ? s.changedTouches[0].clientX : s.clientX, this.clientY = s.type === "touchmove" || s.type === "touchstart" ? s.touches[0].clientY : s.type === "touchend" ? s.changedTouches[0].clientY : s.clientY, s.type === "mousedown" && s.which === 1 || s.type === "touchstart") {
          var d = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - d.left - a.globals.barPadForNumericAxis, this.startY = this.clientY - d.top, this.dragged = !1, this.w.globals.mousedown = !0;
        }
        (s.type === "mousemove" && s.which === 1 || s.type === "touchmove") && (this.dragged = !0, a.globals.panEnabled ? (a.globals.selection = null, this.w.globals.mousedown && this.panDragging({ context: this, zoomtype: o, xyRatios: i })) : (this.w.globals.mousedown && a.globals.zoomEnabled || this.w.globals.mousedown && a.globals.selectionEnabled) && (this.selection = this.selectionDrawing({ context: this, zoomtype: o }))), s.type !== "mouseup" && s.type !== "touchend" && s.type !== "mouseleave" || this.handleMouseUp({ zoomtype: o }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: "handleMouseUp", value: function(i) {
    var s, a = i.zoomtype, n = i.isResized, o = this.w, l = (s = this.gridRect) === null || s === void 0 ? void 0 : s.getBoundingClientRect();
    l && (this.w.globals.mousedown || n) && (this.endX = this.clientX - l.left - o.globals.barPadForNumericAxis, this.endY = this.clientY - l.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (o.globals.zoomEnabled || o.globals.selectionEnabled) && this.selectionDrawn({ context: this, zoomtype: a })), o.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = !1, this.w.globals.mousedown = !1;
  } }, { key: "mouseWheelEvent", value: function(i) {
    var s = this, a = this.w;
    i.preventDefault();
    var n = Date.now();
    n - a.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(i), a.globals.lastWheelExecution = n), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function() {
      n - a.globals.lastWheelExecution > s.wheelDelay && (s.executeMouseWheelZoom(i), a.globals.lastWheelExecution = n);
    }, this.debounceDelay);
  } }, { key: "executeMouseWheelZoom", value: function(i) {
    var s, a = this.w;
    this.minX = a.globals.isRangeBar ? a.globals.minY : a.globals.minX, this.maxX = a.globals.isRangeBar ? a.globals.maxY : a.globals.maxX;
    var n = (s = this.gridRect) === null || s === void 0 ? void 0 : s.getBoundingClientRect();
    if (n) {
      var o, l, c, h = (i.clientX - n.left) / n.width, d = this.minX, u = this.maxX, g = u - d;
      if (i.deltaY < 0) {
        var p = d + h * g;
        l = p - (o = 0.5 * g) / 2, c = p + o / 2;
      } else l = d - (o = 1.5 * g) / 2, c = u + o / 2;
      if (!a.globals.isRangeBar) {
        l = Math.max(l, a.globals.initialMinX), c = Math.min(c, a.globals.initialMaxX);
        var f = 0.01 * (a.globals.initialMaxX - a.globals.initialMinX);
        if (c - l < f) {
          var x = (l + c) / 2;
          l = x - f / 2, c = x + f / 2;
        }
      }
      var m = this._getNewMinXMaxX(l, c);
      isNaN(m.minX) || isNaN(m.maxX) || this.zoomUpdateOptions(m.minX, m.maxX);
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var i = this, s = this.w;
    if (this.selectionRect) {
      var a = this.selectionRect.node.getBoundingClientRect();
      a.width > 0 && a.height > 0 && (this.selectionRect.select(!1).resize(!1), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(n, o, l, c, h) {
        return h === "l" || h === "r" ? n.circle(8).css({ "stroke-width": 1, stroke: "#333", fill: "#fff" }) : n.circle(0);
      }, updateHandle: function(n, o) {
        return n.center(o[0], o[1]);
      } }).resize().on("resize", function() {
        var n = s.globals.zoomEnabled ? s.config.chart.zoom.type : s.config.chart.selection.type;
        i.handleMouseUp({ zoomtype: n, isResized: !0 });
      }));
    }
  } }, { key: "preselectedSelection", value: function() {
    var i = this.w, s = this.xyRatios;
    if (!i.globals.zoomEnabled) {
      if (i.globals.selection !== void 0 && i.globals.selection !== null) this.drawSelectionRect(q(q({}, i.globals.selection), {}, { translateX: i.globals.translateX, translateY: i.globals.translateY }));
      else if (i.config.chart.selection.xaxis.min !== void 0 && i.config.chart.selection.xaxis.max !== void 0) {
        var a = (i.config.chart.selection.xaxis.min - i.globals.minX) / s.xRatio, n = i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / s.xRatio - a;
        i.globals.isRangeBar && (a = (i.config.chart.selection.xaxis.min - i.globals.yAxisScale[0].niceMin) / s.invertedYRatio, n = (i.config.chart.selection.xaxis.max - i.config.chart.selection.xaxis.min) / s.invertedYRatio);
        var o = { x: a, y: 0, width: n, height: i.globals.gridHeight, translateX: i.globals.translateX, translateY: i.globals.translateY, selectionEnabled: !0 };
        this.drawSelectionRect(o), this.makeSelectionRectDraggable(), typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(this.ctx, { xaxis: { min: i.config.chart.selection.xaxis.min, max: i.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(i) {
    var s = i.x, a = i.y, n = i.width, o = i.height, l = i.translateX, c = l === void 0 ? 0 : l, h = i.translateY, d = h === void 0 ? 0 : h, u = this.w, g = this.zoomRect, p = this.selectionRect;
    if (this.dragged || u.globals.selection !== null) {
      var f = { transform: "translate(" + c + ", " + d + ")" };
      u.globals.zoomEnabled && this.dragged && (n < 0 && (n = 1), g.attr({ x: s, y: a, width: n, height: o, fill: u.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": u.config.chart.zoom.zoomedArea.fill.opacity, stroke: u.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": u.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": u.config.chart.zoom.zoomedArea.stroke.opacity }), B.setAttrs(g.node, f)), u.globals.selectionEnabled && (p.attr({ x: s, y: a, width: n > 0 ? n : 0, height: o > 0 ? o : 0, fill: u.config.chart.selection.fill.color, "fill-opacity": u.config.chart.selection.fill.opacity, stroke: u.config.chart.selection.stroke.color, "stroke-width": u.config.chart.selection.stroke.width, "stroke-dasharray": u.config.chart.selection.stroke.dashArray, "stroke-opacity": u.config.chart.selection.stroke.opacity }), B.setAttrs(p.node, f));
    }
  } }, { key: "hideSelectionRect", value: function(i) {
    i && i.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(i) {
    var s = i.context, a = i.zoomtype, n = this.w, o = s, l = this.gridRect.getBoundingClientRect(), c = o.startX - 1, h = o.startY, d = !1, u = !1, g = o.clientX - l.left - n.globals.barPadForNumericAxis, p = o.clientY - l.top, f = g - c, x = p - h, m = { translateX: n.globals.translateX, translateY: n.globals.translateY };
    return Math.abs(f + c) > n.globals.gridWidth ? f = n.globals.gridWidth - c : g < 0 && (f = c), c > g && (d = !0, f = Math.abs(f)), h > p && (u = !0, x = Math.abs(x)), m = q(q({}, m = a === "x" ? { x: d ? c - f : c, y: 0, width: f, height: n.globals.gridHeight } : a === "y" ? { x: 0, y: u ? h - x : h, width: n.globals.gridWidth, height: x } : { x: d ? c - f : c, y: u ? h - x : h, width: f, height: x }), {}, { translateX: n.globals.translateX, translateY: n.globals.translateY }), o.drawSelectionRect(m), o.selectionDragging("resizing"), m;
  } }, { key: "selectionDragging", value: function(i, s) {
    var a = this, n = this.w;
    if (s) {
      s.preventDefault();
      var o = s.detail, l = o.handler, c = o.box, h = c.x, d = c.y;
      h < this.constraints.x && (h = this.constraints.x), d < this.constraints.y && (d = this.constraints.y), c.x2 > this.constraints.x2 && (h = this.constraints.x2 - c.w), c.y2 > this.constraints.y2 && (d = this.constraints.y2 - c.h), l.move(h, d);
      var u = this.xyRatios, g = this.selectionRect, p = 0;
      i === "resizing" && (p = 30);
      var f = function(m) {
        return parseFloat(g.node.getAttribute(m));
      }, x = { x: f("x"), y: f("y"), width: f("width"), height: f("height") };
      n.globals.selection = x, typeof n.config.chart.events.selection == "function" && n.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var m, b, w, y, v = a.gridRect.getBoundingClientRect(), S = g.node.getBoundingClientRect();
        n.globals.isRangeBar ? (m = n.globals.yAxisScale[0].niceMin + (S.left - v.left) * u.invertedYRatio, b = n.globals.yAxisScale[0].niceMin + (S.right - v.left) * u.invertedYRatio, w = 0, y = 1) : (m = n.globals.xAxisScale.niceMin + (S.left - v.left) * u.xRatio, b = n.globals.xAxisScale.niceMin + (S.right - v.left) * u.xRatio, w = n.globals.yAxisScale[0].niceMin + (v.bottom - S.bottom) * u.yRatio[0], y = n.globals.yAxisScale[0].niceMax - (S.top - v.top) * u.yRatio[0]);
        var k = { xaxis: { min: m, max: b }, yaxis: { min: w, max: y } };
        n.config.chart.events.selection(a.ctx, k), n.config.chart.brush.enabled && n.config.chart.events.brushScrolled !== void 0 && n.config.chart.events.brushScrolled(a.ctx, k);
      }, p));
    }
  } }, { key: "selectionDrawn", value: function(i) {
    var s, a, n = i.context, o = i.zoomtype, l = this.w, c = n, h = this.xyRatios, d = this.ctx.toolbar, u = l.globals.zoomEnabled ? c.zoomRect.node.getBoundingClientRect() : c.selectionRect.node.getBoundingClientRect(), g = c.gridRect.getBoundingClientRect(), p = u.left - g.left - l.globals.barPadForNumericAxis, f = u.right - g.left - l.globals.barPadForNumericAxis, x = u.top - g.top, m = u.bottom - g.top;
    l.globals.isRangeBar ? (s = l.globals.yAxisScale[0].niceMin + p * h.invertedYRatio, a = l.globals.yAxisScale[0].niceMin + f * h.invertedYRatio) : (s = l.globals.xAxisScale.niceMin + p * h.xRatio, a = l.globals.xAxisScale.niceMin + f * h.xRatio);
    var b = [], w = [];
    if (l.config.yaxis.forEach(function(P, A) {
      var E = l.globals.seriesYAxisMap[A][0], N = l.globals.yAxisScale[A].niceMax - h.yRatio[E] * x, O = l.globals.yAxisScale[A].niceMax - h.yRatio[E] * m;
      b.push(N), w.push(O);
    }), c.dragged && (c.dragX > 10 || c.dragY > 10) && s !== a) {
      if (l.globals.zoomEnabled) {
        var y = z.clone(l.globals.initialConfig.yaxis), v = z.clone(l.globals.initialConfig.xaxis);
        if (l.globals.zoomed = !0, l.config.xaxis.convertedCatToNumeric && (s = Math.floor(s), a = Math.floor(a), s < 1 && (s = 1, a = l.globals.dataPoints), a - s < 2 && (a = s + 1)), o !== "xy" && o !== "x" || (v = { min: s, max: a }), o !== "xy" && o !== "y" || y.forEach(function(P, A) {
          y[A].min = w[A], y[A].max = b[A];
        }), d) {
          var S = d.getBeforeZoomRange(v, y);
          S && (v = S.xaxis ? S.xaxis : v, y = S.yaxis ? S.yaxis : y);
        }
        var k = { xaxis: v };
        l.config.chart.group || (k.yaxis = y), c.ctx.updateHelpers._updateOptions(k, !1, c.w.config.chart.animations.dynamicAnimation.enabled), typeof l.config.chart.events.zoomed == "function" && d.zoomCallback(v, y);
      } else if (l.globals.selectionEnabled) {
        var C, R = null;
        C = { min: s, max: a }, o !== "xy" && o !== "y" || (R = z.clone(l.config.yaxis)).forEach(function(P, A) {
          R[A].min = w[A], R[A].max = b[A];
        }), l.globals.selection = c.selection, typeof l.config.chart.events.selection == "function" && l.config.chart.events.selection(c.ctx, { xaxis: C, yaxis: R });
      }
    }
  } }, { key: "panDragging", value: function(i) {
    var s = i.context, a = this.w, n = s;
    if (a.globals.lastClientPosition.x !== void 0) {
      var o = a.globals.lastClientPosition.x - n.clientX, l = a.globals.lastClientPosition.y - n.clientY;
      Math.abs(o) > Math.abs(l) && o > 0 ? this.moveDirection = "left" : Math.abs(o) > Math.abs(l) && o < 0 ? this.moveDirection = "right" : Math.abs(l) > Math.abs(o) && l > 0 ? this.moveDirection = "up" : Math.abs(l) > Math.abs(o) && l < 0 && (this.moveDirection = "down");
    }
    a.globals.lastClientPosition = { x: n.clientX, y: n.clientY };
    var c = a.globals.isRangeBar ? a.globals.minY : a.globals.minX, h = a.globals.isRangeBar ? a.globals.maxY : a.globals.maxX;
    n.panScrolled(c, h);
  } }, { key: "panScrolled", value: function(i, s) {
    var a = this.w, n = this.xyRatios, o = z.clone(a.globals.initialConfig.yaxis), l = n.xRatio, c = a.globals.minX, h = a.globals.maxX;
    a.globals.isRangeBar && (l = n.invertedYRatio, c = a.globals.minY, h = a.globals.maxY), this.moveDirection === "left" ? (i = c + a.globals.gridWidth / 15 * l, s = h + a.globals.gridWidth / 15 * l) : this.moveDirection === "right" && (i = c - a.globals.gridWidth / 15 * l, s = h - a.globals.gridWidth / 15 * l), a.globals.isRangeBar || (i < a.globals.initialMinX || s > a.globals.initialMaxX) && (i = c, s = h);
    var d = { xaxis: { min: i, max: s } };
    a.config.chart.group || (d.yaxis = o), this.updateScrolledChart(d, i, s);
  } }, { key: "updateScrolledChart", value: function(i, s, a) {
    var n = this.w;
    if (this.ctx.updateHelpers._updateOptions(i, !1, !1), typeof n.config.chart.events.scrolled == "function") {
      var o = { xaxis: { min: s, max: a } };
      n.config.chart.events.scrolled(this.ctx, o), this.ctx.events.fireEvent("scrolled", o);
    }
  } }]), t;
}(), Ro = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx;
  }
  return te(r, [{ key: "getNearestValues", value: function(e) {
    var t = e.hoverArea, i = e.elGrid, s = e.clientX, a = e.clientY, n = this.w, o = i.getBoundingClientRect(), l = o.width, c = o.height, h = l / (n.globals.dataPoints - 1), d = c / n.globals.dataPoints, u = this.hasBars();
    !n.globals.comboCharts && !u || n.config.xaxis.convertedCatToNumeric || (h = l / n.globals.dataPoints);
    var g = s - o.left - n.globals.barPadForNumericAxis, p = a - o.top;
    g < 0 || p < 0 || g > l || p > c ? (t.classList.remove("hovering-zoom"), t.classList.remove("hovering-pan")) : n.globals.zoomEnabled ? (t.classList.remove("hovering-pan"), t.classList.add("hovering-zoom")) : n.globals.panEnabled && (t.classList.remove("hovering-zoom"), t.classList.add("hovering-pan"));
    var f = Math.round(g / h), x = Math.floor(p / d);
    u && !n.config.xaxis.convertedCatToNumeric && (f = Math.ceil(g / h), f -= 1);
    var m = null, b = null, w = n.globals.seriesXvalues.map(function(C) {
      return C.filter(function(R) {
        return z.isNumber(R);
      });
    }), y = n.globals.seriesYvalues.map(function(C) {
      return C.filter(function(R) {
        return z.isNumber(R);
      });
    });
    if (n.globals.isXNumeric) {
      var v = this.ttCtx.getElGrid().getBoundingClientRect(), S = g * (v.width / l), k = p * (v.height / c);
      m = (b = this.closestInMultiArray(S, k, w, y)).index, f = b.j, m !== null && n.globals.hasNullValues && (w = n.globals.seriesXvalues[m], f = (b = this.closestInArray(S, w)).j);
    }
    return n.globals.capturedSeriesIndex = m === null ? -1 : m, (!f || f < 1) && (f = 0), n.globals.isBarHorizontal ? n.globals.capturedDataPointIndex = x : n.globals.capturedDataPointIndex = f, { capturedSeries: m, j: n.globals.isBarHorizontal ? x : f, hoverX: g, hoverY: p };
  } }, { key: "getFirstActiveXArray", value: function(e) {
    for (var t = this.w, i = 0, s = e.map(function(n, o) {
      return n.length > 0 ? o : -1;
    }), a = 0; a < s.length; a++) if (s[a] !== -1 && t.globals.collapsedSeriesIndices.indexOf(a) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(a) === -1) {
      i = s[a];
      break;
    }
    return i;
  } }, { key: "closestInMultiArray", value: function(e, t, i, s) {
    for (var a, n = this.w, o = 1 / 0, l = null, c = null, h = 0; h < i.length; h++) if (a = h, n.globals.collapsedSeriesIndices.indexOf(a) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(a) === -1) for (var d = i[h], u = s[h], g = Math.min(d.length, u.length), p = 0; p < g; p++) {
      var f = e - d[p], x = Math.sqrt(f * f);
      if (!n.globals.allSeriesHasEqualX) {
        var m = t - u[p];
        x = Math.sqrt(f * f + m * m);
      }
      x < o && (o = x, l = h, c = p);
    }
    return { index: l, j: c };
  } }, { key: "closestInArray", value: function(e, t) {
    for (var i = t[0], s = null, a = Math.abs(e - i), n = 0; n < t.length; n++) {
      var o = Math.abs(e - t[n]);
      o < a && (a = o, s = n);
    }
    return { j: s };
  } }, { key: "isXoverlap", value: function(e) {
    var t = [], i = this.w.globals.seriesX.filter(function(a) {
      return a[0] !== void 0;
    });
    if (i.length > 0) for (var s = 0; s < i.length - 1; s++) i[s][e] !== void 0 && i[s + 1][e] !== void 0 && i[s][e] !== i[s + 1][e] && t.push("unEqual");
    return t.length === 0;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var e = !0, t = this.w.globals.initialSeries, i = 0; i < t.length - 1; i++) if (t[i].data.length !== t[i + 1].data.length) {
      e = !1;
      break;
    }
    return e;
  } }, { key: "getBarsHeight", value: function(e) {
    return De(e).reduce(function(t, i) {
      return t + i.getBBox().height;
    }, 0);
  } }, { key: "getElMarkers", value: function(e) {
    return typeof e == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
  } }, { key: "getAllMarkers", value: function() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], i = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
    i = De(i), t && (i = i.filter(function(a) {
      var n = Number(a.getAttribute("data:realIndex"));
      return e.w.globals.collapsedSeriesIndices.indexOf(n) === -1;
    })), i.sort(function(a, n) {
      var o = Number(a.getAttribute("data:realIndex")), l = Number(n.getAttribute("data:realIndex"));
      return l < o ? 1 : l > o ? -1 : 0;
    });
    var s = [];
    return i.forEach(function(a) {
      s.push(a.querySelector(".apexcharts-marker"));
    }), s;
  } }, { key: "hasMarkers", value: function(e) {
    return this.getElMarkers(e).length > 0;
  } }, { key: "getPathFromPoint", value: function(e, t) {
    var i = Number(e.getAttribute("cx")), s = Number(e.getAttribute("cy")), a = e.getAttribute("shape");
    return new B(this.ctx).getMarkerPath(i, s, a, t);
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "getHoverMarkerSize", value: function(e) {
    var t = this.w, i = t.config.markers.hover.size;
    return i === void 0 && (i = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset), i;
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(e) {
    var t = this.w, i = this.ttCtx;
    i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var s = i.allTooltipSeriesGroups, a = 0; a < s.length; a++) e === "enable" ? (s[a].classList.add("apexcharts-active"), s[a].style.display = t.config.tooltip.items.display) : (s[a].classList.remove("apexcharts-active"), s[a].style.display = "none");
  } }]), r;
}(), ld = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Ro(e);
  }
  return te(r, [{ key: "drawSeriesTexts", value: function(e) {
    var t = e.shared, i = t === void 0 || t, s = e.ttItems, a = e.i, n = a === void 0 ? 0 : a, o = e.j, l = o === void 0 ? null : o, c = e.y1, h = e.y2, d = e.e, u = this.w;
    u.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: n, j: l, y1: c, y2: h, w: u }) : this.toggleActiveInactiveSeries(i, n);
    var g = this.getValuesToPrint({ i: n, j: l });
    this.printLabels({ i: n, j: l, values: g, ttItems: s, shared: i, e: d });
    var p = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(e) {
    var t, i = this, s = e.i, a = e.j, n = e.values, o = e.ttItems, l = e.shared, c = e.e, h = this.w, d = [], u = function(v) {
      return h.globals.seriesGoals[v] && h.globals.seriesGoals[v][a] && Array.isArray(h.globals.seriesGoals[v][a]);
    }, g = n.xVal, p = n.zVal, f = n.xAxisTTVal, x = "", m = h.globals.colors[s];
    a !== null && h.config.plotOptions.bar.distributed && (m = h.globals.colors[a]);
    for (var b = function(v, S) {
      var k = i.getFormatters(s);
      x = i.getSeriesName({ fn: k.yLbTitleFormatter, index: s, seriesIndex: s, j: a }), h.config.chart.type === "treemap" && (x = k.yLbTitleFormatter(String(h.config.series[s].data[a].x), { series: h.globals.series, seriesIndex: s, dataPointIndex: a, w: h }));
      var C = h.config.tooltip.inverseOrder ? S : v;
      if (h.globals.axisCharts) {
        var R = function(E) {
          var N, O, L, I;
          return h.globals.isRangeData ? k.yLbFormatter((N = h.globals.seriesRangeStart) === null || N === void 0 || (O = N[E]) === null || O === void 0 ? void 0 : O[a], { series: h.globals.seriesRangeStart, seriesIndex: E, dataPointIndex: a, w: h }) + " - " + k.yLbFormatter((L = h.globals.seriesRangeEnd) === null || L === void 0 || (I = L[E]) === null || I === void 0 ? void 0 : I[a], { series: h.globals.seriesRangeEnd, seriesIndex: E, dataPointIndex: a, w: h }) : k.yLbFormatter(h.globals.series[E][a], { series: h.globals.series, seriesIndex: E, dataPointIndex: a, w: h });
        };
        if (l) k = i.getFormatters(C), x = i.getSeriesName({ fn: k.yLbTitleFormatter, index: C, seriesIndex: s, j: a }), m = h.globals.colors[C], t = R(C), u(C) && (d = h.globals.seriesGoals[C][a].map(function(E) {
          return { attrs: E, val: k.yLbFormatter(E.value, { seriesIndex: C, dataPointIndex: a, w: h }) };
        }));
        else {
          var P, A = c == null || (P = c.target) === null || P === void 0 ? void 0 : P.getAttribute("fill");
          A && (A.indexOf("url") !== -1 ? A.indexOf("Pattern") !== -1 && (m = h.globals.dom.baseEl.querySelector(A.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : m = A), t = R(s), u(s) && Array.isArray(h.globals.seriesGoals[s][a]) && (d = h.globals.seriesGoals[s][a].map(function(E) {
            return { attrs: E, val: k.yLbFormatter(E.value, { seriesIndex: s, dataPointIndex: a, w: h }) };
          }));
        }
      }
      a === null && (t = k.yLbFormatter(h.globals.series[s], q(q({}, h), {}, { seriesIndex: s, dataPointIndex: s }))), i.DOMHandling({ i: s, t: C, j: a, ttItems: o, values: { val: t, goalVals: d, xVal: g, xAxisTTVal: f, zVal: p }, seriesName: x, shared: l, pColor: m });
    }, w = 0, y = h.globals.series.length - 1; w < h.globals.series.length; w++, y--) b(w, y);
  } }, { key: "getFormatters", value: function(e) {
    var t, i = this.w, s = i.globals.yLabelFormatters[e];
    return i.globals.ttVal !== void 0 ? Array.isArray(i.globals.ttVal) ? (s = i.globals.ttVal[e] && i.globals.ttVal[e].formatter, t = i.globals.ttVal[e] && i.globals.ttVal[e].title && i.globals.ttVal[e].title.formatter) : (s = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter == "function" && (t = i.globals.ttVal.title.formatter)) : t = i.config.tooltip.y.title.formatter, typeof s != "function" && (s = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(a) {
      return a;
    }), typeof t != "function" && (t = function(a) {
      return a ? a + ": " : "";
    }), { yLbFormatter: s, yLbTitleFormatter: t };
  } }, { key: "getSeriesName", value: function(e) {
    var t = e.fn, i = e.index, s = e.seriesIndex, a = e.j, n = this.w;
    return t(String(n.globals.seriesNames[i]), { series: n.globals.series, seriesIndex: s, dataPointIndex: a, w: n });
  } }, { key: "DOMHandling", value: function(e) {
    e.i;
    var t = e.t, i = e.j, s = e.ttItems, a = e.values, n = e.seriesName, o = e.shared, l = e.pColor, c = this.w, h = this.ttCtx, d = a.val, u = a.goalVals, g = a.xVal, p = a.xAxisTTVal, f = a.zVal, x = null;
    x = s[t].children, c.config.tooltip.fillSeriesColor && (s[t].style.backgroundColor = l, x[0].style.display = "none"), h.showTooltipTitle && (h.tooltipTitle === null && (h.tooltipTitle = c.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h.tooltipTitle.innerHTML = g), h.isXAxisTooltipEnabled && (h.xaxisTooltipText.innerHTML = p !== "" ? p : g);
    var m = s[t].querySelector(".apexcharts-tooltip-text-y-label");
    m && (m.innerHTML = n || "");
    var b = s[t].querySelector(".apexcharts-tooltip-text-y-value");
    b && (b.innerHTML = d !== void 0 ? d : ""), x[0] && x[0].classList.contains("apexcharts-tooltip-marker") && (c.config.tooltip.marker.fillColors && Array.isArray(c.config.tooltip.marker.fillColors) && (l = c.config.tooltip.marker.fillColors[t]), c.config.tooltip.fillSeriesColor ? x[0].style.backgroundColor = l : x[0].style.color = l), c.config.tooltip.marker.show || (x[0].style.display = "none");
    var w = s[t].querySelector(".apexcharts-tooltip-text-goals-label"), y = s[t].querySelector(".apexcharts-tooltip-text-goals-value");
    if (u.length && c.globals.seriesGoals[t]) {
      var v = function() {
        var C = "<div>", R = "<div>";
        u.forEach(function(P, A) {
          C += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(P.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(P.attrs.name, "</div>"), R += "<div>".concat(P.val, "</div>");
        }), w.innerHTML = C + "</div>", y.innerHTML = R + "</div>";
      };
      o ? c.globals.seriesGoals[t][i] && Array.isArray(c.globals.seriesGoals[t][i]) ? v() : (w.innerHTML = "", y.innerHTML = "") : v();
    } else w.innerHTML = "", y.innerHTML = "";
    if (f !== null && (s[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = c.config.tooltip.z.title, s[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = f !== void 0 ? f : ""), o && x[0]) {
      if (c.config.tooltip.hideEmptySeries) {
        var S = s[t].querySelector(".apexcharts-tooltip-marker"), k = s[t].querySelector(".apexcharts-tooltip-text");
        parseFloat(d) == 0 ? (S.style.display = "none", k.style.display = "none") : (S.style.display = "block", k.style.display = "block");
      }
      d == null || c.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || c.globals.collapsedSeriesIndices.indexOf(t) > -1 || Array.isArray(h.tConfig.enabledOnSeries) && h.tConfig.enabledOnSeries.indexOf(t) === -1 ? x[0].parentNode.style.display = "none" : x[0].parentNode.style.display = c.config.tooltip.items.display;
    } else Array.isArray(h.tConfig.enabledOnSeries) && h.tConfig.enabledOnSeries.indexOf(t) === -1 && (x[0].parentNode.style.display = "none");
  } }, { key: "toggleActiveInactiveSeries", value: function(e, t) {
    var i = this.w;
    if (e) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var s = i.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(t));
      s && (s.classList.add("apexcharts-active"), s.style.display = i.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(e) {
    var t = e.i, i = e.j, s = this.w, a = this.ctx.series.filteredSeriesX(), n = "", o = "", l = null, c = null, h = { series: s.globals.series, seriesIndex: t, dataPointIndex: i, w: s }, d = s.globals.ttZFormatter;
    i === null ? c = s.globals.series[t] : s.globals.isXNumeric && s.config.chart.type !== "treemap" ? (n = a[t][i], a[t].length === 0 && (n = a[this.tooltipUtil.getFirstActiveXArray(a)][i])) : n = new Zr(this.ctx).isFormatXY() ? s.config.series[t].data[i] !== void 0 ? s.config.series[t].data[i].x : "" : s.globals.labels[i] !== void 0 ? s.globals.labels[i] : "";
    var u = n;
    return s.globals.isXNumeric && s.config.xaxis.type === "datetime" ? n = new Ti(this.ctx).xLabelFormat(s.globals.ttKeyFormatter, u, u, { i: void 0, dateFormatter: new Ye(this.ctx).formatDate, w: this.w }) : n = s.globals.isBarHorizontal ? s.globals.yLabelFormatters[0](u, h) : s.globals.xLabelFormatter(u, h), s.config.tooltip.x.formatter !== void 0 && (n = s.globals.ttKeyFormatter(u, h)), s.globals.seriesZ.length > 0 && s.globals.seriesZ[t].length > 0 && (l = d(s.globals.seriesZ[t][i], s)), o = typeof s.config.xaxis.tooltip.formatter == "function" ? s.globals.xaxisTooltipFormatter(u, h) : n, { val: Array.isArray(c) ? c.join(" ") : c, xVal: Array.isArray(n) ? n.join(" ") : n, xAxisTTVal: Array.isArray(o) ? o.join(" ") : o, zVal: l };
  } }, { key: "handleCustomTooltip", value: function(e) {
    var t = e.i, i = e.j, s = e.y1, a = e.y2, n = e.w, o = this.ttCtx.getElTooltip(), l = n.config.tooltip.custom;
    Array.isArray(l) && l[t] && (l = l[t]);
    var c = l({ ctx: this.ctx, series: n.globals.series, seriesIndex: t, dataPointIndex: i, y1: s, y2: a, w: n });
    typeof c == "string" || typeof c == "number" ? o.innerHTML = c : (c instanceof Element || typeof c.nodeName == "string") && (o.innerHTML = "", o.appendChild(c.cloneNode(!0)));
  } }]), r;
}(), Po = function() {
  function r(e) {
    ee(this, r), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w;
  }
  return te(r, [{ key: "moveXCrosshairs", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.ttCtx, s = this.w, a = i.getElXCrosshairs(), n = e - i.xcrosshairsWidth / 2, o = s.globals.labels.slice().length;
    if (t !== null && (n = s.globals.gridWidth / o * t), a === null || s.globals.isBarHorizontal || (a.setAttribute("x", n), a.setAttribute("x1", n), a.setAttribute("x2", n), a.setAttribute("y2", s.globals.gridHeight), a.classList.add("apexcharts-active")), n < 0 && (n = 0), n > s.globals.gridWidth && (n = s.globals.gridWidth), i.isXAxisTooltipEnabled) {
      var l = n;
      s.config.xaxis.crosshairs.width !== "tickWidth" && s.config.xaxis.crosshairs.width !== "barWidth" || (l = n + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(l);
    }
  } }, { key: "moveYCrosshairs", value: function(e) {
    var t = this.ttCtx;
    t.ycrosshairs !== null && B.setAttrs(t.ycrosshairs, { y1: e, y2: e }), t.ycrosshairsHidden !== null && B.setAttrs(t.ycrosshairsHidden, { y1: e, y2: e });
  } }, { key: "moveXAxisTooltip", value: function(e) {
    var t = this.w, i = this.ttCtx;
    if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
      i.xaxisTooltip.classList.add("apexcharts-active");
      var s = i.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY;
      if (e -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(e)) {
        e += t.globals.translateX;
        var a;
        a = new B(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = a.width + "px", i.xaxisTooltip.style.left = e + "px", i.xaxisTooltip.style.top = s + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(e) {
    var t = this.w, i = this.ttCtx;
    i.yaxisTTEls === null && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var s = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), a = t.globals.translateY + s, n = i.yaxisTTEls[e].getBoundingClientRect(), o = n.height, l = t.globals.translateYAxisX[e] - 2;
    t.config.yaxis[e].opposite && (l -= n.width), a -= o / 2, t.globals.ignoreYAxisIndexes.indexOf(e) === -1 && a > 0 && a < t.globals.gridHeight ? (i.yaxisTTEls[e].classList.add("apexcharts-active"), i.yaxisTTEls[e].style.top = a + "px", i.yaxisTTEls[e].style.left = l + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active");
  } }, { key: "moveTooltip", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, s = this.w, a = this.ttCtx, n = a.getElTooltip(), o = a.tooltipRect, l = i !== null ? parseFloat(i) : 1, c = parseFloat(e) + l + 5, h = parseFloat(t) + l / 2;
    if (c > s.globals.gridWidth / 2 && (c = c - o.ttWidth - l - 10), c > s.globals.gridWidth - o.ttWidth - 10 && (c = s.globals.gridWidth - o.ttWidth), c < -20 && (c = -20), s.config.tooltip.followCursor) {
      var d = a.getElGrid().getBoundingClientRect();
      (c = a.e.clientX - d.left) > s.globals.gridWidth / 2 && (c -= a.tooltipRect.ttWidth), (h = a.e.clientY + s.globals.translateY - d.top) > s.globals.gridHeight / 2 && (h -= a.tooltipRect.ttHeight);
    } else s.globals.isBarHorizontal || o.ttHeight / 2 + h > s.globals.gridHeight && (h = s.globals.gridHeight - o.ttHeight + s.globals.translateY);
    isNaN(c) || (c += s.globals.translateX, n.style.left = c + "px", n.style.top = h + "px");
  } }, { key: "moveMarkers", value: function(e, t) {
    var i = this.w, s = this.ttCtx;
    if (i.globals.markers.size[e] > 0) for (var a = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), n = 0; n < a.length; n++) parseInt(a[n].getAttribute("rel"), 10) === t && (s.marker.resetPointsSize(), s.marker.enlargeCurrentPoint(t, a[n]));
    else s.marker.resetPointsSize(), this.moveDynamicPointOnHover(t, e);
  } }, { key: "moveDynamicPointOnHover", value: function(e, t) {
    var i, s, a, n, o = this.w, l = this.ttCtx, c = new B(this.ctx), h = o.globals.pointsArray, d = l.tooltipUtil.getHoverMarkerSize(t), u = o.config.series[t].type;
    if (!u || u !== "column" && u !== "candlestick" && u !== "boxPlot") {
      a = (i = h[t][e]) === null || i === void 0 ? void 0 : i[0], n = ((s = h[t][e]) === null || s === void 0 ? void 0 : s[1]) || 0;
      var g = o.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers path"));
      if (g && n < o.globals.gridHeight && n > 0) {
        var p = g.getAttribute("shape"), f = c.getMarkerPath(a, n, p, 1.5 * d);
        g.setAttribute("d", f);
      }
      this.moveXCrosshairs(a), l.fixedTooltip || this.moveTooltip(a, n, d);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(e) {
    var t, i = this.ttCtx, s = i.w, a = 0, n = 0, o = s.globals.pointsArray, l = new ot(this.ctx), c = new B(this.ctx);
    t = l.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
    var h = i.tooltipUtil.getHoverMarkerSize(t);
    if (o[t] && (a = o[t][e][0], n = o[t][e][1]), !isNaN(a)) {
      var d = i.tooltipUtil.getAllMarkers();
      if (d.length) for (var u = 0; u < s.globals.series.length; u++) {
        var g = o[u];
        if (s.globals.comboCharts && g === void 0 && d.splice(u, 0, null), g && g.length) {
          var p = o[u][e][1], f = void 0;
          d[u].setAttribute("cx", a);
          var x = d[u].getAttribute("shape");
          if (s.config.chart.type === "rangeArea" && !s.globals.comboCharts) {
            var m = e + s.globals.series[u].length;
            f = o[u][m][1], p -= Math.abs(p - f) / 2;
          }
          if (p !== null && !isNaN(p) && p < s.globals.gridHeight + h && p + h > 0) {
            var b = c.getMarkerPath(a, p, x, h);
            d[u].setAttribute("d", b);
          } else d[u].setAttribute("d", "");
        }
      }
      this.moveXCrosshairs(a), i.fixedTooltip || this.moveTooltip(a, n || s.globals.gridHeight, h);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(e, t) {
    var i = this.w, s = this.ttCtx, a = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length;
    i.config.chart.stacked && (a = i.globals.barGroups.length);
    var n = a >= 2 && a % 2 == 0 ? Math.floor(a / 2) : Math.floor(a / 2) + 1;
    i.globals.isBarHorizontal && (n = new ot(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    var o = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(n, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "']"));
    o || typeof t != "number" || (o = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, "']")));
    var l = o ? parseFloat(o.getAttribute("cx")) : 0, c = o ? parseFloat(o.getAttribute("cy")) : 0, h = o ? parseFloat(o.getAttribute("barWidth")) : 0, d = s.getElGrid().getBoundingClientRect(), u = o && (o.classList.contains("apexcharts-candlestick-area") || o.classList.contains("apexcharts-boxPlot-area"));
    i.globals.isXNumeric ? (o && !u && (l -= a % 2 != 0 ? h / 2 : 0), o && u && (l -= h / 2)) : i.globals.isBarHorizontal || (l = s.xAxisTicksPositions[e - 1] + s.dataPointsDividedWidth / 2, isNaN(l) && (l = s.xAxisTicksPositions[e] - s.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? c -= s.tooltipRect.ttHeight : i.config.tooltip.followCursor ? c = s.e.clientY - d.top - s.tooltipRect.ttHeight / 2 : c + s.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (c = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(l), s.fixedTooltip || this.moveTooltip(l, c || i.globals.gridHeight);
  } }]), r;
}(), cd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new Po(e);
  }
  return te(r, [{ key: "drawDynamicPoints", value: function() {
    var e = this.w, t = new B(this.ctx), i = new ai(this.ctx), s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    s = De(s), e.config.chart.stacked && s.sort(function(d, u) {
      return parseFloat(d.getAttribute("data:realIndex")) - parseFloat(u.getAttribute("data:realIndex"));
    });
    for (var a = 0; a < s.length; a++) {
      var n = s[a].querySelector(".apexcharts-series-markers-wrap");
      if (n !== null) {
        var o = void 0, l = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        e.config.chart.type !== "line" && e.config.chart.type !== "area" || e.globals.comboCharts || e.config.tooltip.intersect || (l += " no-pointer-events");
        var c = i.getMarkerConfig({ cssClass: l, seriesIndex: Number(n.getAttribute("data:realIndex")) });
        (o = t.drawMarker(0, 0, c)).node.setAttribute("default-marker-size", 0);
        var h = document.createElementNS(e.globals.SVGNS, "g");
        h.classList.add("apexcharts-series-markers"), h.appendChild(o.node), n.appendChild(h);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, a = this.w;
    a.config.chart.type !== "bubble" && this.newPointSize(e, t);
    var n = t.getAttribute("cx"), o = t.getAttribute("cy");
    if (i !== null && s !== null && (n = i, o = s), this.tooltipPosition.moveXCrosshairs(n), !this.fixedTooltip) {
      if (a.config.chart.type === "radar") {
        var l = this.ttCtx.getElGrid().getBoundingClientRect();
        n = this.ttCtx.e.clientX - l.left;
      }
      this.tooltipPosition.moveTooltip(n, o, a.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(e) {
    for (var t = this.w, i = this, s = this.ttCtx, a = e, n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o = t.config.markers.hover.size, l = 0; l < n.length; l++) {
      var c = n[l].getAttribute("rel"), h = n[l].getAttribute("index");
      if (o === void 0 && (o = t.globals.markers.size[h] + t.config.markers.hover.sizeOffset), a === parseInt(c, 10)) {
        i.newPointSize(a, n[l]);
        var d = n[l].getAttribute("cx"), u = n[l].getAttribute("cy");
        i.tooltipPosition.moveXCrosshairs(d), s.fixedTooltip || i.tooltipPosition.moveTooltip(d, u, o);
      } else i.oldPointSize(n[l]);
    }
  } }, { key: "newPointSize", value: function(e, t) {
    var i = this.w, s = i.config.markers.hover.size, a = e === 0 ? t.parentNode.firstChild : t.parentNode.lastChild;
    if (a.getAttribute("default-marker-size") !== "0") {
      var n = parseInt(a.getAttribute("index"), 10);
      s === void 0 && (s = i.globals.markers.size[n] + i.config.markers.hover.sizeOffset), s < 0 && (s = 0);
      var o = this.ttCtx.tooltipUtil.getPathFromPoint(t, s);
      t.setAttribute("d", o);
    }
  } }, { key: "oldPointSize", value: function(e) {
    var t = parseFloat(e.getAttribute("default-marker-size")), i = this.ttCtx.tooltipUtil.getPathFromPoint(e, t);
    e.setAttribute("d", i);
  } }, { key: "resetPointsSize", value: function() {
    for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
      var i = parseFloat(e[t].getAttribute("default-marker-size"));
      if (z.isNumber(i) && i > 0) {
        var s = this.ttCtx.tooltipUtil.getPathFromPoint(e[t], i);
        e[t].setAttribute("d", s);
      } else e[t].setAttribute("d", "M0,0");
    }
  } }]), r;
}(), hd = function() {
  function r(e) {
    ee(this, r), this.w = e.w;
    var t = this.w;
    this.ttCtx = e, this.isVerticalGroupedRangeBar = !t.globals.isBarHorizontal && t.config.chart.type === "rangeBar" && t.config.plotOptions.bar.rangeBarGroupRows;
  }
  return te(r, [{ key: "getAttr", value: function(e, t) {
    return parseFloat(e.target.getAttribute(t));
  } }, { key: "handleHeatTreeTooltip", value: function(e) {
    var t = e.e, i = e.opt, s = e.x, a = e.y, n = e.type, o = this.ttCtx, l = this.w;
    if (t.target.classList.contains("apexcharts-".concat(n, "-rect"))) {
      var c = this.getAttr(t, "i"), h = this.getAttr(t, "j"), d = this.getAttr(t, "cx"), u = this.getAttr(t, "cy"), g = this.getAttr(t, "width"), p = this.getAttr(t, "height");
      if (o.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: c, j: h, shared: !1, e: t }), l.globals.capturedSeriesIndex = c, l.globals.capturedDataPointIndex = h, s = d + o.tooltipRect.ttWidth / 2 + g, a = u + o.tooltipRect.ttHeight / 2 - p / 2, o.tooltipPosition.moveXCrosshairs(d + g / 2), s > l.globals.gridWidth / 2 && (s = d - o.tooltipRect.ttWidth / 2 + g), o.w.config.tooltip.followCursor) {
        var f = l.globals.dom.elWrap.getBoundingClientRect();
        s = l.globals.clientX - f.left - (s > l.globals.gridWidth / 2 ? o.tooltipRect.ttWidth : 0), a = l.globals.clientY - f.top - (a > l.globals.gridHeight / 2 ? o.tooltipRect.ttHeight : 0);
      }
    }
    return { x: s, y: a };
  } }, { key: "handleMarkerTooltip", value: function(e) {
    var t, i, s = e.e, a = e.opt, n = e.x, o = e.y, l = this.w, c = this.ttCtx;
    if (s.target.classList.contains("apexcharts-marker")) {
      var h = parseInt(a.paths.getAttribute("cx"), 10), d = parseInt(a.paths.getAttribute("cy"), 10), u = parseFloat(a.paths.getAttribute("val"));
      if (i = parseInt(a.paths.getAttribute("rel"), 10), t = parseInt(a.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, c.intersect) {
        var g = z.findAncestor(a.paths, "apexcharts-series");
        g && (t = parseInt(g.getAttribute("data:realIndex"), 10));
      }
      if (c.tooltipLabels.drawSeriesTexts({ ttItems: a.ttItems, i: t, j: i, shared: !c.showOnIntersect && l.config.tooltip.shared, e: s }), s.type === "mouseup" && c.markerClick(s, t, i), l.globals.capturedSeriesIndex = t, l.globals.capturedDataPointIndex = i, n = h, o = d + l.globals.translateY - 1.4 * c.tooltipRect.ttHeight, c.w.config.tooltip.followCursor) {
        var p = c.getElGrid().getBoundingClientRect();
        o = c.e.clientY + l.globals.translateY - p.top;
      }
      u < 0 && (o = d), c.marker.enlargeCurrentPoint(i, a.paths, n, o);
    }
    return { x: n, y: o };
  } }, { key: "handleBarTooltip", value: function(e) {
    var t, i, s = e.e, a = e.opt, n = this.w, o = this.ttCtx, l = o.getElTooltip(), c = 0, h = 0, d = 0, u = this.getBarTooltipXY({ e: s, opt: a });
    if (u.j !== null || u.barHeight !== 0 || u.barWidth !== 0) {
      t = u.i;
      var g = u.j;
      if (n.globals.capturedSeriesIndex = t, n.globals.capturedDataPointIndex = g, n.globals.isBarHorizontal && o.tooltipUtil.hasBars() || !n.config.tooltip.shared ? (h = u.x, d = u.y, i = Array.isArray(n.config.stroke.width) ? n.config.stroke.width[t] : n.config.stroke.width, c = h) : n.globals.comboCharts || n.config.tooltip.shared || (c /= 2), isNaN(d) && (d = n.globals.svgHeight - o.tooltipRect.ttHeight), parseInt(a.paths.parentNode.getAttribute("data:realIndex"), 10), h + o.tooltipRect.ttWidth > n.globals.gridWidth ? h -= o.tooltipRect.ttWidth : h < 0 && (h = 0), o.w.config.tooltip.followCursor) {
        var p = o.getElGrid().getBoundingClientRect();
        d = o.e.clientY - p.top;
      }
      o.tooltip === null && (o.tooltip = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), n.config.tooltip.shared || (n.globals.comboBarCount > 0 ? o.tooltipPosition.moveXCrosshairs(c + i / 2) : o.tooltipPosition.moveXCrosshairs(c)), !o.fixedTooltip && (!n.config.tooltip.shared || n.globals.isBarHorizontal && o.tooltipUtil.hasBars()) && (d = d + n.globals.translateY - o.tooltipRect.ttHeight / 2, l.style.left = h + n.globals.translateX + "px", l.style.top = d + "px");
    }
  } }, { key: "getBarTooltipXY", value: function(e) {
    var t = this, i = e.e, s = e.opt, a = this.w, n = null, o = this.ttCtx, l = 0, c = 0, h = 0, d = 0, u = 0, g = i.target.classList;
    if (g.contains("apexcharts-bar-area") || g.contains("apexcharts-candlestick-area") || g.contains("apexcharts-boxPlot-area") || g.contains("apexcharts-rangebar-area")) {
      var p = i.target, f = p.getBoundingClientRect(), x = s.elGrid.getBoundingClientRect(), m = f.height;
      u = f.height;
      var b = f.width, w = parseInt(p.getAttribute("cx"), 10), y = parseInt(p.getAttribute("cy"), 10);
      d = parseFloat(p.getAttribute("barWidth"));
      var v = i.type === "touchmove" ? i.touches[0].clientX : i.clientX;
      n = parseInt(p.getAttribute("j"), 10), l = parseInt(p.parentNode.getAttribute("rel"), 10) - 1;
      var S = p.getAttribute("data-range-y1"), k = p.getAttribute("data-range-y2");
      a.globals.comboCharts && (l = parseInt(p.parentNode.getAttribute("data:realIndex"), 10));
      var C = function(P) {
        return a.globals.isXNumeric ? w - b / 2 : t.isVerticalGroupedRangeBar ? w + b / 2 : w - o.dataPointsDividedWidth + b / 2;
      }, R = function() {
        return y - o.dataPointsDividedHeight + m / 2 - o.tooltipRect.ttHeight / 2;
      };
      o.tooltipLabels.drawSeriesTexts({ ttItems: s.ttItems, i: l, j: n, y1: S ? parseInt(S, 10) : null, y2: k ? parseInt(k, 10) : null, shared: !o.showOnIntersect && a.config.tooltip.shared, e: i }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (c = v - x.left + 15, h = R()) : (c = C(), h = i.clientY - x.top - o.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((c = w) < o.xyRatios.baseLineInvertedY && (c = w - o.tooltipRect.ttWidth), h = R()) : (c = C(), h = y);
    }
    return { x: c, y: h, barHeight: u, barWidth: d, i: l, j: n };
  } }]), r;
}(), dd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.ttCtx = e;
  }
  return te(r, [{ key: "drawXaxisTooltip", value: function() {
    var e = this.w, t = this.ttCtx, i = e.config.xaxis.position === "bottom";
    t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
    var s = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", a = e.globals.dom.elWrap;
    t.isXAxisTooltipEnabled && e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (t.xaxisTooltip = document.createElement("div"), t.xaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + e.config.tooltip.theme), a.appendChild(t.xaxisTooltip), t.xaxisTooltipText = document.createElement("div"), t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily, t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize, t.xaxisTooltip.appendChild(t.xaxisTooltipText));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var e = this.w, t = this.ttCtx, i = 0; i < e.config.yaxis.length; i++) {
      var s = e.config.yaxis[i].opposite || e.config.yaxis[i].crosshairs.opposite;
      t.yaxisOffX = s ? e.globals.gridWidth + 1 : 1;
      var a = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, s ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), n = e.globals.dom.elWrap;
      e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) === null && (t.yaxisTooltip = document.createElement("div"), t.yaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + e.config.tooltip.theme), n.appendChild(t.yaxisTooltip), i === 0 && (t.yaxisTooltipText = []), t.yaxisTooltipText[i] = document.createElement("div"), t.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), t.yaxisTooltip.appendChild(t.yaxisTooltipText[i]));
    }
  } }, { key: "setXCrosshairWidth", value: function() {
    var e = this.w, t = this.ttCtx, i = t.getElXCrosshairs();
    if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10), e.globals.comboCharts) {
      var s = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (s !== null && e.config.xaxis.crosshairs.width === "barWidth") {
        var a = parseFloat(s.getAttribute("barWidth"));
        t.xcrosshairsWidth = a;
      } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
        var n = e.globals.labels.length;
        t.xcrosshairsWidth = e.globals.gridWidth / n;
      }
    } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
      var o = e.globals.labels.length;
      t.xcrosshairsWidth = e.globals.gridWidth / o;
    } else if (e.config.xaxis.crosshairs.width === "barWidth") {
      var l = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (l !== null) {
        var c = parseFloat(l.getAttribute("barWidth"));
        t.xcrosshairsWidth = c;
      } else t.xcrosshairsWidth = 1;
    }
    e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0), i !== null && t.xcrosshairsWidth > 0 && i.setAttribute("width", t.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var e = this.w, t = this.ttCtx;
    t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(e, t, i) {
    var s = this.ttCtx, a = this.w, n = a.globals, o = n.seriesYAxisMap[e];
    if (s.yaxisTooltips[e] && o.length > 0) {
      var l = n.yLabelFormatters[e], c = s.getElGrid().getBoundingClientRect(), h = o[0], d = 0;
      i.yRatio.length > 1 && (d = h);
      var u = (t - c.top) * i.yRatio[d], g = n.maxYArr[h] - n.minYArr[h], p = n.minYArr[h] + (g - u);
      a.config.yaxis[e].reversed && (p = n.maxYArr[h] - (g - u)), s.tooltipPosition.moveYCrosshairs(t - c.top), s.yaxisTooltipText[e].innerHTML = l(p), s.tooltipPosition.moveYAxisTooltip(e);
    }
  } }]), r;
}(), $a = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.tConfig = t.config.tooltip, this.tooltipUtil = new Ro(this), this.tooltipLabels = new ld(this), this.tooltipPosition = new Po(this), this.marker = new cd(this), this.intersect = new hd(this), this.axesTooltip = new dd(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !t.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return te(r, [{ key: "getElTooltip", value: function(e) {
    return e || (e = this), e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(e) {
    var t = this.w;
    this.xyRatios = e, this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts, this.yaxisTooltips = t.config.yaxis.map(function(n, o) {
      return !!(n.show && n.tooltip.enabled && t.globals.axisCharts);
    }), this.allTooltipSeriesGroups = [], t.globals.axisCharts || (this.showTooltipTitle = !1);
    var i = document.createElement("div");
    if (i.classList.add("apexcharts-tooltip"), t.config.tooltip.cssClass && i.classList.add(t.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme || "light")), t.globals.dom.elWrap.appendChild(i), t.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var s = new Mi(this.ctx);
      this.xAxisTicksPositions = s.getXAxisTicksPositions();
    }
    if (!t.globals.comboCharts && !this.tConfig.intersect && t.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), t.config.markers.size !== 0 && t.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), t.globals.collapsedSeries.length !== t.globals.series.length) {
      this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints, this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
      var a = t.globals.series.length;
      (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (a = this.showOnIntersect ? 1 : t.globals.series.length), this.legendLabels = t.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(a), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(e) {
    for (var t = this, i = this.w, s = [], a = this.getElTooltip(), n = function(l) {
      var c = document.createElement("div");
      c.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(l)), c.style.order = i.config.tooltip.inverseOrder ? e - l : l + 1;
      var h = document.createElement("span");
      h.classList.add("apexcharts-tooltip-marker"), i.config.tooltip.fillSeriesColor ? h.style.backgroundColor = i.globals.colors[l] : h.style.color = i.globals.colors[l];
      var d = i.config.markers.shape, u = d;
      Array.isArray(d) && (u = d[l]), h.setAttribute("shape", u), c.appendChild(h);
      var g = document.createElement("div");
      g.classList.add("apexcharts-tooltip-text"), g.style.fontFamily = t.tConfig.style.fontFamily || i.config.chart.fontFamily, g.style.fontSize = t.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(p) {
        var f = document.createElement("div");
        f.classList.add("apexcharts-tooltip-".concat(p, "-group"));
        var x = document.createElement("span");
        x.classList.add("apexcharts-tooltip-text-".concat(p, "-label")), f.appendChild(x);
        var m = document.createElement("span");
        m.classList.add("apexcharts-tooltip-text-".concat(p, "-value")), f.appendChild(m), g.appendChild(f);
      }), c.appendChild(g), a.appendChild(c), s.push(c);
    }, o = 0; o < e; o++) n(o);
    return s;
  } }, { key: "addSVGEvents", value: function() {
    var e = this.w, t = e.config.chart.type, i = this.getElTooltip(), s = !(t !== "bar" && t !== "candlestick" && t !== "boxPlot" && t !== "rangeBar"), a = t === "area" || t === "line" || t === "scatter" || t === "bubble" || t === "radar", n = e.globals.dom.Paper.node, o = this.getElGrid();
    o && (this.seriesBound = o.getBoundingClientRect());
    var l, c = [], h = [], d = { hoverArea: n, elGrid: o, tooltipEl: i, tooltipY: c, tooltipX: h, ttItems: this.ttItems };
    if (e.globals.axisCharts && (a ? l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : s ? l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : t !== "heatmap" && t !== "treemap" || (l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), l && l.length)) for (var u = 0; u < l.length; u++) c.push(l[u].getAttribute("cy")), h.push(l[u].getAttribute("cx"));
    if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || s && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([n], d);
    else if (s && !e.globals.comboCharts || a && this.showOnIntersect) this.addDatapointEventsListeners(d);
    else if (!e.globals.axisCharts || t === "heatmap" || t === "treemap") {
      var g = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(g, d);
    }
    if (this.showOnIntersect) {
      var p = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
      p.length > 0 && this.addPathsEventListeners(p, d), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(d);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var e = this.w, t = this.getElTooltip(), i = t.getBoundingClientRect(), s = i.width + 10, a = i.height + 10, n = this.tConfig.fixed.offsetX, o = this.tConfig.fixed.offsetY, l = this.tConfig.fixed.position.toLowerCase();
    return l.indexOf("right") > -1 && (n = n + e.globals.svgWidth - s + 10), l.indexOf("bottom") > -1 && (o = o + e.globals.svgHeight - a - 10), t.style.left = n + "px", t.style.top = o + "px", { x: n, y: o, ttWidth: s, ttHeight: a };
  } }, { key: "addDatapointEventsListeners", value: function(e) {
    var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(t, e);
  } }, { key: "addPathsEventListeners", value: function(e, t) {
    for (var i = this, s = function(n) {
      var o = { paths: e[n], tooltipEl: t.tooltipEl, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: t.ttItems };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(l) {
        return e[n].addEventListener(l, i.onSeriesHover.bind(i, o), { capture: !1, passive: !0 });
      });
    }, a = 0; a < e.length; a++) s(a);
  } }, { key: "onSeriesHover", value: function(e, t) {
    var i = this, s = Date.now() - this.lastHoverTime;
    s >= 20 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
      i.seriesHover(e, t);
    }, 20 - s));
  } }, { key: "seriesHover", value: function(e, t) {
    var i = this;
    this.lastHoverTime = Date.now();
    var s = [], a = this.w;
    a.config.chart.group && (s = this.ctx.getGroupedCharts()), a.globals.axisCharts && (a.globals.minX === -1 / 0 && a.globals.maxX === 1 / 0 || a.globals.dataPoints === 0) || (s.length ? s.forEach(function(n) {
      var o = i.getElTooltip(n), l = { paths: e.paths, tooltipEl: o, tooltipY: e.tooltipY, tooltipX: e.tooltipX, elGrid: e.elGrid, hoverArea: e.hoverArea, ttItems: n.w.globals.tooltip.ttItems };
      n.w.globals.minX === i.w.globals.minX && n.w.globals.maxX === i.w.globals.maxX && n.w.globals.tooltip.seriesHoverByContext({ chartCtx: n, ttCtx: n.w.globals.tooltip, opt: l, e: t });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: e, e: t }));
  } }, { key: "seriesHoverByContext", value: function(e) {
    var t = e.chartCtx, i = e.ttCtx, s = e.opt, a = e.e, n = t.w, o = this.getElTooltip(t);
    o && (i.tooltipRect = { x: 0, y: 0, ttWidth: o.getBoundingClientRect().width, ttHeight: o.getBoundingClientRect().height }, i.e = a, i.tooltipUtil.hasBars() && !n.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new ot(t).toggleSeriesOnHover(a, a.target.parentNode), n.globals.axisCharts ? i.axisChartsTooltips({ e: a, opt: s, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: a, opt: s, tooltipRect: i.tooltipRect }), i.fixedTooltip && i.drawFixedTooltipRect());
  } }, { key: "axisChartsTooltips", value: function(e) {
    var t, i, s = e.e, a = e.opt, n = this.w, o = a.elGrid.getBoundingClientRect(), l = s.type === "touchmove" ? s.touches[0].clientX : s.clientX, c = s.type === "touchmove" ? s.touches[0].clientY : s.clientY;
    if (this.clientY = c, this.clientX = l, n.globals.capturedSeriesIndex = -1, n.globals.capturedDataPointIndex = -1, c < o.top || c > o.top + o.height) this.handleMouseOut(a);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !n.config.tooltip.shared) {
        var h = parseInt(a.paths.getAttribute("index"), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h) < 0) return void this.handleMouseOut(a);
      }
      var d = this.getElTooltip(), u = this.getElXCrosshairs(), g = [];
      n.config.chart.group && (g = this.ctx.getSyncedCharts());
      var p = n.globals.xyCharts || n.config.chart.type === "bar" && !n.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || n.globals.comboCharts && this.tooltipUtil.hasBars();
      if (s.type === "mousemove" || s.type === "touchmove" || s.type === "mouseup") {
        if (n.globals.collapsedSeries.length + n.globals.ancillaryCollapsedSeries.length === n.globals.series.length) return;
        u !== null && u.classList.add("apexcharts-active");
        var f = this.yaxisTooltips.filter(function(b) {
          return b === !0;
        });
        if (this.ycrosshairs !== null && f.length && this.ycrosshairs.classList.add("apexcharts-active"), p && !this.showOnIntersect || g.length > 1) this.handleStickyTooltip(s, l, c, a);
        else if (n.config.chart.type === "heatmap" || n.config.chart.type === "treemap") {
          var x = this.intersect.handleHeatTreeTooltip({ e: s, opt: a, x: t, y: i, type: n.config.chart.type });
          t = x.x, i = x.y, d.style.left = t + "px", d.style.top = i + "px";
        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: s, opt: a }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: s, opt: a, x: t, y: i });
        if (this.yaxisTooltips.length) for (var m = 0; m < n.config.yaxis.length; m++) this.axesTooltip.drawYaxisTooltipText(m, c, this.xyRatios);
        n.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), a.tooltipEl.classList.add("apexcharts-active");
      } else s.type !== "mouseout" && s.type !== "touchend" || this.handleMouseOut(a);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(e) {
    var t = e.e, i = e.opt, s = e.tooltipRect, a = this.w, n = i.paths.getAttribute("rel"), o = this.getElTooltip(), l = a.globals.dom.elWrap.getBoundingClientRect();
    if (t.type === "mousemove" || t.type === "touchmove") {
      a.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), o.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(n, 10) - 1, shared: !1 });
      var c = a.globals.clientX - l.left - s.ttWidth / 2, h = a.globals.clientY - l.top - s.ttHeight - 10;
      if (o.style.left = c + "px", o.style.top = h + "px", a.config.legend.tooltipHoverFormatter) {
        var d = n - 1, u = (0, a.config.legend.tooltipHoverFormatter)(this.legendLabels[d].getAttribute("data:default-text"), { seriesIndex: d, dataPointIndex: d, w: a });
        this.legendLabels[d].innerHTML = u;
      }
    } else t.type !== "mouseout" && t.type !== "touchend" || (o.classList.remove("apexcharts-active"), a.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), a.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(g) {
      var p = g.getAttribute("data:default-text");
      g.innerHTML = decodeURIComponent(p);
    }));
  } }, { key: "handleStickyTooltip", value: function(e, t, i, s) {
    var a = this.w, n = this.tooltipUtil.getNearestValues({ context: this, hoverArea: s.hoverArea, elGrid: s.elGrid, clientX: t, clientY: i }), o = n.j, l = n.capturedSeries;
    a.globals.collapsedSeriesIndices.includes(l) && (l = null);
    var c = s.elGrid.getBoundingClientRect();
    if (n.hoverX < 0 || n.hoverX > c.width) this.handleMouseOut(s);
    else if (l !== null) this.handleStickyCapturedSeries(e, l, s, o);
    else if (this.tooltipUtil.isXoverlap(o) || a.globals.isBarHorizontal) {
      var h = a.globals.series.findIndex(function(d, u) {
        return !a.globals.collapsedSeriesIndices.includes(u);
      });
      this.create(e, this, h, o, s.ttItems);
    }
  } }, { key: "handleStickyCapturedSeries", value: function(e, t, i, s) {
    var a = this.w;
    if (!this.tConfig.shared && a.globals.series[t][s] === null) return void this.handleMouseOut(i);
    if (a.globals.series[t][s] !== void 0) this.tConfig.shared && this.tooltipUtil.isXoverlap(s) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, s, i.ttItems) : this.create(e, this, t, s, i.ttItems, !1);
    else if (this.tooltipUtil.isXoverlap(s)) {
      var n = a.globals.series.findIndex(function(o, l) {
        return !a.globals.collapsedSeriesIndices.includes(l);
      });
      this.create(e, this, n, s, i.ttItems);
    }
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var e = this.w, t = new B(this.ctx), i = e.globals.dom.Paper.find(".apexcharts-bar-area"), s = 0; s < i.length; s++) t.pathMouseLeave(i[s]);
  } }, { key: "handleMouseOut", value: function(e) {
    var t = this.w, i = this.getElXCrosshairs();
    if (t.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), e.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), t.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      this.yaxisTTEls === null && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var s = 0; s < this.yaxisTTEls.length; s++) this.yaxisTTEls[s].classList.remove("apexcharts-active");
    }
    t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(a) {
      var n = a.getAttribute("data:default-text");
      a.innerHTML = decodeURIComponent(n);
    });
  } }, { key: "markerClick", value: function(e, t, i) {
    var s = this.w;
    typeof s.config.chart.events.markerClick == "function" && s.config.chart.events.markerClick(e, this.ctx, { seriesIndex: t, dataPointIndex: i, w: s }), this.ctx.events.fireEvent("markerClick", [e, this.ctx, { seriesIndex: t, dataPointIndex: i, w: s }]);
  } }, { key: "create", value: function(e, t, i, s, a) {
    var n, o, l, c, h, d, u, g, p, f, x, m, b, w, y, v, S = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, k = this.w, C = t;
    e.type === "mouseup" && this.markerClick(e, i, s), S === null && (S = this.tConfig.shared);
    var R = this.tooltipUtil.hasMarkers(i), P = this.tooltipUtil.getElBars(), A = function() {
      k.globals.markers.largestSize > 0 ? C.marker.enlargePoints(s) : C.tooltipPosition.moveDynamicPointsOnHover(s);
    };
    if (k.config.legend.tooltipHoverFormatter) {
      var E = k.config.legend.tooltipHoverFormatter, N = Array.from(this.legendLabels);
      N.forEach(function(Z) {
        var X = Z.getAttribute("data:default-text");
        Z.innerHTML = decodeURIComponent(X);
      });
      for (var O = 0; O < N.length; O++) {
        var L = N[O], I = parseInt(L.getAttribute("i"), 10), F = decodeURIComponent(L.getAttribute("data:default-text")), D = E(F, { seriesIndex: S ? I : i, dataPointIndex: s, w: k });
        if (S) L.innerHTML = k.globals.collapsedSeriesIndices.indexOf(I) < 0 ? D : F;
        else if (L.innerHTML = I === i ? D : F, i === I) break;
      }
    }
    var Y = q(q({ ttItems: a, i, j: s }, ((n = k.globals.seriesRange) === null || n === void 0 || (o = n[i]) === null || o === void 0 || (l = o[s]) === null || l === void 0 || (c = l.y[0]) === null || c === void 0 ? void 0 : c.y1) !== void 0 && { y1: (h = k.globals.seriesRange) === null || h === void 0 || (d = h[i]) === null || d === void 0 || (u = d[s]) === null || u === void 0 || (g = u.y[0]) === null || g === void 0 ? void 0 : g.y1 }), ((p = k.globals.seriesRange) === null || p === void 0 || (f = p[i]) === null || f === void 0 || (x = f[s]) === null || x === void 0 || (m = x.y[0]) === null || m === void 0 ? void 0 : m.y2) !== void 0 && { y2: (b = k.globals.seriesRange) === null || b === void 0 || (w = b[i]) === null || w === void 0 || (y = w[s]) === null || y === void 0 || (v = y.y[0]) === null || v === void 0 ? void 0 : v.y2 });
    if (S) {
      if (C.tooltipLabels.drawSeriesTexts(q(q({}, Y), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), R) A();
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(P), this.barSeriesHeight > 0)) {
        var _ = new B(this.ctx), H = k.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(s, "']"));
        this.deactivateHoverFilter(), C.tooltipUtil.getAllMarkers(!0).length && !this.barSeriesHeight && A(), C.tooltipPosition.moveStickyTooltipOverBars(s, i);
        for (var V = 0; V < H.length; V++) _.pathMouseEnter(H[V]);
      }
    } else C.tooltipLabels.drawSeriesTexts(q({ shared: !1 }, Y)), this.tooltipUtil.hasBars() && C.tooltipPosition.moveStickyTooltipOverBars(s, i), R && C.tooltipPosition.moveMarkers(i, s);
  } }]), r;
}(), ud = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.barCtx = e, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return te(r, [{ key: "handleBarDataLabels", value: function(e) {
    var t, i, s = e.x, a = e.y, n = e.y1, o = e.y2, l = e.i, c = e.j, h = e.realIndex, d = e.columnGroupIndex, u = e.series, g = e.barHeight, p = e.barWidth, f = e.barXPosition, x = e.barYPosition, m = e.visibleSeries, b = this.w, w = new B(this.barCtx.ctx), y = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h] : this.barCtx.strokeWidth;
    b.globals.isXNumeric && !b.globals.isBarHorizontal ? (t = s + parseFloat(p * (m + 1)), i = a + parseFloat(g * (m + 1)) - y) : (t = s + parseFloat(p * m), i = a + parseFloat(g * m));
    var v, S = null, k = s, C = a, R = {}, P = b.config.dataLabels, A = this.barCtx.barOptions.dataLabels, E = this.barCtx.barOptions.dataLabels.total;
    x !== void 0 && this.barCtx.isRangeBar && (i = x, C = x), f !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (t = f, k = f);
    var N = P.offsetX, O = P.offsetY, L = { width: 0, height: 0 };
    if (b.config.dataLabels.enabled) {
      var I = b.globals.series[l][c];
      L = w.getTextRects(b.config.dataLabels.formatter ? b.config.dataLabels.formatter(I, q(q({}, b), {}, { seriesIndex: l, dataPointIndex: c, w: b })) : b.globals.yLabelFormatters[0](I), parseFloat(P.style.fontSize));
    }
    var F = { x: s, y: a, i: l, j: c, realIndex: h, columnGroupIndex: d, bcx: t, bcy: i, barHeight: g, barWidth: p, textRects: L, strokeWidth: y, dataLabelsX: k, dataLabelsY: C, dataLabelsConfig: P, barDataLabelsConfig: A, barTotalDataLabelsConfig: E, offX: N, offY: O };
    return R = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(F) : this.calculateColumnsDataLabelsPosition(F), v = this.drawCalculatedDataLabels({ x: R.dataLabelsX, y: R.dataLabelsY, val: this.barCtx.isRangeBar ? [n, o] : b.config.chart.stackType === "100%" ? u[h][c] : b.globals.series[h][c], i: h, j: c, barWidth: p, barHeight: g, textRects: L, dataLabelsConfig: P }), b.config.chart.stacked && E.enabled && (S = this.drawTotalDataLabels({ x: R.totalDataLabelsX, y: R.totalDataLabelsY, barWidth: p, barHeight: g, realIndex: h, textAnchor: R.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h, j: c }), dataLabelsConfig: P, barTotalDataLabelsConfig: E })), { dataLabelsPos: R, dataLabels: v, totalDataLabels: S };
  } }, { key: "getStackedTotalDataLabel", value: function(e) {
    var t = e.realIndex, i = e.j, s = this.w, a = this.barCtx.stackedSeriesTotals[i];
    return this.totalFormatter && (a = this.totalFormatter(a, q(q({}, s), {}, { seriesIndex: t, dataPointIndex: i, w: s }))), a;
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(e) {
    var t = this, i = this.w, s = e.i, a = e.j, n = e.realIndex;
    e.columnGroupIndex;
    var o, l, c = e.y, h = e.bcx, d = e.barWidth, u = e.barHeight, g = e.textRects, p = e.dataLabelsX, f = e.dataLabelsY, x = e.dataLabelsConfig, m = e.barDataLabelsConfig, b = e.barTotalDataLabelsConfig, w = e.strokeWidth, y = e.offX, v = e.offY, S = h;
    u = Math.abs(u);
    var k = i.config.plotOptions.bar.dataLabels.orientation === "vertical", C = this.barCtx.barHelpers.getZeroValueEncounters({ i: s, j: a }).zeroEncounters;
    h -= w / 2;
    var R = i.globals.gridWidth / i.globals.dataPoints;
    this.barCtx.isVerticalGroupedRangeBar ? p += d / 2 : (p = i.globals.isXNumeric ? h - d / 2 + y : h - R + d / 2 + y, !i.config.chart.stacked && C > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (p -= d * C)), k && (p = p + g.height / 2 - w / 2 - 2);
    var P = i.globals.series[s][a] < 0, A = c;
    switch (this.barCtx.isReversed && (A = c + (P ? u : -u)), m.position) {
      case "center":
        f = k ? P ? A - u / 2 + v : A + u / 2 - v : P ? A - u / 2 + g.height / 2 + v : A + u / 2 + g.height / 2 - v;
        break;
      case "bottom":
        f = k ? P ? A - u + v : A + u - v : P ? A - u + g.height + w + v : A + u - g.height / 2 + w - v;
        break;
      case "top":
        f = k ? P ? A + v : A - v : P ? A - g.height / 2 - v : A + g.height + v;
    }
    var E = A;
    if (i.globals.seriesGroups.forEach(function(L) {
      var I;
      (I = t.barCtx[L.join(",")]) === null || I === void 0 || I.prevY.forEach(function(F) {
        E = P ? Math.max(F[a], E) : Math.min(F[a], E);
      });
    }), this.barCtx.lastActiveBarSerieIndex === n && b.enabled) {
      var N = new B(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n, j: a }), x.fontSize);
      o = P ? E - N.height / 2 - v - b.offsetY + 18 : E + N.height + v + b.offsetY - 18;
      var O = R;
      l = S + (i.globals.isXNumeric ? -d * i.globals.barGroups.length / 2 : i.globals.barGroups.length * d / 2 - (i.globals.barGroups.length - 1) * d - O) + b.offsetX;
    }
    return i.config.chart.stacked || (f < 0 ? f = 0 + w : f + g.height / 3 > i.globals.gridHeight && (f = i.globals.gridHeight - w)), { bcx: h, bcy: c, dataLabelsX: p, dataLabelsY: f, totalDataLabelsX: l, totalDataLabelsY: o, totalDataLabelsAnchor: "middle" };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(e) {
    var t = this, i = this.w, s = e.x, a = e.i, n = e.j, o = e.realIndex, l = e.bcy, c = e.barHeight, h = e.barWidth, d = e.textRects, u = e.dataLabelsX, g = e.strokeWidth, p = e.dataLabelsConfig, f = e.barDataLabelsConfig, x = e.barTotalDataLabelsConfig, m = e.offX, b = e.offY, w = i.globals.gridHeight / i.globals.dataPoints, y = this.barCtx.barHelpers.getZeroValueEncounters({ i: a, j: n }).zeroEncounters;
    h = Math.abs(h);
    var v, S, k = l - (this.barCtx.isRangeBar ? 0 : w) + c / 2 + d.height / 2 + b - 3;
    !i.config.chart.stacked && y > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (k -= c * y);
    var C = "start", R = i.globals.series[a][n] < 0, P = s;
    switch (this.barCtx.isReversed && (P = s + (R ? -h : h), C = R ? "start" : "end"), f.position) {
      case "center":
        u = R ? P + h / 2 - m : Math.max(d.width / 2, P - h / 2) + m;
        break;
      case "bottom":
        u = R ? P + h - g - m : P - h + g + m;
        break;
      case "top":
        u = R ? P - g - m : P - g + m;
    }
    var A = P;
    if (i.globals.seriesGroups.forEach(function(N) {
      var O;
      (O = t.barCtx[N.join(",")]) === null || O === void 0 || O.prevX.forEach(function(L) {
        A = R ? Math.min(L[n], A) : Math.max(L[n], A);
      });
    }), this.barCtx.lastActiveBarSerieIndex === o && x.enabled) {
      var E = new B(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: o, j: n }), p.fontSize);
      R ? (v = A - g - m - x.offsetX, C = "end") : v = A + m + x.offsetX + (this.barCtx.isReversed ? -(h + g) : g), S = k - d.height / 2 + E.height / 2 + x.offsetY + g, i.globals.barGroups.length > 1 && (S -= i.globals.barGroups.length / 2 * (c / 2));
    }
    return i.config.chart.stacked || (p.textAnchor === "start" ? u - d.width < 0 ? u = R ? d.width + g : g : u + d.width > i.globals.gridWidth && (u = R ? i.globals.gridWidth - g : i.globals.gridWidth - d.width - g) : p.textAnchor === "middle" ? u - d.width / 2 < 0 ? u = d.width / 2 + g : u + d.width / 2 > i.globals.gridWidth && (u = i.globals.gridWidth - d.width / 2 - g) : p.textAnchor === "end" && (u < 1 ? u = d.width + g : u + 1 > i.globals.gridWidth && (u = i.globals.gridWidth - d.width - g))), { bcx: s, bcy: l, dataLabelsX: u, dataLabelsY: k, totalDataLabelsX: v, totalDataLabelsY: S, totalDataLabelsAnchor: C };
  } }, { key: "drawCalculatedDataLabels", value: function(e) {
    var t = e.x, i = e.y, s = e.val, a = e.i, n = e.j, o = e.textRects, l = e.barHeight, c = e.barWidth, h = e.dataLabelsConfig, d = this.w, u = "rotate(0)";
    d.config.plotOptions.bar.dataLabels.orientation === "vertical" && (u = "rotate(-90, ".concat(t, ", ").concat(i, ")"));
    var g = new Jt(this.barCtx.ctx), p = new B(this.barCtx.ctx), f = h.formatter, x = null, m = d.globals.collapsedSeriesIndices.indexOf(a) > -1;
    if (h.enabled && !m) {
      x = p.group({ class: "apexcharts-data-labels", transform: u });
      var b = "";
      s !== void 0 && (b = f(s, q(q({}, d), {}, { seriesIndex: a, dataPointIndex: n, w: d }))), !s && d.config.plotOptions.bar.hideZeroBarsWhenGrouped && (b = "");
      var w = d.globals.series[a][n] < 0, y = d.config.plotOptions.bar.dataLabels.position;
      d.config.plotOptions.bar.dataLabels.orientation === "vertical" && (y === "top" && (h.textAnchor = w ? "end" : "start"), y === "center" && (h.textAnchor = "middle"), y === "bottom" && (h.textAnchor = w ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && c < p.getTextRects(b, parseFloat(h.style.fontSize)).width && (b = ""), d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? o.width / 1.6 > Math.abs(c) && (b = "") : o.height / 1.6 > Math.abs(l) && (b = ""));
      var v = q({}, h);
      this.barCtx.isHorizontal && s < 0 && (h.textAnchor === "start" ? v.textAnchor = "end" : h.textAnchor === "end" && (v.textAnchor = "start")), g.plotDataLabelsText({ x: t, y: i, text: b, i: a, j: n, parent: x, dataLabelsConfig: v, alwaysDrawDataLabel: !0, offsetCorrection: !0 });
    }
    return x;
  } }, { key: "drawTotalDataLabels", value: function(e) {
    var t = e.x, i = e.y, s = e.val, a = e.realIndex, n = e.textAnchor, o = e.barTotalDataLabelsConfig;
    this.w;
    var l, c = new B(this.barCtx.ctx);
    return o.enabled && t !== void 0 && i !== void 0 && this.barCtx.lastActiveBarSerieIndex === a && (l = c.drawText({ x: t, y: i, foreColor: o.style.color, text: s, textAnchor: n, fontFamily: o.style.fontFamily, fontSize: o.style.fontSize, fontWeight: o.style.fontWeight })), l;
  } }]), r;
}(), gd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.barCtx = e;
  }
  return te(r, [{ key: "initVariables", value: function(e) {
    var t = this.w;
    this.barCtx.series = e, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i = 0; i < e.length; i++) if (e[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += e[i].length), t.globals.isXNumeric) for (var s = 0; s < e[i].length; s++) t.globals.seriesX[i][s] > t.globals.minX && t.globals.seriesX[i][s] < t.globals.maxX && this.barCtx.visibleItems++;
    else this.barCtx.visibleItems = t.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(t.globals.series), z.isSafari() && (this.arrBorderRadius = this.arrBorderRadius.map(function(a) {
      return a.map(function(n) {
        return "none";
      });
    })), this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], t.globals.comboCharts || this.checkZeroSeries({ series: e });
  } }, { key: "initialPositions", value: function(e) {
    var t, i, s, a, n, o, l, c, h = this.w, d = h.globals.dataPoints;
    this.barCtx.isRangeBar && (d = h.globals.labels.length);
    var u = this.barCtx.seriesLen;
    if (h.config.plotOptions.bar.rangeBarGroupRows && (u = 1), this.barCtx.isHorizontal) n = (s = h.globals.gridHeight / d) / u, h.globals.isXNumeric && (n = (s = h.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), n = n * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (n = parseInt(this.barCtx.barOptions.barHeight, 10)), c = this.barCtx.baseLineInvertedY + h.globals.padHorizontal + (this.barCtx.isReversed ? h.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (c = h.globals.gridWidth / 2), i = (s - n * this.barCtx.seriesLen) / 2;
    else {
      if (a = h.globals.gridWidth / this.barCtx.visibleItems, h.config.xaxis.convertedCatToNumeric && (a = h.globals.gridWidth / h.globals.dataPoints), o = a / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h.globals.isXNumeric) {
        var g = this.barCtx.xRatio;
        h.globals.minXDiff && h.globals.minXDiff !== 0.5 && h.globals.minXDiff / g > 0 && (a = h.globals.minXDiff / g), (o = a / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (o = 1);
      }
      String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (o = parseInt(this.barCtx.barOptions.columnWidth, 10)), l = h.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h.globals.isXNumeric ? t = this.barCtx.getBarXForNumericXAxis({ x: t, j: 0, realIndex: e, barWidth: o }).x : t = h.globals.padHorizontal + z.noExponents(a - o * this.barCtx.seriesLen) / 2;
    }
    return h.globals.barHeight = n, h.globals.barWidth = o, { x: t, y: i, yDivision: s, xDivision: a, barHeight: n, barWidth: o, zeroH: l, zeroW: c };
  } }, { key: "initializeStackedPrevVars", value: function(e) {
    e.w.globals.seriesGroups.forEach(function(t) {
      e[t] || (e[t] = {}), e[t].prevY = [], e[t].prevX = [], e[t].prevYF = [], e[t].prevXF = [], e[t].prevYVal = [], e[t].prevXVal = [];
    });
  } }, { key: "initializeStackedXYVars", value: function(e) {
    e.w.globals.seriesGroups.forEach(function(t) {
      e[t] || (e[t] = {}), e[t].xArrj = [], e[t].xArrjF = [], e[t].xArrjVal = [], e[t].yArrj = [], e[t].yArrjF = [], e[t].yArrjVal = [];
    });
  } }, { key: "getPathFillColor", value: function(e, t, i, s) {
    var a, n, o, l, c = this.w, h = this.barCtx.ctx.fill, d = null, u = this.barCtx.barOptions.distributed ? i : t, g = !1;
    return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(p) {
      e[t][i] >= p.from && e[t][i] <= p.to && (d = p.color, g = !0);
    }), { color: h.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? u : s, dataPointIndex: i, color: d, value: e[t][i], fillConfig: (a = c.config.series[t].data[i]) === null || a === void 0 ? void 0 : a.fill, fillType: (n = c.config.series[t].data[i]) !== null && n !== void 0 && (o = n.fill) !== null && o !== void 0 && o.type ? (l = c.config.series[t].data[i]) === null || l === void 0 ? void 0 : l.fill.type : Array.isArray(c.config.fill.type) ? c.config.fill.type[s] : c.config.fill.type }), useRangeColor: g };
  } }, { key: "getStrokeWidth", value: function(e, t, i) {
    var s = 0, a = this.w;
    return this.barCtx.series[e][t] === void 0 || this.barCtx.series[e][t] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, a.config.stroke.show && (this.barCtx.isNullValue || (s = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), s;
  } }, { key: "createBorderRadiusArr", value: function(e) {
    var t, i = this.w, s = !this.w.config.chart.stacked || i.config.plotOptions.bar.borderRadius <= 0, a = e.length, n = 0 | ((t = e[0]) === null || t === void 0 ? void 0 : t.length), o = Array.from({ length: a }, function() {
      return Array(n).fill(s ? "top" : "none");
    });
    if (s) return o;
    for (var l = 0; l < n; l++) {
      for (var c = [], h = [], d = 0, u = 0; u < a; u++) {
        var g = e[u][l];
        g > 0 ? (c.push(u), d++) : g < 0 && (h.push(u), d++);
      }
      if (c.length > 0 && h.length === 0) if (c.length === 1) o[c[0]][l] = "both";
      else {
        var p, f = c[0], x = c[c.length - 1], m = gi(c);
        try {
          for (m.s(); !(p = m.n()).done; ) {
            var b = p.value;
            o[b][l] = b === f ? "bottom" : b === x ? "top" : "none";
          }
        } catch (I) {
          m.e(I);
        } finally {
          m.f();
        }
      }
      else if (h.length > 0 && c.length === 0) if (h.length === 1) o[h[0]][l] = "both";
      else {
        var w, y = Math.max.apply(Math, h), v = Math.min.apply(Math, h), S = gi(h);
        try {
          for (S.s(); !(w = S.n()).done; ) {
            var k = w.value;
            o[k][l] = k === y ? "bottom" : k === v ? "top" : "none";
          }
        } catch (I) {
          S.e(I);
        } finally {
          S.f();
        }
      }
      else if (c.length > 0 && h.length > 0) {
        var C, R = c[c.length - 1], P = gi(c);
        try {
          for (P.s(); !(C = P.n()).done; ) {
            var A = C.value;
            o[A][l] = A === R ? "top" : "none";
          }
        } catch (I) {
          P.e(I);
        } finally {
          P.f();
        }
        var E, N = Math.max.apply(Math, h), O = gi(h);
        try {
          for (O.s(); !(E = O.n()).done; ) {
            var L = E.value;
            o[L][l] = L === N ? "bottom" : "none";
          }
        } catch (I) {
          O.e(I);
        } finally {
          O.f();
        }
      } else d === 1 && (o[c[0] || h[0]][l] = "both");
    }
    return o;
  } }, { key: "barBackground", value: function(e) {
    var t = e.j, i = e.i, s = e.x1, a = e.x2, n = e.y1, o = e.y2, l = e.elSeries, c = this.w, h = new B(this.barCtx.ctx), d = new ot(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && d === i) {
      t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var u = this.barCtx.barOptions.colors.backgroundBarColors[t], g = h.drawRect(s !== void 0 ? s : 0, n !== void 0 ? n : 0, a !== void 0 ? a : c.globals.gridWidth, o !== void 0 ? o : c.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, u, this.barCtx.barOptions.colors.backgroundBarOpacity);
      l.add(g), g.node.classList.add("apexcharts-backgroundBar");
    }
  } }, { key: "getColumnPaths", value: function(e) {
    var t, i = e.barWidth, s = e.barXPosition, a = e.y1, n = e.y2, o = e.strokeWidth, l = e.isReversed, c = e.series, h = e.seriesGroup, d = e.realIndex, u = e.i, g = e.j, p = e.w, f = new B(this.barCtx.ctx);
    (o = Array.isArray(o) ? o[d] : o) || (o = 0);
    var x = i, m = s;
    (t = p.config.series[d].data[g]) !== null && t !== void 0 && t.columnWidthOffset && (m = s - p.config.series[d].data[g].columnWidthOffset / 2, x = i + p.config.series[d].data[g].columnWidthOffset);
    var b = o / 2, w = m + b, y = m + x - b, v = (c[u][g] >= 0 ? 1 : -1) * (l ? -1 : 1);
    a += 1e-3 - b * v, n += 1e-3 + b * v;
    var S = f.move(w, a), k = f.move(w, a), C = f.line(y, a);
    if (p.globals.previousPaths.length > 0 && (k = this.barCtx.getPreviousPath(d, g, !1)), S = S + f.line(w, n) + f.line(y, n) + C + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), k = k + f.line(w, a) + C + C + C + C + C + f.line(w, a) + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), this.arrBorderRadius[d][g] !== "none" && (S = f.roundPathCorners(S, p.config.plotOptions.bar.borderRadius)), p.config.chart.stacked) {
      var R = this.barCtx;
      (R = this.barCtx[h]).yArrj.push(n - b * v), R.yArrjF.push(Math.abs(a - n + o * v)), R.yArrjVal.push(this.barCtx.series[u][g]);
    }
    return { pathTo: S, pathFrom: k };
  } }, { key: "getBarpaths", value: function(e) {
    var t, i = e.barYPosition, s = e.barHeight, a = e.x1, n = e.x2, o = e.strokeWidth, l = e.isReversed, c = e.series, h = e.seriesGroup, d = e.realIndex, u = e.i, g = e.j, p = e.w, f = new B(this.barCtx.ctx);
    (o = Array.isArray(o) ? o[d] : o) || (o = 0);
    var x = i, m = s;
    (t = p.config.series[d].data[g]) !== null && t !== void 0 && t.barHeightOffset && (x = i - p.config.series[d].data[g].barHeightOffset / 2, m = s + p.config.series[d].data[g].barHeightOffset);
    var b = o / 2, w = x + b, y = x + m - b, v = (c[u][g] >= 0 ? 1 : -1) * (l ? -1 : 1);
    a += 1e-3 + b * v, n += 1e-3 - b * v;
    var S = f.move(a, w), k = f.move(a, w);
    p.globals.previousPaths.length > 0 && (k = this.barCtx.getPreviousPath(d, g, !1));
    var C = f.line(a, y);
    if (S = S + f.line(n, w) + f.line(n, y) + C + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), k = k + f.line(a, w) + C + C + C + C + C + f.line(a, w) + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), this.arrBorderRadius[d][g] !== "none" && (S = f.roundPathCorners(S, p.config.plotOptions.bar.borderRadius)), p.config.chart.stacked) {
      var R = this.barCtx;
      (R = this.barCtx[h]).xArrj.push(n + b * v), R.xArrjF.push(Math.abs(a - n - o * v)), R.xArrjVal.push(this.barCtx.series[u][g]);
    }
    return { pathTo: S, pathFrom: k };
  } }, { key: "checkZeroSeries", value: function(e) {
    for (var t = e.series, i = this.w, s = 0; s < t.length; s++) {
      for (var a = 0, n = 0; n < t[i.globals.maxValsInArrayIndex].length; n++) a += t[s][n];
      a === 0 && this.barCtx.zeroSerieses.push(s);
    }
  } }, { key: "getXForValue", value: function(e, t) {
    var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? t : null;
    return e != null && (i = t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0)), i;
  } }, { key: "getYForValue", value: function(e, t, i) {
    var s = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3] ? t : null;
    return e != null && (s = t - e / this.barCtx.yRatio[i] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[i] : 0)), s;
  } }, { key: "getGoalValues", value: function(e, t, i, s, a, n) {
    var o = this, l = this.w, c = [], h = function(g, p) {
      var f;
      c.push((Zi(f = {}, e, e === "x" ? o.getXForValue(g, t, !1) : o.getYForValue(g, i, n, !1)), Zi(f, "attrs", p), f));
    };
    if (l.globals.seriesGoals[s] && l.globals.seriesGoals[s][a] && Array.isArray(l.globals.seriesGoals[s][a]) && l.globals.seriesGoals[s][a].forEach(function(g) {
      h(g.value, g);
    }), this.barCtx.barOptions.isDumbbell && l.globals.seriesRange.length) {
      var d = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l.globals.colors, u = { strokeHeight: e === "x" ? 0 : l.globals.markers.size[s], strokeWidth: e === "x" ? l.globals.markers.size[s] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d[s]) ? d[s][0] : d[s] };
      h(l.globals.seriesRangeStart[s][a], u), h(l.globals.seriesRangeEnd[s][a], q(q({}, u), {}, { strokeColor: Array.isArray(d[s]) ? d[s][1] : d[s] }));
    }
    return c;
  } }, { key: "drawGoalLine", value: function(e) {
    var t = e.barXPosition, i = e.barYPosition, s = e.goalX, a = e.goalY, n = e.barWidth, o = e.barHeight, l = new B(this.barCtx.ctx), c = l.group({ className: "apexcharts-bar-goals-groups" });
    c.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: c.node }), c.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
    var h = null;
    return this.barCtx.isHorizontal ? Array.isArray(s) && s.forEach(function(d) {
      if (d.x >= -1 && d.x <= l.w.globals.gridWidth + 1) {
        var u = d.attrs.strokeHeight !== void 0 ? d.attrs.strokeHeight : o / 2, g = i + u + o / 2;
        h = l.drawLine(d.x, g - 2 * u, d.x, g, d.attrs.strokeColor ? d.attrs.strokeColor : void 0, d.attrs.strokeDashArray, d.attrs.strokeWidth ? d.attrs.strokeWidth : 2, d.attrs.strokeLineCap), c.add(h);
      }
    }) : Array.isArray(a) && a.forEach(function(d) {
      if (d.y >= -1 && d.y <= l.w.globals.gridHeight + 1) {
        var u = d.attrs.strokeWidth !== void 0 ? d.attrs.strokeWidth : n / 2, g = t + u + n / 2;
        h = l.drawLine(g - 2 * u, d.y, g, d.y, d.attrs.strokeColor ? d.attrs.strokeColor : void 0, d.attrs.strokeDashArray, d.attrs.strokeHeight ? d.attrs.strokeHeight : 2, d.attrs.strokeLineCap), c.add(h);
      }
    }), c;
  } }, { key: "drawBarShadow", value: function(e) {
    var t = e.prevPaths, i = e.currPaths, s = e.color, a = this.w, n = t.x, o = t.x1, l = t.barYPosition, c = i.x, h = i.x1, d = i.barYPosition, u = l + i.barHeight, g = new B(this.barCtx.ctx), p = new z(), f = g.move(o, u) + g.line(n, u) + g.line(c, d) + g.line(h, d) + g.line(o, u) + (a.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[realIndex][j] === "both" ? " Z" : " z");
    return g.drawPath({ d: f, fill: p.shadeColor(0.5, z.rgb2hex(s)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadow apexcharts-decoration-element" });
  } }, { key: "getZeroValueEncounters", value: function(e) {
    var t, i = e.i, s = e.j, a = this.w, n = 0, o = 0;
    return (a.config.plotOptions.bar.horizontal ? a.globals.series.map(function(l, c) {
      return c;
    }) : ((t = a.globals.columnSeries) === null || t === void 0 ? void 0 : t.i.map(function(l) {
      return l;
    })) || []).forEach(function(l) {
      var c = a.globals.seriesPercent[l][s];
      c && n++, l < i && c === 0 && o++;
    }), { nonZeroColumns: n, zeroEncounters: o };
  } }, { key: "getGroupIndex", value: function(e) {
    var t = this.w, i = t.globals.seriesGroups.findIndex(function(n) {
      return n.indexOf(t.globals.seriesNames[e]) > -1;
    }), s = this.barCtx.columnGroupIndices, a = s.indexOf(i);
    return a < 0 && (s.push(i), a = s.length - 1), { groupIndex: i, columnGroupIndex: a };
  } }]), r;
}(), Kt = function() {
  function r(e, t) {
    ee(this, r), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = t, this.xyRatios !== null && (this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.invertedXRatio = t.invertedXRatio, this.invertedYRatio = t.invertedYRatio, this.baseLineY = t.baseLineY, this.baseLineInvertedY = t.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var s = new ot(this.ctx);
    this.lastActiveBarSerieIndex = s.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
    var a = s.getBarSeriesIndices(), n = new ze(this.ctx);
    this.stackedSeriesTotals = n.getStackedSeriesTotals(this.w.config.series.map(function(o, l) {
      return a.indexOf(l) === -1 ? l : -1;
    }).filter(function(o) {
      return o !== -1;
    })), this.barHelpers = new gd(this);
  }
  return te(r, [{ key: "draw", value: function(e, t) {
    var i = this.w, s = new B(this.ctx), a = new ze(this.ctx, i);
    e = a.getLogSeries(e), this.series = e, this.yRatio = a.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e);
    var n = s.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
    for (var o = 0, l = 0; o < e.length; o++, l++) {
      var c, h, d, u, g = void 0, p = void 0, f = [], x = [], m = i.globals.comboCharts ? t[o] : o, b = this.barHelpers.getGroupIndex(m).columnGroupIndex, w = s.group({ class: "apexcharts-series", rel: o + 1, seriesName: z.escapeString(i.globals.seriesNames[m]), "data:realIndex": m });
      this.ctx.series.addCollapsedClassToSeries(w, m), e[o].length > 0 && (this.visibleI = this.visibleI + 1);
      var y = 0, v = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[m], this.translationsIndex = m);
      var S = this.translationsIndex;
      this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      var k = this.barHelpers.initialPositions(m);
      p = k.y, y = k.barHeight, h = k.yDivision, u = k.zeroW, g = k.x, v = k.barWidth, c = k.xDivision, d = k.zeroH, this.isHorizontal || x.push(g + v / 2);
      var C = s.group({ class: "apexcharts-datalabels", "data:realIndex": m });
      i.globals.delayedElements.push({ el: C.node }), C.node.classList.add("apexcharts-element-hidden");
      var R = s.group({ class: "apexcharts-bar-goals-markers" }), P = s.group({ class: "apexcharts-bar-shadows" });
      i.globals.delayedElements.push({ el: P.node }), P.node.classList.add("apexcharts-element-hidden");
      for (var A = 0; A < e[o].length; A++) {
        var E = this.barHelpers.getStrokeWidth(o, A, m), N = null, O = { indexes: { i: o, j: A, realIndex: m, translationsIndex: S, bc: l }, x: g, y: p, strokeWidth: E, elSeries: w };
        this.isHorizontal ? (N = this.drawBarPaths(q(q({}, O), {}, { barHeight: y, zeroW: u, yDivision: h })), v = this.series[o][A] / this.invertedYRatio) : (N = this.drawColumnPaths(q(q({}, O), {}, { xDivision: c, barWidth: v, zeroH: d })), y = this.series[o][A] / this.yRatio[S]);
        var L = this.barHelpers.getPathFillColor(e, o, A, m);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && A > 0) {
          var I, F = this.barHelpers.drawBarShadow({ color: typeof L.color == "string" && ((I = L.color) === null || I === void 0 ? void 0 : I.indexOf("url")) === -1 ? L.color : z.hexToRgba(i.globals.colors[o]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: N });
          P.add(F), i.config.chart.dropShadow.enabled && new je(this.ctx).dropShadow(F, i.config.chart.dropShadow, m);
        }
        this.pathArr.push(N);
        var D = this.barHelpers.drawGoalLine({ barXPosition: N.barXPosition, barYPosition: N.barYPosition, goalX: N.goalX, goalY: N.goalY, barHeight: y, barWidth: v });
        D && R.add(D), p = N.y, g = N.x, A > 0 && x.push(g + v / 2), f.push(p), this.renderSeries(q(q({ realIndex: m, pathFill: L.color }, L.useRangeColor ? { lineFill: L.color } : {}), {}, { j: A, i: o, columnGroupIndex: b, pathFrom: N.pathFrom, pathTo: N.pathTo, strokeWidth: E, elSeries: w, x: g, y: p, series: e, barHeight: Math.abs(N.barHeight ? N.barHeight : y), barWidth: Math.abs(N.barWidth ? N.barWidth : v), elDataLabelsWrap: C, elGoalsMarkers: R, elBarShadows: P, visibleSeries: this.visibleI, type: "bar" }));
      }
      i.globals.seriesXvalues[m] = x, i.globals.seriesYvalues[m] = f, n.add(w);
    }
    return n;
  } }, { key: "renderSeries", value: function(e) {
    var t = e.realIndex, i = e.pathFill, s = e.lineFill, a = e.j, n = e.i, o = e.columnGroupIndex, l = e.pathFrom, c = e.pathTo, h = e.strokeWidth, d = e.elSeries, u = e.x, g = e.y, p = e.y1, f = e.y2, x = e.series, m = e.barHeight, b = e.barWidth, w = e.barXPosition, y = e.barYPosition, v = e.elDataLabelsWrap, S = e.elGoalsMarkers, k = e.elBarShadows, C = e.visibleSeries, R = e.type, P = e.classes, A = this.w, E = new B(this.ctx), N = !1;
    if (!s) {
      var O = typeof A.globals.stroke.colors[t] == "function" ? function(Y) {
        var _, H = A.config.stroke.colors;
        return Array.isArray(H) && H.length > 0 && ((_ = H[Y]) || (_ = ""), typeof _ == "function") ? _({ value: A.globals.series[Y][a], dataPointIndex: a, w: A }) : _;
      }(t) : A.globals.stroke.colors[t];
      s = this.barOptions.distributed ? A.globals.stroke.colors[a] : O;
    }
    var L = new ud(this).handleBarDataLabels({ x: u, y: g, y1: p, y2: f, i: n, j: a, series: x, realIndex: t, columnGroupIndex: o, barHeight: m, barWidth: b, barXPosition: w, barYPosition: y, visibleSeries: C });
    A.globals.isBarHorizontal || (L.dataLabelsPos.dataLabelsX + b < 0 || L.dataLabelsPos.dataLabelsX - b > A.globals.gridWidth) && (N = !0), A.config.series[n].data[a] && A.config.series[n].data[a].strokeColor && (s = A.config.series[n].data[a].strokeColor), this.isNullValue && (i = "none");
    var I = a / A.config.chart.animations.animateGradually.delay * (A.config.chart.animations.speed / A.globals.dataPoints) / 2.4;
    if (!N) {
      var F = E.renderPaths({ i: n, j: a, realIndex: t, pathFrom: l, pathTo: c, stroke: s, strokeWidth: h, strokeLineCap: A.config.stroke.lineCap, fill: i, animationDelay: I, initialSpeed: A.config.chart.animations.speed, dataChangeSpeed: A.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(R, "-area ").concat(P), chartType: R });
      F.attr("clip-path", "url(#gridRectBarMask".concat(A.globals.cuid, ")"));
      var D = A.config.forecastDataPoints;
      D.count > 0 && a >= A.globals.dataPoints - D.count && (F.node.setAttribute("stroke-dasharray", D.dashArray), F.node.setAttribute("stroke-width", D.strokeWidth), F.node.setAttribute("fill-opacity", D.fillOpacity)), p !== void 0 && f !== void 0 && (F.attr("data-range-y1", p), F.attr("data-range-y2", f)), new je(this.ctx).setSelectionFilter(F, t, a), d.add(F), F.attr({ cy: L.dataLabelsPos.bcy, cx: L.dataLabelsPos.bcx, j: a, val: A.globals.series[n][a], barHeight: m, barWidth: b }), L.dataLabels !== null && v.add(L.dataLabels), L.totalDataLabels && v.add(L.totalDataLabels), d.add(v), S && d.add(S), k && d.add(k);
    }
    return d;
  } }, { key: "drawBarPaths", value: function(e) {
    var t, i = e.indexes, s = e.barHeight, a = e.strokeWidth, n = e.zeroW, o = e.x, l = e.y, c = e.yDivision, h = e.elSeries, d = this.w, u = i.i, g = i.j;
    if (d.globals.isXNumeric) t = (l = (d.globals.seriesX[u][g] - d.globals.minX) / this.invertedXRatio - s) + s * this.visibleI;
    else if (d.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var p = this.barHelpers.getZeroValueEncounters({ i: u, j: g }), f = p.nonZeroColumns, x = p.zeroEncounters;
      f > 0 && (s = this.seriesLen * s / f), t = l + s * this.visibleI, t -= s * x;
    } else t = l + s * this.visibleI;
    this.isFunnel && (n -= (this.barHelpers.getXForValue(this.series[u][g], n) - n) / 2), o = this.barHelpers.getXForValue(this.series[u][g], n);
    var m = this.barHelpers.getBarpaths({ barYPosition: t, barHeight: s, x1: n, x2: o, strokeWidth: a, isReversed: this.isReversed, series: this.series, realIndex: i.realIndex, i: u, j: g, w: d });
    return d.globals.isXNumeric || (l += c), this.barHelpers.barBackground({ j: g, i: u, y1: t - s * this.visibleI, y2: s * this.seriesLen, elSeries: h }), { pathTo: m.pathTo, pathFrom: m.pathFrom, x1: n, x: o, y: l, goalX: this.barHelpers.getGoalValues("x", n, null, u, g), barYPosition: t, barHeight: s };
  } }, { key: "drawColumnPaths", value: function(e) {
    var t, i = e.indexes, s = e.x, a = e.y, n = e.xDivision, o = e.barWidth, l = e.zeroH, c = e.strokeWidth, h = e.elSeries, d = this.w, u = i.realIndex, g = i.translationsIndex, p = i.i, f = i.j, x = i.bc;
    if (d.globals.isXNumeric) {
      var m = this.getBarXForNumericXAxis({ x: s, j: f, realIndex: u, barWidth: o });
      s = m.x, t = m.barXPosition;
    } else if (d.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var b = this.barHelpers.getZeroValueEncounters({ i: p, j: f }), w = b.nonZeroColumns, y = b.zeroEncounters;
      w > 0 && (o = this.seriesLen * o / w), t = s + o * this.visibleI, t -= o * y;
    } else t = s + o * this.visibleI;
    a = this.barHelpers.getYForValue(this.series[p][f], l, g);
    var v = this.barHelpers.getColumnPaths({ barXPosition: t, barWidth: o, y1: l, y2: a, strokeWidth: c, isReversed: this.isReversed, series: this.series, realIndex: u, i: p, j: f, w: d });
    return d.globals.isXNumeric || (s += n), this.barHelpers.barBackground({ bc: x, j: f, i: p, x1: t - c / 2 - o * this.visibleI, x2: o * this.seriesLen + c / 2, elSeries: h }), { pathTo: v.pathTo, pathFrom: v.pathFrom, x: s, y: a, goalY: this.barHelpers.getGoalValues("y", null, l, p, f, g), barXPosition: t, barWidth: o };
  } }, { key: "getBarXForNumericXAxis", value: function(e) {
    var t = e.x, i = e.barWidth, s = e.realIndex, a = e.j, n = this.w, o = s;
    return n.globals.seriesX[s].length || (o = n.globals.maxValsInArrayIndex), z.isNumber(n.globals.seriesX[o][a]) && (t = (n.globals.seriesX[o][a] - n.globals.minX) / this.xRatio - i * this.seriesLen / 2), { barXPosition: t + i * this.visibleI, x: t };
  } }, { key: "getPreviousPath", value: function(e, t) {
    for (var i = this.w, s = "M 0 0", a = 0; a < i.globals.previousPaths.length; a++) {
      var n = i.globals.previousPaths[a];
      n.paths && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(e, 10) && i.globals.previousPaths[a].paths[t] !== void 0 && (s = i.globals.previousPaths[a].paths[t].d);
    }
    return s;
  } }]), r;
}(), Ua = function(r) {
  Pi(t, Kt);
  var e = Ri(t);
  function t() {
    return ee(this, t), e.apply(this, arguments);
  }
  return te(t, [{ key: "draw", value: function(i, s) {
    var a = this, n = this.w;
    this.graphics = new B(this.ctx), this.bar = new Kt(this.ctx, this.xyRatios);
    var o = new ze(this.ctx, n);
    i = o.getLogSeries(i), this.yRatio = o.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), n.config.chart.stackType === "100%" && (i = n.globals.comboCharts ? s.map(function(p) {
      return n.globals.seriesPercent[p];
    }) : n.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
    for (var l = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), c = 0, h = 0, d = function(p, f) {
      var x = void 0, m = void 0, b = void 0, w = void 0, y = n.globals.comboCharts ? s[p] : p, v = a.barHelpers.getGroupIndex(y), S = v.groupIndex, k = v.columnGroupIndex;
      a.groupCtx = a[n.globals.seriesGroups[S]];
      var C = [], R = [], P = 0;
      a.yRatio.length > 1 && (a.yaxisIndex = n.globals.seriesYAxisReverseMap[y][0], P = y), a.isReversed = n.config.yaxis[a.yaxisIndex] && n.config.yaxis[a.yaxisIndex].reversed;
      var A = a.graphics.group({ class: "apexcharts-series", seriesName: z.escapeString(n.globals.seriesNames[y]), rel: p + 1, "data:realIndex": y });
      a.ctx.series.addCollapsedClassToSeries(A, y);
      var E = a.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": y }), N = a.graphics.group({ class: "apexcharts-bar-goals-markers" }), O = 0, L = 0, I = a.initialPositions(c, h, x, m, b, w, P);
      h = I.y, O = I.barHeight, m = I.yDivision, w = I.zeroW, c = I.x, L = I.barWidth, x = I.xDivision, b = I.zeroH, n.globals.barHeight = O, n.globals.barWidth = L, a.barHelpers.initializeStackedXYVars(a), a.groupCtx.prevY.length === 1 && a.groupCtx.prevY[0].every(function(J) {
        return isNaN(J);
      }) && (a.groupCtx.prevY[0] = a.groupCtx.prevY[0].map(function() {
        return b;
      }), a.groupCtx.prevYF[0] = a.groupCtx.prevYF[0].map(function() {
        return 0;
      }));
      for (var F = 0; F < n.globals.dataPoints; F++) {
        var D = a.barHelpers.getStrokeWidth(p, F, y), Y = { indexes: { i: p, j: F, realIndex: y, translationsIndex: P, bc: f }, strokeWidth: D, x: c, y: h, elSeries: A, columnGroupIndex: k, seriesGroup: n.globals.seriesGroups[S] }, _ = null;
        a.isHorizontal ? (_ = a.drawStackedBarPaths(q(q({}, Y), {}, { zeroW: w, barHeight: O, yDivision: m })), L = a.series[p][F] / a.invertedYRatio) : (_ = a.drawStackedColumnPaths(q(q({}, Y), {}, { xDivision: x, barWidth: L, zeroH: b })), O = a.series[p][F] / a.yRatio[P]);
        var H = a.barHelpers.drawGoalLine({ barXPosition: _.barXPosition, barYPosition: _.barYPosition, goalX: _.goalX, goalY: _.goalY, barHeight: O, barWidth: L });
        H && N.add(H), h = _.y, c = _.x, C.push(c), R.push(h);
        var V = a.barHelpers.getPathFillColor(i, p, F, y), Z = "", X = n.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
        (a.barHelpers.arrBorderRadius[y][F] === "bottom" && n.globals.series[y][F] > 0 || a.barHelpers.arrBorderRadius[y][F] === "top" && n.globals.series[y][F] < 0) && (Z = X), A = a.renderSeries(q(q({ realIndex: y, pathFill: V.color }, V.useRangeColor ? { lineFill: V.color } : {}), {}, { j: F, i: p, columnGroupIndex: k, pathFrom: _.pathFrom, pathTo: _.pathTo, strokeWidth: D, elSeries: A, x: c, y: h, series: i, barHeight: O, barWidth: L, elDataLabelsWrap: E, elGoalsMarkers: N, type: "bar", visibleSeries: k, classes: Z }));
      }
      n.globals.seriesXvalues[y] = C, n.globals.seriesYvalues[y] = R, a.groupCtx.prevY.push(a.groupCtx.yArrj), a.groupCtx.prevYF.push(a.groupCtx.yArrjF), a.groupCtx.prevYVal.push(a.groupCtx.yArrjVal), a.groupCtx.prevX.push(a.groupCtx.xArrj), a.groupCtx.prevXF.push(a.groupCtx.xArrjF), a.groupCtx.prevXVal.push(a.groupCtx.xArrjVal), l.add(A);
    }, u = 0, g = 0; u < i.length; u++, g++) d(u, g);
    return l;
  } }, { key: "initialPositions", value: function(i, s, a, n, o, l, c) {
    var h, d, u = this.w;
    if (this.isHorizontal) {
      n = u.globals.gridHeight / u.globals.dataPoints;
      var g = u.config.plotOptions.bar.barHeight;
      h = String(g).indexOf("%") === -1 ? parseInt(g, 10) : n * parseInt(g, 10) / 100, l = u.globals.padHorizontal + (this.isReversed ? u.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), s = (n - h) / 2;
    } else {
      d = a = u.globals.gridWidth / u.globals.dataPoints;
      var p = u.config.plotOptions.bar.columnWidth;
      u.globals.isXNumeric && u.globals.dataPoints > 1 ? d = (a = u.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : String(p).indexOf("%") === -1 ? d = parseInt(p, 10) : d *= parseInt(p, 10) / 100, o = this.isReversed ? this.baseLineY[c] : u.globals.gridHeight - this.baseLineY[c], i = u.globals.padHorizontal + (a - d) / 2;
    }
    var f = u.globals.barGroups.length || 1;
    return { x: i, y: s, yDivision: n, xDivision: a, barHeight: h / f, barWidth: d / f, zeroH: o, zeroW: l };
  } }, { key: "drawStackedBarPaths", value: function(i) {
    for (var s, a = i.indexes, n = i.barHeight, o = i.strokeWidth, l = i.zeroW, c = i.x, h = i.y, d = i.columnGroupIndex, u = i.seriesGroup, g = i.yDivision, p = i.elSeries, f = this.w, x = h + d * n, m = a.i, b = a.j, w = a.realIndex, y = a.translationsIndex, v = 0, S = 0; S < this.groupCtx.prevXF.length; S++) v += this.groupCtx.prevXF[S][b];
    var k = m;
    if (f.config.series[w].name && (k = u.indexOf(f.config.series[w].name)), k > 0) {
      var C = l;
      this.groupCtx.prevXVal[k - 1][b] < 0 ? C = this.series[m][b] >= 0 ? this.groupCtx.prevX[k - 1][b] + v - 2 * (this.isReversed ? v : 0) : this.groupCtx.prevX[k - 1][b] : this.groupCtx.prevXVal[k - 1][b] >= 0 && (C = this.series[m][b] >= 0 ? this.groupCtx.prevX[k - 1][b] : this.groupCtx.prevX[k - 1][b] - v + 2 * (this.isReversed ? v : 0)), s = C;
    } else s = l;
    c = this.series[m][b] === null ? s : s + this.series[m][b] / this.invertedYRatio - 2 * (this.isReversed ? this.series[m][b] / this.invertedYRatio : 0);
    var R = this.barHelpers.getBarpaths({ barYPosition: x, barHeight: n, x1: s, x2: c, strokeWidth: o, isReversed: this.isReversed, series: this.series, realIndex: a.realIndex, seriesGroup: u, i: m, j: b, w: f });
    return this.barHelpers.barBackground({ j: b, i: m, y1: x, y2: n, elSeries: p }), h += g, { pathTo: R.pathTo, pathFrom: R.pathFrom, goalX: this.barHelpers.getGoalValues("x", l, null, m, b, y), barXPosition: s, barYPosition: x, x: c, y: h };
  } }, { key: "drawStackedColumnPaths", value: function(i) {
    var s = i.indexes, a = i.x, n = i.y, o = i.xDivision, l = i.barWidth, c = i.zeroH, h = i.columnGroupIndex, d = i.seriesGroup, u = i.elSeries, g = this.w, p = s.i, f = s.j, x = s.bc, m = s.realIndex, b = s.translationsIndex;
    if (g.globals.isXNumeric) {
      var w = g.globals.seriesX[m][f];
      w || (w = 0), a = (w - g.globals.minX) / this.xRatio - l / 2 * g.globals.barGroups.length;
    }
    for (var y, v = a + h * l, S = 0, k = 0; k < this.groupCtx.prevYF.length; k++) S += isNaN(this.groupCtx.prevYF[k][f]) ? 0 : this.groupCtx.prevYF[k][f];
    var C = p;
    if (d && (C = d.indexOf(g.globals.seriesNames[m])), C > 0 && !g.globals.isXNumeric || C > 0 && g.globals.isXNumeric && g.globals.seriesX[m - 1][f] === g.globals.seriesX[m][f]) {
      var R, P, A, E = Math.min(this.yRatio.length + 1, m + 1);
      if (this.groupCtx.prevY[C - 1] !== void 0 && this.groupCtx.prevY[C - 1].length) for (var N = 1; N < E; N++) {
        var O;
        if (!isNaN((O = this.groupCtx.prevY[C - N]) === null || O === void 0 ? void 0 : O[f])) {
          A = this.groupCtx.prevY[C - N][f];
          break;
        }
      }
      for (var L = 1; L < E; L++) {
        var I, F;
        if (((I = this.groupCtx.prevYVal[C - L]) === null || I === void 0 ? void 0 : I[f]) < 0) {
          P = this.series[p][f] >= 0 ? A - S + 2 * (this.isReversed ? S : 0) : A;
          break;
        }
        if (((F = this.groupCtx.prevYVal[C - L]) === null || F === void 0 ? void 0 : F[f]) >= 0) {
          P = this.series[p][f] >= 0 ? A : A + S - 2 * (this.isReversed ? S : 0);
          break;
        }
      }
      P === void 0 && (P = g.globals.gridHeight), y = (R = this.groupCtx.prevYF[0]) !== null && R !== void 0 && R.every(function(Y) {
        return Y === 0;
      }) && this.groupCtx.prevYF.slice(1, C).every(function(Y) {
        return Y.every(function(_) {
          return isNaN(_);
        });
      }) ? c : P;
    } else y = c;
    n = this.series[p][f] ? y - this.series[p][f] / this.yRatio[b] + 2 * (this.isReversed ? this.series[p][f] / this.yRatio[b] : 0) : y;
    var D = this.barHelpers.getColumnPaths({ barXPosition: v, barWidth: l, y1: y, y2: n, yRatio: this.yRatio[b], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: d, realIndex: s.realIndex, i: p, j: f, w: g });
    return this.barHelpers.barBackground({ bc: x, j: f, i: p, x1: v, x2: l, elSeries: u }), { pathTo: D.pathTo, pathFrom: D.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, c, p, f), barXPosition: v, x: g.globals.isXNumeric ? a : a + o, y: n };
  } }]), t;
}(), Es = function(r) {
  Pi(t, Kt);
  var e = Ri(t);
  function t() {
    return ee(this, t), e.apply(this, arguments);
  }
  return te(t, [{ key: "draw", value: function(i, s, a) {
    var n = this, o = this.w, l = new B(this.ctx), c = o.globals.comboCharts ? s : o.config.chart.type, h = new ht(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = o.config.plotOptions.bar.horizontal, this.isOHLC = this.candlestickOptions && this.candlestickOptions.type === "ohlc";
    var d = new ze(this.ctx, o);
    i = d.getLogSeries(i), this.series = i, this.yRatio = d.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
    for (var u = l.group({ class: "apexcharts-".concat(c, "-series apexcharts-plot-series") }), g = function(f) {
      n.isBoxPlot = o.config.chart.type === "boxPlot" || o.config.series[f].type === "boxPlot";
      var x, m, b, w, y = void 0, v = void 0, S = [], k = [], C = o.globals.comboCharts ? a[f] : f, R = n.barHelpers.getGroupIndex(C).columnGroupIndex, P = l.group({ class: "apexcharts-series", seriesName: z.escapeString(o.globals.seriesNames[C]), rel: f + 1, "data:realIndex": C });
      n.ctx.series.addCollapsedClassToSeries(P, C), i[f].length > 0 && (n.visibleI = n.visibleI + 1);
      var A, E, N = 0;
      n.yRatio.length > 1 && (n.yaxisIndex = o.globals.seriesYAxisReverseMap[C][0], N = C);
      var O = n.barHelpers.initialPositions(C);
      v = O.y, A = O.barHeight, m = O.yDivision, w = O.zeroW, y = O.x, E = O.barWidth, x = O.xDivision, b = O.zeroH, k.push(y + E / 2);
      for (var L = l.group({ class: "apexcharts-datalabels", "data:realIndex": C }), I = l.group({ class: "apexcharts-bar-goals-markers" }), F = function(Y) {
        var _ = n.barHelpers.getStrokeWidth(f, Y, C), H = null, V = { indexes: { i: f, j: Y, realIndex: C, translationsIndex: N }, x: y, y: v, strokeWidth: _, elSeries: P };
        H = n.isHorizontal ? n.drawHorizontalBoxPaths(q(q({}, V), {}, { yDivision: m, barHeight: A, zeroW: w })) : n.drawVerticalBoxPaths(q(q({}, V), {}, { xDivision: x, barWidth: E, zeroH: b })), v = H.y, y = H.x;
        var Z = n.barHelpers.drawGoalLine({ barXPosition: H.barXPosition, barYPosition: H.barYPosition, goalX: H.goalX, goalY: H.goalY, barHeight: A, barWidth: E });
        Z && I.add(Z), Y > 0 && k.push(y + E / 2), S.push(v), H.pathTo.forEach(function(X, J) {
          var G = !n.isBoxPlot && n.candlestickOptions.wick.useFillColor ? H.color[J] : o.globals.stroke.colors[f], $ = h.fillPath({ seriesNumber: C, dataPointIndex: Y, color: H.color[J], value: i[f][Y] });
          n.renderSeries({ realIndex: C, pathFill: $, lineFill: G, j: Y, i: f, pathFrom: H.pathFrom, pathTo: X, strokeWidth: _, elSeries: P, x: y, y: v, series: i, columnGroupIndex: R, barHeight: A, barWidth: E, elDataLabelsWrap: L, elGoalsMarkers: I, visibleSeries: n.visibleI, type: o.config.chart.type });
        });
      }, D = 0; D < o.globals.dataPoints; D++) F(D);
      o.globals.seriesXvalues[C] = k, o.globals.seriesYvalues[C] = S, u.add(P);
    }, p = 0; p < i.length; p++) g(p);
    return u;
  } }, { key: "drawVerticalBoxPaths", value: function(i) {
    var s = i.indexes, a = i.x;
    i.y;
    var n = i.xDivision, o = i.barWidth, l = i.zeroH, c = i.strokeWidth, h = this.w, d = new B(this.ctx), u = s.i, g = s.j, p = h.config.plotOptions.candlestick.colors, f = this.boxOptions.colors, x = s.realIndex, m = function(D) {
      return Array.isArray(D) ? D[x] : D;
    }, b = m(p.upward), w = m(p.downward), y = this.yRatio[s.translationsIndex], v = this.getOHLCValue(x, g), S = l, k = l, C = v.o < v.c ? [b] : [w];
    this.isBoxPlot && (C = [m(f.lower), m(f.upper)]);
    var R = Math.min(v.o, v.c), P = Math.max(v.o, v.c), A = v.m;
    h.globals.isXNumeric && (a = (h.globals.seriesX[x][g] - h.globals.minX) / this.xRatio - o / 2);
    var E = a + o * this.visibleI;
    this.series[u][g] === void 0 || this.series[u][g] === null ? (R = l, P = l) : (R = l - R / y, P = l - P / y, S = l - v.h / y, k = l - v.l / y, A = l - v.m / y);
    var N = d.move(E, l), O = d.move(E + o / 2, R);
    if (h.globals.previousPaths.length > 0 && (O = this.getPreviousPath(x, g, !0)), this.isOHLC) {
      var L = E + o / 2, I = l - v.o / y, F = l - v.c / y;
      N = [d.move(L, S) + d.line(L, k) + d.move(L, I) + d.line(E, I) + d.move(L, F) + d.line(E + o, F)];
    } else N = this.isBoxPlot ? [d.move(E, R) + d.line(E + o / 2, R) + d.line(E + o / 2, S) + d.line(E + o / 4, S) + d.line(E + o - o / 4, S) + d.line(E + o / 2, S) + d.line(E + o / 2, R) + d.line(E + o, R) + d.line(E + o, A) + d.line(E, A) + d.line(E, R + c / 2), d.move(E, A) + d.line(E + o, A) + d.line(E + o, P) + d.line(E + o / 2, P) + d.line(E + o / 2, k) + d.line(E + o - o / 4, k) + d.line(E + o / 4, k) + d.line(E + o / 2, k) + d.line(E + o / 2, P) + d.line(E, P) + d.line(E, A) + "z"] : [d.move(E, P) + d.line(E + o / 2, P) + d.line(E + o / 2, S) + d.line(E + o / 2, P) + d.line(E + o, P) + d.line(E + o, R) + d.line(E + o / 2, R) + d.line(E + o / 2, k) + d.line(E + o / 2, R) + d.line(E, R) + d.line(E, P - c / 2)];
    return O += d.move(E, R), h.globals.isXNumeric || (a += n), { pathTo: N, pathFrom: O, x: a, y: P, goalY: this.barHelpers.getGoalValues("y", null, l, u, g, s.translationsIndex), barXPosition: E, color: C };
  } }, { key: "drawHorizontalBoxPaths", value: function(i) {
    var s = i.indexes;
    i.x;
    var a = i.y, n = i.yDivision, o = i.barHeight, l = i.zeroW, c = i.strokeWidth, h = this.w, d = new B(this.ctx), u = s.i, g = s.j, p = this.boxOptions.colors.lower;
    this.isBoxPlot && (p = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var f = this.invertedYRatio, x = s.realIndex, m = this.getOHLCValue(x, g), b = l, w = l, y = Math.min(m.o, m.c), v = Math.max(m.o, m.c), S = m.m;
    h.globals.isXNumeric && (a = (h.globals.seriesX[x][g] - h.globals.minX) / this.invertedXRatio - o / 2);
    var k = a + o * this.visibleI;
    this.series[u][g] === void 0 || this.series[u][g] === null ? (y = l, v = l) : (y = l + y / f, v = l + v / f, b = l + m.h / f, w = l + m.l / f, S = l + m.m / f);
    var C = d.move(l, k), R = d.move(y, k + o / 2);
    return h.globals.previousPaths.length > 0 && (R = this.getPreviousPath(x, g, !0)), C = [d.move(y, k) + d.line(y, k + o / 2) + d.line(b, k + o / 2) + d.line(b, k + o / 2 - o / 4) + d.line(b, k + o / 2 + o / 4) + d.line(b, k + o / 2) + d.line(y, k + o / 2) + d.line(y, k + o) + d.line(S, k + o) + d.line(S, k) + d.line(y + c / 2, k), d.move(S, k) + d.line(S, k + o) + d.line(v, k + o) + d.line(v, k + o / 2) + d.line(w, k + o / 2) + d.line(w, k + o - o / 4) + d.line(w, k + o / 4) + d.line(w, k + o / 2) + d.line(v, k + o / 2) + d.line(v, k) + d.line(S, k) + "z"], R += d.move(y, k), h.globals.isXNumeric || (a += n), { pathTo: C, pathFrom: R, x: v, y: a, goalX: this.barHelpers.getGoalValues("x", l, null, u, g), barYPosition: k, color: p };
  } }, { key: "getOHLCValue", value: function(i, s) {
    var a = this.w, n = new ze(this.ctx, a), o = n.getLogValAtSeriesIndex(a.globals.seriesCandleH[i][s], i), l = n.getLogValAtSeriesIndex(a.globals.seriesCandleO[i][s], i), c = n.getLogValAtSeriesIndex(a.globals.seriesCandleM[i][s], i), h = n.getLogValAtSeriesIndex(a.globals.seriesCandleC[i][s], i), d = n.getLogValAtSeriesIndex(a.globals.seriesCandleL[i][s], i);
    return { o: this.isBoxPlot ? o : l, h: this.isBoxPlot ? l : o, m: c, l: this.isBoxPlot ? h : d, c: this.isBoxPlot ? d : h };
  } }]), t;
}(), Lo = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "checkColorRange", value: function() {
    var e = this.w, t = !1, i = e.config.plotOptions[e.config.chart.type];
    return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(s, a) {
      s.from <= 0 && (t = !0);
    }), t;
  } }, { key: "getShadeColor", value: function(e, t, i, s) {
    var a = this.w, n = 1, o = a.config.plotOptions[e].shadeIntensity, l = this.determineColor(e, t, i);
    a.globals.hasNegs || s ? n = a.config.plotOptions[e].reverseNegativeShade ? l.percent < 0 ? l.percent / 100 * (1.25 * o) : (1 - l.percent / 100) * (1.25 * o) : l.percent <= 0 ? 1 - (1 + l.percent / 100) * o : (1 - l.percent / 100) * o : (n = 1 - l.percent / 100, e === "treemap" && (n = (1 - l.percent / 100) * (1.25 * o)));
    var c = l.color, h = new z();
    if (a.config.plotOptions[e].enableShades) if (this.w.config.theme.mode === "dark") {
      var d = h.shadeColor(-1 * n, l.color);
      c = z.hexToRgba(z.isColorHex(d) ? d : z.rgb2hex(d), a.config.fill.opacity);
    } else {
      var u = h.shadeColor(n, l.color);
      c = z.hexToRgba(z.isColorHex(u) ? u : z.rgb2hex(u), a.config.fill.opacity);
    }
    return { color: c, colorProps: l };
  } }, { key: "determineColor", value: function(e, t, i) {
    var s = this.w, a = s.globals.series[t][i], n = s.config.plotOptions[e], o = n.colorScale.inverse ? i : t;
    n.distributed && s.config.chart.type === "treemap" && (o = i);
    var l = s.globals.colors[o], c = null, h = Math.min.apply(Math, De(s.globals.series[t])), d = Math.max.apply(Math, De(s.globals.series[t]));
    n.distributed || e !== "heatmap" || (h = s.globals.minY, d = s.globals.maxY), n.colorScale.min !== void 0 && (h = n.colorScale.min < s.globals.minY ? n.colorScale.min : s.globals.minY, d = n.colorScale.max > s.globals.maxY ? n.colorScale.max : s.globals.maxY);
    var u = Math.abs(d) + Math.abs(h), g = 100 * a / (u === 0 ? u - 1e-6 : u);
    return n.colorScale.ranges.length > 0 && n.colorScale.ranges.map(function(p, f) {
      if (a >= p.from && a <= p.to) {
        l = p.color, c = p.foreColor ? p.foreColor : null, h = p.from, d = p.to;
        var x = Math.abs(d) + Math.abs(h);
        g = 100 * a / (x === 0 ? x - 1e-6 : x);
      }
    }), { color: l, foreColor: c, percent: g };
  } }, { key: "calculateDataLabels", value: function(e) {
    var t = e.text, i = e.x, s = e.y, a = e.i, n = e.j, o = e.colorProps, l = e.fontSize, c = this.w.config.dataLabels, h = new B(this.ctx), d = new Jt(this.ctx), u = null;
    if (c.enabled) {
      u = h.group({ class: "apexcharts-data-labels" });
      var g = c.offsetX, p = c.offsetY, f = i + g, x = s + parseFloat(c.style.fontSize) / 3 + p;
      d.plotDataLabelsText({ x: f, y: x, text: t, i: a, j: n, color: o.foreColor, parent: u, fontSize: l, dataLabelsConfig: c });
    }
    return u;
  } }, { key: "addListeners", value: function(e) {
    var t = new B(this.ctx);
    e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)), e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e));
  } }]), r;
}(), fd = function() {
  function r(e, t) {
    ee(this, r), this.ctx = e, this.w = e.w, this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Lo(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return te(r, [{ key: "draw", value: function(e) {
    var t = this.w, i = new B(this.ctx), s = i.group({ class: "apexcharts-heatmap" });
    s.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")"));
    var a = t.globals.gridWidth / t.globals.dataPoints, n = t.globals.gridHeight / t.globals.series.length, o = 0, l = !1;
    this.negRange = this.helpers.checkColorRange();
    var c = e.slice();
    t.config.yaxis[0].reversed && (l = !0, c.reverse());
    for (var h = l ? 0 : c.length - 1; l ? h < c.length : h >= 0; l ? h++ : h--) {
      var d = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: z.escapeString(t.globals.seriesNames[h]), rel: h + 1, "data:realIndex": h });
      if (this.ctx.series.addCollapsedClassToSeries(d, h), t.config.chart.dropShadow.enabled) {
        var u = t.config.chart.dropShadow;
        new je(this.ctx).dropShadow(d, u, h);
      }
      for (var g = 0, p = t.config.plotOptions.heatmap.shadeIntensity, f = 0, x = 0; x < t.globals.dataPoints; x++) if (t.globals.seriesX.length && !t.globals.allSeriesHasEqualX && t.globals.minX + t.globals.minXDiff * x < t.globals.seriesX[h][f]) g += a;
      else {
        if (f >= c[h].length) break;
        var m = this.helpers.getShadeColor(t.config.chart.type, h, f, this.negRange), b = m.color, w = m.colorProps;
        t.config.fill.type === "image" && (b = new ht(this.ctx).fillPath({ seriesNumber: h, dataPointIndex: f, opacity: t.globals.hasNegs ? w.percent < 0 ? 1 - (1 + w.percent / 100) : p + w.percent / 100 : w.percent / 100, patternID: z.randomId(), width: t.config.fill.image.width ? t.config.fill.image.width : a, height: t.config.fill.image.height ? t.config.fill.image.height : n }));
        var y = this.rectRadius, v = i.drawRect(g, o, a, n, y);
        if (v.attr({ cx: g, cy: o }), v.node.classList.add("apexcharts-heatmap-rect"), d.add(v), v.attr({ fill: b, i: h, index: h, j: f, val: e[h][f], "stroke-width": this.strokeWidth, stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? b : t.globals.stroke.colors[0], color: b }), this.helpers.addListeners(v), t.config.chart.animations.enabled && !t.globals.dataChanged) {
          var S = 1;
          t.globals.resized || (S = t.config.chart.animations.speed), this.animateHeatMap(v, g, o, a, n, S);
        }
        if (t.globals.dataChanged) {
          var k = 1;
          if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
            k = this.dynamicAnim.speed;
            var C = t.globals.previousPaths[h] && t.globals.previousPaths[h][f] && t.globals.previousPaths[h][f].color;
            C || (C = "rgba(255, 255, 255, 0)"), this.animateHeatColor(v, z.isColorHex(C) ? C : z.rgb2hex(C), z.isColorHex(b) ? b : z.rgb2hex(b), k);
          }
        }
        var R = (0, t.config.dataLabels.formatter)(t.globals.series[h][f], { value: t.globals.series[h][f], seriesIndex: h, dataPointIndex: f, w: t }), P = this.helpers.calculateDataLabels({ text: R, x: g + a / 2, y: o + n / 2, i: h, j: f, colorProps: w, series: c });
        P !== null && d.add(P), g += a, f++;
      }
      o += n, s.add(d);
    }
    var A = t.globals.yAxisScale[0].result.slice();
    return t.config.yaxis[0].reversed ? A.unshift("") : A.push(""), t.globals.yAxisScale[0].result = A, s;
  } }, { key: "animateHeatMap", value: function(e, t, i, s, a, n) {
    var o = new ti(this.ctx);
    o.animateRect(e, { x: t + s / 2, y: i + a / 2, width: 0, height: 0 }, { x: t, y: i, width: s, height: a }, n, function() {
      o.animationCompleted(e);
    });
  } }, { key: "animateHeatColor", value: function(e, t, i, s) {
    e.attr({ fill: t }).animate(s).attr({ fill: i });
  } }]), r;
}(), Io = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "drawYAxisTexts", value: function(e, t, i, s) {
    var a = this.w, n = a.config.yaxis[0], o = a.globals.yLabelFormatters[0];
    return new B(this.ctx).drawText({ x: e + n.labels.offsetX, y: t + n.labels.offsetY, text: o(s, i), textAnchor: "middle", fontSize: n.labels.style.fontSize, fontFamily: n.labels.style.fontFamily, foreColor: Array.isArray(n.labels.style.colors) ? n.labels.style.colors[i] : n.labels.style.colors });
  } }]), r;
}(), Eo = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = Math.min(t.globals.gridWidth, t.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = t.globals.gridWidth / 2, t.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(t.config.plotOptions.pie.endAngle - t.config.plotOptions.pie.startAngle), this.initialAngle = t.config.plotOptions.pie.startAngle % this.fullAngle, t.globals.radialSize = this.defaultSize / 2.05 - t.config.stroke.width - (t.config.chart.sparkline.enabled ? 0 : t.config.chart.dropShadow.blur), this.donutSize = t.globals.radialSize * parseInt(t.config.plotOptions.pie.donut.size, 10) / 100;
    var i = t.config.plotOptions.pie.customScale, s = t.globals.gridWidth / 2, a = t.globals.gridHeight / 2;
    this.translateX = s - s * i, this.translateY = a - a * i, this.dataLabelsGroup = new B(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return te(r, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, s = new B(this.ctx), a = s.group({ class: "apexcharts-pie" });
    if (i.globals.noData) return a;
    for (var n = 0, o = 0; o < e.length; o++) n += z.negToZero(e[o]);
    var l = [], c = s.group();
    n === 0 && (n = 1e-5), e.forEach(function(w) {
      t.maxY = Math.max(t.maxY, w);
    }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(a);
    for (var h = 0; h < e.length; h++) {
      var d = this.fullAngle * z.negToZero(e[h]) / n;
      l.push(d), this.chartType === "polarArea" ? (l[h] = this.fullAngle / e.length, this.sliceSizes.push(i.globals.radialSize * e[h] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
    }
    if (i.globals.dataChanged) {
      for (var u, g = 0, p = 0; p < i.globals.previousPaths.length; p++) g += z.negToZero(i.globals.previousPaths[p]);
      for (var f = 0; f < i.globals.previousPaths.length; f++) u = this.fullAngle * z.negToZero(i.globals.previousPaths[f]) / g, this.prevSectorAngleArr.push(u);
    }
    if (this.donutSize < 0 && (this.donutSize = 0), this.chartType === "donut") {
      var x = s.drawCircle(this.donutSize);
      x.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), c.add(x);
    }
    var m = this.drawArcs(l, e);
    if (this.sliceLabels.forEach(function(w) {
      m.add(w);
    }), c.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), c.add(m), a.add(c), this.donutDataLabels.show) {
      var b = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      a.add(b);
    }
    return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(a), a;
  } }, { key: "drawArcs", value: function(e, t) {
    var i = this.w, s = new je(this.ctx), a = new B(this.ctx), n = new ht(this.ctx), o = a.group({ class: "apexcharts-slices" }), l = this.initialAngle, c = this.initialAngle, h = this.initialAngle, d = this.initialAngle;
    this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
    for (var u = 0; u < e.length; u++) {
      var g = a.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: z.escapeString(i.globals.seriesNames[u]), rel: u + 1, "data:realIndex": u });
      o.add(g), c = d, h = (l = h) + e[u], d = c + this.prevSectorAngleArr[u];
      var p = h < l ? this.fullAngle + h - l : h - l, f = n.fillPath({ seriesNumber: u, size: this.sliceSizes[u], value: t[u] }), x = this.getChangedPath(c, d), m = a.drawPath({ d: x, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[u] : this.lineColorArr, strokeWidth: 0, fill: f, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(u) });
      if (m.attr({ index: 0, j: u }), s.setSelectionFilter(m, 0, u), i.config.chart.dropShadow.enabled) {
        var b = i.config.chart.dropShadow;
        s.dropShadow(m, b, u);
      }
      this.addListeners(m, this.donutDataLabels), B.setAttrs(m.node, { "data:angle": p, "data:startAngle": l, "data:strokeWidth": this.strokeWidth, "data:value": t[u] });
      var w = { x: 0, y: 0 };
      this.chartType === "pie" || this.chartType === "polarArea" ? w = z.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (l + p / 2) % this.fullAngle) : this.chartType === "donut" && (w = z.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (l + p / 2) % this.fullAngle)), g.add(m);
      var y = 0;
      if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((y = p / this.fullAngle * i.config.chart.animations.speed) === 0 && (y = 1), this.animDur = y + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(m, { size: this.sliceSizes[u], endAngle: h, startAngle: l, prevStartAngle: c, prevEndAngle: d, animateStartingPos: !0, i: u, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(m, { size: this.sliceSizes[u], endAngle: h, startAngle: l, i: u, totalItems: e.length - 1, animBeginArr: this.animBeginArr, dur: y }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && m.node.addEventListener("mouseup", this.pieClicked.bind(this, u)), i.globals.selectedDataPoints[0] !== void 0 && i.globals.selectedDataPoints[0].indexOf(u) > -1 && this.pieClicked(u), i.config.dataLabels.enabled) {
        var v = w.x, S = w.y, k = 100 * p / this.fullAngle + "%";
        if (p !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[u]) {
          var C = i.config.dataLabels.formatter;
          C !== void 0 && (k = C(i.globals.seriesPercent[u][0], { seriesIndex: u, w: i }));
          var R = i.globals.dataLabels.style.colors[u], P = a.group({ class: "apexcharts-datalabels" }), A = a.drawText({ x: v, y: S, text: k, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: R });
          if (P.add(A), i.config.dataLabels.dropShadow.enabled) {
            var E = i.config.dataLabels.dropShadow;
            s.dropShadow(A, E);
          }
          A.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === !1 && (A.node.classList.add("apexcharts-pie-label-delay"), A.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(P);
        }
      }
    }
    return o;
  } }, { key: "addListeners", value: function(e, t) {
    var i = new B(this.ctx);
    e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e)), e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e)), this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)));
  } }, { key: "animatePaths", value: function(e, t) {
    var i = this.w, s = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle, a = s, n = t.startAngle, o = t.startAngle;
    t.prevStartAngle !== void 0 && t.prevEndAngle !== void 0 && (n = t.prevEndAngle, a = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle), t.i === i.config.series.length - 1 && (s + o > this.fullAngle ? t.endAngle = t.endAngle - (s + o) : s + o < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (s + o)))), s === this.fullAngle && (s = this.fullAngle - 0.01), this.animateArc(e, n, o, s, a, t);
  } }, { key: "animateArc", value: function(e, t, i, s, a, n) {
    var o, l = this, c = this.w, h = new ti(this.ctx), d = n.size;
    (isNaN(t) || isNaN(a)) && (t = i, a = s, n.dur = 0);
    var u = s, g = i, p = t < i ? this.fullAngle + t - i : t - i;
    c.globals.dataChanged && n.shouldSetPrevPaths && n.prevEndAngle && (o = l.getPiePath({ me: l, startAngle: n.prevStartAngle, angle: n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle, size: d }), e.attr({ d: o })), n.dur !== 0 ? e.animate(n.dur, n.animBeginArr[n.i]).after(function() {
      l.chartType !== "pie" && l.chartType !== "donut" && l.chartType !== "polarArea" || this.animate(c.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": l.strokeWidth }), n.i === c.config.series.length - 1 && h.animationCompleted(e);
    }).during(function(f) {
      u = p + (s - p) * f, n.animateStartingPos && (u = a + (s - a) * f, g = t - a + (i - (t - a)) * f), o = l.getPiePath({ me: l, startAngle: g, angle: u, size: d }), e.node.setAttribute("data:pathOrig", o), e.attr({ d: o });
    }) : (o = l.getPiePath({ me: l, startAngle: g, angle: s, size: d }), n.isTrack || (c.globals.animationEnded = !0), e.node.setAttribute("data:pathOrig", o), e.attr({ d: o, "stroke-width": l.strokeWidth }));
  } }, { key: "pieClicked", value: function(e) {
    var t, i = this.w, s = this, a = s.sliceSizes[e] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), n = i.globals.dom.Paper.findOne(".apexcharts-".concat(s.chartType.toLowerCase(), "-slice-").concat(e));
    if (n.attr("data:pieClicked") !== "true") {
      var o = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
      Array.prototype.forEach.call(o, function(d) {
        d.setAttribute("data:pieClicked", "false");
        var u = d.getAttribute("data:pathOrig");
        u && d.setAttribute("d", u);
      }), i.globals.capturedDataPointIndex = e, n.attr("data:pieClicked", "true");
      var l = parseInt(n.attr("data:startAngle"), 10), c = parseInt(n.attr("data:angle"), 10);
      t = s.getPiePath({ me: s, startAngle: l, angle: c, size: a }), c !== 360 && n.plot(t);
    } else {
      n.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(n.node, this.donutDataLabels);
      var h = n.attr("data:pathOrig");
      n.attr({ d: h });
    }
  } }, { key: "getChangedPath", value: function(e, t) {
    var i = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: e, angle: t - e, size: this.size })), i;
  } }, { key: "getPiePath", value: function(e) {
    var t, i = e.me, s = e.startAngle, a = e.angle, n = e.size, o = new B(this.ctx), l = s, c = Math.PI * (l - 90) / 180, h = a + s;
    Math.ceil(h) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h) > this.fullAngle && (h -= this.fullAngle);
    var d = Math.PI * (h - 90) / 180, u = i.centerX + n * Math.cos(c), g = i.centerY + n * Math.sin(c), p = i.centerX + n * Math.cos(d), f = i.centerY + n * Math.sin(d), x = z.polarToCartesian(i.centerX, i.centerY, i.donutSize, h), m = z.polarToCartesian(i.centerX, i.centerY, i.donutSize, l), b = a > 180 ? 1 : 0, w = ["M", u, g, "A", n, n, 0, b, 1, p, f];
    return t = i.chartType === "donut" ? [].concat(w, ["L", x.x, x.y, "A", i.donutSize, i.donutSize, 0, b, 0, m.x, m.y, "L", u, g, "z"]).join(" ") : i.chartType === "pie" || i.chartType === "polarArea" ? [].concat(w, ["L", i.centerX, i.centerY, "L", u, g]).join(" ") : [].concat(w).join(" "), o.roundPathCorners(t, 2 * this.strokeWidth);
  } }, { key: "drawPolarElements", value: function(e) {
    var t = this.w, i = new Co(this.ctx), s = new B(this.ctx), a = new Io(this.ctx), n = s.group(), o = s.group(), l = i.niceScale(0, Math.ceil(this.maxY), 0), c = l.result.reverse(), h = l.result.length;
    this.maxY = l.niceMax;
    for (var d = t.globals.radialSize, u = d / (h - 1), g = 0; g < h - 1; g++) {
      var p = s.drawCircle(d);
      if (p.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth, stroke: t.config.plotOptions.polarArea.rings.strokeColor }), t.config.yaxis[0].show) {
        var f = a.drawYAxisTexts(this.centerX, this.centerY - d + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, g, c[g]);
        o.add(f);
      }
      n.add(p), d -= u;
    }
    this.drawSpokes(e), e.add(n), e.add(o);
  } }, { key: "renderInnerDataLabels", value: function(e, t, i) {
    var s = this.w, a = new B(this.ctx), n = t.total.show;
    e.node.innerHTML = "", e.node.style.opacity = i.opacity;
    var o, l, c = i.centerX, h = this.donutDataLabels.total.label ? i.centerY : i.centerY - i.centerY / 6;
    o = t.name.color === void 0 ? s.globals.colors[0] : t.name.color;
    var d = t.name.fontSize, u = t.name.fontFamily, g = t.name.fontWeight;
    l = t.value.color === void 0 ? s.config.chart.foreColor : t.value.color;
    var p = t.value.formatter, f = "", x = "";
    if (n ? (o = t.total.color, d = t.total.fontSize, u = t.total.fontFamily, g = t.total.fontWeight, x = this.donutDataLabels.total.label ? t.total.label : "", f = t.total.formatter(s)) : s.globals.series.length === 1 && (f = p(s.globals.series[0], s), x = s.globals.seriesNames[0]), x && (x = t.name.formatter(x, t.total.show, s)), t.name.show) {
      var m = a.drawText({ x: c, y: h + parseFloat(t.name.offsetY), text: x, textAnchor: "middle", foreColor: o, fontSize: d, fontWeight: g, fontFamily: u });
      m.node.classList.add("apexcharts-datalabel-label"), e.add(m);
    }
    if (t.value.show) {
      var b = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, w = a.drawText({ x: c, y: h + b, text: f, textAnchor: "middle", foreColor: l, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily });
      w.node.classList.add("apexcharts-datalabel-value"), e.add(w);
    }
    return e;
  } }, { key: "printInnerLabels", value: function(e, t, i, s) {
    var a, n = this.w;
    s ? a = e.name.color === void 0 ? n.globals.colors[parseInt(s.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : n.globals.series.length > 1 && e.total.show && (a = e.total.color);
    var o = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), l = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i = (0, e.value.formatter)(i, n), s || typeof e.total.formatter != "function" || (i = e.total.formatter(n));
    var c = t === e.total.label;
    t = this.donutDataLabels.total.label ? e.name.formatter(t, c, n) : "", o !== null && (o.textContent = t), l !== null && (l.textContent = i), o !== null && (o.style.fill = a);
  } }, { key: "printDataLabelsInner", value: function(e, t) {
    var i = this.w, s = e.getAttribute("data:value"), a = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
    i.globals.series.length > 1 && this.printInnerLabels(t, a, s, e);
    var n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    n !== null && (n.style.opacity = 1);
  } }, { key: "drawSpokes", value: function(e) {
    var t = this, i = this.w, s = new B(this.ctx), a = i.config.plotOptions.polarArea.spokes;
    if (a.strokeWidth !== 0) {
      for (var n = [], o = 360 / i.globals.series.length, l = 0; l < i.globals.series.length; l++) n.push(z.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + o * l));
      n.forEach(function(c, h) {
        var d = s.drawLine(c.x, c.y, t.centerX, t.centerY, Array.isArray(a.connectorColors) ? a.connectorColors[h] : a.connectorColors);
        e.add(d);
      });
    }
  } }, { key: "revertDataLabelsInner", value: function() {
    var e = this.w;
    if (this.donutDataLabels.show) {
      var t = e.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i = this.renderInnerDataLabels(t, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      e.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i);
    }
  } }]), r;
}(), pd = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var t = this.w;
    this.graphics = new B(this.ctx), this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = t.globals.svgHeight < t.globals.svgWidth ? t.globals.gridHeight : t.globals.gridWidth, this.isLog = t.config.yaxis[0].logarithmic, this.logBase = t.config.yaxis[0].logBase, this.coreUtils = new ze(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, t.globals.maxY, 0) : t.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : t.globals.minY, this.polygons = t.config.plotOptions.radar.polygons, this.strokeWidth = t.config.stroke.show ? t.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - t.config.chart.dropShadow.blur, t.config.xaxis.labels.show && (this.size = this.size - t.globals.xAxisLabelsWidth / 1.75), t.config.plotOptions.radar.size !== void 0 && (this.size = t.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return te(r, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, s = new ht(this.ctx), a = [], n = new Jt(this.ctx);
    e.length && (this.dataPointsLen = e[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var o = i.globals.gridWidth / 2, l = i.globals.gridHeight / 2, c = o + i.config.plotOptions.radar.offsetX, h = l + i.config.plotOptions.radar.offsetY, d = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(c || 0, ", ").concat(h || 0, ")") }), u = [], g = null, p = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), e.forEach(function(x, m) {
      var b = x.length === i.globals.dataPoints, w = t.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": b, seriesName: z.escapeString(i.globals.seriesNames[m]), rel: m + 1, "data:realIndex": m });
      t.dataRadiusOfPercent[m] = [], t.dataRadius[m] = [], t.angleArr[m] = [], x.forEach(function(N, O) {
        var L = Math.abs(t.maxValue - t.minValue);
        N -= t.minValue, t.isLog && (N = t.coreUtils.getLogVal(t.logBase, N, 0)), t.dataRadiusOfPercent[m][O] = N / L, t.dataRadius[m][O] = t.dataRadiusOfPercent[m][O] * t.size, t.angleArr[m][O] = O * t.disAngle;
      }), u = t.getDataPointsPos(t.dataRadius[m], t.angleArr[m]);
      var y = t.createPaths(u, { x: 0, y: 0 });
      g = t.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p = t.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": m }), i.globals.delayedElements.push({ el: g.node, index: m });
      var v = { i: m, realIndex: m, animationDelay: m, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[m], strokeLineCap: i.config.stroke.lineCap }, S = null;
      i.globals.previousPaths.length > 0 && (S = t.getPreviousPath(m));
      for (var k = 0; k < y.linePathsTo.length; k++) {
        var C = t.graphics.renderPaths(q(q({}, v), {}, { pathFrom: S === null ? y.linePathsFrom[k] : S, pathTo: y.linePathsTo[k], strokeWidth: Array.isArray(t.strokeWidth) ? t.strokeWidth[m] : t.strokeWidth, fill: "none", drawShadow: !1 }));
        w.add(C);
        var R = s.fillPath({ seriesNumber: m }), P = t.graphics.renderPaths(q(q({}, v), {}, { pathFrom: S === null ? y.areaPathsFrom[k] : S, pathTo: y.areaPathsTo[k], strokeWidth: 0, fill: R, drawShadow: !1 }));
        if (i.config.chart.dropShadow.enabled) {
          var A = new je(t.ctx), E = i.config.chart.dropShadow;
          A.dropShadow(P, Object.assign({}, E, { noUserSpaceOnUse: !0 }), m);
        }
        w.add(P);
      }
      x.forEach(function(N, O) {
        var L = new ai(t.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: m, dataPointIndex: O }), I = t.graphics.drawMarker(u[O].x, u[O].y, L);
        I.attr("rel", O), I.attr("j", O), I.attr("index", m), I.node.setAttribute("default-marker-size", L.pSize);
        var F = t.graphics.group({ class: "apexcharts-series-markers" });
        F && F.add(I), g.add(F), w.add(g);
        var D = i.config.dataLabels;
        if (D.enabled) {
          var Y = D.formatter(i.globals.series[m][O], { seriesIndex: m, dataPointIndex: O, w: i });
          n.plotDataLabelsText({ x: u[O].x, y: u[O].y, text: Y, textAnchor: "middle", i: m, j: m, parent: p, offsetCorrection: !1, dataLabelsConfig: q({}, D) });
        }
        w.add(p);
      }), a.push(w);
    }), this.drawPolygons({ parent: d }), i.config.xaxis.labels.show) {
      var f = this.drawXAxisTexts();
      d.add(f);
    }
    return a.forEach(function(x) {
      d.add(x);
    }), d.add(this.yaxisLabels), d;
  } }, { key: "drawPolygons", value: function(e) {
    for (var t = this, i = this.w, s = e.parent, a = new Io(this.ctx), n = i.globals.yAxisScale[0].result.reverse(), o = n.length, l = [], c = this.size / (o - 1), h = 0; h < o; h++) l[h] = c * h;
    l.reverse();
    var d = [], u = [];
    l.forEach(function(g, p) {
      var f = z.getPolygonPos(g, t.dataPointsLen), x = "";
      f.forEach(function(m, b) {
        if (p === 0) {
          var w = t.graphics.drawLine(m.x, m.y, 0, 0, Array.isArray(t.polygons.connectorColors) ? t.polygons.connectorColors[b] : t.polygons.connectorColors);
          u.push(w);
        }
        b === 0 && t.yaxisLabelsTextsPos.push({ x: m.x, y: m.y }), x += m.x + "," + m.y + " ";
      }), d.push(x);
    }), d.forEach(function(g, p) {
      var f = t.polygons.strokeColors, x = t.polygons.strokeWidth, m = t.graphics.drawPolygon(g, Array.isArray(f) ? f[p] : f, Array.isArray(x) ? x[p] : x, i.globals.radarPolygons.fill.colors[p]);
      s.add(m);
    }), u.forEach(function(g) {
      s.add(g);
    }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(g, p) {
      var f = a.drawYAxisTexts(g.x, g.y, p, n[p]);
      t.yaxisLabels.add(f);
    });
  } }, { key: "drawXAxisTexts", value: function() {
    var e = this, t = this.w, i = t.config.xaxis.labels, s = this.graphics.group({ class: "apexcharts-xaxis" }), a = z.getPolygonPos(this.size, this.dataPointsLen);
    return t.globals.labels.forEach(function(n, o) {
      var l = t.config.xaxis.labels.formatter, c = new Jt(e.ctx);
      if (a[o]) {
        var h = e.getTextPos(a[o], e.size), d = l(n, { seriesIndex: -1, dataPointIndex: o, w: t });
        c.plotDataLabelsText({ x: h.newX, y: h.newY, text: d, textAnchor: h.textAnchor, i: o, j: o, parent: s, className: "apexcharts-xaxis-label", color: Array.isArray(i.style.colors) && i.style.colors[o] ? i.style.colors[o] : "#a8a8a8", dataLabelsConfig: q({ textAnchor: h.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1 }).on("click", function(u) {
          if (typeof t.config.chart.events.xAxisLabelClick == "function") {
            var g = Object.assign({}, t, { labelIndex: o });
            t.config.chart.events.xAxisLabelClick(u, e.ctx, g);
          }
        });
      }
    }), s;
  } }, { key: "createPaths", value: function(e, t) {
    var i = this, s = [], a = [], n = [], o = [];
    if (e.length) {
      a = [this.graphics.move(t.x, t.y)], o = [this.graphics.move(t.x, t.y)];
      var l = this.graphics.move(e[0].x, e[0].y), c = this.graphics.move(e[0].x, e[0].y);
      e.forEach(function(h, d) {
        l += i.graphics.line(h.x, h.y), c += i.graphics.line(h.x, h.y), d === e.length - 1 && (l += "Z", c += "Z");
      }), s.push(l), n.push(c);
    }
    return { linePathsFrom: a, linePathsTo: s, areaPathsFrom: o, areaPathsTo: n };
  } }, { key: "getTextPos", value: function(e, t) {
    var i = "middle", s = e.x, a = e.y;
    return Math.abs(e.x) >= 10 ? e.x > 0 ? (i = "start", s += 10) : e.x < 0 && (i = "end", s -= 10) : i = "middle", Math.abs(e.y) >= t - 10 && (e.y < 0 ? a -= 10 : e.y > 0 && (a += 10)), { textAnchor: i, newX: s, newY: a };
  } }, { key: "getPreviousPath", value: function(e) {
    for (var t = this.w, i = null, s = 0; s < t.globals.previousPaths.length; s++) {
      var a = t.globals.previousPaths[s];
      a.paths.length > 0 && parseInt(a.realIndex, 10) === parseInt(e, 10) && t.globals.previousPaths[s].paths[0] !== void 0 && (i = t.globals.previousPaths[s].paths[0].d);
    }
    return i;
  } }, { key: "getDataPointsPos", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
    e = e || [], t = t || [];
    for (var s = [], a = 0; a < i; a++) {
      var n = {};
      n.x = e[a] * Math.sin(t[a]), n.y = -e[a] * Math.cos(t[a]), s.push(n);
    }
    return s;
  } }]), r;
}(), xd = function(r) {
  Pi(t, Eo);
  var e = Ri(t);
  function t(i) {
    var s;
    ee(this, t), (s = e.call(this, i)).ctx = i, s.w = i.w, s.animBeginArr = [0], s.animDur = 0;
    var a = s.w;
    return s.startAngle = a.config.plotOptions.radialBar.startAngle, s.endAngle = a.config.plotOptions.radialBar.endAngle, s.totalAngle = Math.abs(a.config.plotOptions.radialBar.endAngle - a.config.plotOptions.radialBar.startAngle), s.trackStartAngle = a.config.plotOptions.radialBar.track.startAngle, s.trackEndAngle = a.config.plotOptions.radialBar.track.endAngle, s.barLabels = s.w.config.plotOptions.radialBar.barLabels, s.donutDataLabels = s.w.config.plotOptions.radialBar.dataLabels, s.radialDataLabels = s.donutDataLabels, s.trackStartAngle || (s.trackStartAngle = s.startAngle), s.trackEndAngle || (s.trackEndAngle = s.endAngle), s.endAngle === 360 && (s.endAngle = 359.99), s.margin = parseInt(a.config.plotOptions.radialBar.track.margin, 10), s.onBarLabelClick = s.onBarLabelClick.bind(Bn(s)), s;
  }
  return te(t, [{ key: "draw", value: function(i) {
    var s = this.w, a = new B(this.ctx), n = a.group({ class: "apexcharts-radialbar" });
    if (s.globals.noData) return n;
    var o = a.group(), l = this.defaultSize / 2, c = s.globals.gridWidth / 2, h = this.defaultSize / 2.05;
    s.config.chart.sparkline.enabled || (h = h - s.config.stroke.width - s.config.chart.dropShadow.blur);
    var d = s.globals.fill.colors;
    if (s.config.plotOptions.radialBar.track.show) {
      var u = this.drawTracks({ size: h, centerX: c, centerY: l, colorArr: d, series: i });
      o.add(u);
    }
    var g = this.drawArcs({ size: h, centerX: c, centerY: l, colorArr: d, series: i }), p = 360;
    s.config.plotOptions.radialBar.startAngle < 0 && (p = this.totalAngle);
    var f = (360 - p) / 360;
    if (s.globals.radialSize = h - h * f, this.radialDataLabels.value.show) {
      var x = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      s.globals.radialSize += x * f;
    }
    return o.add(g.g), s.config.plotOptions.radialBar.hollow.position === "front" && (g.g.add(g.elHollow), g.dataLabels && g.g.add(g.dataLabels)), n.add(o), n;
  } }, { key: "drawTracks", value: function(i) {
    var s = this.w, a = new B(this.ctx), n = a.group({ class: "apexcharts-tracks" }), o = new je(this.ctx), l = new ht(this.ctx), c = this.getStrokeWidth(i);
    i.size = i.size - c / 2;
    for (var h = 0; h < i.series.length; h++) {
      var d = a.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      n.add(d), d.attr({ rel: h + 1 }), i.size = i.size - c - this.margin;
      var u = s.config.plotOptions.radialBar.track, g = l.fillPath({ seriesNumber: 0, size: i.size, fillColors: Array.isArray(u.background) ? u.background[h] : u.background, solid: !0 }), p = this.trackStartAngle, f = this.trackEndAngle;
      Math.abs(f) + Math.abs(p) >= 360 && (f = 360 - Math.abs(this.startAngle) - 0.1);
      var x = a.drawPath({ d: "", stroke: g, strokeWidth: c * parseInt(u.strokeWidth, 10) / 100, fill: "none", strokeOpacity: u.opacity, classes: "apexcharts-radialbar-area" });
      if (u.dropShadow.enabled) {
        var m = u.dropShadow;
        o.dropShadow(x, m);
      }
      d.add(x), x.attr("id", "apexcharts-radialbarTrack-" + h), this.animatePaths(x, { centerX: i.centerX, centerY: i.centerY, endAngle: f, startAngle: p, size: i.size, i: h, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0 });
    }
    return n;
  } }, { key: "drawArcs", value: function(i) {
    var s = this.w, a = new B(this.ctx), n = new ht(this.ctx), o = new je(this.ctx), l = a.group(), c = this.getStrokeWidth(i);
    i.size = i.size - c / 2;
    var h = s.config.plotOptions.radialBar.hollow.background, d = i.size - c * i.series.length - this.margin * i.series.length - c * parseInt(s.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, u = d - s.config.plotOptions.radialBar.hollow.margin;
    s.config.plotOptions.radialBar.hollow.image !== void 0 && (h = this.drawHollowImage(i, l, d, h));
    var g = this.drawHollow({ size: u, centerX: i.centerX, centerY: i.centerY, fill: h || "transparent" });
    if (s.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var p = s.config.plotOptions.radialBar.hollow.dropShadow;
      o.dropShadow(g, p);
    }
    var f = 1;
    !this.radialDataLabels.total.show && s.globals.series.length > 1 && (f = 0);
    var x = null;
    if (this.radialDataLabels.show) {
      var m = s.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
      x = this.renderInnerDataLabels(m, this.radialDataLabels, { hollowSize: d, centerX: i.centerX, centerY: i.centerY, opacity: f });
    }
    s.config.plotOptions.radialBar.hollow.position === "back" && (l.add(g), x && l.add(x));
    var b = !1;
    s.config.plotOptions.radialBar.inverseOrder && (b = !0);
    for (var w = b ? i.series.length - 1 : 0; b ? w >= 0 : w < i.series.length; b ? w-- : w++) {
      var y = a.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: z.escapeString(s.globals.seriesNames[w]) });
      l.add(y), y.attr({ rel: w + 1, "data:realIndex": w }), this.ctx.series.addCollapsedClassToSeries(y, w), i.size = i.size - c - this.margin;
      var v = n.fillPath({ seriesNumber: w, size: i.size, value: i.series[w] }), S = this.startAngle, k = void 0, C = z.negToZero(i.series[w] > 100 ? 100 : i.series[w]) / 100, R = Math.round(this.totalAngle * C) + this.startAngle, P = void 0;
      s.globals.dataChanged && (k = this.startAngle, P = Math.round(this.totalAngle * z.negToZero(s.globals.previousPaths[w]) / 100) + k), Math.abs(R) + Math.abs(S) > 360 && (R -= 0.01), Math.abs(P) + Math.abs(k) > 360 && (P -= 0.01);
      var A = R - S, E = Array.isArray(s.config.stroke.dashArray) ? s.config.stroke.dashArray[w] : s.config.stroke.dashArray, N = a.drawPath({ d: "", stroke: v, strokeWidth: c, fill: "none", fillOpacity: s.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + w, strokeDashArray: E });
      if (B.setAttrs(N.node, { "data:angle": A, "data:value": i.series[w] }), s.config.chart.dropShadow.enabled) {
        var O = s.config.chart.dropShadow;
        o.dropShadow(N, O, w);
      }
      if (o.setSelectionFilter(N, 0, w), this.addListeners(N, this.radialDataLabels), y.add(N), N.attr({ index: 0, j: w }), this.barLabels.enabled) {
        var L = z.polarToCartesian(i.centerX, i.centerY, i.size, S), I = this.barLabels.formatter(s.globals.seriesNames[w], { seriesIndex: w, w: s }), F = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || F.push("apexcharts-no-click");
        var D = this.barLabels.useSeriesColors ? s.globals.colors[w] : s.config.chart.foreColor;
        D || (D = s.config.chart.foreColor);
        var Y = L.x + this.barLabels.offsetX, _ = L.y + this.barLabels.offsetY, H = a.drawText({ x: Y, y: _, text: I, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: D, cssClass: F.join(" ") });
        H.on("click", this.onBarLabelClick), H.attr({ rel: w + 1 }), S !== 0 && H.attr({ "transform-origin": "".concat(Y, " ").concat(_), transform: "rotate(".concat(S, " 0 0)") }), y.add(H);
      }
      var V = 0;
      !this.initialAnim || s.globals.resized || s.globals.dataChanged || (V = s.config.chart.animations.speed), s.globals.dataChanged && (V = s.config.chart.animations.dynamicAnimation.speed), this.animDur = V / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(N, { centerX: i.centerX, centerY: i.centerY, endAngle: R, startAngle: S, prevEndAngle: P, prevStartAngle: k, size: i.size, i: w, totalItems: 2, animBeginArr: this.animBeginArr, dur: V, shouldSetPrevPaths: !0 });
    }
    return { g: l, elHollow: g, dataLabels: x };
  } }, { key: "drawHollow", value: function(i) {
    var s = new B(this.ctx).drawCircle(2 * i.size);
    return s.attr({ class: "apexcharts-radialbar-hollow", cx: i.centerX, cy: i.centerY, r: i.size, fill: i.fill }), s;
  } }, { key: "drawHollowImage", value: function(i, s, a, n) {
    var o = this.w, l = new ht(this.ctx), c = z.randomId(), h = o.config.plotOptions.radialBar.hollow.image;
    if (o.config.plotOptions.radialBar.hollow.imageClipped) l.clippedImgArea({ width: a, height: a, image: h, patternID: "pattern".concat(o.globals.cuid).concat(c) }), n = "url(#pattern".concat(o.globals.cuid).concat(c, ")");
    else {
      var d = o.config.plotOptions.radialBar.hollow.imageWidth, u = o.config.plotOptions.radialBar.hollow.imageHeight;
      if (d === void 0 && u === void 0) {
        var g = o.globals.dom.Paper.image(h, function(f) {
          this.move(i.centerX - f.width / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - f.height / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        s.add(g);
      } else {
        var p = o.globals.dom.Paper.image(h, function(f) {
          this.move(i.centerX - d / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - u / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(d, u);
        });
        s.add(p);
      }
    }
    return n;
  } }, { key: "getStrokeWidth", value: function(i) {
    var s = this.w;
    return i.size * (100 - parseInt(s.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin;
  } }, { key: "onBarLabelClick", value: function(i) {
    var s = parseInt(i.target.getAttribute("rel"), 10) - 1, a = this.barLabels.onClick, n = this.w;
    a && a(n.globals.seriesNames[s], { w: n, seriesIndex: s });
  } }]), t;
}(), md = function(r) {
  Pi(t, Kt);
  var e = Ri(t);
  function t() {
    return ee(this, t), e.apply(this, arguments);
  }
  return te(t, [{ key: "draw", value: function(i, s) {
    var a = this.w, n = new B(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = a.globals.seriesRangeStart, this.seriesRangeEnd = a.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
    for (var o = n.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), l = 0; l < i.length; l++) {
      var c, h, d, u, g = void 0, p = void 0, f = a.globals.comboCharts ? s[l] : l, x = this.barHelpers.getGroupIndex(f).columnGroupIndex, m = n.group({ class: "apexcharts-series", seriesName: z.escapeString(a.globals.seriesNames[f]), rel: l + 1, "data:realIndex": f });
      this.ctx.series.addCollapsedClassToSeries(m, f), i[l].length > 0 && (this.visibleI = this.visibleI + 1);
      var b = 0, w = 0, y = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = a.globals.seriesYAxisReverseMap[f][0], y = f);
      var v = this.barHelpers.initialPositions(f);
      p = v.y, u = v.zeroW, g = v.x, w = v.barWidth, b = v.barHeight, c = v.xDivision, h = v.yDivision, d = v.zeroH;
      for (var S = n.group({ class: "apexcharts-datalabels", "data:realIndex": f }), k = n.group({ class: "apexcharts-rangebar-goals-markers" }), C = 0; C < a.globals.dataPoints; C++) {
        var R = this.barHelpers.getStrokeWidth(l, C, f), P = this.seriesRangeStart[l][C], A = this.seriesRangeEnd[l][C], E = null, N = null, O = null, L = { x: g, y: p, strokeWidth: R, elSeries: m }, I = this.seriesLen;
        if (a.config.plotOptions.bar.rangeBarGroupRows && (I = 1), a.config.series[l].data[C] === void 0) break;
        if (this.isHorizontal) {
          O = p + b * this.visibleI;
          var F = (h - b * I) / 2;
          if (a.config.series[l].data[C].x) {
            var D = this.detectOverlappingBars({ i: l, j: C, barYPosition: O, srty: F, barHeight: b, yDivision: h, initPositions: v });
            b = D.barHeight, O = D.barYPosition;
          }
          w = (E = this.drawRangeBarPaths(q({ indexes: { i: l, j: C, realIndex: f }, barHeight: b, barYPosition: O, zeroW: u, yDivision: h, y1: P, y2: A }, L))).barWidth;
        } else {
          a.globals.isXNumeric && (g = (a.globals.seriesX[l][C] - a.globals.minX) / this.xRatio - w / 2), N = g + w * this.visibleI;
          var Y = (c - w * I) / 2;
          if (a.config.series[l].data[C].x) {
            var _ = this.detectOverlappingBars({ i: l, j: C, barXPosition: N, srtx: Y, barWidth: w, xDivision: c, initPositions: v });
            w = _.barWidth, N = _.barXPosition;
          }
          b = (E = this.drawRangeColumnPaths(q({ indexes: { i: l, j: C, realIndex: f, translationsIndex: y }, barWidth: w, barXPosition: N, zeroH: d, xDivision: c }, L))).barHeight;
        }
        var H = this.barHelpers.drawGoalLine({ barXPosition: E.barXPosition, barYPosition: O, goalX: E.goalX, goalY: E.goalY, barHeight: b, barWidth: w });
        H && k.add(H), p = E.y, g = E.x;
        var V = this.barHelpers.getPathFillColor(i, l, C, f);
        this.renderSeries({ realIndex: f, pathFill: V.color, lineFill: V.useRangeColor ? V.color : a.globals.stroke.colors[f], j: C, i: l, x: g, y: p, y1: P, y2: A, pathFrom: E.pathFrom, pathTo: E.pathTo, strokeWidth: R, elSeries: m, series: i, barHeight: b, barWidth: w, barXPosition: N, barYPosition: O, columnGroupIndex: x, elDataLabelsWrap: S, elGoalsMarkers: k, visibleSeries: this.visibleI, type: "rangebar" });
      }
      o.add(m);
    }
    return o;
  } }, { key: "detectOverlappingBars", value: function(i) {
    var s = i.i, a = i.j, n = i.barYPosition, o = i.barXPosition, l = i.srty, c = i.srtx, h = i.barHeight, d = i.barWidth, u = i.yDivision, g = i.xDivision, p = i.initPositions, f = this.w, x = [], m = f.config.series[s].data[a].rangeName, b = f.config.series[s].data[a].x, w = Array.isArray(b) ? b.join(" ") : b, y = f.globals.labels.map(function(S) {
      return Array.isArray(S) ? S.join(" ") : S;
    }).indexOf(w), v = f.globals.seriesRange[s].findIndex(function(S) {
      return S.x === w && S.overlaps.length > 0;
    });
    return this.isHorizontal ? (n = f.config.plotOptions.bar.rangeBarGroupRows ? l + u * y : l + h * this.visibleI + u * y, v > -1 && !f.config.plotOptions.bar.rangeBarOverlap && (x = f.globals.seriesRange[s][v].overlaps).indexOf(m) > -1 && (n = (h = p.barHeight / x.length) * this.visibleI + u * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + h * (this.visibleI + x.indexOf(m)) + u * y)) : (y > -1 && !f.globals.timescaleLabels.length && (o = f.config.plotOptions.bar.rangeBarGroupRows ? c + g * y : c + d * this.visibleI + g * y), v > -1 && !f.config.plotOptions.bar.rangeBarOverlap && (x = f.globals.seriesRange[s][v].overlaps).indexOf(m) > -1 && (o = (d = p.barWidth / x.length) * this.visibleI + g * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + d * (this.visibleI + x.indexOf(m)) + g * y)), { barYPosition: n, barXPosition: o, barHeight: h, barWidth: d };
  } }, { key: "drawRangeColumnPaths", value: function(i) {
    var s = i.indexes, a = i.x, n = i.xDivision, o = i.barWidth, l = i.barXPosition, c = i.zeroH, h = this.w, d = s.i, u = s.j, g = s.realIndex, p = s.translationsIndex, f = this.yRatio[p], x = this.getRangeValue(g, u), m = Math.min(x.start, x.end), b = Math.max(x.start, x.end);
    this.series[d][u] === void 0 || this.series[d][u] === null ? m = c : (m = c - m / f, b = c - b / f);
    var w = Math.abs(b - m), y = this.barHelpers.getColumnPaths({ barXPosition: l, barWidth: o, y1: m, y2: b, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: g, i: g, j: u, w: h });
    if (h.globals.isXNumeric) {
      var v = this.getBarXForNumericXAxis({ x: a, j: u, realIndex: g, barWidth: o });
      a = v.x, l = v.barXPosition;
    } else a += n;
    return { pathTo: y.pathTo, pathFrom: y.pathFrom, barHeight: w, x: a, y: x.start < 0 && x.end < 0 ? m : b, goalY: this.barHelpers.getGoalValues("y", null, c, d, u, p), barXPosition: l };
  } }, { key: "preventBarOverflow", value: function(i) {
    var s = this.w;
    return i < 0 && (i = 0), i > s.globals.gridWidth && (i = s.globals.gridWidth), i;
  } }, { key: "drawRangeBarPaths", value: function(i) {
    var s = i.indexes, a = i.y, n = i.y1, o = i.y2, l = i.yDivision, c = i.barHeight, h = i.barYPosition, d = i.zeroW, u = this.w, g = s.realIndex, p = s.j, f = this.preventBarOverflow(d + n / this.invertedYRatio), x = this.preventBarOverflow(d + o / this.invertedYRatio), m = this.getRangeValue(g, p), b = Math.abs(x - f), w = this.barHelpers.getBarpaths({ barYPosition: h, barHeight: c, x1: f, x2: x, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: g, realIndex: g, j: p, w: u });
    return u.globals.isXNumeric || (a += l), { pathTo: w.pathTo, pathFrom: w.pathFrom, barWidth: b, x: m.start < 0 && m.end < 0 ? f : x, goalX: this.barHelpers.getGoalValues("x", d, null, g, p), y: a };
  } }, { key: "getRangeValue", value: function(i, s) {
    var a = this.w;
    return { start: a.globals.seriesRangeStart[i][s], end: a.globals.seriesRangeEnd[i][s] };
  } }]), t;
}(), bd = function() {
  function r(e) {
    ee(this, r), this.w = e.w, this.lineCtx = e;
  }
  return te(r, [{ key: "sameValueSeriesFix", value: function(e, t) {
    var i = this.w;
    if ((i.config.fill.type === "gradient" || i.config.fill.type[e] === "gradient") && new ze(this.lineCtx.ctx, i).seriesHaveSameValues(e)) {
      var s = t[e].slice();
      s[s.length - 1] = s[s.length - 1] + 1e-6, t[e] = s;
    }
    return t;
  } }, { key: "calculatePoints", value: function(e) {
    var t = e.series, i = e.realIndex, s = e.x, a = e.y, n = e.i, o = e.j, l = e.prevY, c = this.w, h = [], d = [], u = this.lineCtx.categoryAxisCorrection + c.config.markers.offsetX;
    return c.globals.isXNumeric && (u = (c.globals.seriesX[i][0] - c.globals.minX) / this.lineCtx.xRatio + c.config.markers.offsetX), o === 0 && (h.push(u), d.push(z.isNumber(t[n][0]) ? l + c.config.markers.offsetY : null)), h.push(s + c.config.markers.offsetX), d.push(z.isNumber(t[n][o + 1]) ? a + c.config.markers.offsetY : null), { x: h, y: d };
  } }, { key: "checkPreviousPaths", value: function(e) {
    for (var t = e.pathFromLine, i = e.pathFromArea, s = e.realIndex, a = this.w, n = 0; n < a.globals.previousPaths.length; n++) {
      var o = a.globals.previousPaths[n];
      (o.type === "line" || o.type === "area") && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(s, 10) && (o.type === "line" ? (this.lineCtx.appendPathFrom = !1, t = a.globals.previousPaths[n].paths[0].d) : o.type === "area" && (this.lineCtx.appendPathFrom = !1, i = a.globals.previousPaths[n].paths[0].d, a.config.stroke.show && a.globals.previousPaths[n].paths[1] && (t = a.globals.previousPaths[n].paths[1].d)));
    }
    return { pathFromLine: t, pathFromArea: i };
  } }, { key: "determineFirstPrevY", value: function(e) {
    var t, i, s, a = e.i, n = e.realIndex, o = e.series, l = e.prevY, c = e.lineYPosition, h = e.translationsIndex, d = this.w, u = d.config.chart.stacked && !d.globals.comboCharts || d.config.chart.stacked && d.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t = this.w.config.series[n]) === null || t === void 0 ? void 0 : t.type) === "bar" || ((i = this.w.config.series[n]) === null || i === void 0 ? void 0 : i.type) === "column");
    if (((s = o[a]) === null || s === void 0 ? void 0 : s[0]) !== void 0) l = (c = u && a > 0 ? this.lineCtx.prevSeriesY[a - 1][0] : this.lineCtx.zeroY) - o[a][0] / this.lineCtx.yRatio[h] + 2 * (this.lineCtx.isReversed ? o[a][0] / this.lineCtx.yRatio[h] : 0);
    else if (u && a > 0 && o[a][0] === void 0) {
      for (var g = a - 1; g >= 0; g--) if (o[g][0] !== null && o[g][0] !== void 0) {
        l = c = this.lineCtx.prevSeriesY[g][0];
        break;
      }
    }
    return { prevY: l, lineYPosition: c };
  } }]), r;
}(), vd = function(r) {
  for (var e, t, i, s, a = function(h) {
    for (var d = [], u = h[0], g = h[1], p = d[0] = Ts(u, g), f = 1, x = h.length - 1; f < x; f++) u = g, g = h[f + 1], d[f] = 0.5 * (p + (p = Ts(u, g)));
    return d[f] = p, d;
  }(r), n = r.length - 1, o = [], l = 0; l < n; l++) i = Ts(r[l], r[l + 1]), Math.abs(i) < 1e-6 ? a[l] = a[l + 1] = 0 : (s = (e = a[l] / i) * e + (t = a[l + 1] / i) * t) > 9 && (s = 3 * i / Math.sqrt(s), a[l] = s * e, a[l + 1] = s * t);
  for (var c = 0; c <= n; c++) s = (r[Math.min(n, c + 1)][0] - r[Math.max(0, c - 1)][0]) / (6 * (1 + a[c] * a[c])), o.push([s || 0, a[c] * s || 0]);
  return o;
}, yd = function(r) {
  var e = vd(r), t = r[1], i = r[0], s = [], a = e[1], n = e[0];
  s.push(i, [i[0] + n[0], i[1] + n[1], t[0] - a[0], t[1] - a[1], t[0], t[1]]);
  for (var o = 2, l = e.length; o < l; o++) {
    var c = r[o], h = e[o];
    s.push([c[0] - h[0], c[1] - h[1], c[0], c[1]]);
  }
  return s;
}, wd = function(r, e, t) {
  var i = r.slice(e, t);
  if (e) {
    if (t - e > 1 && i[1].length < 6) {
      var s = i[0].length;
      i[1] = [2 * i[0][s - 2] - i[0][s - 4], 2 * i[0][s - 1] - i[0][s - 3]].concat(i[1]);
    }
    i[0] = i[0].slice(-2);
  }
  return i;
};
function Ts(r, e) {
  return (e[1] - r[1]) / (e[0] - r[0]);
}
var _s = function() {
  function r(e, t, i) {
    ee(this, r), this.ctx = e, this.w = e.w, this.xyRatios = t, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new So(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new bd(this), this.markers = new ai(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return te(r, [{ key: "draw", value: function(e, t, i, s) {
    var a, n = this.w, o = new B(this.ctx), l = n.globals.comboCharts ? t : n.config.chart.type, c = o.group({ class: "apexcharts-".concat(l, "-series apexcharts-plot-series") }), h = new ze(this.ctx, n);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, e = h.getLogSeries(e), this.yRatio = h.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var d = [], u = 0; u < e.length; u++) {
      e = this.lineHelpers.sameValueSeriesFix(u, e);
      var g = n.globals.comboCharts ? i[u] : u, p = this.yRatio.length > 1 ? g : 0;
      this._initSerieVariables(e, u, g);
      var f = [], x = [], m = [], b = n.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, g), n.globals.isXNumeric && n.globals.seriesX.length > 0 && (b = (n.globals.seriesX[g][0] - n.globals.minX) / this.xRatio), m.push(b);
      var w, y = b, v = void 0, S = y, k = this.zeroY, C = this.zeroY;
      k = this.lineHelpers.determineFirstPrevY({ i: u, realIndex: g, series: e, prevY: k, lineYPosition: 0, translationsIndex: p }).prevY, n.config.stroke.curve === "monotoneCubic" && e[u][0] === null ? f.push(null) : f.push(k), w = k, l === "rangeArea" && (v = C = this.lineHelpers.determineFirstPrevY({ i: u, realIndex: g, series: s, prevY: C, lineYPosition: 0, translationsIndex: p }).prevY, x.push(f[0] !== null ? C : null));
      var R = this._calculatePathsFrom({ type: l, series: e, i: u, realIndex: g, translationsIndex: p, prevX: S, prevY: k, prevY2: C }), P = [f[0]], A = [x[0]], E = { type: l, series: e, realIndex: g, translationsIndex: p, i: u, x: b, y: 1, pX: y, pY: w, pathsFrom: R, linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: m, yArrj: f, y2Arrj: x, seriesRangeEnd: s }, N = this._iterateOverDataPoints(q(q({}, E), {}, { iterations: l === "rangeArea" ? e[u].length - 1 : void 0, isRangeStart: !0 }));
      if (l === "rangeArea") {
        for (var O = this._calculatePathsFrom({ series: s, i: u, realIndex: g, prevX: S, prevY: C }), L = this._iterateOverDataPoints(q(q({}, E), {}, { series: s, xArrj: [b], yArrj: P, y2Arrj: A, pY: v, areaPaths: N.areaPaths, pathsFrom: O, iterations: s[u].length - 1, isRangeStart: !1 })), I = N.linePaths.length / 2, F = 0; F < I; F++) N.linePaths[F] = L.linePaths[F + I] + N.linePaths[F];
        N.linePaths.splice(I), N.pathFromLine = L.pathFromLine + N.pathFromLine;
      } else N.pathFromArea += "z";
      this._handlePaths({ type: l, realIndex: g, i: u, paths: N }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), d.push(this.elSeries);
    }
    if (((a = n.config.series[0]) === null || a === void 0 ? void 0 : a.zIndex) !== void 0 && d.sort(function(_, H) {
      return Number(_.node.getAttribute("zIndex")) - Number(H.node.getAttribute("zIndex"));
    }), n.config.chart.stacked) for (var D = d.length - 1; D >= 0; D--) c.add(d[D]);
    else for (var Y = 0; Y < d.length; Y++) c.add(d[Y]);
    return c;
  } }, { key: "_initSerieVariables", value: function(e, t, i) {
    var s = this.w, a = new B(this.ctx);
    this.xDivision = s.globals.gridWidth / (s.globals.dataPoints - (s.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(s.config.stroke.width) ? s.config.stroke.width[i] : s.config.stroke.width;
    var n = 0;
    if (this.yRatio.length > 1 && (this.yaxisIndex = s.globals.seriesYAxisReverseMap[i], n = i), this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed, this.zeroY = s.globals.gridHeight - this.baseLineY[n] - (this.isReversed ? s.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[n] : 0), this.areaBottomY = this.zeroY, (this.zeroY > s.globals.gridHeight || s.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = s.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = a.group({ class: "apexcharts-series", zIndex: s.config.series[i].zIndex !== void 0 ? s.config.series[i].zIndex : i, seriesName: z.escapeString(s.globals.seriesNames[i]) }), this.elPointsMain = a.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), s.globals.hasNullValues) {
      var o = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [s.globals.gridHeight + s.globals.markers.largestSize] }, seriesIndex: t, j: 0, pSize: 0.1, alwaysDrawMarker: !0, isVirtualPoint: !0 });
      o !== null && this.elPointsMain.add(o);
    }
    this.elDataLabelsWrap = a.group({ class: "apexcharts-datalabels", "data:realIndex": i });
    var l = e[t].length === s.globals.dataPoints;
    this.elSeries.attr({ "data:longestSeries": l, rel: t + 1, "data:realIndex": i }), this.appendPathFrom = !0;
  } }, { key: "_calculatePathsFrom", value: function(e) {
    var t, i, s, a, n = e.type, o = e.series, l = e.i, c = e.realIndex, h = e.translationsIndex, d = e.prevX, u = e.prevY, g = e.prevY2, p = this.w, f = new B(this.ctx);
    if (o[l][0] === null) {
      for (var x = 0; x < o[l].length; x++) if (o[l][x] !== null) {
        d = this.xDivision * x, u = this.zeroY - o[l][x] / this.yRatio[h], t = f.move(d, u), i = f.move(d, this.areaBottomY);
        break;
      }
    } else t = f.move(d, u), n === "rangeArea" && (t = f.move(d, g) + f.line(d, u)), i = f.move(d, this.areaBottomY) + f.line(d, u);
    if (s = f.move(0, this.areaBottomY) + f.line(0, this.areaBottomY), a = f.move(0, this.areaBottomY) + f.line(0, this.areaBottomY), p.globals.previousPaths.length > 0) {
      var m = this.lineHelpers.checkPreviousPaths({ pathFromLine: s, pathFromArea: a, realIndex: c });
      s = m.pathFromLine, a = m.pathFromArea;
    }
    return { prevX: d, prevY: u, linePath: t, areaPath: i, pathFromLine: s, pathFromArea: a };
  } }, { key: "_handlePaths", value: function(e) {
    var t = e.type, i = e.realIndex, s = e.i, a = e.paths, n = this.w, o = new B(this.ctx), l = new ht(this.ctx);
    this.prevSeriesY.push(a.yArrj), n.globals.seriesXvalues[i] = a.xArrj, n.globals.seriesYvalues[i] = a.yArrj;
    var c = n.config.forecastDataPoints;
    if (c.count > 0 && t !== "rangeArea") {
      var h = n.globals.seriesXvalues[i][n.globals.seriesXvalues[i].length - c.count - 1], d = o.drawRect(h, 0, n.globals.gridWidth, n.globals.gridHeight, 0);
      n.globals.dom.elForecastMask.appendChild(d.node);
      var u = o.drawRect(0, 0, h, n.globals.gridHeight, 0);
      n.globals.dom.elNonForecastMask.appendChild(u.node);
    }
    this.pointsChart || n.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
    var g = { i: s, realIndex: i, animationDelay: s, initialSpeed: n.config.chart.animations.speed, dataChangeSpeed: n.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(t) };
    if (t === "area") for (var p = l.fillPath({ seriesNumber: i }), f = 0; f < a.areaPaths.length; f++) {
      var x = o.renderPaths(q(q({}, g), {}, { pathFrom: a.pathFromArea, pathTo: a.areaPaths[f], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p }));
      this.elSeries.add(x);
    }
    if (n.config.stroke.show && !this.pointsChart) {
      var m = null;
      if (t === "line") m = l.fillPath({ seriesNumber: i, i: s });
      else if (n.config.stroke.fill.type === "solid") m = n.globals.stroke.colors[i];
      else {
        var b = n.config.fill;
        n.config.fill = n.config.stroke.fill, m = l.fillPath({ seriesNumber: i, i: s }), n.config.fill = b;
      }
      for (var w = 0; w < a.linePaths.length; w++) {
        var y = m;
        t === "rangeArea" && (y = l.fillPath({ seriesNumber: i }));
        var v = q(q({}, g), {}, { pathFrom: a.pathFromLine, pathTo: a.linePaths[w], stroke: m, strokeWidth: this.strokeWidth, strokeLineCap: n.config.stroke.lineCap, fill: t === "rangeArea" ? y : "none" }), S = o.renderPaths(v);
        if (this.elSeries.add(S), S.attr("fill-rule", "evenodd"), c.count > 0 && t !== "rangeArea") {
          var k = o.renderPaths(v);
          k.node.setAttribute("stroke-dasharray", c.dashArray), c.strokeWidth && k.node.setAttribute("stroke-width", c.strokeWidth), this.elSeries.add(k), k.attr("clip-path", "url(#forecastMask".concat(n.globals.cuid, ")")), S.attr("clip-path", "url(#nonForecastMask".concat(n.globals.cuid, ")"));
        }
      }
    }
  } }, { key: "_iterateOverDataPoints", value: function(e) {
    var t, i, s = this, a = e.type, n = e.series, o = e.iterations, l = e.realIndex, c = e.translationsIndex, h = e.i, d = e.x, u = e.y, g = e.pX, p = e.pY, f = e.pathsFrom, x = e.linePaths, m = e.areaPaths, b = e.seriesIndex, w = e.lineYPosition, y = e.xArrj, v = e.yArrj, S = e.y2Arrj, k = e.isRangeStart, C = e.seriesRangeEnd, R = this.w, P = new B(this.ctx), A = this.yRatio, E = f.prevY, N = f.linePath, O = f.areaPath, L = f.pathFromLine, I = f.pathFromArea, F = z.isNumber(R.globals.minYArr[l]) ? R.globals.minYArr[l] : R.globals.minY;
    o || (o = R.globals.dataPoints > 1 ? R.globals.dataPoints - 1 : R.globals.dataPoints);
    var D = function(re, Q) {
      return Q - re / A[c] + 2 * (s.isReversed ? re / A[c] : 0);
    }, Y = u, _ = R.config.chart.stacked && !R.globals.comboCharts || R.config.chart.stacked && R.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t = this.w.config.series[l]) === null || t === void 0 ? void 0 : t.type) === "bar" || ((i = this.w.config.series[l]) === null || i === void 0 ? void 0 : i.type) === "column"), H = R.config.stroke.curve;
    Array.isArray(H) && (H = Array.isArray(b) ? H[b[h]] : H[h]);
    for (var V, Z = 0, X = 0; X < o && n[h].length !== 0; X++) {
      var J = n[h][X + 1] === void 0 || n[h][X + 1] === null;
      if (R.globals.isXNumeric) {
        var G = R.globals.seriesX[l][X + 1];
        R.globals.seriesX[l][X + 1] === void 0 && (G = R.globals.seriesX[l][o - 1]), d = (G - R.globals.minX) / this.xRatio;
      } else d += this.xDivision;
      _ ? h > 0 && R.globals.collapsedSeries.length < R.config.series.length - 1 ? w = this.prevSeriesY[function(re) {
        for (var Q = re; Q > 0; Q--) {
          if (!(R.globals.collapsedSeriesIndices.indexOf((b == null ? void 0 : b[Q]) || Q) > -1)) return Q;
          Q--;
        }
        return 0;
      }(h - 1)][X + 1] : w = this.zeroY : w = this.zeroY, J ? u = D(F, w) : (u = D(n[h][X + 1], w), a === "rangeArea" && (Y = D(C[h][X + 1], w))), y.push(n[h][X + 1] === null ? null : d), !J || R.config.stroke.curve !== "smooth" && R.config.stroke.curve !== "monotoneCubic" ? (v.push(u), S.push(Y)) : (v.push(null), S.push(null));
      var $ = this.lineHelpers.calculatePoints({ series: n, x: d, y: u, realIndex: l, i: h, j: X, prevY: E }), K = this._createPaths({ type: a, series: n, i: h, realIndex: l, j: X, x: d, y: u, y2: Y, xArrj: y, yArrj: v, y2Arrj: S, pX: g, pY: p, pathState: Z, segmentStartX: V, linePath: N, areaPath: O, linePaths: x, areaPaths: m, curve: H, isRangeStart: k });
      m = K.areaPaths, x = K.linePaths, g = K.pX, p = K.pY, Z = K.pathState, V = K.segmentStartX, O = K.areaPath, N = K.linePath, !this.appendPathFrom || R.globals.hasNullValues || H === "monotoneCubic" && a === "rangeArea" || (L += P.line(d, this.areaBottomY), I += P.line(d, this.areaBottomY)), this.handleNullDataPoints(n, $, h, X, l), this._handleMarkersAndLabels({ type: a, pointsPos: $, i: h, j: X, realIndex: l, isRangeStart: k });
    }
    return { yArrj: v, xArrj: y, pathFromArea: I, areaPaths: m, pathFromLine: L, linePaths: x, linePath: N, areaPath: O };
  } }, { key: "_handleMarkersAndLabels", value: function(e) {
    var t = e.type, i = e.pointsPos, s = e.isRangeStart, a = e.i, n = e.j, o = e.realIndex, l = this.w, c = new Jt(this.ctx);
    if (this.pointsChart) this.scatter.draw(this.elSeries, n, { realIndex: o, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      l.globals.series[a].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      var h = this.markers.plotChartMarkers({ pointsPos: i, seriesIndex: o, j: n + 1 });
      h !== null && this.elPointsMain.add(h);
    }
    var d = c.drawDataLabel({ type: t, isRangeStart: s, pos: i, i: o, j: n + 1 });
    d !== null && this.elDataLabelsWrap.add(d);
  } }, { key: "_createPaths", value: function(e) {
    var t = e.type, i = e.series, s = e.i;
    e.realIndex;
    var a, n = e.j, o = e.x, l = e.y, c = e.xArrj, h = e.yArrj, d = e.y2, u = e.y2Arrj, g = e.pX, p = e.pY, f = e.pathState, x = e.segmentStartX, m = e.linePath, b = e.areaPath, w = e.linePaths, y = e.areaPaths, v = e.curve, S = e.isRangeStart, k = new B(this.ctx), C = this.areaBottomY, R = t === "rangeArea", P = t === "rangeArea" && S;
    switch (v) {
      case "monotoneCubic":
        var A = S ? h : u;
        switch (f) {
          case 0:
            if (A[n + 1] === null) break;
            f = 1;
          case 1:
            if (!(R ? c.length === i[s].length : n === i[s].length - 2)) break;
          case 2:
            var E = S ? c : c.slice().reverse(), N = S ? A : A.slice().reverse(), O = (a = N, E.map(function(G, $) {
              return [G, a[$]];
            }).filter(function(G) {
              return G[1] !== null;
            })), L = O.length > 1 ? yd(O) : O, I = [];
            R && (P ? y = O : I = y.reverse());
            var F = 0, D = 0;
            if (function(G, $) {
              for (var K = function(W) {
                var fe = [], _e = 0;
                return W.forEach(function(He) {
                  He !== null ? _e++ : _e > 0 && (fe.push(_e), _e = 0);
                }), _e > 0 && fe.push(_e), fe;
              }(G), re = [], Q = 0, ae = 0; Q < K.length; ae += K[Q++]) re[Q] = wd($, ae, ae + K[Q]);
              return re;
            }(N, L).forEach(function(G) {
              F++;
              var $ = function(Q) {
                for (var ae = "", W = 0; W < Q.length; W++) {
                  var fe = Q[W], _e = fe.length;
                  _e > 4 ? (ae += "C".concat(fe[0], ", ").concat(fe[1]), ae += ", ".concat(fe[2], ", ").concat(fe[3]), ae += ", ".concat(fe[4], ", ").concat(fe[5])) : _e > 2 && (ae += "S".concat(fe[0], ", ").concat(fe[1]), ae += ", ".concat(fe[2], ", ").concat(fe[3]));
                }
                return ae;
              }(G), K = D, re = (D += G.length) - 1;
              P ? m = k.move(O[K][0], O[K][1]) + $ : R ? m = k.move(I[K][0], I[K][1]) + k.line(O[K][0], O[K][1]) + $ + k.line(I[re][0], I[re][1]) : (m = k.move(O[K][0], O[K][1]) + $, b = m + k.line(O[re][0], C) + k.line(O[K][0], C) + "z", y.push(b)), w.push(m);
            }), R && F > 1 && !P) {
              var Y = w.slice(F).reverse();
              w.splice(F), Y.forEach(function(G) {
                return w.push(G);
              });
            }
            f = 0;
        }
        break;
      case "smooth":
        var _ = 0.35 * (o - g);
        if (i[s][n] === null) f = 0;
        else switch (f) {
          case 0:
            if (x = g, m = P ? k.move(g, u[n]) + k.line(g, p) : k.move(g, p), b = k.move(g, p), i[s][n + 1] === null || i[s][n + 1] === void 0) {
              w.push(m), y.push(b);
              break;
            }
            if (f = 1, n < i[s].length - 2) {
              var H = k.curve(g + _, p, o - _, l, o, l);
              m += H, b += H;
              break;
            }
          case 1:
            if (i[s][n + 1] === null) m += P ? k.line(g, d) : k.move(g, p), b += k.line(g, C) + k.line(x, C) + "z", w.push(m), y.push(b), f = -1;
            else {
              var V = k.curve(g + _, p, o - _, l, o, l);
              m += V, b += V, n >= i[s].length - 2 && (P && (m += k.curve(o, l, o, l, o, d) + k.move(o, d)), b += k.curve(o, l, o, l, o, C) + k.line(x, C) + "z", w.push(m), y.push(b), f = -1);
            }
        }
        g = o, p = l;
        break;
      default:
        var Z = function(G, $, K) {
          var re = [];
          switch (G) {
            case "stepline":
              re = k.line($, null, "H") + k.line(null, K, "V");
              break;
            case "linestep":
              re = k.line(null, K, "V") + k.line($, null, "H");
              break;
            case "straight":
              re = k.line($, K);
          }
          return re;
        };
        if (i[s][n] === null) f = 0;
        else switch (f) {
          case 0:
            if (x = g, m = P ? k.move(g, u[n]) + k.line(g, p) : k.move(g, p), b = k.move(g, p), i[s][n + 1] === null || i[s][n + 1] === void 0) {
              w.push(m), y.push(b);
              break;
            }
            if (f = 1, n < i[s].length - 2) {
              var X = Z(v, o, l);
              m += X, b += X;
              break;
            }
          case 1:
            if (i[s][n + 1] === null) m += P ? k.line(g, d) : k.move(g, p), b += k.line(g, C) + k.line(x, C) + "z", w.push(m), y.push(b), f = -1;
            else {
              var J = Z(v, o, l);
              m += J, b += J, n >= i[s].length - 2 && (P && (m += k.line(o, d)), b += k.line(o, C) + k.line(x, C) + "z", w.push(m), y.push(b), f = -1);
            }
        }
        g = o, p = l;
    }
    return { linePaths: w, areaPaths: y, pX: g, pY: p, pathState: f, segmentStartX: x, linePath: m, areaPath: b };
  } }, { key: "handleNullDataPoints", value: function(e, t, i, s, a) {
    var n = this.w;
    if (e[i][s] === null && n.config.markers.showNullDataPoints || e[i].length === 1) {
      var o = this.strokeWidth - n.config.markers.strokeWidth / 2;
      o > 0 || (o = 0);
      var l = this.markers.plotChartMarkers({ pointsPos: t, seriesIndex: a, j: s + 1, pSize: o, alwaysDrawMarker: !0 });
      l !== null && this.elPointsMain.add(l);
    }
  } }]), r;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ function() {
  function r(o, l, c, h) {
    this.xoffset = o, this.yoffset = l, this.height = h, this.width = c, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(d) {
      var u, g = [], p = this.xoffset, f = this.yoffset, x = a(d) / this.height, m = a(d) / this.width;
      if (this.width >= this.height) for (u = 0; u < d.length; u++) g.push([p, f, p + x, f + d[u] / x]), f += d[u] / x;
      else for (u = 0; u < d.length; u++) g.push([p, f, p + d[u] / m, f + m]), p += d[u] / m;
      return g;
    }, this.cutArea = function(d) {
      var u;
      if (this.width >= this.height) {
        var g = d / this.height, p = this.width - g;
        u = new r(this.xoffset + g, this.yoffset, p, this.height);
      } else {
        var f = d / this.width, x = this.height - f;
        u = new r(this.xoffset, this.yoffset + f, this.width, x);
      }
      return u;
    };
  }
  function e(o, l, c, h, d) {
    h = h === void 0 ? 0 : h, d = d === void 0 ? 0 : d;
    var u = t(function(g, p) {
      var f, x = [], m = p / a(g);
      for (f = 0; f < g.length; f++) x[f] = g[f] * m;
      return x;
    }(o, l * c), [], new r(h, d, l, c), []);
    return function(g) {
      var p, f, x = [];
      for (p = 0; p < g.length; p++) for (f = 0; f < g[p].length; f++) x.push(g[p][f]);
      return x;
    }(u);
  }
  function t(o, l, c, h) {
    var d, u, g;
    if (o.length !== 0) return d = c.shortestEdge(), function(p, f, x) {
      var m;
      if (p.length === 0) return !0;
      (m = p.slice()).push(f);
      var b = i(p, x), w = i(m, x);
      return b >= w;
    }(l, u = o[0], d) ? (l.push(u), t(o.slice(1), l, c, h)) : (g = c.cutArea(a(l), h), h.push(c.getCoordinates(l)), t(o, [], g, h)), h;
    h.push(c.getCoordinates(l));
  }
  function i(o, l) {
    var c = Math.min.apply(Math, o), h = Math.max.apply(Math, o), d = a(o);
    return Math.max(Math.pow(l, 2) * h / Math.pow(d, 2), Math.pow(d, 2) / (Math.pow(l, 2) * c));
  }
  function s(o) {
    return o && o.constructor === Array;
  }
  function a(o) {
    var l, c = 0;
    for (l = 0; l < o.length; l++) c += o[l];
    return c;
  }
  function n(o) {
    var l, c = 0;
    if (s(o[0])) for (l = 0; l < o.length; l++) c += n(o[l]);
    else c = a(o);
    return c;
  }
  return function o(l, c, h, d, u) {
    d = d === void 0 ? 0 : d, u = u === void 0 ? 0 : u;
    var g, p, f = [], x = [];
    if (s(l[0])) {
      for (p = 0; p < l.length; p++) f[p] = n(l[p]);
      for (g = e(f, c, h, d, u), p = 0; p < l.length; p++) x.push(o(l[p], g[p][2] - g[p][0], g[p][3] - g[p][1], g[p][0], g[p][1]));
    } else x = e(l, c, h, d, u);
    return x;
  };
}();
var Sd = function() {
  function r(e, t) {
    ee(this, r), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Lo(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return te(r, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, s = new B(this.ctx), a = new ht(this.ctx), n = s.group({ class: "apexcharts-treemap" });
    if (i.globals.noData) return n;
    var o = [];
    return e.forEach(function(l) {
      var c = l.map(function(h) {
        return Math.abs(h);
      });
      o.push(c);
    }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(l, c) {
      l.data.forEach(function(h) {
        Array.isArray(t.labels[c]) || (t.labels[c] = []), t.labels[c].push(h.x);
      });
    }), window.TreemapSquared.generate(o, i.globals.gridWidth, i.globals.gridHeight).forEach(function(l, c) {
      var h = s.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: z.escapeString(i.globals.seriesNames[c]), rel: c + 1, "data:realIndex": c });
      if (i.config.chart.dropShadow.enabled) {
        var d = i.config.chart.dropShadow;
        new je(t.ctx).dropShadow(n, d, c);
      }
      var u = s.group({ class: "apexcharts-data-labels" }), g = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      l.forEach(function(L, I) {
        var F = L[0], D = L[1], Y = L[2], _ = L[3];
        g.xMin = Math.min(g.xMin, F), g.yMin = Math.min(g.yMin, D), g.xMax = Math.max(g.xMax, Y), g.yMax = Math.max(g.yMax, _);
        var H = t.helpers.getShadeColor(i.config.chart.type, c, I, t.negRange), V = H.color, Z = a.fillPath({ color: V, seriesNumber: c, dataPointIndex: I }), X = s.drawRect(F, D, Y - F, _ - D, i.config.plotOptions.treemap.borderRadius, "#fff", 1, t.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? V : i.globals.stroke.colors[c]);
        X.attr({ cx: F, cy: D, index: c, i: c, j: I, width: Y - F, height: _ - D, fill: Z }), X.node.classList.add("apexcharts-treemap-rect"), t.helpers.addListeners(X);
        var J = { x: F + (Y - F) / 2, y: D + (_ - D) / 2, width: 0, height: 0 }, G = { x: F, y: D, width: Y - F, height: _ - D };
        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
          var $ = 1;
          i.globals.resized || ($ = i.config.chart.animations.speed), t.animateTreemap(X, J, G, $);
        }
        if (i.globals.dataChanged) {
          var K = 1;
          t.dynamicAnim.enabled && i.globals.shouldAnimate && (K = t.dynamicAnim.speed, i.globals.previousPaths[c] && i.globals.previousPaths[c][I] && i.globals.previousPaths[c][I].rect && (J = i.globals.previousPaths[c][I].rect), t.animateTreemap(X, J, G, K));
        }
        var re = t.getFontSize(L), Q = i.config.dataLabels.formatter(t.labels[c][I], { value: i.globals.series[c][I], seriesIndex: c, dataPointIndex: I, w: i });
        i.config.plotOptions.treemap.dataLabels.format === "truncate" && (re = parseInt(i.config.dataLabels.style.fontSize, 10), Q = t.truncateLabels(Q, re, F, D, Y, _));
        var ae = null;
        i.globals.series[c][I] && (ae = t.helpers.calculateDataLabels({ text: Q, x: (F + Y) / 2, y: (D + _) / 2 + t.strokeWidth / 2 + re / 3, i: c, j: I, colorProps: H, fontSize: re, series: e })), i.config.dataLabels.enabled && ae && t.rotateToFitLabel(ae, re, Q, F, D, Y, _), h.add(X), ae !== null && h.add(ae);
      });
      var p = i.config.plotOptions.treemap.seriesTitle;
      if (i.config.series.length > 1 && p && p.show) {
        var f = i.config.series[c].name || "";
        if (f && g.xMin < 1 / 0 && g.yMin < 1 / 0) {
          var x = p.offsetX, m = p.offsetY, b = p.borderColor, w = p.borderWidth, y = p.borderRadius, v = p.style, S = v.color || i.config.chart.foreColor, k = { left: v.padding.left, right: v.padding.right, top: v.padding.top, bottom: v.padding.bottom }, C = s.getTextRects(f, v.fontSize, v.fontFamily), R = C.width + k.left + k.right, P = C.height + k.top + k.bottom, A = g.xMin + (x || 0), E = g.yMin + (m || 0), N = s.drawRect(A, E, R, P, y, v.background, 1, w, b), O = s.drawText({ x: A + k.left, y: E + k.top + 0.75 * C.height, text: f, fontSize: v.fontSize, fontFamily: v.fontFamily, fontWeight: v.fontWeight, foreColor: S, cssClass: v.cssClass || "" });
          h.add(N), h.add(O);
        }
      }
      h.add(u), n.add(h);
    }), n;
  } }, { key: "getFontSize", value: function(e) {
    var t = this.w, i = function s(a) {
      var n, o = 0;
      if (Array.isArray(a[0])) for (n = 0; n < a.length; n++) o += s(a[n]);
      else for (n = 0; n < a.length; n++) o += a[n].length;
      return o;
    }(this.labels) / function s(a) {
      var n, o = 0;
      if (Array.isArray(a[0])) for (n = 0; n < a.length; n++) o += s(a[n]);
      else for (n = 0; n < a.length; n++) o += 1;
      return o;
    }(this.labels);
    return function(s, a) {
      var n = s * a, o = Math.pow(n, 0.5);
      return Math.min(o / i, parseInt(t.config.dataLabels.style.fontSize, 10));
    }(e[2] - e[0], e[3] - e[1]);
  } }, { key: "rotateToFitLabel", value: function(e, t, i, s, a, n, o) {
    var l = new B(this.ctx), c = l.getTextRects(i, t);
    if (c.width + this.w.config.stroke.width + 5 > n - s && c.width <= o - a) {
      var h = l.rotateAroundCenter(e.node);
      e.node.setAttribute("transform", "rotate(-90 ".concat(h.x, " ").concat(h.y, ") translate(").concat(c.height / 3, ")"));
    }
  } }, { key: "truncateLabels", value: function(e, t, i, s, a, n) {
    var o = new B(this.ctx), l = o.getTextRects(e, t).width + this.w.config.stroke.width + 5 > a - i && n - s > a - i ? n - s : a - i, c = o.getTextBasedOnMaxWidth({ text: e, maxWidth: l, fontSize: t });
    return e.length !== c.length && l / t < 5 ? "" : c;
  } }, { key: "animateTreemap", value: function(e, t, i, s) {
    var a = new ti(this.ctx);
    a.animateRect(e, t, i, s, function() {
      a.animationCompleted(e);
    });
  } }]), r;
}(), To = 86400, kd = 10 / To, Cd = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return te(r, [{ key: "calculateTimeScaleTicks", value: function(e, t) {
    var i = this, s = this.w;
    if (s.globals.allSeriesCollapsed) return s.globals.labels = [], s.globals.timescaleLabels = [], [];
    var a = new Ye(this.ctx), n = (t - e) / 864e5;
    this.determineInterval(n), s.globals.disableZoomIn = !1, s.globals.disableZoomOut = !1, n < kd ? s.globals.disableZoomIn = !0 : n > 5e4 && (s.globals.disableZoomOut = !0);
    var o = a.getTimeUnitsfromTimestamp(e, t, this.utc), l = s.globals.gridWidth / n, c = l / 24, h = c / 60, d = h / 60, u = Math.floor(24 * n), g = Math.floor(1440 * n), p = Math.floor(n * To), f = Math.floor(n), x = Math.floor(n / 30), m = Math.floor(n / 365), b = { minMillisecond: o.minMillisecond, minSecond: o.minSecond, minMinute: o.minMinute, minHour: o.minHour, minDate: o.minDate, minMonth: o.minMonth, minYear: o.minYear }, w = { firstVal: b, currentMillisecond: b.minMillisecond, currentSecond: b.minSecond, currentMinute: b.minMinute, currentHour: b.minHour, currentMonthDate: b.minDate, currentDate: b.minDate, currentMonth: b.minMonth, currentYear: b.minYear, daysWidthOnXAxis: l, hoursWidthOnXAxis: c, minutesWidthOnXAxis: h, secondsWidthOnXAxis: d, numberOfSeconds: p, numberOfMinutes: g, numberOfHours: u, numberOfDays: f, numberOfMonths: x, numberOfYears: m };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(w);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(w);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(w);
        break;
      case "hours":
        this.generateHourScale(w);
        break;
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(w);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(w);
    }
    var y = this.timeScaleArray.map(function(v) {
      var S = { position: v.position, unit: v.unit, year: v.year, day: v.day ? v.day : 1, hour: v.hour ? v.hour : 0, month: v.month + 1 };
      return v.unit === "month" ? q(q({}, S), {}, { day: 1, value: v.value + 1 }) : v.unit === "day" || v.unit === "hour" ? q(q({}, S), {}, { value: v.value }) : v.unit === "minute" ? q(q({}, S), {}, { value: v.value, minute: v.value }) : v.unit === "second" ? q(q({}, S), {}, { value: v.value, minute: v.minute, second: v.second }) : v;
    });
    return y.filter(function(v) {
      var S = 1, k = Math.ceil(s.globals.gridWidth / 120), C = v.value;
      s.config.xaxis.tickAmount !== void 0 && (k = s.config.xaxis.tickAmount), y.length > k && (S = Math.floor(y.length / k));
      var R = !1, P = !1;
      switch (i.tickInterval) {
        case "years":
          v.unit === "year" && (R = !0);
          break;
        case "half_year":
          S = 7, v.unit === "year" && (R = !0);
          break;
        case "months":
          S = 1, v.unit === "year" && (R = !0);
          break;
        case "months_fortnight":
          S = 15, v.unit !== "year" && v.unit !== "month" || (R = !0), C === 30 && (P = !0);
          break;
        case "months_days":
          S = 10, v.unit === "month" && (R = !0), C === 30 && (P = !0);
          break;
        case "week_days":
          S = 8, v.unit === "month" && (R = !0);
          break;
        case "days":
          S = 1, v.unit === "month" && (R = !0);
          break;
        case "hours":
          v.unit === "day" && (R = !0);
          break;
        case "minutes_fives":
        case "seconds_fives":
          C % 5 != 0 && (P = !0);
          break;
        case "seconds_tens":
          C % 10 != 0 && (P = !0);
      }
      if (i.tickInterval === "hours" || i.tickInterval === "minutes_fives" || i.tickInterval === "seconds_tens" || i.tickInterval === "seconds_fives") {
        if (!P) return !0;
      } else if ((C % S == 0 || R) && !P) return !0;
    });
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(e, t) {
    var i = this.w, s = this.formatDates(e), a = this.removeOverlappingTS(s);
    i.globals.timescaleLabels = a.slice(), new es(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(e) {
    var t = 24 * e, i = 60 * t;
    switch (!0) {
      case e / 365 > 5:
        this.tickInterval = "years";
        break;
      case e > 800:
        this.tickInterval = "half_year";
        break;
      case e > 180:
        this.tickInterval = "months";
        break;
      case e > 90:
        this.tickInterval = "months_fortnight";
        break;
      case e > 60:
        this.tickInterval = "months_days";
        break;
      case e > 30:
        this.tickInterval = "week_days";
        break;
      case e > 2:
        this.tickInterval = "days";
        break;
      case t > 2.4:
        this.tickInterval = "hours";
        break;
      case i > 15:
        this.tickInterval = "minutes_fives";
        break;
      case i > 5:
        this.tickInterval = "minutes";
        break;
      case i > 1:
        this.tickInterval = "seconds_tens";
        break;
      case 60 * i > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
    }
  } }, { key: "generateYearScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonth, s = e.currentYear, a = e.daysWidthOnXAxis, n = e.numberOfYears, o = t.minYear, l = 0, c = new Ye(this.ctx), h = "year";
    if (t.minDate > 1 || t.minMonth > 0) {
      var d = c.determineRemainingDaysOfYear(t.minYear, t.minMonth, t.minDate);
      l = (c.determineDaysOfYear(t.minYear) - d + 1) * a, o = t.minYear + 1, this.timeScaleArray.push({ position: l, value: o, unit: h, year: o, month: z.monthMod(i + 1) });
    } else t.minDate === 1 && t.minMonth === 0 && this.timeScaleArray.push({ position: l, value: o, unit: h, year: s, month: z.monthMod(i + 1) });
    for (var u = o, g = l, p = 0; p < n; p++) u++, g = c.determineDaysOfYear(u - 1) * a + g, this.timeScaleArray.push({ position: g, value: u, unit: h, year: u, month: 1 });
  } }, { key: "generateMonthScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonthDate, s = e.currentMonth, a = e.currentYear, n = e.daysWidthOnXAxis, o = e.numberOfMonths, l = s, c = 0, h = new Ye(this.ctx), d = "month", u = 0;
    if (t.minDate > 1) {
      c = (h.determineDaysOfMonths(s + 1, t.minYear) - i + 1) * n, l = z.monthMod(s + 1);
      var g = a + u, p = z.monthMod(l), f = l;
      l === 0 && (d = "year", f = g, p = 1, g += u += 1), this.timeScaleArray.push({ position: c, value: f, unit: d, year: g, month: p });
    } else this.timeScaleArray.push({ position: c, value: l, unit: d, year: a, month: z.monthMod(s) });
    for (var x = l + 1, m = c, b = 0, w = 1; b < o; b++, w++) {
      (x = z.monthMod(x)) === 0 ? (d = "year", u += 1) : d = "month";
      var y = this._getYear(a, x, u);
      m = h.determineDaysOfMonths(x, y) * n + m;
      var v = x === 0 ? y : x;
      this.timeScaleArray.push({ position: m, value: v, unit: d, year: y, month: x === 0 ? 1 : x }), x++;
    }
  } }, { key: "generateDayScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonth, s = e.currentYear, a = e.hoursWidthOnXAxis, n = e.numberOfDays, o = new Ye(this.ctx), l = "day", c = t.minDate + 1, h = c, d = function(w, y, v) {
      return w > o.determineDaysOfMonths(y + 1, v) && (h = 1, l = "month", g = y += 1), y;
    }, u = (24 - t.minHour) * a, g = c, p = d(h, i, s);
    t.minHour === 0 && t.minDate === 1 ? (u = 0, g = z.monthMod(t.minMonth), l = "month", h = t.minDate) : t.minDate !== 1 && t.minHour === 0 && t.minMinute === 0 && (u = 0, c = t.minDate, g = c, p = d(h = c, i, s), g !== 1 && (l = "day")), this.timeScaleArray.push({ position: u, value: g, unit: l, year: this._getYear(s, p, 0), month: z.monthMod(p), day: h });
    for (var f = u, x = 0; x < n; x++) {
      l = "day", p = d(h += 1, p, this._getYear(s, p, 0));
      var m = this._getYear(s, p, 0);
      f = 24 * a + f;
      var b = h === 1 ? z.monthMod(p) : h;
      this.timeScaleArray.push({ position: f, value: b, unit: l, year: m, month: z.monthMod(p), day: b });
    }
  } }, { key: "generateHourScale", value: function(e) {
    var t = e.firstVal, i = e.currentDate, s = e.currentMonth, a = e.currentYear, n = e.minutesWidthOnXAxis, o = e.numberOfHours, l = new Ye(this.ctx), c = "hour", h = function(S, k) {
      return S > l.determineDaysOfMonths(k + 1, a) && (x = 1, k += 1), { month: k, date: x };
    }, d = function(S, k) {
      return S > l.determineDaysOfMonths(k + 1, a) ? k += 1 : k;
    }, u = 60 - (t.minMinute + t.minSecond / 60), g = u * n, p = t.minHour + 1, f = p;
    u === 60 && (g = 0, f = p = t.minHour);
    var x = i;
    f >= 24 && (f = 0, c = "day", p = x += 1);
    var m = h(x, s).month;
    m = d(x, m), p > 31 && (p = x = 1), this.timeScaleArray.push({ position: g, value: p, unit: c, day: x, hour: f, year: a, month: z.monthMod(m) }), f++;
    for (var b = g, w = 0; w < o; w++) {
      c = "hour", f >= 24 && (f = 0, c = "day", m = h(x += 1, m).month, m = d(x, m));
      var y = this._getYear(a, m, 0);
      b = 60 * n + b;
      var v = f === 0 ? x : f;
      this.timeScaleArray.push({ position: b, value: v, unit: c, hour: f, day: x, year: y, month: z.monthMod(m) }), f++;
    }
  } }, { key: "generateMinuteScale", value: function(e) {
    for (var t = e.currentMillisecond, i = e.currentSecond, s = e.currentMinute, a = e.currentHour, n = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.minutesWidthOnXAxis, h = e.secondsWidthOnXAxis, d = e.numberOfMinutes, u = s + 1, g = n, p = o, f = l, x = a, m = (60 - i - t / 1e3) * h, b = 0; b < d; b++) u >= 60 && (u = 0, (x += 1) === 24 && (x = 0)), this.timeScaleArray.push({ position: m, value: u, unit: "minute", hour: x, minute: u, day: g, year: this._getYear(f, p, 0), month: z.monthMod(p) }), m += c, u++;
  } }, { key: "generateSecondScale", value: function(e) {
    for (var t = e.currentMillisecond, i = e.currentSecond, s = e.currentMinute, a = e.currentHour, n = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.secondsWidthOnXAxis, h = e.numberOfSeconds, d = i + 1, u = s, g = n, p = o, f = l, x = a, m = (1e3 - t) / 1e3 * c, b = 0; b < h; b++) d >= 60 && (d = 0, ++u >= 60 && (u = 0, ++x === 24 && (x = 0))), this.timeScaleArray.push({ position: m, value: d, unit: "second", hour: x, minute: u, second: d, day: g, year: this._getYear(f, p, 0), month: z.monthMod(p) }), m += c, d++;
  } }, { key: "createRawDateString", value: function(e, t) {
    var i = e.year;
    return e.month === 0 && (e.month = 1), i += "-" + ("0" + e.month.toString()).slice(-2), e.unit === "day" ? i += e.unit === "day" ? "-" + ("0" + t).slice(-2) : "-01" : i += "-" + ("0" + (e.day ? e.day : "1")).slice(-2), e.unit === "hour" ? i += e.unit === "hour" ? "T" + ("0" + t).slice(-2) : "T00" : i += "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2), e.unit === "minute" ? i += ":" + ("0" + t).slice(-2) : i += ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"), e.unit === "second" ? i += ":" + ("0" + t).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
  } }, { key: "formatDates", value: function(e) {
    var t = this, i = this.w;
    return e.map(function(s) {
      var a = s.value.toString(), n = new Ye(t.ctx), o = t.createRawDateString(s, a), l = n.getDate(n.parseDate(o));
      if (t.utc || (l = n.getDate(n.parseDateWithTimezone(o))), i.config.xaxis.labels.format === void 0) {
        var c = "dd MMM", h = i.config.xaxis.labels.datetimeFormatter;
        s.unit === "year" && (c = h.year), s.unit === "month" && (c = h.month), s.unit === "day" && (c = h.day), s.unit === "hour" && (c = h.hour), s.unit === "minute" && (c = h.minute), s.unit === "second" && (c = h.second), a = n.formatDate(l, c);
      } else a = n.formatDate(l, i.config.xaxis.labels.format);
      return { dateString: o, position: s.position, value: a, unit: s.unit, year: s.year, month: s.month };
    });
  } }, { key: "removeOverlappingTS", value: function(e) {
    var t, i = this, s = new B(this.ctx), a = !1;
    e.length > 0 && e[0].value && e.every(function(l) {
      return l.value.length === e[0].value.length;
    }) && (a = !0, t = s.getTextRects(e[0].value).width);
    var n = 0, o = e.map(function(l, c) {
      if (c > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
        var h = a ? t : s.getTextRects(e[n].value).width, d = e[n].position;
        return l.position > d + h + 10 ? (n = c, l) : null;
      }
      return l;
    });
    return o = o.filter(function(l) {
      return l !== null;
    });
  } }, { key: "_getYear", value: function(e, t, i) {
    return e + Math.floor(t / 12) + i;
  } }]), r;
}(), Ad = function() {
  function r(e, t) {
    ee(this, r), this.ctx = t, this.w = t.w, this.el = e;
  }
  return te(r, [{ key: "setupElements", value: function() {
    var e = this.w, t = e.globals, i = e.config, s = i.chart.type;
    t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(s), t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(s), t.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(s) && i.plotOptions.bar.horizontal, t.chartClass = ".apexcharts".concat(t.chartID), t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), B.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: "apexcharts-canvas ".concat(t.chartClass.substring(1)) }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = window.SVG().addTo(t.dom.elWrap), t.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i.chart.offsetX, ", ").concat(i.chart.offsetY, ")") }), t.dom.Paper.node.style.background = i.theme.mode !== "dark" || i.chart.background ? i.theme.mode !== "light" || i.chart.background ? i.chart.background : "#fff" : "#343A3F", this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), B.setAttrs(t.dom.elLegendForeign, { x: 0, y: 0, width: t.svgWidth, height: t.svgHeight }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
  } }, { key: "plotChartType", value: function(e, t) {
    var i = this.w, s = this.ctx, a = i.config, n = i.globals, o = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, l = a.chart.type || "line", c = null, h = 0;
    n.series.forEach(function(S, k) {
      var C = e[k].type === "column" ? "bar" : e[k].type || (l === "column" ? "bar" : l);
      o[C] ? (C === "rangeArea" ? (o[C].series.push(n.seriesRangeStart[k]), o[C].seriesRangeEnd.push(n.seriesRangeEnd[k])) : o[C].series.push(S), o[C].i.push(k), C === "bar" && (i.globals.columnSeries = o.bar)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(C) ? c = C : console.warn("You have specified an unrecognized series type (".concat(C, ").")), l !== C && C !== "scatter" && h++;
    }), h > 0 && (c && console.warn("Chart or series type ".concat(c, " cannot appear with other chart or series types.")), o.bar.series.length > 0 && a.plotOptions.bar.horizontal && (h -= o.bar.series.length, o.bar = { series: [], i: [] }, i.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), n.comboCharts || (n.comboCharts = h > 0);
    var d = new _s(s, t), u = new Es(s, t);
    s.pie = new Eo(s);
    var g = new xd(s);
    s.rangeBar = new md(s, t);
    var p = new pd(s), f = [];
    if (n.comboCharts) {
      var x, m, b = new ze(s);
      if (o.area.series.length > 0 && (x = f).push.apply(x, De(b.drawSeriesByGroup(o.area, n.areaGroups, "area", d))), o.bar.series.length > 0) if (a.chart.stacked) {
        var w = new Ua(s, t);
        f.push(w.draw(o.bar.series, o.bar.i));
      } else s.bar = new Kt(s, t), f.push(s.bar.draw(o.bar.series, o.bar.i));
      if (o.rangeArea.series.length > 0 && f.push(d.draw(o.rangeArea.series, "rangeArea", o.rangeArea.i, o.rangeArea.seriesRangeEnd)), o.line.series.length > 0 && (m = f).push.apply(m, De(b.drawSeriesByGroup(o.line, n.lineGroups, "line", d))), o.candlestick.series.length > 0 && f.push(u.draw(o.candlestick.series, "candlestick", o.candlestick.i)), o.boxPlot.series.length > 0 && f.push(u.draw(o.boxPlot.series, "boxPlot", o.boxPlot.i)), o.rangeBar.series.length > 0 && f.push(s.rangeBar.draw(o.rangeBar.series, o.rangeBar.i)), o.scatter.series.length > 0) {
        var y = new _s(s, t, !0);
        f.push(y.draw(o.scatter.series, "scatter", o.scatter.i));
      }
      if (o.bubble.series.length > 0) {
        var v = new _s(s, t, !0);
        f.push(v.draw(o.bubble.series, "bubble", o.bubble.i));
      }
    } else switch (a.chart.type) {
      case "line":
        f = d.draw(n.series, "line");
        break;
      case "area":
        f = d.draw(n.series, "area");
        break;
      case "bar":
        a.chart.stacked ? f = new Ua(s, t).draw(n.series) : (s.bar = new Kt(s, t), f = s.bar.draw(n.series));
        break;
      case "candlestick":
        f = new Es(s, t).draw(n.series, "candlestick");
        break;
      case "boxPlot":
        f = new Es(s, t).draw(n.series, a.chart.type);
        break;
      case "rangeBar":
        f = s.rangeBar.draw(n.series);
        break;
      case "rangeArea":
        f = d.draw(n.seriesRangeStart, "rangeArea", void 0, n.seriesRangeEnd);
        break;
      case "heatmap":
        f = new fd(s, t).draw(n.series);
        break;
      case "treemap":
        f = new Sd(s, t).draw(n.series);
        break;
      case "pie":
      case "donut":
      case "polarArea":
        f = s.pie.draw(n.series);
        break;
      case "radialBar":
        f = g.draw(n.series);
        break;
      case "radar":
        f = p.draw(n.series);
        break;
      default:
        f = d.draw(n.series);
    }
    return f;
  } }, { key: "setSVGDimensions", value: function() {
    var e = this.w, t = e.globals, i = e.config;
    i.chart.width = i.chart.width || "100%", i.chart.height = i.chart.height || "auto", t.svgWidth = i.chart.width, t.svgHeight = i.chart.height;
    var s = z.getDimensions(this.el), a = i.chart.width.toString().split(/[0-9]+/g).pop();
    a === "%" ? z.isNumber(s[0]) && (s[0].width === 0 && (s = z.getDimensions(this.el.parentNode)), t.svgWidth = s[0] * parseInt(i.chart.width, 10) / 100) : a !== "px" && a !== "" || (t.svgWidth = parseInt(i.chart.width, 10));
    var n = String(i.chart.height).toString().split(/[0-9]+/g).pop();
    if (t.svgHeight !== "auto" && t.svgHeight !== "") if (n === "%") {
      var o = z.getDimensions(this.el.parentNode);
      t.svgHeight = o[1] * parseInt(i.chart.height, 10) / 100;
    } else t.svgHeight = parseInt(i.chart.height, 10);
    else t.svgHeight = t.axisCharts ? t.svgWidth / 1.61 : t.svgWidth / 1.2;
    if (t.svgWidth = Math.max(t.svgWidth, 0), t.svgHeight = Math.max(t.svgHeight, 0), B.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }), n !== "%") {
      var l = i.chart.sparkline.enabled ? 0 : t.axisCharts ? i.chart.parentHeightOffset : 0;
      t.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(t.svgHeight + l, "px");
    }
    t.dom.elWrap.style.width = "".concat(t.svgWidth, "px"), t.dom.elWrap.style.height = "".concat(t.svgHeight, "px");
  } }, { key: "shiftGraphPosition", value: function() {
    var e = this.w.globals, t = e.translateY, i = e.translateX;
    B.setAttrs(e.dom.elGraphical.node, { transform: "translate(".concat(i, ", ").concat(t, ")") });
  } }, { key: "resizeNonAxisCharts", value: function() {
    var e = this.w, t = e.globals, i = 0, s = e.config.chart.sparkline.enabled ? 1 : 15;
    s += e.config.grid.padding.bottom, ["top", "bottom"].includes(e.config.legend.position) && e.config.legend.show && !e.config.legend.floating && (i = new Ao(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var a = e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), n = 2.05 * e.globals.radialSize;
    if (a && !e.config.chart.sparkline.enabled && e.config.plotOptions.radialBar.startAngle !== 0) {
      var o = z.getBoundingClientRect(a);
      n = o.bottom;
      var l = o.bottom - o.top;
      n = Math.max(2.05 * e.globals.radialSize, l);
    }
    var c = Math.ceil(n + t.translateY + i + s);
    t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", c), e.config.chart.height && String(e.config.chart.height).includes("%") || (t.dom.elWrap.style.height = "".concat(c, "px"), B.setAttrs(t.dom.Paper.node, { height: c }), t.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(c, "px"));
  } }, { key: "coreCalculations", value: function() {
    new br(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var e = this, t = function() {
      return e.w.config.series.map(function() {
        return [];
      });
    }, i = new wo(), s = this.w.globals;
    i.initGlobalVars(s), s.seriesXvalues = t(), s.seriesYvalues = t();
  } }, { key: "isMultipleY", value: function() {
    return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = !0, !0);
  } }, { key: "xySettings", value: function() {
    var e = this.w, t = null;
    if (e.globals.axisCharts) {
      if (e.config.xaxis.crosshairs.position === "back" && new vr(this.ctx).drawXCrosshairs(), e.config.yaxis[0].crosshairs.position === "back" && new vr(this.ctx).drawYCrosshairs(), e.config.xaxis.type === "datetime" && e.config.xaxis.labels.formatter === void 0) {
        this.ctx.timeScale = new Cd(this.ctx);
        var i = [];
        isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
      }
      t = new ze(this.ctx).getCalculatedRatios();
    }
    return t;
  } }, { key: "updateSourceChart", value: function(e) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: e.w.globals.minX, max: e.w.globals.maxX } } } }, !1, !1);
  } }, { key: "setupBrushHandler", value: function() {
    var e = this, t = this.ctx, i = this.w;
    if (i.config.chart.brush.enabled && typeof i.config.chart.events.selection != "function") {
      var s = Array.isArray(i.config.chart.brush.targets) ? i.config.chart.brush.targets : [i.config.chart.brush.target];
      s.forEach(function(a) {
        var n = t.constructor.getChartByID(a);
        n.w.globals.brushSource = e.ctx, typeof n.w.config.chart.events.zoomed != "function" && (n.w.config.chart.events.zoomed = function() {
          return e.updateSourceChart(n);
        }), typeof n.w.config.chart.events.scrolled != "function" && (n.w.config.chart.events.scrolled = function() {
          return e.updateSourceChart(n);
        });
      }), i.config.chart.events.selection = function(a, n) {
        s.forEach(function(o) {
          t.constructor.getChartByID(o).ctx.updateHelpers._updateOptions({ xaxis: { min: n.xaxis.min, max: n.xaxis.max } }, !1, !1, !1, !1);
        });
      };
    }
  } }]), r;
}(), Md = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "_updateOptions", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], n = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
    return new Promise(function(o) {
      var l = [t.ctx];
      a && (l = t.ctx.getSyncedCharts()), t.ctx.w.globals.isExecCalled && (l = [t.ctx], t.ctx.w.globals.isExecCalled = !1), l.forEach(function(c, h) {
        var d = c.w;
        if (d.globals.shouldAnimate = s, i || (d.globals.resized = !0, d.globals.dataChanged = !0, s && c.series.getPreviousPaths()), e && Zt(e) === "object" && (c.config = new Ai(e), e = ze.extendArrayProps(c.config, e, d), c.w.globals.chartID !== t.ctx.w.globals.chartID && delete e.series, d.config = z.extend(d.config, e), n && (d.globals.lastXAxis = e.xaxis ? z.clone(e.xaxis) : [], d.globals.lastYAxis = e.yaxis ? z.clone(e.yaxis) : [], d.globals.initialConfig = z.extend({}, d.config), d.globals.initialSeries = z.clone(d.config.series), e.series))) {
          for (var u = 0; u < d.globals.collapsedSeriesIndices.length; u++) {
            var g = d.config.series[d.globals.collapsedSeriesIndices[u]];
            d.globals.collapsedSeries[u].data = d.globals.axisCharts ? g.data.slice() : g;
          }
          for (var p = 0; p < d.globals.ancillaryCollapsedSeriesIndices.length; p++) {
            var f = d.config.series[d.globals.ancillaryCollapsedSeriesIndices[p]];
            d.globals.ancillaryCollapsedSeries[p].data = d.globals.axisCharts ? f.data.slice() : f;
          }
          c.series.emptyCollapsedSeries(d.config.series);
        }
        return c.update(e).then(function() {
          h === l.length - 1 && o(c);
        });
      });
    });
  } }, { key: "_updateSeries", value: function(e, t) {
    var i = this, s = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    return new Promise(function(a) {
      var n, o = i.w;
      return o.globals.shouldAnimate = t, o.globals.dataChanged = !0, t && i.ctx.series.getPreviousPaths(), o.globals.axisCharts ? ((n = e.map(function(l, c) {
        return i._extendSeries(l, c);
      })).length === 0 && (n = [{ data: [] }]), o.config.series = n) : o.config.series = e.slice(), s && (o.globals.initialConfig.series = z.clone(o.config.series), o.globals.initialSeries = z.clone(o.config.series)), i.ctx.update().then(function() {
        a(i.ctx);
      });
    });
  } }, { key: "_extendSeries", value: function(e, t) {
    var i = this.w, s = i.config.series[t];
    return q(q({}, i.config.series[t]), {}, { name: e.name ? e.name : s == null ? void 0 : s.name, color: e.color ? e.color : s == null ? void 0 : s.color, type: e.type ? e.type : s == null ? void 0 : s.type, group: e.group ? e.group : s == null ? void 0 : s.group, hidden: e.hidden !== void 0 ? e.hidden : s == null ? void 0 : s.hidden, data: e.data ? e.data : s == null ? void 0 : s.data, zIndex: e.zIndex !== void 0 ? e.zIndex : t });
  } }, { key: "toggleDataPointSelection", value: function(e, t) {
    var i = this.w, s = null, a = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
    return i.globals.axisCharts ? s = i.globals.dom.Paper.findOne("".concat(a, " path[j='").concat(t, "'], ").concat(a, " circle[j='").concat(t, "'], ").concat(a, " rect[j='").concat(t, "']")) : t === void 0 && (s = i.globals.dom.Paper.findOne("".concat(a, " path[j='").concat(e, "']")), i.config.chart.type !== "pie" && i.config.chart.type !== "polarArea" && i.config.chart.type !== "donut" || this.ctx.pie.pieClicked(e)), s ? (new B(this.ctx).pathMouseDown(s, null), s.node ? s.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
  } }, { key: "forceXAxisUpdate", value: function(e) {
    var t = this.w;
    if (["min", "max"].forEach(function(s) {
      e.xaxis[s] !== void 0 && (t.config.xaxis[s] = e.xaxis[s], t.globals.lastXAxis[s] = e.xaxis[s]);
    }), e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories), t.config.xaxis.convertedCatToNumeric) {
      var i = new Ci(e);
      e = i.convertCatToNumericXaxis(e, this.ctx);
    }
    return e;
  } }, { key: "forceYAxisUpdate", value: function(e) {
    return e.chart && e.chart.stacked && e.chart.stackType === "100%" && (Array.isArray(e.yaxis) ? e.yaxis.forEach(function(t, i) {
      e.yaxis[i].min = 0, e.yaxis[i].max = 100;
    }) : (e.yaxis.min = 0, e.yaxis.max = 100)), e;
  } }, { key: "revertDefaultAxisMinMax", value: function(e) {
    var t = this, i = this.w, s = i.globals.lastXAxis, a = i.globals.lastYAxis;
    e && e.xaxis && (s = e.xaxis), e && e.yaxis && (a = e.yaxis), i.config.xaxis.min = s.min, i.config.xaxis.max = s.max;
    var n = function(o) {
      a[o] !== void 0 && (i.config.yaxis[o].min = a[o].min, i.config.yaxis[o].max = a[o].max);
    };
    i.config.yaxis.map(function(o, l) {
      i.globals.zoomed || a[l] !== void 0 ? n(l) : t.ctx.opts.yaxis[l] !== void 0 && (o.min = t.ctx.opts.yaxis[l].min, o.max = t.ctx.opts.yaxis[l].max);
    });
  } }]), r;
}();
(function() {
  function r() {
    for (var a = arguments.length > 0 && arguments[0] !== d ? arguments[0] : [], n = arguments.length > 1 ? arguments[1] : d, o = arguments.length > 2 ? arguments[2] : d, l = arguments.length > 3 ? arguments[3] : d, c = arguments.length > 4 ? arguments[4] : d, h = arguments.length > 5 ? arguments[5] : d, d = arguments.length > 6 ? arguments[6] : d, u = a.slice(n, o || d), g = l.slice(c, h || d), p = 0, f = { pos: [0, 0], start: [0, 0] }, x = { pos: [0, 0], start: [0, 0] }; u[p] = e.call(f, u[p]), g[p] = e.call(x, g[p]), u[p][0] != g[p][0] || u[p][0] == "M" || u[p][0] == "A" && (u[p][4] != g[p][4] || u[p][5] != g[p][5]) ? (Array.prototype.splice.apply(u, [p, 1].concat(i.call(f, u[p]))), Array.prototype.splice.apply(g, [p, 1].concat(i.call(x, g[p])))) : (u[p] = t.call(f, u[p]), g[p] = t.call(x, g[p])), !(++p == u.length && p == g.length); )
      p == u.length && u.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]), p == g.length && g.push(["C", x.pos[0], x.pos[1], x.pos[0], x.pos[1], x.pos[0], x.pos[1]]);
    return { start: u, dest: g };
  }
  function e(a) {
    switch (a[0]) {
      case "z":
      case "Z":
        a[0] = "L", a[1] = this.start[0], a[2] = this.start[1];
        break;
      case "H":
        a[0] = "L", a[2] = this.pos[1];
        break;
      case "V":
        a[0] = "L", a[2] = a[1], a[1] = this.pos[0];
        break;
      case "T":
        a[0] = "Q", a[3] = a[1], a[4] = a[2], a[1] = this.reflection[1], a[2] = this.reflection[0];
        break;
      case "S":
        a[0] = "C", a[6] = a[4], a[5] = a[3], a[4] = a[2], a[3] = a[1], a[2] = this.reflection[1], a[1] = this.reflection[0];
    }
    return a;
  }
  function t(a) {
    var n = a.length;
    return this.pos = [a[n - 2], a[n - 1]], "SCQT".indexOf(a[0]) != -1 && (this.reflection = [2 * this.pos[0] - a[n - 4], 2 * this.pos[1] - a[n - 3]]), a;
  }
  function i(a) {
    var n = [a];
    switch (a[0]) {
      case "M":
        return this.pos = this.start = [a[1], a[2]], n;
      case "L":
        a[5] = a[3] = a[1], a[6] = a[4] = a[2], a[1] = this.pos[0], a[2] = this.pos[1];
        break;
      case "Q":
        a[6] = a[4], a[5] = a[3], a[4] = 1 * a[4] / 3 + 2 * a[2] / 3, a[3] = 1 * a[3] / 3 + 2 * a[1] / 3, a[2] = 1 * this.pos[1] / 3 + 2 * a[2] / 3, a[1] = 1 * this.pos[0] / 3 + 2 * a[1] / 3;
        break;
      case "A":
        n = function(o, l) {
          var c, h, d, u, g, p, f, x, m, b, w, y, v, S, k, C, R, P, A, E, N, O, L, I, F, D, Y = Math.abs(l[1]), _ = Math.abs(l[2]), H = l[3] % 360, V = l[4], Z = l[5], X = l[6], J = l[7], G = new ye(o), $ = new ye(X, J), K = [];
          if (Y === 0 || _ === 0 || G.x === $.x && G.y === $.y) return [["C", G.x, G.y, $.x, $.y, $.x, $.y]];
          for (c = new ye((G.x - $.x) / 2, (G.y - $.y) / 2).transform(new ne().rotate(H)), h = c.x * c.x / (Y * Y) + c.y * c.y / (_ * _), h > 1 && (Y *= h = Math.sqrt(h), _ *= h), d = new ne().rotate(H).scale(1 / Y, 1 / _).rotate(-H), G = G.transform(d), $ = $.transform(d), u = [$.x - G.x, $.y - G.y], p = u[0] * u[0] + u[1] * u[1], g = Math.sqrt(p), u[0] /= g, u[1] /= g, f = p < 4 ? Math.sqrt(1 - p / 4) : 0, V === Z && (f *= -1), x = new ye(($.x + G.x) / 2 + f * -u[1], ($.y + G.y) / 2 + f * u[0]), m = new ye(G.x - x.x, G.y - x.y), b = new ye($.x - x.x, $.y - x.y), w = Math.acos(m.x / Math.sqrt(m.x * m.x + m.y * m.y)), m.y < 0 && (w *= -1), y = Math.acos(b.x / Math.sqrt(b.x * b.x + b.y * b.y)), b.y < 0 && (y *= -1), Z && w > y && (y += 2 * Math.PI), !Z && w < y && (y -= 2 * Math.PI), S = Math.ceil(2 * Math.abs(w - y) / Math.PI), C = [], R = w, v = (y - w) / S, k = 4 * Math.tan(v / 4) / 3, N = 0; N <= S; N++) A = Math.cos(R), P = Math.sin(R), E = new ye(x.x + A, x.y + P), C[N] = [new ye(E.x + k * P, E.y - k * A), E, new ye(E.x - k * P, E.y + k * A)], R += v;
          for (C[0][0] = C[0][1].clone(), C[C.length - 1][2] = C[C.length - 1][1].clone(), d = new ne().rotate(H).scale(Y, _).rotate(-H), N = 0, O = C.length; N < O; N++) C[N][0] = C[N][0].transform(d), C[N][1] = C[N][1].transform(d), C[N][2] = C[N][2].transform(d);
          for (N = 1, O = C.length; N < O; N++) L = (E = C[N - 1][2]).x, I = E.y, F = (E = C[N][0]).x, D = E.y, X = (E = C[N][1]).x, J = E.y, K.push(["C", L, I, F, D, X, J]);
          return K;
        }(this.pos, a), a = n[0];
    }
    return a[0] = "C", this.pos = [a[5], a[6]], this.reflection = [2 * a[5] - a[3], 2 * a[6] - a[4]], n;
  }
  function s() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 ? arguments[1] : void 0;
    if (n === !1) return !1;
    for (var o = n, l = a.length; o < l; ++o) if (a[o][0] == "M") return o;
    return !1;
  }
  oe(lt, { morph: function(a, n, o, l, c) {
    for (var h = this.parse(a), d = this.parse(n), u = 0, g = 0, p = !1, f = !1; u !== !1 || g !== !1; ) {
      var x;
      p = s(h, u !== !1 && u + 1), f = s(d, g !== !1 && g + 1), u === !1 && (u = (x = new lt(m.start).bbox()).height == 0 || x.width == 0 ? h.push(h[0]) - 1 : h.push(["M", x.x + x.width / 2, x.y + x.height / 2]) - 1), g === !1 && (g = (x = new lt(m.dest).bbox()).height == 0 || x.width == 0 ? d.push(d[0]) - 1 : d.push(["M", x.x + x.width / 2, x.y + x.height / 2]) - 1);
      var m = r(h, u, p, d, g, f);
      h = h.slice(0, u).concat(m.start, p === !1 ? [] : h.slice(p)), d = d.slice(0, g).concat(m.dest, f === !1 ? [] : d.slice(f)), u = p !== !1 && u + m.start.length, g = f !== !1 && g + m.dest.length;
    }
    this._array = h, this.destination = new lt(), this.destination._array = d;
    var b = this.fromArray(h.map(function(w, y) {
      var v = d[y].map(function(S, k) {
        return k === 0 ? S : l.step(w[k], d[y][k], o, c[y], c);
      });
      return v;
    }));
    return b;
  } });
})();
const qa = (r) => (r.changedTouches && (r = r.changedTouches[0]), { x: r.clientX, y: r.clientY });
class Rd {
  constructor(e) {
    e.remember("_draggable", this), this.el = e, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(e) {
    e ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: !1 })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
  }
  startDrag(e) {
    const t = !e.type.indexOf("mouse");
    if (t && e.which !== 1 && e.buttons !== 0 || this.el.dispatch("beforedrag", { event: e, handler: this }).defaultPrevented) return;
    e.preventDefault(), e.stopPropagation(), this.init(!1), this.box = this.el.bbox(), this.lastClick = this.el.point(qa(e));
    const i = (t ? "mouseup" : "touchend") + ".drag";
    bt(window, (t ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: !1 }), bt(window, i, this.endDrag, this, { passive: !1 }), this.el.fire("dragstart", { event: e, handler: this, box: this.box });
  }
  drag(e) {
    const { box: t, lastClick: i } = this, s = this.el.point(qa(e)), a = s.x - i.x, n = s.y - i.y;
    if (!a && !n) return t;
    const o = t.x + a, l = t.y + n;
    this.box = new Oe(o, l, t.w, t.h), this.lastClick = s, this.el.dispatch("dragmove", { event: e, handler: this, box: this.box }).defaultPrevented || this.move(o, l);
  }
  move(e, t) {
    this.el.type === "svg" ? At.prototype.move.call(this.el, e, t) : this.el.move(e, t);
  }
  endDrag(e) {
    this.drag(e), this.el.fire("dragend", { event: e, handler: this, box: this.box }), nt(window, "mousemove.drag"), nt(window, "touchmove.drag"), nt(window, "mouseup.drag"), nt(window, "touchend.drag"), this.init(!0);
  }
}
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function yr(r, e, t, i = null) {
  return function(s) {
    s.preventDefault(), s.stopPropagation();
    var a = s.pageX || s.touches[0].pageX, n = s.pageY || s.touches[0].pageY;
    e.fire(r, { x: a, y: n, event: s, index: i, points: t });
  };
}
function wr([r, e], { a: t, b: i, c: s, d: a, e: n, f: o }) {
  return [r * t + e * s + n, r * i + e * a + o];
}
oe(Be, { draggable(r = !0) {
  return (this.remember("_draggable") || new Rd(this)).init(r), this;
} });
let _o = class {
  constructor(r) {
    this.el = r, r.remember("_selectHandler", this), this.selection = new At(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = Li();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(r) {
    this.createHandle = r.createHandle || this.createHandleFn, this.createRot = r.createRot || this.createRotFn, this.updateHandle = r.updateHandle || this.updateHandleFn, this.updateRot = r.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(r, e) {
    if (!r) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((r, e, t) => {
      const i = this.order[e];
      this.createHandle.call(this, this.selection, r, e, t, i), this.selection.get(e + 1).addClass("svg_select_handle svg_select_handle_" + i).on("mousedown.selection touchstart.selection", yr(i, this.el, this.handlePoints, e));
    });
  }
  createHandleFn(r) {
    r.polyline();
  }
  updateHandleFn(r, e, t, i) {
    const s = i.at(t - 1), a = i[(t + 1) % i.length], n = e, o = [n[0] - s[0], n[1] - s[1]], l = [n[0] - a[0], n[1] - a[1]], c = Math.sqrt(o[0] * o[0] + o[1] * o[1]), h = Math.sqrt(l[0] * l[0] + l[1] * l[1]), d = [o[0] / c, o[1] / c], u = [l[0] / h, l[1] / h], g = [n[0] - 10 * d[0], n[1] - 10 * d[1]], p = [n[0] - 10 * u[0], n[1] - 10 * u[1]];
    r.plot([g, n, p]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((r, e, t) => {
      const i = this.order[e];
      this.updateHandle.call(this, this.selection.get(e + 1), r, e, t, i);
    });
  }
  createRotFn(r) {
    r.line(), r.circle(5);
  }
  getPoint(r) {
    return this.handlePoints[this.order.indexOf(r)];
  }
  getPointHandle(r) {
    return this.selection.get(this.order.indexOf(r) + 1);
  }
  updateRotFn(r, e) {
    const t = this.getPoint("t");
    r.get(0).plot(t[0], t[1], e[0], e[1]), r.get(1).center(e[0], e[1]);
  }
  createRotationHandle() {
    const r = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", yr("rot", this.el, this.handlePoints));
    this.createRot.call(this, r);
  }
  updateRotationHandle() {
    const r = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(r, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const r = this.el.bbox(), e = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(r).map((t) => wr(t, e)), this.rotationPoint = wr(this.getRotationPoint(r), e);
  }
  getHandlePoints({ x: r, x2: e, y: t, y2: i, cx: s, cy: a } = this.el.bbox()) {
    return [[r, t], [s, t], [e, t], [e, a], [e, i], [s, i], [r, i], [r, a]];
  }
  getRotationPoint({ y: r, cx: e } = this.el.bbox()) {
    return [e, r - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
const Za = (r) => function(e = !0, t = {}) {
  typeof e == "object" && (t = e, e = !0);
  let i = this.remember("_" + r.name);
  return i || (e.prototype instanceof _o ? (i = new e(this), e = !0) : i = new r(this), this.remember("_" + r.name, i)), i.active(e, t), this;
};
/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Sr(r, e, t, i = null) {
  return function(s) {
    s.preventDefault(), s.stopPropagation();
    var a = s.pageX || s.touches[0].pageX, n = s.pageY || s.touches[0].pageY;
    e.fire(r, { x: a, y: n, event: s, index: i, points: t });
  };
}
function kr([r, e], { a: t, b: i, c: s, d: a, e: n, f: o }) {
  return [r * t + e * s + n, r * i + e * a + o];
}
oe(Be, { select: Za(_o) }), oe([zt, Ft, Ot], { pointSelect: Za(class {
  constructor(r) {
    this.el = r, r.remember("_pointSelectHandler", this), this.selection = new At(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = Li();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(r) {
    this.createHandle = r.createHandle || this.createHandleFn, this.updateHandle = r.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(r, e) {
    if (!r) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((r, e, t) => {
      this.createHandle.call(this, this.selection, r, e, t), this.selection.get(e + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", yr("point", this.el, this.points, e));
    });
  }
  createHandleFn(r) {
    r.circle(5);
  }
  updateHandleFn(r, e) {
    r.center(e[0], e[1]);
  }
  updatePointHandles() {
    this.points.forEach((r, e, t) => {
      this.updateHandle.call(this, this.selection.get(e + 1), r, e, t);
    });
  }
  updatePoints() {
    const r = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e) => wr(e, r));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
class Oo {
  constructor(e) {
    this.el = e, e.remember("_selectHandler", this), this.selection = new At(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const t = Li();
    this.observer = new t.MutationObserver(this.mutationHandler);
  }
  init(e) {
    this.createHandle = e.createHandle || this.createHandleFn, this.createRot = e.createRot || this.createRotFn, this.updateHandle = e.updateHandle || this.updateHandleFn, this.updateRot = e.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(e, t) {
    if (!e) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(t);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((e, t, i) => {
      const s = this.order[t];
      this.createHandle.call(this, this.selection, e, t, i, s), this.selection.get(t + 1).addClass("svg_select_handle svg_select_handle_" + s).on("mousedown.selection touchstart.selection", Sr(s, this.el, this.handlePoints, t));
    });
  }
  createHandleFn(e) {
    e.polyline();
  }
  updateHandleFn(e, t, i, s) {
    const a = s.at(i - 1), n = s[(i + 1) % s.length], o = t, l = [o[0] - a[0], o[1] - a[1]], c = [o[0] - n[0], o[1] - n[1]], h = Math.sqrt(l[0] * l[0] + l[1] * l[1]), d = Math.sqrt(c[0] * c[0] + c[1] * c[1]), u = [l[0] / h, l[1] / h], g = [c[0] / d, c[1] / d], p = [o[0] - 10 * u[0], o[1] - 10 * u[1]], f = [o[0] - 10 * g[0], o[1] - 10 * g[1]];
    e.plot([p, o, f]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((e, t, i) => {
      const s = this.order[t];
      this.updateHandle.call(this, this.selection.get(t + 1), e, t, i, s);
    });
  }
  createRotFn(e) {
    e.line(), e.circle(5);
  }
  getPoint(e) {
    return this.handlePoints[this.order.indexOf(e)];
  }
  getPointHandle(e) {
    return this.selection.get(this.order.indexOf(e) + 1);
  }
  updateRotFn(e, t) {
    const i = this.getPoint("t");
    e.get(0).plot(i[0], i[1], t[0], t[1]), e.get(1).center(t[0], t[1]);
  }
  createRotationHandle() {
    const e = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Sr("rot", this.el, this.handlePoints));
    this.createRot.call(this, e);
  }
  updateRotationHandle() {
    const e = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(e, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const e = this.el.bbox(), t = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(e).map((i) => kr(i, t)), this.rotationPoint = kr(this.getRotationPoint(e), t);
  }
  getHandlePoints({ x: e, x2: t, y: i, y2: s, cx: a, cy: n } = this.el.bbox()) {
    return [[e, i], [a, i], [t, i], [t, n], [t, s], [a, s], [e, s], [e, n]];
  }
  getRotationPoint({ y: e, cx: t } = this.el.bbox()) {
    return [t, e - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
}
const Ja = (r) => function(e = !0, t = {}) {
  typeof e == "object" && (t = e, e = !0);
  let i = this.remember("_" + r.name);
  return i || (e.prototype instanceof Oo ? (i = new e(this), e = !0) : i = new r(this), this.remember("_" + r.name, i)), i.active(e, t), this;
};
oe(Be, { select: Ja(Oo) }), oe([zt, Ft, Ot], { pointSelect: Ja(class {
  constructor(r) {
    this.el = r, r.remember("_pointSelectHandler", this), this.selection = new At(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = Li();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(r) {
    this.createHandle = r.createHandle || this.createHandleFn, this.updateHandle = r.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(r, e) {
    if (!r) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((r, e, t) => {
      this.createHandle.call(this, this.selection, r, e, t), this.selection.get(e + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Sr("point", this.el, this.points, e));
    });
  }
  createHandleFn(r) {
    r.circle(5);
  }
  updateHandleFn(r, e) {
    r.center(e[0], e[1]);
  }
  updatePointHandles() {
    this.points.forEach((r, e, t) => {
      this.updateHandle.call(this, this.selection.get(e + 1), r, e, t);
    });
  }
  updatePoints() {
    const r = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e) => kr(e, r));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
const Ni = (r) => (r.changedTouches && (r = r.changedTouches[0]), { x: r.clientX, y: r.clientY }), Ka = (r) => {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, s = -1 / 0;
  for (let a = 0; a < r.length; a++) {
    const n = r[a];
    e = Math.min(e, n[0]), t = Math.min(t, n[1]), i = Math.max(i, n[0]), s = Math.max(s, n[1]);
  }
  return new Oe(e, t, i - e, s - t);
};
class Qa {
  constructor(e) {
    this.el = e, e.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(e, t) {
    this.preserveAspectRatio = t.preserveAspectRatio ?? !1, this.aroundCenter = t.aroundCenter ?? !1, this.grid = t.grid ?? 0, this.degree = t.degree ?? 0, this.el.off(".resize"), e && (this.el.on(["lt.resize", "rt.resize", "rb.resize", "lb.resize", "t.resize", "r.resize", "b.resize", "l.resize", "rot.resize", "point.resize"], this.handleResize), this.lastEvent && (this.eventType === "rot" ? this.rotate(this.lastEvent) : this.eventType === "point" ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(e) {
    this.eventType = e.type;
    const { event: t, index: i, points: s } = e.detail, a = !t.type.indexOf("mouse");
    if (a && (t.which || t.buttons) !== 1 || this.el.dispatch("beforeresize", { event: e, handler: this }).defaultPrevented) return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(Ni(t)), this.index = i, this.points = s.slice();
    const n = (a ? "mousemove" : "touchmove") + ".resize", o = (a ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    e.type === "point" ? bt(window, n, this.movePoint) : e.type === "rot" ? bt(window, n, this.rotate) : bt(window, n, this.resize), bt(window, o, this.endResize);
  }
  resize(e) {
    this.lastEvent = e;
    const t = this.snapToGrid(this.el.point(Ni(e)));
    let i = t.x - this.startPoint.x, s = t.y - this.startPoint.y;
    this.preserveAspectRatio && this.aroundCenter && (i *= 2, s *= 2);
    const a = this.box.x + i, n = this.box.y + s, o = this.box.x2 + i, l = this.box.y2 + s;
    let c = new Oe(this.box);
    if (this.eventType.includes("l") && (c.x = Math.min(a, this.box.x2), c.x2 = Math.max(a, this.box.x2)), this.eventType.includes("r") && (c.x = Math.min(o, this.box.x), c.x2 = Math.max(o, this.box.x)), this.eventType.includes("t") && (c.y = Math.min(n, this.box.y2), c.y2 = Math.max(n, this.box.y2)), this.eventType.includes("b") && (c.y = Math.min(l, this.box.y), c.y2 = Math.max(l, this.box.y)), c.width = c.x2 - c.x, c.height = c.y2 - c.y, this.preserveAspectRatio) {
      const h = c.width / this.box.width, d = c.height / this.box.height, u = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"], g = (u.indexOf(this.eventType) + 4) % u.length, p = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[g];
      let f = this.eventType.includes("t") || this.eventType.includes("b") ? d : h;
      f = this.eventType.length === 2 ? Math.max(h, d) : f, c = function(x, m, b) {
        const w = [[x.x, x.y], [x.x + x.width, x.y], [x.x + x.width, x.y + x.height], [x.x, x.y + x.height]].map(([y, v]) => {
          const S = y - m[0], k = (v - m[1]) * b;
          return [S * b + m[0], k + m[1]];
        });
        return Ka(w);
      }(this.box, p, f);
    }
    this.el.dispatch("resize", { box: new Oe(c), angle: 0, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.size(c.width, c.height).move(c.x, c.y);
  }
  movePoint(e) {
    this.lastEvent = e;
    const { x: t, y: i } = this.snapToGrid(this.el.point(Ni(e))), s = this.el.array().slice();
    s[this.index] = [t, i], this.el.dispatch("resize", { box: Ka(s), angle: 0, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.plot(s);
  }
  rotate(e) {
    this.lastEvent = e;
    const t = this.startPoint, i = this.el.point(Ni(e)), { cx: s, cy: a } = this.box, n = t.x - s, o = t.y - a, l = i.x - s, c = i.y - a, h = Math.sqrt(n * n + o * o) * Math.sqrt(l * l + c * c);
    if (h === 0) return;
    let d = Math.acos((n * l + o * c) / h) / Math.PI * 180;
    if (!d) return;
    i.x < t.x && (d = -d);
    const u = new ne(this.el), { x: g, y: p } = new ye(s, a).transformO(u), { rotate: f } = u.decompose(), x = this.snapToAngle(f + d) - f;
    this.el.dispatch("resize", { box: this.box, angle: x, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.transform(u.rotateO(x, g, p));
  }
  endResize(e) {
    this.eventType !== "rot" && this.eventType !== "point" && this.resize(e), this.lastEvent = null, this.eventType = "", nt(window, "mousemove.resize touchmove.resize"), nt(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(e) {
    return this.grid && (e.x = Math.round(e.x / this.grid) * this.grid, e.y = Math.round(e.y / this.grid) * this.grid), e;
  }
  snapToAngle(e) {
    return this.degree && (e = Math.round(e / this.degree) * this.degree), e;
  }
}
oe(Be, { resize: function(r = !0, e = {}) {
  typeof r == "object" && (e = r, r = !0);
  let t = this.remember("_ResizeHandler");
  return t || (r.prototype instanceof Qa ? (t = new r(this), r = !0) : t = new Qa(this), this.remember("_resizeHandler", t)), t.active(r, e), this;
} }), window.SVG === void 0 && (window.SVG = Xh), window.Apex === void 0 && (window.Apex = {});
var en = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "initModules", value: function() {
    this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new ti(this.ctx), this.ctx.axes = new Kh(this.ctx), this.ctx.core = new Ad(this.ctx.el, this.ctx), this.ctx.config = new Ai({}), this.ctx.data = new Zr(this.ctx), this.ctx.grid = new ko(this.ctx), this.ctx.graphics = new B(this.ctx), this.ctx.coreUtils = new ze(this.ctx), this.ctx.crosshairs = new vr(this.ctx), this.ctx.events = new Zh(this.ctx), this.ctx.exports = new mi(this.ctx), this.ctx.fill = new ht(this.ctx), this.ctx.localization = new Jh(this.ctx), this.ctx.options = new _t(), this.ctx.responsive = new Qh(this.ctx), this.ctx.series = new ot(this.ctx), this.ctx.theme = new ed(this.ctx), this.ctx.formatters = new Ti(this.ctx), this.ctx.titleSubtitle = new td(this.ctx), this.ctx.legend = new Ao(this.ctx), this.ctx.toolbar = new Mo(this.ctx), this.ctx.tooltip = new $a(this.ctx), this.ctx.dimensions = new es(this.ctx), this.ctx.updateHelpers = new Md(this.ctx), this.ctx.zoomPanSelection = new od(this.ctx), this.ctx.w.globals.tooltip = new $a(this.ctx);
  } }]), r;
}(), tn = function() {
  function r(e) {
    ee(this, r), this.ctx = e, this.w = e.w;
  }
  return te(r, [{ key: "clear", value: function(e) {
    var t = e.isUpdating;
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: t });
  } }, { key: "killSVG", value: function(e) {
    e.each(function() {
      this.removeClass("*"), this.off();
    }, !0), e.clear();
  } }, { key: "clearDomElements", value: function(e) {
    var t = this, i = e.isUpdating, s = this.w.globals.dom.Paper.node;
    s.parentNode && s.parentNode.parentNode && !i && (s.parentNode.parentNode.style.minHeight = "unset");
    var a = this.w.globals.dom.baseEl;
    a && this.ctx.eventList.forEach(function(o) {
      a.removeEventListener(o, t.ctx.events.documentEvent);
    });
    var n = this.w.globals.dom;
    if (this.ctx.el !== null) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(n.Paper), n.Paper.remove(), n.elWrap = null, n.elGraphical = null, n.elLegendWrap = null, n.elLegendForeign = null, n.baseEl = null, n.elGridRect = null, n.elGridRectMask = null, n.elGridRectBarMask = null, n.elGridRectMarkerMask = null, n.elForecastMask = null, n.elNonForecastMask = null, n.elDefs = null;
  } }]), r;
}(), Os = /* @__PURE__ */ new WeakMap(), Pd = function() {
  function r(e, t) {
    ee(this, r), this.opts = t, this.ctx = this, this.w = new qh(t).init(), this.el = e, this.w.globals.cuid = z.randomId(), this.w.globals.chartID = this.w.config.chart.id ? z.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new en(this).initModules(), this.lastUpdateOptions = null, this.create = z.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return te(r, [{ key: "render", value: function() {
    var e = this;
    return new Promise(function(t, i) {
      if (z.elementExists(e.el)) {
        Apex._chartInstances === void 0 && (Apex._chartInstances = []), e.w.config.chart.id && Apex._chartInstances.push({ id: e.w.globals.chartID, group: e.w.config.chart.group, chart: e }), e.setLocale(e.w.config.chart.defaultLocale);
        var s = e.w.config.chart.events.beforeMount;
        typeof s == "function" && s(e, e.w), e.events.fireEvent("beforeMount", [e, e.w]), window.addEventListener("resize", e.windowResizeHandler), function(u, g) {
          var p = !1;
          if (u.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var f = u.getBoundingClientRect();
            u.style.display !== "none" && f.width !== 0 || (p = !0);
          }
          var x = new ResizeObserver(function(m) {
            p && g.call(u, m), p = !0;
          });
          u.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(u.children).forEach(function(m) {
            return x.observe(m);
          }) : x.observe(u), Os.set(g, x);
        }(e.el.parentNode, e.parentResizeHandler);
        var a = e.el.getRootNode && e.el.getRootNode(), n = z.is("ShadowRoot", a), o = e.el.ownerDocument, l = n ? a.getElementById("apexcharts-css") : o.getElementById("apexcharts-css");
        if (!l) {
          var c;
          (l = document.createElement("style")).id = "apexcharts-css", l.textContent = `@keyframes opaque {
  0% {
    opacity: 0
  }

  to {
    opacity: 1
  }
}

@keyframes resizeanim {

  0%,
  to {
    opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  direction: ltr !important;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0, 0, 0, .5);
  box-shadow: 0 0 1px rgba(255, 255, 255, .5);
  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

rect.legend-mouseover-inactive,
.legend-mouseover-inactive rect,
.legend-mouseover-inactive path,
.legend-mouseover-inactive circle,
.legend-mouseover-inactive line,
.legend-mouseover-inactive text.apexcharts-yaxis-title-text,
.legend-mouseover-inactive text.apexcharts-yaxis-label {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255, 255, 255, .96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30, 30, 30, .8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0, 0, 0, .7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,
.apexcharts-tooltip-text-y-value,
.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,
.apexcharts-tooltip-text-goals-value:empty,
.apexcharts-tooltip-text-y-label:empty,
.apexcharts-tooltip-text-y-value:empty,
.apexcharts-tooltip-text-z-value:empty,
.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,
.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,
.apexcharts-tooltip-text-goals-label,
.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),
.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  display: inline-block;
  position: relative;
  width: 16px;
  height: 16px;
  font-size: 16px;
  line-height: 16px;
  margin-right: 4px;
  text-align: center;
  vertical-align: middle;
  color: inherit;
}

.apexcharts-tooltip-marker::before {
  content: "";
  display: inline-block;
  width: 100%;
  text-align: center;
  color: currentcolor;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  font-size: 26px;
  font-family: Arial, Helvetica, sans-serif;
  line-height: 14px;
  font-weight: 900;
}

.apexcharts-tooltip-marker[shape="circle"]::before {
  content: "\\25CF";
}

.apexcharts-tooltip-marker[shape="square"]::before,
.apexcharts-tooltip-marker[shape="rect"]::before {
  content: "\\25A0";
  transform: translate(-1px, -2px);
}

.apexcharts-tooltip-marker[shape="line"]::before {
  content: "\\2500";
}

.apexcharts-tooltip-marker[shape="diamond"]::before {
  content: "\\25C6";
  font-size: 28px;
}

.apexcharts-tooltip-marker[shape="triangle"]::before {
  content: "\\25B2";
  font-size: 22px;
}

.apexcharts-tooltip-marker[shape="cross"]::before {
  content: "\\2715";
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="plus"]::before {
  content: "\\2715";
  transform: rotate(45deg) translate(-1px, -1px);
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="star"]::before {
  content: "\\2605";
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="sparkle"]::before {
  content: "\\2726";
  font-size: 20px;
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,
.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,
.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,
.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0, 0, 0, .7);
  border: 1px solid rgba(0, 0, 0, .5);
  color: #fff
}

.apexcharts-xaxistooltip:after,
.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,
.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,
.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,
.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0, 0, 0, .5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,
.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0, 0, 0, .5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0, 0, 0, .7);
  border: 1px solid rgba(0, 0, 0, .5);
  color: #fff
}

.apexcharts-yaxistooltip:after,
.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,
.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,
.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,
.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0, 0, 0, .5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,
.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0, 0, 0, .5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,
.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,
.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_shape {
  stroke-width: 1;
  stroke-dasharray: 10 10;
  stroke: black;
  stroke-opacity: 0.1;
  pointer-events: none;
  fill: none;
}

.svg_select_handle {
  stroke-width: 3;
  stroke: black;
  fill: none;
}

.svg_select_handle_r {
  cursor: e-resize;
}

.svg_select_handle_l {
  cursor: w-resize;
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,
.apexcharts-pan-icon,
.apexcharts-reset-icon,
.apexcharts-selection-icon,
.apexcharts-toolbar-custom-icon,
.apexcharts-zoom-icon,
.apexcharts-zoomin-icon,
.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,
.apexcharts-reset-icon svg,
.apexcharts-zoom-icon svg,
.apexcharts-zoomin-icon svg,
.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,
.apexcharts-theme-dark .apexcharts-pan-icon svg,
.apexcharts-theme-dark .apexcharts-reset-icon svg,
.apexcharts-theme-dark .apexcharts-selection-icon svg,
.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,
.apexcharts-theme-dark .apexcharts-zoom-icon svg,
.apexcharts-theme-dark .apexcharts-zoomin-icon svg,
.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,
.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,
.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,
.apexcharts-theme-light .apexcharts-reset-icon:hover svg,
.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,
.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,
.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,
.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,
.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,
.apexcharts-reset-icon,
.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,
.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0, 0, 0, .7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
    opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,
.apexcharts-datalabel.apexcharts-element-hidden,
.apexcharts-hide .apexcharts-series-points {
  opacity: 0;
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}

.apexcharts-datalabel,
.apexcharts-datalabel-label,
.apexcharts-datalabel-value,
.apexcharts-datalabels,
.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-radialbar-label {
  cursor: pointer;
}

.apexcharts-annotation-rect,
.apexcharts-area-series .apexcharts-area,
.apexcharts-gridline,
.apexcharts-line,
.apexcharts-point-annotation-label,
.apexcharts-radar-series path:not(.apexcharts-marker),
.apexcharts-radar-series polygon,
.apexcharts-toolbar svg,
.apexcharts-tooltip .apexcharts-marker,
.apexcharts-xaxis-annotation-label,
.apexcharts-yaxis-annotation-label,
.apexcharts-zoom-rect,
.no-pointer-events {
  pointer-events: none
}

.apexcharts-tooltip-active .apexcharts-marker {
  transition: .15s ease all
}

.apexcharts-radar-series .apexcharts-yaxis {
  pointer-events: none;
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,
.resize-triggers,
.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers {
  pointer-events: none
}

.apexcharts-bar-shadows {
  pointer-events: none
}

.apexcharts-rangebar-goals-markers {
  pointer-events: none
}

.apexcharts-disable-transitions * {
  transition: none !important;
}`;
          var h = ((c = e.opts.chart) === null || c === void 0 ? void 0 : c.nonce) || e.w.config.chart.nonce;
          h && l.setAttribute("nonce", h), n ? a.prepend(l) : o.head.appendChild(l);
        }
        var d = e.create(e.w.config.series, {});
        if (!d) return t(e);
        e.mount(d).then(function() {
          typeof e.w.config.chart.events.mounted == "function" && e.w.config.chart.events.mounted(e, e.w), e.events.fireEvent("mounted", [e, e.w]), t(d);
        }).catch(function(u) {
          i(u);
        });
      } else i(new Error("Element not found"));
    });
  } }, { key: "create", value: function(e, t) {
    var i = this, s = this.w;
    new en(this).initModules();
    var a = this.w.globals;
    if (a.noData = !1, a.animationEnded = !1, !z.elementExists(this.el) || (this.responsive.checkResponsiveConfig(t), s.config.xaxis.convertedCatToNumeric && new Ci(s.config).convertCatToNumericXaxis(s.config, this.ctx), this.core.setupElements(), s.config.chart.type === "treemap" && (s.config.grid.show = !1, s.config.yaxis[0].show = !1), a.svgWidth === 0)) return a.animationEnded = !0, null;
    var n = e;
    e.forEach(function(u, g) {
      u.hidden && (n = i.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: g }));
    });
    var o = ze.checkComboSeries(n, s.config.chart.type);
    a.comboCharts = o.comboCharts, a.comboBarCount = o.comboBarCount;
    var l = n.every(function(u) {
      return u.data && u.data.length === 0;
    });
    (n.length === 0 || l && a.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(n), this.theme.init(), new ai(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length && !s.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), s.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = s.globals.minX, this.ctx.toolbar.maxX = s.globals.maxX), this.formatters.heatmapLabelFormatters(), new ze(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var c = this.core.xySettings();
    this.grid.createGridMask();
    var h = this.core.plotChartType(n, c), d = new Jt(this);
    return d.bringForward(), s.config.dataLabels.background.enabled && d.dataLabelsBackground(), this.core.shiftGraphPosition(), s.globals.dataPoints > 50 && s.globals.dom.elWrap.classList.add("apexcharts-disable-transitions"), { elGraph: h, xyRatios: c, dimensions: { plot: { left: s.globals.translateX, top: s.globals.translateY, width: s.globals.gridWidth, height: s.globals.gridHeight } } };
  } }, { key: "mount", value: function() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i = this, s = i.w;
    return new Promise(function(a, n) {
      if (i.el === null) return n(new Error("Not enough data to display or target element not found"));
      (t === null || s.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new ko(i);
      var o, l, c = i.grid.drawGrid();
      if (i.annotations = new Uh(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), s.config.grid.position === "back" && (c && s.globals.dom.elGraphical.add(c.el), c != null && (o = c.elGridBorders) !== null && o !== void 0 && o.node && s.globals.dom.elGraphical.add(c.elGridBorders)), Array.isArray(t.elGraph)) for (var h = 0; h < t.elGraph.length; h++) s.globals.dom.elGraphical.add(t.elGraph[h]);
      else s.globals.dom.elGraphical.add(t.elGraph);
      s.config.grid.position === "front" && (c && s.globals.dom.elGraphical.add(c.el), c != null && (l = c.elGridBorders) !== null && l !== void 0 && l.node && s.globals.dom.elGraphical.add(c.elGridBorders)), s.config.xaxis.crosshairs.position === "front" && i.crosshairs.drawXCrosshairs(), s.config.yaxis[0].crosshairs.position === "front" && i.crosshairs.drawYCrosshairs(), s.config.chart.type !== "treemap" && i.axes.drawAxis(s.config.chart.type, c);
      var d = new Mi(e.ctx, c), u = new Jr(e.ctx, c);
      if (c !== null && (d.xAxisLabelCorrections(c.xAxisTickWidth), u.setYAxisTextAlignments(), s.config.yaxis.map(function(p, f) {
        s.globals.ignoreYAxisIndexes.indexOf(f) === -1 && u.yAxisTitleRotate(f, p.opposite);
      })), i.annotations.drawAxesAnnotations(), !s.globals.noData) {
        if (s.config.tooltip.enabled && !s.globals.noData && i.w.globals.tooltip.drawTooltip(t.xyRatios), s.globals.axisCharts && (s.globals.isXNumeric || s.config.xaxis.convertedCatToNumeric || s.globals.isRangeBar)) (s.config.chart.zoom.enabled || s.config.chart.selection && s.config.chart.selection.enabled || s.config.chart.pan && s.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: t.xyRatios });
        else {
          var g = s.config.chart.toolbar.tools;
          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(p) {
            g[p] = !1;
          });
        }
        s.config.chart.toolbar.show && !s.globals.allSeriesCollapsed && i.toolbar.createToolbar();
      }
      s.globals.memory.methodsToExec.length > 0 && s.globals.memory.methodsToExec.forEach(function(p) {
        p.method(p.params, !1, p.context);
      }), s.globals.axisCharts || s.globals.noData || i.core.resizeNonAxisCharts(), a(i);
    });
  } }, { key: "destroy", value: function() {
    window.removeEventListener("resize", this.windowResizeHandler), function(t, i) {
      var s = Os.get(i);
      s && (s.disconnect(), Os.delete(i));
    }(this.el.parentNode, this.parentResizeHandler);
    var e = this.w.config.chart.id;
    e && Apex._chartInstances.forEach(function(t, i) {
      t.id === z.escapeString(e) && Apex._chartInstances.splice(i, 1);
    }), new tn(this.ctx).clear({ isUpdating: !1 });
  } }, { key: "updateOptions", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], n = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], o = this.w;
    return o.globals.selection = void 0, this.lastUpdateOptions && JSON.stringify(this.lastUpdateOptions) === JSON.stringify(e) ? this : (this.lastUpdateOptions = z.clone(e), e.series && (this.series.resetSeries(!1, !0, !1), e.series.length && e.series[0].data && (e.series = e.series.map(function(l, c) {
      return t.updateHelpers._extendSeries(l, c);
    })), this.updateHelpers.revertDefaultAxisMinMax()), e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)), e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)), o.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), e.theme && (e = this.theme.updateThemeOptions(e)), this.updateHelpers._updateOptions(e, i, s, a, n));
  } }, { key: "updateSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
    return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(e, t, i);
  } }, { key: "appendSeries", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], s = this.w.config.series.slice();
    return s.push(e), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(s, t, i);
  } }, { key: "appendData", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this;
    i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
    for (var s = i.w.config.series.slice(), a = 0; a < s.length; a++) if (e[a] !== null && e[a] !== void 0) for (var n = 0; n < e[a].data.length; n++) s[a].data.push(e[a].data[n]);
    return i.w.config.series = s, t && (i.w.globals.initialSeries = z.clone(i.w.config.series)), this.update();
  } }, { key: "update", value: function(e) {
    var t = this;
    return new Promise(function(i, s) {
      if (t.lastUpdateOptions && JSON.stringify(t.lastUpdateOptions) === JSON.stringify(e)) return i(t);
      t.lastUpdateOptions = z.clone(e), new tn(t.ctx).clear({ isUpdating: !0 });
      var a = t.create(t.w.config.series, e);
      if (!a) return i(t);
      t.mount(a).then(function() {
        typeof t.w.config.chart.events.updated == "function" && t.w.config.chart.events.updated(t, t.w), t.events.fireEvent("updated", [t, t.w]), t.w.globals.isDirty = !0, i(t);
      }).catch(function(n) {
        s(n);
      });
    });
  } }, { key: "getSyncedCharts", value: function() {
    var e = this.getGroupedCharts(), t = [this];
    return e.length && (t = [], e.forEach(function(i) {
      t.push(i);
    })), t;
  } }, { key: "getGroupedCharts", value: function() {
    var e = this;
    return Apex._chartInstances.filter(function(t) {
      if (t.group) return !0;
    }).map(function(t) {
      return e.w.config.chart.group === t.group ? t.chart : e;
    });
  } }, { key: "toggleSeries", value: function(e) {
    return this.series.toggleSeries(e);
  } }, { key: "highlightSeriesOnLegendHover", value: function(e, t) {
    return this.series.toggleSeriesOnHover(e, t);
  } }, { key: "showSeries", value: function(e) {
    this.series.showSeries(e);
  } }, { key: "hideSeries", value: function(e) {
    this.series.hideSeries(e);
  } }, { key: "highlightSeries", value: function(e) {
    this.series.highlightSeries(e);
  } }, { key: "isSeriesHidden", value: function(e) {
    this.series.isSeriesHidden(e);
  } }, { key: "resetSeries", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    this.series.resetSeries(e, t);
  } }, { key: "addEventListener", value: function(e, t) {
    this.events.addEventListener(e, t);
  } }, { key: "removeEventListener", value: function(e, t) {
    this.events.removeEventListener(e, t);
  } }, { key: "addXaxisAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addXaxisAnnotationExternal(e, t, s);
  } }, { key: "addYaxisAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addYaxisAnnotationExternal(e, t, s);
  } }, { key: "addPointAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, s = this;
    i && (s = i), s.annotations.addPointAnnotationExternal(e, t, s);
  } }, { key: "clearAnnotations", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, t = this;
    e && (t = e), t.annotations.clearAnnotations(t);
  } }, { key: "removeAnnotation", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i = this;
    t && (i = t), i.annotations.removeAnnotation(i, e);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(e, t) {
    return this.coreUtils.getSeriesTotalsXRange(e, t);
  } }, { key: "getHighestValueInSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new br(this.ctx).getMinYMaxY(e).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new br(this.ctx).getMinYMaxY(e).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "toggleDataPointSelection", value: function(e, t) {
    return this.updateHelpers.toggleDataPointSelection(e, t);
  } }, { key: "zoomX", value: function(e, t) {
    this.ctx.toolbar.zoomUpdateOptions(e, t);
  } }, { key: "setLocale", value: function(e) {
    this.localization.setCurrentLocaleValues(e);
  } }, { key: "dataURI", value: function(e) {
    return new mi(this.ctx).dataURI(e);
  } }, { key: "getSvgString", value: function(e) {
    return new mi(this.ctx).getSvgString(e);
  } }, { key: "exportToCSV", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new mi(this.ctx).exportToCSV(e);
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "_parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  } }, { key: "_windowResize", value: function() {
    var e = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      e.w.globals.resized = !0, e.w.globals.dataChanged = !1, e.ctx.update();
    }, 150);
  } }, { key: "_windowResizeHandler", value: function() {
    var e = this.w.config.chart.redrawOnWindowResize;
    typeof e == "function" && (e = e()), e && this._windowResize();
  } }], [{ key: "getChartByID", value: function(e) {
    var t = z.escapeString(e);
    if (Apex._chartInstances) {
      var i = Apex._chartInstances.filter(function(s) {
        return s.id === t;
      })[0];
      return i && i.chart;
    }
  } }, { key: "initOnLoad", value: function() {
    for (var e = document.querySelectorAll("[data-apexcharts]"), t = 0; t < e.length; t++)
      new r(e[t], JSON.parse(e[t].getAttribute("data-options"))).render();
  } }, { key: "exec", value: function(e, t) {
    var i = this.getChartByID(e);
    if (i) {
      i.w.globals.isExecCalled = !0;
      var s = null;
      if (i.publicMethods.indexOf(t) !== -1) {
        for (var a = arguments.length, n = new Array(a > 2 ? a - 2 : 0), o = 2; o < a; o++) n[o - 2] = arguments[o];
        s = i[t].apply(i, n);
      }
      return s;
    }
  } }, { key: "merge", value: function(e, t) {
    return z.extend(e, t);
  } }]), r;
}();
const Ld = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Pd
}, Symbol.toStringTag, { value: "Module" })), Id = /* @__PURE__ */ Ml(Ld);
var Cr = { exports: {} }, Di = { exports: {} }, Se = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sn;
function Ed() {
  if (sn) return Se;
  sn = 1;
  var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, t = r ? Symbol.for("react.portal") : 60106, i = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, n = r ? Symbol.for("react.provider") : 60109, o = r ? Symbol.for("react.context") : 60110, l = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, u = r ? Symbol.for("react.suspense_list") : 60120, g = r ? Symbol.for("react.memo") : 60115, p = r ? Symbol.for("react.lazy") : 60116, f = r ? Symbol.for("react.block") : 60121, x = r ? Symbol.for("react.fundamental") : 60117, m = r ? Symbol.for("react.responder") : 60118, b = r ? Symbol.for("react.scope") : 60119;
  function w(v) {
    if (typeof v == "object" && v !== null) {
      var S = v.$$typeof;
      switch (S) {
        case e:
          switch (v = v.type, v) {
            case l:
            case c:
            case i:
            case a:
            case s:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case o:
                case h:
                case p:
                case g:
                case n:
                  return v;
                default:
                  return S;
              }
          }
        case t:
          return S;
      }
    }
  }
  function y(v) {
    return w(v) === c;
  }
  return Se.AsyncMode = l, Se.ConcurrentMode = c, Se.ContextConsumer = o, Se.ContextProvider = n, Se.Element = e, Se.ForwardRef = h, Se.Fragment = i, Se.Lazy = p, Se.Memo = g, Se.Portal = t, Se.Profiler = a, Se.StrictMode = s, Se.Suspense = d, Se.isAsyncMode = function(v) {
    return y(v) || w(v) === l;
  }, Se.isConcurrentMode = y, Se.isContextConsumer = function(v) {
    return w(v) === o;
  }, Se.isContextProvider = function(v) {
    return w(v) === n;
  }, Se.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, Se.isForwardRef = function(v) {
    return w(v) === h;
  }, Se.isFragment = function(v) {
    return w(v) === i;
  }, Se.isLazy = function(v) {
    return w(v) === p;
  }, Se.isMemo = function(v) {
    return w(v) === g;
  }, Se.isPortal = function(v) {
    return w(v) === t;
  }, Se.isProfiler = function(v) {
    return w(v) === a;
  }, Se.isStrictMode = function(v) {
    return w(v) === s;
  }, Se.isSuspense = function(v) {
    return w(v) === d;
  }, Se.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === i || v === c || v === a || v === s || v === d || v === u || typeof v == "object" && v !== null && (v.$$typeof === p || v.$$typeof === g || v.$$typeof === n || v.$$typeof === o || v.$$typeof === h || v.$$typeof === x || v.$$typeof === m || v.$$typeof === b || v.$$typeof === f);
  }, Se.typeOf = w, Se;
}
var ke = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rn;
function Td() {
  return rn || (rn = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, e = r ? Symbol.for("react.element") : 60103, t = r ? Symbol.for("react.portal") : 60106, i = r ? Symbol.for("react.fragment") : 60107, s = r ? Symbol.for("react.strict_mode") : 60108, a = r ? Symbol.for("react.profiler") : 60114, n = r ? Symbol.for("react.provider") : 60109, o = r ? Symbol.for("react.context") : 60110, l = r ? Symbol.for("react.async_mode") : 60111, c = r ? Symbol.for("react.concurrent_mode") : 60111, h = r ? Symbol.for("react.forward_ref") : 60112, d = r ? Symbol.for("react.suspense") : 60113, u = r ? Symbol.for("react.suspense_list") : 60120, g = r ? Symbol.for("react.memo") : 60115, p = r ? Symbol.for("react.lazy") : 60116, f = r ? Symbol.for("react.block") : 60121, x = r ? Symbol.for("react.fundamental") : 60117, m = r ? Symbol.for("react.responder") : 60118, b = r ? Symbol.for("react.scope") : 60119;
    function w(W) {
      return typeof W == "string" || typeof W == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      W === i || W === c || W === a || W === s || W === d || W === u || typeof W == "object" && W !== null && (W.$$typeof === p || W.$$typeof === g || W.$$typeof === n || W.$$typeof === o || W.$$typeof === h || W.$$typeof === x || W.$$typeof === m || W.$$typeof === b || W.$$typeof === f);
    }
    function y(W) {
      if (typeof W == "object" && W !== null) {
        var fe = W.$$typeof;
        switch (fe) {
          case e:
            var _e = W.type;
            switch (_e) {
              case l:
              case c:
              case i:
              case a:
              case s:
              case d:
                return _e;
              default:
                var He = _e && _e.$$typeof;
                switch (He) {
                  case o:
                  case h:
                  case p:
                  case g:
                  case n:
                    return He;
                  default:
                    return fe;
                }
            }
          case t:
            return fe;
        }
      }
    }
    var v = l, S = c, k = o, C = n, R = e, P = h, A = i, E = p, N = g, O = t, L = a, I = s, F = d, D = !1;
    function Y(W) {
      return D || (D = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(W) || y(W) === l;
    }
    function _(W) {
      return y(W) === c;
    }
    function H(W) {
      return y(W) === o;
    }
    function V(W) {
      return y(W) === n;
    }
    function Z(W) {
      return typeof W == "object" && W !== null && W.$$typeof === e;
    }
    function X(W) {
      return y(W) === h;
    }
    function J(W) {
      return y(W) === i;
    }
    function G(W) {
      return y(W) === p;
    }
    function $(W) {
      return y(W) === g;
    }
    function K(W) {
      return y(W) === t;
    }
    function re(W) {
      return y(W) === a;
    }
    function Q(W) {
      return y(W) === s;
    }
    function ae(W) {
      return y(W) === d;
    }
    ke.AsyncMode = v, ke.ConcurrentMode = S, ke.ContextConsumer = k, ke.ContextProvider = C, ke.Element = R, ke.ForwardRef = P, ke.Fragment = A, ke.Lazy = E, ke.Memo = N, ke.Portal = O, ke.Profiler = L, ke.StrictMode = I, ke.Suspense = F, ke.isAsyncMode = Y, ke.isConcurrentMode = _, ke.isContextConsumer = H, ke.isContextProvider = V, ke.isElement = Z, ke.isForwardRef = X, ke.isFragment = J, ke.isLazy = G, ke.isMemo = $, ke.isPortal = K, ke.isProfiler = re, ke.isStrictMode = Q, ke.isSuspense = ae, ke.isValidElementType = w, ke.typeOf = y;
  }()), ke;
}
var an;
function zo() {
  return an || (an = 1, process.env.NODE_ENV === "production" ? Di.exports = Ed() : Di.exports = Td()), Di.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var zs, nn;
function _d() {
  if (nn) return zs;
  nn = 1;
  var r = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function i(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function s() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var n = {}, o = 0; o < 10; o++)
        n["_" + String.fromCharCode(o)] = o;
      var l = Object.getOwnPropertyNames(n).map(function(h) {
        return n[h];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(h) {
        c[h] = h;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return zs = s() ? Object.assign : function(a, n) {
    for (var o, l = i(a), c, h = 1; h < arguments.length; h++) {
      o = Object(arguments[h]);
      for (var d in o)
        e.call(o, d) && (l[d] = o[d]);
      if (r) {
        c = r(o);
        for (var u = 0; u < c.length; u++)
          t.call(o, c[u]) && (l[c[u]] = o[c[u]]);
      }
    }
    return l;
  }, zs;
}
var Fs, on;
function Kr() {
  if (on) return Fs;
  on = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Fs = r, Fs;
}
var Ns, ln;
function Fo() {
  return ln || (ln = 1, Ns = Function.call.bind(Object.prototype.hasOwnProperty)), Ns;
}
var Ds, cn;
function Od() {
  if (cn) return Ds;
  cn = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = Kr(), t = {}, i = Fo();
    r = function(a) {
      var n = "Warning: " + a;
      typeof console < "u" && console.error(n);
      try {
        throw new Error(n);
      } catch {
      }
    };
  }
  function s(a, n, o, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var h in a)
        if (i(a, h)) {
          var d;
          try {
            if (typeof a[h] != "function") {
              var u = Error(
                (l || "React class") + ": " + o + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw u.name = "Invariant Violation", u;
            }
            d = a[h](n, h, l, o, null, e);
          } catch (p) {
            d = p;
          }
          if (d && !(d instanceof Error) && r(
            (l || "React class") + ": type specification of " + o + " `" + h + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in t)) {
            t[d.message] = !0;
            var g = c ? c() : "";
            r(
              "Failed " + o + " type: " + d.message + (g ?? "")
            );
          }
        }
    }
  }
  return s.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, Ds = s, Ds;
}
var Hs, hn;
function zd() {
  if (hn) return Hs;
  hn = 1;
  var r = zo(), e = _d(), t = Kr(), i = Fo(), s = Od(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(o) {
    var l = "Warning: " + o;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function n() {
    return null;
  }
  return Hs = function(o, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, h = "@@iterator";
    function d(_) {
      var H = _ && (c && _[c] || _[h]);
      if (typeof H == "function")
        return H;
    }
    var u = "<<anonymous>>", g = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: b(),
      arrayOf: w,
      element: y(),
      elementType: v(),
      instanceOf: S,
      node: P(),
      objectOf: C,
      oneOf: k,
      oneOfType: R,
      shape: E,
      exact: N
    };
    function p(_, H) {
      return _ === H ? _ !== 0 || 1 / _ === 1 / H : _ !== _ && H !== H;
    }
    function f(_, H) {
      this.message = _, this.data = H && typeof H == "object" ? H : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function x(_) {
      if (process.env.NODE_ENV !== "production")
        var H = {}, V = 0;
      function Z(J, G, $, K, re, Q, ae) {
        if (K = K || u, Q = Q || $, ae !== t) {
          if (l) {
            var W = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw W.name = "Invariant Violation", W;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var fe = K + ":" + $;
            !H[fe] && // Avoid spamming the console because they are often not actionable except for lib authors
            V < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + Q + "` prop on `" + K + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), H[fe] = !0, V++);
          }
        }
        return G[$] == null ? J ? G[$] === null ? new f("The " + re + " `" + Q + "` is marked as required " + ("in `" + K + "`, but its value is `null`.")) : new f("The " + re + " `" + Q + "` is marked as required in " + ("`" + K + "`, but its value is `undefined`.")) : null : _(G, $, K, re, Q);
      }
      var X = Z.bind(null, !1);
      return X.isRequired = Z.bind(null, !0), X;
    }
    function m(_) {
      function H(V, Z, X, J, G, $) {
        var K = V[Z], re = I(K);
        if (re !== _) {
          var Q = F(K);
          return new f(
            "Invalid " + J + " `" + G + "` of type " + ("`" + Q + "` supplied to `" + X + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return x(H);
    }
    function b() {
      return x(n);
    }
    function w(_) {
      function H(V, Z, X, J, G) {
        if (typeof _ != "function")
          return new f("Property `" + G + "` of component `" + X + "` has invalid PropType notation inside arrayOf.");
        var $ = V[Z];
        if (!Array.isArray($)) {
          var K = I($);
          return new f("Invalid " + J + " `" + G + "` of type " + ("`" + K + "` supplied to `" + X + "`, expected an array."));
        }
        for (var re = 0; re < $.length; re++) {
          var Q = _($, re, X, J, G + "[" + re + "]", t);
          if (Q instanceof Error)
            return Q;
        }
        return null;
      }
      return x(H);
    }
    function y() {
      function _(H, V, Z, X, J) {
        var G = H[V];
        if (!o(G)) {
          var $ = I(G);
          return new f("Invalid " + X + " `" + J + "` of type " + ("`" + $ + "` supplied to `" + Z + "`, expected a single ReactElement."));
        }
        return null;
      }
      return x(_);
    }
    function v() {
      function _(H, V, Z, X, J) {
        var G = H[V];
        if (!r.isValidElementType(G)) {
          var $ = I(G);
          return new f("Invalid " + X + " `" + J + "` of type " + ("`" + $ + "` supplied to `" + Z + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return x(_);
    }
    function S(_) {
      function H(V, Z, X, J, G) {
        if (!(V[Z] instanceof _)) {
          var $ = _.name || u, K = Y(V[Z]);
          return new f("Invalid " + J + " `" + G + "` of type " + ("`" + K + "` supplied to `" + X + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return x(H);
    }
    function k(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), n;
      function H(V, Z, X, J, G) {
        for (var $ = V[Z], K = 0; K < _.length; K++)
          if (p($, _[K]))
            return null;
        var re = JSON.stringify(_, function(ae, W) {
          var fe = F(W);
          return fe === "symbol" ? String(W) : W;
        });
        return new f("Invalid " + J + " `" + G + "` of value `" + String($) + "` " + ("supplied to `" + X + "`, expected one of " + re + "."));
      }
      return x(H);
    }
    function C(_) {
      function H(V, Z, X, J, G) {
        if (typeof _ != "function")
          return new f("Property `" + G + "` of component `" + X + "` has invalid PropType notation inside objectOf.");
        var $ = V[Z], K = I($);
        if (K !== "object")
          return new f("Invalid " + J + " `" + G + "` of type " + ("`" + K + "` supplied to `" + X + "`, expected an object."));
        for (var re in $)
          if (i($, re)) {
            var Q = _($, re, X, J, G + "." + re, t);
            if (Q instanceof Error)
              return Q;
          }
        return null;
      }
      return x(H);
    }
    function R(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), n;
      for (var H = 0; H < _.length; H++) {
        var V = _[H];
        if (typeof V != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + D(V) + " at index " + H + "."
          ), n;
      }
      function Z(X, J, G, $, K) {
        for (var re = [], Q = 0; Q < _.length; Q++) {
          var ae = _[Q], W = ae(X, J, G, $, K, t);
          if (W == null)
            return null;
          W.data && i(W.data, "expectedType") && re.push(W.data.expectedType);
        }
        var fe = re.length > 0 ? ", expected one of type [" + re.join(", ") + "]" : "";
        return new f("Invalid " + $ + " `" + K + "` supplied to " + ("`" + G + "`" + fe + "."));
      }
      return x(Z);
    }
    function P() {
      function _(H, V, Z, X, J) {
        return O(H[V]) ? null : new f("Invalid " + X + " `" + J + "` supplied to " + ("`" + Z + "`, expected a ReactNode."));
      }
      return x(_);
    }
    function A(_, H, V, Z, X) {
      return new f(
        (_ || "React class") + ": " + H + " type `" + V + "." + Z + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + X + "`."
      );
    }
    function E(_) {
      function H(V, Z, X, J, G) {
        var $ = V[Z], K = I($);
        if (K !== "object")
          return new f("Invalid " + J + " `" + G + "` of type `" + K + "` " + ("supplied to `" + X + "`, expected `object`."));
        for (var re in _) {
          var Q = _[re];
          if (typeof Q != "function")
            return A(X, J, G, re, F(Q));
          var ae = Q($, re, X, J, G + "." + re, t);
          if (ae)
            return ae;
        }
        return null;
      }
      return x(H);
    }
    function N(_) {
      function H(V, Z, X, J, G) {
        var $ = V[Z], K = I($);
        if (K !== "object")
          return new f("Invalid " + J + " `" + G + "` of type `" + K + "` " + ("supplied to `" + X + "`, expected `object`."));
        var re = e({}, V[Z], _);
        for (var Q in re) {
          var ae = _[Q];
          if (i(_, Q) && typeof ae != "function")
            return A(X, J, G, Q, F(ae));
          if (!ae)
            return new f(
              "Invalid " + J + " `" + G + "` key `" + Q + "` supplied to `" + X + "`.\nBad object: " + JSON.stringify(V[Z], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var W = ae($, Q, X, J, G + "." + Q, t);
          if (W)
            return W;
        }
        return null;
      }
      return x(H);
    }
    function O(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(O);
          if (_ === null || o(_))
            return !0;
          var H = d(_);
          if (H) {
            var V = H.call(_), Z;
            if (H !== _.entries) {
              for (; !(Z = V.next()).done; )
                if (!O(Z.value))
                  return !1;
            } else
              for (; !(Z = V.next()).done; ) {
                var X = Z.value;
                if (X && !O(X[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function L(_, H) {
      return _ === "symbol" ? !0 : H ? H["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && H instanceof Symbol : !1;
    }
    function I(_) {
      var H = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : L(H, _) ? "symbol" : H;
    }
    function F(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var H = I(_);
      if (H === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return H;
    }
    function D(_) {
      var H = F(_);
      switch (H) {
        case "array":
        case "object":
          return "an " + H;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + H;
        default:
          return H;
      }
    }
    function Y(_) {
      return !_.constructor || !_.constructor.name ? u : _.constructor.name;
    }
    return g.checkPropTypes = s, g.resetWarningCache = s.resetWarningCache, g.PropTypes = g, g;
  }, Hs;
}
var Ys, dn;
function Fd() {
  if (dn) return Ys;
  dn = 1;
  var r = Kr();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, Ys = function() {
    function i(n, o, l, c, h, d) {
      if (d !== r) {
        var u = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw u.name = "Invariant Violation", u;
      }
    }
    i.isRequired = i;
    function s() {
      return i;
    }
    var a = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: s,
      element: i,
      elementType: i,
      instanceOf: s,
      node: i,
      objectOf: s,
      oneOf: s,
      oneOfType: s,
      shape: s,
      exact: s,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, Ys;
}
if (process.env.NODE_ENV !== "production") {
  var Nd = zo(), Dd = !0;
  Cr.exports = zd()(Nd.isElement, Dd);
} else
  Cr.exports = Fd()();
var Hd = Cr.exports;
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.default = w;
  var e = o(Xe), t = a(Id), i = a(Hd), s = ["type", "width", "height", "series", "options"];
  function a(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function n(y) {
    var v, S;
    return typeof WeakMap != "function" ? null : (v = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap(), (n = function(k) {
      return k ? S : v;
    })(y));
  }
  function o(y, v) {
    if (!v && y && y.__esModule) return y;
    if (y === null || d(y) != "object" && typeof y != "function") return { default: y };
    if (v = n(v), v && v.has(y)) return v.get(y);
    var S, k, C = { __proto__: null }, R = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (S in y) S !== "default" && {}.hasOwnProperty.call(y, S) && ((k = R ? Object.getOwnPropertyDescriptor(y, S) : null) && (k.get || k.set) ? Object.defineProperty(C, S, k) : C[S] = y[S]);
    return C.default = y, v && v.set(y, C), C;
  }
  function l() {
    return (l = Object.assign ? Object.assign.bind() : function(y) {
      for (var v = 1; v < arguments.length; v++) {
        var S, k = arguments[v];
        for (S in k) !{}.hasOwnProperty.call(k, S) || (y[S] = k[S]);
      }
      return y;
    }).apply(null, arguments);
  }
  function c(y, v) {
    if (y == null) return {};
    var S, k = h(y, v);
    if (Object.getOwnPropertySymbols) for (var C = Object.getOwnPropertySymbols(y), R = 0; R < C.length; R++) S = C[R], v.includes(S) || {}.propertyIsEnumerable.call(y, S) && (k[S] = y[S]);
    return k;
  }
  function h(y, v) {
    if (y == null) return {};
    var S, k = {};
    for (S in y) if ({}.hasOwnProperty.call(y, S)) {
      if (v.includes(S)) continue;
      k[S] = y[S];
    }
    return k;
  }
  function d(y) {
    return (d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(v) {
      return typeof v;
    } : function(v) {
      return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
    })(y);
  }
  function u(y, v) {
    var S, k = Object.keys(y);
    return Object.getOwnPropertySymbols && (S = Object.getOwnPropertySymbols(y), v && (S = S.filter(function(C) {
      return Object.getOwnPropertyDescriptor(y, C).enumerable;
    })), k.push.apply(k, S)), k;
  }
  function g(y) {
    for (var v = 1; v < arguments.length; v++) {
      var S = arguments[v] != null ? arguments[v] : {};
      v % 2 ? u(Object(S), !0).forEach(function(k) {
        p(y, k, S[k]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(S)) : u(Object(S)).forEach(function(k) {
        Object.defineProperty(y, k, Object.getOwnPropertyDescriptor(S, k));
      });
    }
    return y;
  }
  function p(y, v, S) {
    return (v = f(v)) in y ? Object.defineProperty(y, v, { value: S, enumerable: !0, configurable: !0, writable: !0 }) : y[v] = S, y;
  }
  function f(y) {
    return y = x(y, "string"), d(y) == "symbol" ? y : y + "";
  }
  function x(y, v) {
    if (d(y) != "object" || !y) return y;
    var S = y[Symbol.toPrimitive];
    if (S === void 0) return (v === "string" ? String : Number)(y);
    if (S = S.call(y, v), d(S) != "object") return S;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  function m(y, v) {
    var S = g({}, y);
    return v.forEach(function(k) {
      delete S[k];
    }), S;
  }
  function b(y, v) {
    var S = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new WeakSet();
    if (y !== v) {
      if (d(y) !== "object" || y === null || d(v) !== "object" || v === null) return !1;
      if (!S.has(y) && !S.has(v)) {
        S.add(y), S.add(v);
        var k = Object.keys(y), C = Object.keys(v);
        if (k.length !== C.length) return !1;
        for (var R = 0, P = k; R < P.length; R++) {
          var A = P[R];
          if (!C.includes(A) || !b(y[A], v[A], S)) return !1;
        }
      }
    }
    return !0;
  }
  function w(F) {
    function v(D) {
      return D && d(D) === "object" && !Array.isArray(D);
    }
    var A = F.type, S = A === void 0 ? "line" : A, A = F.width, k = A === void 0 ? "100%" : A, A = F.height, C = A === void 0 ? "auto" : A, R = F.series, P = F.options, A = c(F, s), E = (0, e.useRef)(null), N = (0, e.useRef)(null), O = (0, e.useRef)(), L = ((0, e.useEffect)(function() {
      O.current = P;
      var D = E.current;
      return N.current = new t.default(D, L()), N.current.render(), function() {
        N.current && typeof N.current.destroy == "function" && N.current.destroy();
      };
    }, []), (0, e.useEffect)(function() {
      var D = !b(N.current.w.config.series, R), Y = !b(O.current, P) || C !== N.current.opts.chart.height || k !== N.current.opts.chart.width;
      (D || Y) && (!D || Y ? N.current.updateOptions(L()) : N.current.updateSeries(R)), O.current = P;
    }, [P, R, C, k]), function() {
      return I(P, { chart: { type: S, height: C, width: k }, series: R });
    }), I = function(D, Y) {
      var _ = g({}, D);
      return v(D) && v(Y) && Object.keys(Y).forEach(function(H) {
        v(Y[H]) && H in D ? _[H] = I(D[H], Y[H]) : Object.assign(_, p({}, H, Y[H]));
      }), _;
    }, F = m(A, Object.keys(w.propTypes));
    return e.default.createElement("div", l({ ref: E }, F));
  }
  w.propTypes = { type: i.default.string.isRequired, series: i.default.array.isRequired, options: i.default.object.isRequired, width: i.default.oneOfType([i.default.string, i.default.number]), height: i.default.oneOfType([i.default.string, i.default.number]) };
})(Xn);
const Yd = /* @__PURE__ */ xn(Xn), un = {
  chart: {
    toolbar: {
      show: !1
    },
    zoom: {
      enabled: !1
    }
  },
  colors: ["#3B82F6", "#10B981", "#F59E0B", "#EF4444", "#8B5CF6"],
  grid: {
    borderColor: "#E5E7EB",
    strokeDashArray: 4,
    xaxis: {
      lines: {
        show: !0
      }
    },
    yaxis: {
      lines: {
        show: !0
      }
    }
  },
  stroke: {
    curve: "smooth",
    width: 2
  },
  tooltip: {
    theme: "light",
    x: {
      show: !0
    }
  }
}, xg = ({
  type: r,
  series: e,
  width: t = "100%",
  height: i = 350,
  options: s = {},
  className: a
}) => {
  const n = {
    ...un,
    ...s,
    chart: {
      ...un.chart,
      ...s.chart,
      type: r
    }
  };
  return /* @__PURE__ */ M.jsx("div", { className: a, children: /* @__PURE__ */ M.jsx(
    Yd,
    {
      type: r,
      series: e,
      options: n,
      width: t,
      height: i
    }
  ) });
}, mg = ({
  label: r,
  error: e,
  disabled: t = !1,
  indeterminate: i = !1,
  variantSize: s = "sm",
  variant: a = "square",
  color: n = "primary",
  className: o = "",
  ...l
}) => {
  const c = {
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  }, h = {
    primary: "checked:bg-primary-600 checked:border-primary-600 hover:border-primary-600",
    secondary: "checked:bg-secondary-600 checked:border-secondary-600 hover:border-secondary-600",
    success: "checked:bg-success-600 checked:border-success-600 hover:border-success-600",
    warning: "checked:bg-warning-600 checked:border-warning-600 hover:border-warning-600",
    error: "checked:bg-danger-600 checked:border-danger-600 hover:border-danger-600"
  }, u = Dt(
    "border-2 transition-colors duration-200",
    "appearance-none cursor-pointer",
    "checked:bg-no-repeat checked:bg-center",
    a === "circle" ? 'checked:bg-[url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI2IiBjeT0iNiIgcj0iNCIgZmlsbD0id2hpdGUiLz48L3N2Zz4=")]' : 'checked:bg-[url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTAgM0w0LjUgOC41TDIgNiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=")]',
    {
      square: "rounded",
      circle: "rounded-full"
    }[a],
    c[s],
    h[n],
    t && "opacity-50 cursor-not-allowed",
    o
  ), g = Dt(
    "ml-2 text-sm font-medium",
    t && "opacity-50 cursor-not-allowed",
    e && "text-danger-600"
  );
  return /* @__PURE__ */ M.jsxs("div", { className: "items-center", children: [
    /* @__PURE__ */ M.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ M.jsx(
        "input",
        {
          type: "checkbox",
          className: u,
          disabled: t,
          ref: (p) => {
            p && (p.indeterminate = i);
          },
          ...l
        }
      ),
      r && /* @__PURE__ */ M.jsx("label", { className: g, children: r })
    ] }),
    e && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-sm text-danger-600", children: e })
  ] });
}, jd = {
  solid: {
    primary: "bg-primary-500 text-white",
    success: "bg-success-500 text-white",
    warning: "bg-warning-500 text-white",
    error: "bg-error-500 text-white",
    info: "bg-info-500 text-white",
    danger: "bg-danger-500 text-white",
    default: "bg-neutral-500 text-white"
  },
  outline: {
    primary: "border border-primary-500 text-primary-500",
    success: "border border-success-500 text-success-500",
    warning: "border border-warning-500 text-warning-500",
    error: "border border-error-500 text-error-500",
    info: "border border-info-500 text-info-500",
    danger: "border border-danger-500 text-danger-500",
    default: "border border-neutral-500 text-neutral-500"
  },
  subtle: {
    primary: "bg-primary-100 text-primary-700",
    success: "bg-success-100 text-success-700",
    warning: "bg-warning-100 text-warning-700",
    error: "bg-error-100 text-error-700",
    info: "bg-info-100 text-info-700",
    danger: "bg-danger-100 text-danger-700",
    default: "bg-neutral-100 text-neutral-700"
  },
  soft: {
    primary: "bg-primary-50 text-primary-600",
    success: "bg-success-50 text-success-600",
    warning: "bg-warning-50 text-warning-600",
    error: "bg-error-50 text-error-600",
    info: "bg-info-50 text-info-600",
    danger: "bg-danger-50 text-danger-600",
    default: "bg-neutral-50 text-neutral-600"
  }
}, Xd = {
  sm: "text-xs px-2 py-0.5",
  md: "text-sm px-3 py-1",
  lg: "text-base px-4 py-1.5"
}, bg = ({
  children: r,
  variant: e = "solid",
  color: t = "primary",
  size: i = "md",
  onClose: s,
  className: a,
  icon: n
}) => /* @__PURE__ */ M.jsxs(
  "div",
  {
    className: ie(
      "inline-flex items-center gap-1.5 rounded-full font-medium",
      jd[e][t],
      Xd[i],
      a
    ),
    children: [
      n && /* @__PURE__ */ M.jsx("span", { className: "inline-flex items-center", children: /* @__PURE__ */ M.jsx(Ee, { icon: n, className: "w-4 h-4" }) }),
      r,
      s && /* @__PURE__ */ M.jsx(
        "button",
        {
          onClick: s,
          className: "ml-1 rounded-full hover:bg-black/10 p-0.5",
          "aria-label": "Close",
          children: /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:close", className: "w-3 h-3" })
        }
      )
    ]
  }
);
var No = { exports: {} };
(function(r, e) {
  (function(t, i) {
    r.exports = i();
  })(Al, function() {
    var t = 1e3, i = 6e4, s = 36e5, a = "millisecond", n = "second", o = "minute", l = "hour", c = "day", h = "week", d = "month", u = "quarter", g = "year", p = "date", f = "Invalid Date", x = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(O) {
      var L = ["th", "st", "nd", "rd"], I = O % 100;
      return "[" + O + (L[(I - 20) % 10] || L[I] || L[0]) + "]";
    } }, w = function(O, L, I) {
      var F = String(O);
      return !F || F.length >= L ? O : "" + Array(L + 1 - F.length).join(I) + O;
    }, y = { s: w, z: function(O) {
      var L = -O.utcOffset(), I = Math.abs(L), F = Math.floor(I / 60), D = I % 60;
      return (L <= 0 ? "+" : "-") + w(F, 2, "0") + ":" + w(D, 2, "0");
    }, m: function O(L, I) {
      if (L.date() < I.date()) return -O(I, L);
      var F = 12 * (I.year() - L.year()) + (I.month() - L.month()), D = L.clone().add(F, d), Y = I - D < 0, _ = L.clone().add(F + (Y ? -1 : 1), d);
      return +(-(F + (I - D) / (Y ? D - _ : _ - D)) || 0);
    }, a: function(O) {
      return O < 0 ? Math.ceil(O) || 0 : Math.floor(O);
    }, p: function(O) {
      return { M: d, y: g, w: h, d: c, D: p, h: l, m: o, s: n, ms: a, Q: u }[O] || String(O || "").toLowerCase().replace(/s$/, "");
    }, u: function(O) {
      return O === void 0;
    } }, v = "en", S = {};
    S[v] = b;
    var k = "$isDayjsObject", C = function(O) {
      return O instanceof E || !(!O || !O[k]);
    }, R = function O(L, I, F) {
      var D;
      if (!L) return v;
      if (typeof L == "string") {
        var Y = L.toLowerCase();
        S[Y] && (D = Y), I && (S[Y] = I, D = Y);
        var _ = L.split("-");
        if (!D && _.length > 1) return O(_[0]);
      } else {
        var H = L.name;
        S[H] = L, D = H;
      }
      return !F && D && (v = D), D || !F && v;
    }, P = function(O, L) {
      if (C(O)) return O.clone();
      var I = typeof L == "object" ? L : {};
      return I.date = O, I.args = arguments, new E(I);
    }, A = y;
    A.l = R, A.i = C, A.w = function(O, L) {
      return P(O, { locale: L.$L, utc: L.$u, x: L.$x, $offset: L.$offset });
    };
    var E = function() {
      function O(I) {
        this.$L = R(I.locale, null, !0), this.parse(I), this.$x = this.$x || I.x || {}, this[k] = !0;
      }
      var L = O.prototype;
      return L.parse = function(I) {
        this.$d = function(F) {
          var D = F.date, Y = F.utc;
          if (D === null) return /* @__PURE__ */ new Date(NaN);
          if (A.u(D)) return /* @__PURE__ */ new Date();
          if (D instanceof Date) return new Date(D);
          if (typeof D == "string" && !/Z$/i.test(D)) {
            var _ = D.match(x);
            if (_) {
              var H = _[2] - 1 || 0, V = (_[7] || "0").substring(0, 3);
              return Y ? new Date(Date.UTC(_[1], H, _[3] || 1, _[4] || 0, _[5] || 0, _[6] || 0, V)) : new Date(_[1], H, _[3] || 1, _[4] || 0, _[5] || 0, _[6] || 0, V);
            }
          }
          return new Date(D);
        }(I), this.init();
      }, L.init = function() {
        var I = this.$d;
        this.$y = I.getFullYear(), this.$M = I.getMonth(), this.$D = I.getDate(), this.$W = I.getDay(), this.$H = I.getHours(), this.$m = I.getMinutes(), this.$s = I.getSeconds(), this.$ms = I.getMilliseconds();
      }, L.$utils = function() {
        return A;
      }, L.isValid = function() {
        return this.$d.toString() !== f;
      }, L.isSame = function(I, F) {
        var D = P(I);
        return this.startOf(F) <= D && D <= this.endOf(F);
      }, L.isAfter = function(I, F) {
        return P(I) < this.startOf(F);
      }, L.isBefore = function(I, F) {
        return this.endOf(F) < P(I);
      }, L.$g = function(I, F, D) {
        return A.u(I) ? this[F] : this.set(D, I);
      }, L.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, L.valueOf = function() {
        return this.$d.getTime();
      }, L.startOf = function(I, F) {
        var D = this, Y = !!A.u(F) || F, _ = A.p(I), H = function(re, Q) {
          var ae = A.w(D.$u ? Date.UTC(D.$y, Q, re) : new Date(D.$y, Q, re), D);
          return Y ? ae : ae.endOf(c);
        }, V = function(re, Q) {
          return A.w(D.toDate()[re].apply(D.toDate("s"), (Y ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Q)), D);
        }, Z = this.$W, X = this.$M, J = this.$D, G = "set" + (this.$u ? "UTC" : "");
        switch (_) {
          case g:
            return Y ? H(1, 0) : H(31, 11);
          case d:
            return Y ? H(1, X) : H(0, X + 1);
          case h:
            var $ = this.$locale().weekStart || 0, K = (Z < $ ? Z + 7 : Z) - $;
            return H(Y ? J - K : J + (6 - K), X);
          case c:
          case p:
            return V(G + "Hours", 0);
          case l:
            return V(G + "Minutes", 1);
          case o:
            return V(G + "Seconds", 2);
          case n:
            return V(G + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, L.endOf = function(I) {
        return this.startOf(I, !1);
      }, L.$set = function(I, F) {
        var D, Y = A.p(I), _ = "set" + (this.$u ? "UTC" : ""), H = (D = {}, D[c] = _ + "Date", D[p] = _ + "Date", D[d] = _ + "Month", D[g] = _ + "FullYear", D[l] = _ + "Hours", D[o] = _ + "Minutes", D[n] = _ + "Seconds", D[a] = _ + "Milliseconds", D)[Y], V = Y === c ? this.$D + (F - this.$W) : F;
        if (Y === d || Y === g) {
          var Z = this.clone().set(p, 1);
          Z.$d[H](V), Z.init(), this.$d = Z.set(p, Math.min(this.$D, Z.daysInMonth())).$d;
        } else H && this.$d[H](V);
        return this.init(), this;
      }, L.set = function(I, F) {
        return this.clone().$set(I, F);
      }, L.get = function(I) {
        return this[A.p(I)]();
      }, L.add = function(I, F) {
        var D, Y = this;
        I = Number(I);
        var _ = A.p(F), H = function(X) {
          var J = P(Y);
          return A.w(J.date(J.date() + Math.round(X * I)), Y);
        };
        if (_ === d) return this.set(d, this.$M + I);
        if (_ === g) return this.set(g, this.$y + I);
        if (_ === c) return H(1);
        if (_ === h) return H(7);
        var V = (D = {}, D[o] = i, D[l] = s, D[n] = t, D)[_] || 1, Z = this.$d.getTime() + I * V;
        return A.w(Z, this);
      }, L.subtract = function(I, F) {
        return this.add(-1 * I, F);
      }, L.format = function(I) {
        var F = this, D = this.$locale();
        if (!this.isValid()) return D.invalidDate || f;
        var Y = I || "YYYY-MM-DDTHH:mm:ssZ", _ = A.z(this), H = this.$H, V = this.$m, Z = this.$M, X = D.weekdays, J = D.months, G = D.meridiem, $ = function(Q, ae, W, fe) {
          return Q && (Q[ae] || Q(F, Y)) || W[ae].slice(0, fe);
        }, K = function(Q) {
          return A.s(H % 12 || 12, Q, "0");
        }, re = G || function(Q, ae, W) {
          var fe = Q < 12 ? "AM" : "PM";
          return W ? fe.toLowerCase() : fe;
        };
        return Y.replace(m, function(Q, ae) {
          return ae || function(W) {
            switch (W) {
              case "YY":
                return String(F.$y).slice(-2);
              case "YYYY":
                return A.s(F.$y, 4, "0");
              case "M":
                return Z + 1;
              case "MM":
                return A.s(Z + 1, 2, "0");
              case "MMM":
                return $(D.monthsShort, Z, J, 3);
              case "MMMM":
                return $(J, Z);
              case "D":
                return F.$D;
              case "DD":
                return A.s(F.$D, 2, "0");
              case "d":
                return String(F.$W);
              case "dd":
                return $(D.weekdaysMin, F.$W, X, 2);
              case "ddd":
                return $(D.weekdaysShort, F.$W, X, 3);
              case "dddd":
                return X[F.$W];
              case "H":
                return String(H);
              case "HH":
                return A.s(H, 2, "0");
              case "h":
                return K(1);
              case "hh":
                return K(2);
              case "a":
                return re(H, V, !0);
              case "A":
                return re(H, V, !1);
              case "m":
                return String(V);
              case "mm":
                return A.s(V, 2, "0");
              case "s":
                return String(F.$s);
              case "ss":
                return A.s(F.$s, 2, "0");
              case "SSS":
                return A.s(F.$ms, 3, "0");
              case "Z":
                return _;
            }
            return null;
          }(Q) || _.replace(":", "");
        });
      }, L.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, L.diff = function(I, F, D) {
        var Y, _ = this, H = A.p(F), V = P(I), Z = (V.utcOffset() - this.utcOffset()) * i, X = this - V, J = function() {
          return A.m(_, V);
        };
        switch (H) {
          case g:
            Y = J() / 12;
            break;
          case d:
            Y = J();
            break;
          case u:
            Y = J() / 3;
            break;
          case h:
            Y = (X - Z) / 6048e5;
            break;
          case c:
            Y = (X - Z) / 864e5;
            break;
          case l:
            Y = X / s;
            break;
          case o:
            Y = X / i;
            break;
          case n:
            Y = X / t;
            break;
          default:
            Y = X;
        }
        return D ? Y : A.a(Y);
      }, L.daysInMonth = function() {
        return this.endOf(d).$D;
      }, L.$locale = function() {
        return S[this.$L];
      }, L.locale = function(I, F) {
        if (!I) return this.$L;
        var D = this.clone(), Y = R(I, F, !0);
        return Y && (D.$L = Y), D;
      }, L.clone = function() {
        return A.w(this.$d, this);
      }, L.toDate = function() {
        return new Date(this.valueOf());
      }, L.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, L.toISOString = function() {
        return this.$d.toISOString();
      }, L.toString = function() {
        return this.$d.toUTCString();
      }, O;
    }(), N = E.prototype;
    return P.prototype = N, [["$ms", a], ["$s", n], ["$m", o], ["$H", l], ["$W", c], ["$M", d], ["$y", g], ["$D", p]].forEach(function(O) {
      N[O[1]] = function(L) {
        return this.$g(L, O[0], O[1]);
      };
    }), P.extend = function(O, L) {
      return O.$i || (O(L, E, P), O.$i = !0), P;
    }, P.locale = R, P.isDayjs = C, P.unix = function(O) {
      return P(1e3 * O);
    }, P.en = S[v], P.Ls = S, P.p = {}, P;
  });
})(No);
var Bd = No.exports;
const Ke = /* @__PURE__ */ xn(Bd), Wd = gt(
  "rounded-md border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      fullWidth: !0
    }
  }
), Vd = Ue(
  ({
    value: r,
    endDate: e,
    onChange: t,
    onEndDateChange: i,
    isRangeSelection: s = !1,
    minDate: a,
    maxDate: n,
    variant: o = "default",
    size: l = "md",
    disabled: c = !1,
    errorText: h,
    helperText: d,
    label: u,
    required: g = !1,
    labelPlacement: p = "top",
    fullWidth: f = !1,
    className: x,
    placeholder: m = "Select date",
    ...b
  }, w) => {
    const [y, v] = Ie(!1), [S, k] = Ie(r || null), [C, R] = Ie(e || null), [P, A] = Ie(r || /* @__PURE__ */ new Date()), E = $e(null), N = $e(null), O = $e(null), L = () => {
      if (!y || !N.current || !O.current) return;
      const { bottom: X, left: J, width: G } = N.current.getBoundingClientRect(), $ = O.current;
      Object.assign($.style, {
        position: "fixed",
        left: `${J}px`,
        top: `${X + 4}px`,
        width: `${G}px`,
        maxHeight: `${window.innerHeight - X - 8}px`
      });
    };
    ut(() => {
      const X = () => {
        y && L();
      }, J = () => {
        y && L();
      }, G = ($) => {
        const K = $.target;
        E.current && !E.current.contains(K) && O.current && !O.current.contains(K) && v(!1);
      };
      return y && (L(), window.addEventListener("scroll", X, !0), window.addEventListener("resize", J)), document.addEventListener("click", G), () => {
        window.removeEventListener("scroll", X, !0), window.removeEventListener("resize", J), document.removeEventListener("click", G);
      };
    }, [y]);
    const I = (X) => {
      s ? S ? (Ke(X).isBefore(S) ? (R(S), k(X), t == null || t(X), i == null || i(S)) : (R(X), i == null || i(X)), v(!1)) : (k(X), t == null || t(X)) : (k(X), t == null || t(X), v(!1));
    }, F = () => {
      A(Ke(P).subtract(1, "month").toDate());
    }, D = () => {
      A(Ke(P).add(1, "month").toDate());
    }, Y = () => {
      const X = Ke(P).startOf("month"), J = Ke(P).endOf("month"), G = [];
      let $ = X;
      for (; $.isBefore(J) || $.isSame(J, "day"); )
        G.push($.toDate()), $ = $.add(1, "day");
      return G;
    }, _ = (X) => !!(a && Ke(X).isBefore(a, "day") || n && Ke(X).isAfter(n, "day")), H = Y(), V = Ke(P).startOf("month").day(), Z = () => {
      if (!S) return "";
      const X = Ke(S).format("DD MMM YYYY");
      return s && C ? `${X} - ${Ke(C).format("DD MMM YYYY")}` : X;
    };
    return /* @__PURE__ */ M.jsxs("div", { ref: E, className: ie("relative", f && "w-full", x), children: [
      u && /* @__PURE__ */ M.jsxs(
        "label",
        {
          className: ie(
            "block text-sm font-medium text-gray-700 mb-1",
            p === "left" && "inline-block mr-2"
          ),
          children: [
            u,
            g && /* @__PURE__ */ M.jsx("span", { className: "text-red-500 ml-1", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ M.jsx("div", { ref: N, children: /* @__PURE__ */ M.jsx(
        "input",
        {
          ref: w,
          type: "text",
          value: Z(),
          placeholder: m,
          onClick: () => !c && v(!y),
          readOnly: !0,
          className: ie(Wd({ variant: o, size: l, fullWidth: f })),
          disabled: c,
          ...b
        }
      ) }),
      y && Qt(
        /* @__PURE__ */ M.jsxs(
          "div",
          {
            ref: O,
            className: "fixed z-[9999] bg-white border border-gray-200 rounded-md shadow-lg",
            children: [
              /* @__PURE__ */ M.jsxs("div", { className: "flex items-center justify-between p-2 border-b border-gray-200", children: [
                /* @__PURE__ */ M.jsx(
                  "button",
                  {
                    onClick: F,
                    className: "p-1 rounded-full hover:bg-primary-50 active:bg-primary-100 transition-colors duration-200",
                    children: /* @__PURE__ */ M.jsx(
                      Ee,
                      {
                        icon: "mdi:chevron-left",
                        className: "w-5 h-5 text-neutral-600"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ M.jsx("span", { className: "font-medium text-gray-900", children: Ke(P).format("MMMM YYYY") }),
                /* @__PURE__ */ M.jsx(
                  "button",
                  {
                    onClick: D,
                    className: "p-1 rounded-full hover:bg-primary-50 active:bg-primary-100 transition-colors duration-200",
                    children: /* @__PURE__ */ M.jsx(
                      Ee,
                      {
                        icon: "mdi:chevron-right",
                        className: "w-5 h-5 text-neutral-600"
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ M.jsxs("div", { className: "grid grid-cols-7 gap-1 p-2", children: [
                ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((X) => /* @__PURE__ */ M.jsx(
                  "div",
                  {
                    className: "text-center text-sm font-medium text-gray-500",
                    children: X
                  },
                  X
                )),
                Array.from({ length: V }).map((X, J) => /* @__PURE__ */ M.jsx("div", {}, `empty-${J}`)),
                H.map((X) => {
                  const J = S && Ke(X).isSame(S, "day"), G = _(X), $ = Ke(X).isSame(P, "month");
                  return /* @__PURE__ */ M.jsx(
                    "button",
                    {
                      onClick: () => !G && I(X),
                      disabled: G,
                      className: ie(
                        "p-2 rounded-full text-sm transition-colors duration-200",
                        J && "bg-primary-500 text-white hover:bg-primary-600 active:bg-primary-700",
                        !J && !G && "hover:bg-primary-50 active:bg-primary-100",
                        !$ && "text-neutral-400",
                        G && "opacity-50 cursor-not-allowed"
                      ),
                      children: Ke(X).format("D")
                    },
                    X.toString()
                  );
                })
              ] })
            ]
          }
        ),
        document.body
      ),
      h && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-sm text-red-500", children: h }),
      d && !h && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-sm text-gray-500", children: d })
    ] });
  }
);
Vd.displayName = "DatePicker";
const Do = Ue(
  ({ children: r, onClose: e, className: t, ...i }, s) => /* @__PURE__ */ M.jsxs(
    "div",
    {
      ref: s,
      className: ie("mb-4 flex items-center justify-between", t),
      ...i,
      children: [
        r,
        e && /* @__PURE__ */ M.jsx(
          "button",
          {
            onClick: e,
            className: "ml-4 rounded-full p-1 text-gray-500 hover:bg-gray-100 hover:text-gray-700",
            "aria-label": "Close dialog",
            children: /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:close", className: "h-5 w-5" })
          }
        )
      ]
    }
  )
), Gd = {
  sm: "max-w-sm",
  md: "max-w-md",
  lg: "max-w-lg",
  xl: "max-w-4xl",
  fullscreen: "w-full h-full max-w-none max-h-none rounded-none"
}, $d = Ue(
  ({
    isOpen: r,
    onClose: e,
    children: t,
    className: i,
    backdrop: s = "dark",
    header: a,
    closeOnBackdropClick: n = !0,
    size: o = "md",
    ...l
  }, c) => {
    const [h, d] = Ie(!1), [u, g] = Ie(!1);
    if (ut(() => {
      if (r)
        d(!0), g(!0), document.body.style.overflow = "hidden";
      else {
        g(!1);
        const x = setTimeout(() => {
          d(!1), document.body.style.overflow = "";
        }, 300);
        return () => clearTimeout(x);
      }
    }, [r]), ut(() => {
      const x = (m) => {
        m.key === "Escape" && e();
      };
      return r && document.addEventListener("keydown", x), () => {
        document.removeEventListener("keydown", x);
      };
    }, [r, e]), !h) return null;
    const p = {
      blur: "backdrop-blur-sm bg-black/30",
      dark: "bg-black/50",
      transparent: "bg-transparent"
    }, f = () => {
      n && e();
    };
    return Qt(
      /* @__PURE__ */ M.jsx(
        "div",
        {
          className: ie(
            "fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300",
            p[s],
            u ? "opacity-100" : "opacity-0",
            o === "fullscreen" && "items-start"
          ),
          onClick: f,
          children: /* @__PURE__ */ M.jsxs(
            "div",
            {
              ref: c,
              className: ie(
                "relative transform rounded-lg bg-white p-6 shadow-xl transition-all duration-300",
                Gd[o],
                u ? "scale-100 opacity-100" : "scale-95 opacity-0",
                i
              ),
              onClick: (x) => x.stopPropagation(),
              ...l,
              children: [
                a && /* @__PURE__ */ M.jsx(Do, { onClose: e, children: a }),
                t
              ]
            }
          )
        }
      ),
      document.body
    );
  }
), Ud = Ue(
  ({ children: r, className: e, ...t }, i) => /* @__PURE__ */ M.jsx(
    "h2",
    {
      ref: i,
      className: ie("text-xl font-semibold text-gray-900", e),
      ...t,
      children: r
    }
  )
), qd = Ue(
  ({ children: r, className: e, ...t }, i) => /* @__PURE__ */ M.jsx(
    "div",
    {
      ref: i,
      className: ie("text-gray-600", e),
      ...t,
      children: r
    }
  )
), Zd = Ue(
  ({ children: r, className: e, ...t }, i) => /* @__PURE__ */ M.jsx(
    "div",
    {
      ref: i,
      className: ie("mt-6 flex justify-end gap-3", e),
      ...t,
      children: r
    }
  )
);
$d.displayName = "Dialog";
Ud.displayName = "DialogTitle";
qd.displayName = "DialogBody";
Zd.displayName = "DialogActions";
Do.displayName = "DialogHeader";
const Jd = ({
  orientation: r = "horizontal",
  variant: e = "solid",
  color: t = "neutral",
  size: i = "sm",
  className: s = ""
}) => {
  const a = {
    horizontal: "w-full border-t-0 border-l-0 border-r-0 border-b",
    vertical: "h-full border-l border-t-0 border-r-0 border-b-0"
  }, n = {
    solid: "border-solid",
    dashed: "border-dashed",
    dotted: "border-dotted"
  }, o = {
    primary: "border-primary-300",
    secondary: "border-secondary-300",
    neutral: "border-neutral-300",
    success: "border-success-300",
    warning: "border-warning-300",
    error: "border-error-300"
  }, l = {
    sm: r === "horizontal" ? "border-b" : "border-l",
    md: r === "horizontal" ? "border-b-2" : "border-l-2",
    lg: r === "horizontal" ? "border-b-4" : "border-l-4"
  }, c = Dt(
    "inline-block",
    a[r],
    n[e],
    o[t],
    l[i],
    s
  );
  return /* @__PURE__ */ M.jsx("div", { className: c });
}, vg = ({
  accept: r = ["*"],
  maxSize: e = 5 * 1024 * 1024,
  // 5MB default
  multiple: t = !1,
  value: i = [],
  onChange: s,
  className: a,
  disabled: n = !1,
  placeholder: o = "Drag and drop files here or click to browse"
}) => {
  const [l, c] = Ie(!1), [h, d] = Ie(null), u = $e(null), g = xt((y) => {
    y.preventDefault(), n || c(!0);
  }, [n]), p = xt((y) => {
    y.preventDefault(), c(!1);
  }, []), f = xt((y) => y.size > e ? `File size exceeds ${e / (1024 * 1024)}MB limit` : r[0] !== "*" && !r.some((v) => v.startsWith(".") ? y.name.toLowerCase().endsWith(v.toLowerCase()) : y.type.startsWith(v)) ? `File type not allowed. Allowed types: ${r.join(", ")}` : null, [r, e]), x = xt((y) => {
    if (y.preventDefault(), c(!1), d(null), n) return;
    const v = Array.from(y.dataTransfer.files), S = [], k = [];
    if (v.forEach((C) => {
      const R = f(C);
      R ? k.push(`${C.name}: ${R}`) : S.push(C);
    }), k.length > 0 && d(k.join(`
`)), S.length > 0) {
      const C = t ? [...i, ...S] : S;
      s == null || s(C);
    }
  }, [n, t, s, f, i]), m = xt((y) => {
    if (d(null), n || !y.target.files) return;
    const v = Array.from(y.target.files), S = [], k = [];
    if (v.forEach((C) => {
      const R = f(C);
      R ? k.push(`${C.name}: ${R}`) : S.push(C);
    }), k.length > 0 && d(k.join(`
`)), S.length > 0) {
      const C = t ? [...i, ...S] : S;
      s == null || s(C);
    }
    u.current && (u.current.value = "");
  }, [n, t, s, f, i]), b = xt((y) => {
    const v = [...i];
    v.splice(y, 1), s == null || s(v);
  }, [s, i]), w = (y) => y.type.startsWith("image/") ? /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:image", className: "w-5 h-5" }) : y.type.startsWith("text/") ? /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:file-document", className: "w-5 h-5" }) : /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:file", className: "w-5 h-5" });
  return /* @__PURE__ */ M.jsxs("div", { className: xe("w-full", a), children: [
    /* @__PURE__ */ M.jsxs(
      "div",
      {
        className: xe(
          "border-2 border-dashed rounded-lg p-6 text-center transition-colors",
          "bg-neutral-50",
          "border-neutral-300",
          l && "border-primary bg-primary-50",
          n && "opacity-50 cursor-not-allowed",
          !n && "cursor-pointer hover:border-primary/50"
        ),
        onDragOver: g,
        onDragLeave: p,
        onDrop: x,
        onClick: () => {
          var y;
          return !n && ((y = u.current) == null ? void 0 : y.click());
        },
        children: [
          /* @__PURE__ */ M.jsx(
            "input",
            {
              ref: u,
              type: "file",
              accept: r.join(","),
              multiple: t,
              onChange: m,
              className: "hidden",
              disabled: n
            }
          ),
          /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:upload", className: "w-12 h-12 mx-auto mb-4 text-neutral-400" }),
          /* @__PURE__ */ M.jsx("p", { className: "text-neutral-600", children: o }),
          /* @__PURE__ */ M.jsxs("p", { className: "text-sm text-neutral-500 mt-2", children: [
            "Max file size: ",
            e / (1024 * 1024),
            "MB"
          ] })
        ]
      }
    ),
    h && /* @__PURE__ */ M.jsx("p", { className: "mt-2 text-sm text-danger", children: h }),
    i.length > 0 && /* @__PURE__ */ M.jsx("div", { className: "mt-4 space-y-2", children: i.map((y, v) => /* @__PURE__ */ M.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-2 rounded-md bg-neutral-100",
        children: [
          /* @__PURE__ */ M.jsxs("div", { className: "flex items-center space-x-2", children: [
            w(y),
            /* @__PURE__ */ M.jsx("span", { className: "text-sm text-neutral-700", children: y.name }),
            /* @__PURE__ */ M.jsxs("span", { className: "text-xs text-neutral-500", children: [
              "(",
              (y.size / 1024).toFixed(1),
              " KB)"
            ] })
          ] }),
          !n && /* @__PURE__ */ M.jsx(
            "button",
            {
              onClick: () => b(v),
              className: "p-1 text-neutral-500 hover:text-danger",
              children: /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:close", className: "w-4 h-4" })
            }
          )
        ]
      },
      `${y.name}-${v}`
    )) })
  ] });
}, vt = ({
  icon: r,
  className: e,
  size: t,
  color: i,
  rotate: s,
  flip: a,
  spin: n,
  ...o
}) => /* @__PURE__ */ M.jsx(
  Ee,
  {
    icon: r,
    className: ie(
      n && "animate-spin",
      e
    ),
    style: {
      color: i,
      transform: `rotate(${s || 0}deg)`
    },
    height: t,
    width: t,
    flip: a,
    ...o
  }
), yg = ({
  type: r = "info",
  title: e,
  message: t,
  icon: i,
  duration: s = 0,
  // 5000
  showClose: a = !0,
  className: n,
  onClose: o,
  actions: l = []
}) => {
  const [c, h] = Ie(!0);
  ut(() => {
    if (s > 0) {
      const p = setTimeout(() => {
        d();
      }, s);
      return () => clearTimeout(p);
    }
  }, [s]);
  const d = () => {
    h(!1), setTimeout(() => {
      o == null || o();
    }, 300);
  }, u = () => {
    if (i) return i;
    switch (r) {
      case "success":
        return "mdi:check-circle";
      case "warning":
        return "mdi:alert";
      case "error":
        return "mdi:close-circle";
      default:
        return "mdi:information";
    }
  }, g = () => {
    switch (r) {
      case "success":
        return "bg-green-50 border-green-200 text-green-800";
      case "warning":
        return "bg-yellow-50 border-yellow-200 text-yellow-800";
      case "error":
        return "bg-red-50 border-red-200 text-red-800";
      default:
        return "bg-blue-50 border-blue-200 text-blue-800";
    }
  };
  return c ? /* @__PURE__ */ M.jsx(
    "div",
    {
      className: xe(
        "relative p-4 rounded-lg border transition-all duration-300",
        "transform translate-y-0 opacity-100",
        g(),
        n
      ),
      children: /* @__PURE__ */ M.jsxs("div", { className: "flex items-start", children: [
        /* @__PURE__ */ M.jsx(
          Ee,
          {
            icon: u(),
            className: xe(
              "w-5 h-5 flex-shrink-0 mt-0.5",
              r === "success" && "text-green-500",
              r === "warning" && "text-yellow-500",
              r === "error" && "text-red-500",
              r === "info" && "text-blue-500"
            )
          }
        ),
        /* @__PURE__ */ M.jsxs("div", { className: "ml-3 flex-1", children: [
          e && /* @__PURE__ */ M.jsx("h3", { className: "text-sm font-medium mb-1", children: e }),
          /* @__PURE__ */ M.jsx("p", { className: "text-sm", children: t }),
          l.length > 0 && /* @__PURE__ */ M.jsx("div", { className: "mt-3 flex space-x-2", children: l.map((p, f) => /* @__PURE__ */ M.jsx(
            "button",
            {
              onClick: p.onClick,
              className: xe(
                "text-sm font-medium px-3 py-1 rounded-md transition-colors",
                r === "success" && "text-green-700 hover:bg-green-100",
                r === "warning" && "text-yellow-700 hover:bg-yellow-100",
                r === "error" && "text-red-700 hover:bg-red-100",
                r === "info" && "text-blue-700 hover:bg-blue-100",
                p.className
              ),
              children: p.label
            },
            f
          )) })
        ] }),
        a && /* @__PURE__ */ M.jsx(
          "button",
          {
            onClick: d,
            className: xe(
              "absolute top-4 right-4 p-1 rounded-full transition-colors",
              r === "success" && "hover:bg-green-100",
              r === "warning" && "hover:bg-yellow-100",
              r === "error" && "hover:bg-red-100",
              r === "info" && "hover:bg-blue-100"
            ),
            children: /* @__PURE__ */ M.jsx(
              Ee,
              {
                icon: "mdi:close",
                className: "w-4 h-4"
              }
            )
          }
        )
      ] })
    }
  ) : null;
}, js = "select-dropdown-opened", Kd = gt(
  "rounded-md px-3 py-2 text-sm ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50 bg-white",
        error: "border border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50 bg-white",
        success: "border border-success-500 hover:border-success-600 focus:border-success-600 bg-white",
        ghost: "border-0 hover:bg-neutral-100 focus:bg-neutral-100 bg-transparent",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      fullWidth: !0
    }
  }
), Ho = Ue(
  ({
    className: r,
    variant: e = "default",
    size: t = "md",
    options: i,
    label: s,
    error: a = !1,
    helperText: n,
    required: o = !1,
    placeholder: l,
    value: c,
    onChange: h,
    disabled: d = !1,
    position: u = "bottom",
    fullWidth: g = !0,
    children: p,
    leftIcon: f,
    rightIcon: x,
    ...m
  }, b) => {
    const [w, y] = Ie(!1), v = $e(null), S = $e(null), C = `select-${Xe.useId().replace(/:/g, "")}`, R = () => {
      if (w && v.current && S.current) {
        const L = v.current.getBoundingClientRect(), I = S.current, F = window.innerHeight - L.bottom, D = L.top, _ = L.bottom + I.offsetHeight + 4 >= window.innerHeight, H = D > F, V = _ && H;
        u === "bottom" || u === "top" ? (I.style.position = "fixed", I.style.left = `${L.left}px`, I.style.width = `${L.width}px`, u === "bottom" && V ? (I.style.bottom = `${window.innerHeight - L.top + 4}px`, I.style.top = "auto", I.style.maxHeight = `${D - 8}px`) : u === "bottom" ? (I.style.top = `${L.bottom + 4}px`, I.style.bottom = "auto", I.style.maxHeight = `${F - 8}px`) : u === "top" && !V ? (I.style.top = `${L.bottom + 4}px`, I.style.bottom = "auto", I.style.maxHeight = `${F - 8}px`) : (I.style.bottom = `${window.innerHeight - L.top + 4}px`, I.style.top = "auto", I.style.maxHeight = `${D - 8}px`)) : u === "left" ? (I.style.position = "fixed", I.style.right = `${window.innerWidth - L.left + 4}px`, I.style.top = `${L.top}px`, I.style.maxHeight = `${window.innerHeight - L.top - 8}px`) : u === "right" && (I.style.position = "fixed", I.style.left = `${L.right + 4}px`, I.style.top = `${L.top}px`, I.style.maxHeight = `${window.innerHeight - L.top - 8}px`);
      }
    };
    ut(() => {
      const L = () => {
        w && R();
      }, I = () => {
        w && R();
      };
      return w && (R(), window.addEventListener("scroll", L, !0), window.addEventListener("resize", I)), () => {
        window.removeEventListener("scroll", L, !0), window.removeEventListener("resize", I);
      };
    }, [w, u]), ut(() => {
      const L = (F) => {
        F.detail.id !== C && y(!1);
      }, I = (F) => {
        const D = F.target, Y = v.current, _ = S.current;
        Y && _ && !Y.contains(D) && !_.contains(D) && y(!1);
      };
      return document.addEventListener(js, L), document.addEventListener("click", I), () => {
        document.removeEventListener(js, L), document.removeEventListener("click", I);
      };
    }, [C]);
    const P = () => {
      if (!d) {
        if (w) {
          y(!1);
          return;
        }
        document.dispatchEvent(
          new CustomEvent(js, {
            detail: { id: C }
          })
        ), y(!0);
      }
    }, A = () => {
      if (i) {
        const L = i.find((I) => I.value === c);
        return L == null ? void 0 : L.label;
      }
      if (p) {
        const I = pa.toArray(p).find(
          (F) => us(F) && "value" in F.props && F.props.value === c
        );
        return us(I) ? I.props.children : null;
      }
      return null;
    }, E = (L) => {
      d || (h == null || h(L), y(!1));
    }, N = () => i ? i.map((L) => /* @__PURE__ */ M.jsx(
      ss,
      {
        value: L.value,
        disabled: L.disabled,
        selected: L.value === c,
        onClick: () => E(L.value),
        children: /* @__PURE__ */ M.jsxs("div", { className: "flex items-center gap-2", children: [
          L.icon,
          L.label
        ] })
      },
      L.value
    )) : p ? pa.map(p, (L) => us(L) && "value" in L.props ? Sl(L, {
      selected: L.props.value === c,
      onClick: () => E(L.props.value)
    }) : null) : null, O = () => {
      if (!w || d) return null;
      const L = /* @__PURE__ */ M.jsx(
        "div",
        {
          ref: S,
          className: ie(
            "fixed z-[9999] min-w-[8rem] rounded-md border border-neutral-200 bg-white py-1 shadow-lg",
            u === "left" || u === "right" ? "w-max" : "w-full"
          ),
          onClick: (I) => I.stopPropagation(),
          style: {
            overflowY: "auto"
          },
          children: N()
        }
      );
      return Qt(L, document.body);
    };
    return /* @__PURE__ */ M.jsxs("div", { className: ie(g ? "w-full" : "inline-block"), ref: b, ...m, children: [
      s && /* @__PURE__ */ M.jsxs(
        "label",
        {
          htmlFor: C,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            s,
            o && /* @__PURE__ */ M.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ M.jsxs("div", { className: ie("relative", !g && "inline-block"), children: [
        /* @__PURE__ */ M.jsxs(
          "button",
          {
            id: C,
            ref: v,
            type: "button",
            className: ie(
              Kd({ variant: a ? "error" : e, size: t, fullWidth: g }),
              "flex items-center justify-between",
              d && "cursor-not-allowed opacity-50",
              f && "pl-10",
              x && "pr-10",
              r
            ),
            onClick: P,
            "aria-haspopup": "listbox",
            "aria-expanded": w,
            "aria-describedby": a ? `${C}-error` : n ? `${C}-helper` : void 0,
            disabled: d,
            children: [
              f && /* @__PURE__ */ M.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ M.jsx(vt, { icon: f, className: "w-4 h-4" }) }),
              /* @__PURE__ */ M.jsx("span", { className: "flex items-center text-neutral-500 gap-2 min-w-0 flex-1", children: /* @__PURE__ */ M.jsx("span", { className: "truncate", children: A() || l }) }),
              x ? /* @__PURE__ */ M.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ M.jsx(vt, { icon: x, className: "w-4 h-4" }) }) : /* @__PURE__ */ M.jsx(
                vt,
                {
                  icon: "mdi:chevron-down",
                  className: ie("transition-transform flex-shrink-0 ml-2", w && "rotate-180")
                }
              )
            ]
          }
        ),
        O()
      ] }),
      a && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-xs text-danger-500", id: `${C}-error`, children: a }),
      !a && n && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-xs text-neutral-500", id: `${C}-helper`, children: n })
    ] });
  }
);
Ho.displayName = "Select";
const Qd = ({
  currentPage: r,
  totalPages: e,
  totalData: t,
  onPageChange: i,
  siblingCount: s = 1,
  className: a,
  perPageOptions: n,
  perPage: o = 10,
  label: l = "",
  onPerPageChange: c
}) => {
  const h = (g, p) => {
    const f = p - g + 1;
    return Array.from({ length: f }, (x, m) => m + g);
  }, u = (() => {
    const g = s * 2 + 3, p = g + 2;
    if (e > p) {
      const f = Math.max(2, r - s), x = Math.min(e - 1, r + s);
      let m = h(f, x);
      const b = f > 2, w = e - x > 1, y = g - (m.length + 1);
      if (b && !w)
        m = [...h(f - y, f - 1), ...m];
      else if (!b && w) {
        const v = h(x + 1, x + y);
        m = [...m, ...v];
      } else b && w && (m = [...m]);
      return [1, ...m, e];
    }
    return h(1, e);
  })();
  return /* @__PURE__ */ M.jsxs(
    "nav",
    {
      className: xe("flex items-center justify-between space-x-1", a),
      children: [
        /* @__PURE__ */ M.jsxs("div", { className: "hidden sm:block text-sm text-neutral-700", children: [
          /* @__PURE__ */ M.jsx("b", { children: `${r} - ${e}` }),
          " dari ",
          t,
          " ",
          l
        ] }),
        /* @__PURE__ */ M.jsxs("div", { className: "flex items-center gap-2", children: [
          n && n.length > 0 && /* @__PURE__ */ M.jsxs("div", { className: "flex items-center gap-2 mr-4", children: [
            /* @__PURE__ */ M.jsx("span", { className: "text-neutral-700 text-sm", children: "Menampilkan" }),
            /* @__PURE__ */ M.jsx(
              Ho,
              {
                value: o == null ? void 0 : o.toString(),
                onChange: (g) => c && c(Number(g)),
                size: "sm",
                className: "w-16",
                fullWidth: !1,
                "aria-label": "Items per page",
                children: n.map((g) => /* @__PURE__ */ M.jsx(ss, { value: g.toString(), children: g }, g))
              }
            ),
            /* @__PURE__ */ M.jsx("span", { className: "text-neutral-700 text-sm", children: "data per halaman" })
          ] }),
          /* @__PURE__ */ M.jsx(
            mt,
            {
              variant: "ghost",
              onClick: () => i(r - 1),
              disabled: r === 1,
              className: xe(
                "px-3 py-1 rounded-md text-sm",
                r === 1 ? "text-gray-400 cursor-not-allowed" : "text-gray-700 hover:bg-gray-100"
              ),
              children: /* @__PURE__ */ M.jsx(vt, { size: "18", icon: "mdi:chevron-left" })
            }
          ),
          u.map((g, p) => {
            const f = g === r, x = typeof g == "string" && g === "...";
            return /* @__PURE__ */ M.jsx(
              mt,
              {
                variant: "ghost",
                onClick: () => !x && i(g),
                className: xe(
                  "px-3 py-1 rounded-md text-sm",
                  f ? "bg-primary text-white hover:bg-primary" : "text-gray-700",
                  x && "cursor-default"
                ),
                children: g
              },
              p
            );
          }),
          /* @__PURE__ */ M.jsx(
            mt,
            {
              variant: "ghost",
              onClick: () => i(r + 1),
              disabled: r === e,
              className: xe(
                "px-3 py-1 rounded-md text-sm",
                r === e ? "text-gray-400 cursor-not-allowed" : "text-gray-700"
              ),
              children: /* @__PURE__ */ M.jsx(vt, { size: "18", icon: "mdi:chevron-right" })
            }
          )
        ] })
      ]
    }
  );
}, wg = ({
  label: r,
  checked: e = !1,
  disabled: t = !1,
  onChange: i,
  name: s,
  value: a
}) => {
  const n = (o) => {
    i && i(o.target.checked);
  };
  return /* @__PURE__ */ M.jsxs(
    "label",
    {
      className: xe(
        "inline-flex items-center cursor-pointer",
        t && "opacity-60 cursor-not-allowed"
      ),
      children: [
        /* @__PURE__ */ M.jsx(
          "input",
          {
            type: "radio",
            className: xe(
              "w-5 h-5 border-2 rounded-full appearance-none",
              "focus:outline-none focus:ring-2 focus:ring-primary/25",
              e ? "border-primary bg-primary" : "border-gray-300 hover:border-primary",
              t && "cursor-not-allowed"
            ),
            checked: e,
            disabled: t,
            onChange: n,
            name: s,
            value: a
          }
        ),
        r && /* @__PURE__ */ M.jsx("span", { className: "ml-2 text-sm text-gray-700 dark:text-gray-300", children: r })
      ]
    }
  );
}, eu = ({
  className: r = "",
  variant: e = "text",
  animation: t = "pulse",
  height: i,
  width: s,
  color: a = "neutral"
}) => {
  const n = "bg-gray-200 dark:bg-gray-700", o = {
    text: "h-4 rounded",
    circular: "rounded-full",
    rectangular: "rounded"
  }, l = {
    pulse: "animate-pulse",
    wave: "animate-wave"
  }, c = {
    primary: "bg-blue-100 dark:bg-blue-900",
    secondary: "bg-gray-100 dark:bg-gray-700",
    success: "bg-green-100 dark:bg-green-900",
    warning: "bg-yellow-100 dark:bg-yellow-900",
    error: "bg-red-100 dark:bg-red-900",
    info: "bg-cyan-100 dark:bg-cyan-900",
    neutral: "bg-gray-200 dark:bg-gray-200"
  }, h = Dt(
    n,
    o[e],
    l[t],
    c[a],
    r
  ), d = {
    ...i && { height: i },
    ...s && { width: s }
  };
  return /* @__PURE__ */ M.jsx(
    "div",
    {
      className: h,
      style: d,
      role: "status",
      "aria-label": "Loading"
    }
  );
}, Sg = ({
  min: r = 0,
  max: e = 100,
  step: t = 1,
  value: i,
  defaultValue: s = r,
  onChange: a,
  className: n,
  disabled: o = !1,
  showValue: l = !1,
  marks: c = []
}) => {
  const [h, d] = Ie(s), [u, g] = Ie(!1), p = $e(null), f = i !== void 0 ? i : h, x = (S) => {
    if (o) return;
    const k = Math.min(Math.max(S, r), e);
    i === void 0 && d(k), a == null || a(k);
  }, m = (S) => {
    o || (g(!0), y(S));
  }, b = (S) => {
    !u || o || y(S);
  }, w = () => {
    g(!1);
  }, y = (S) => {
    if (!p.current) return;
    const k = p.current.getBoundingClientRect(), R = (S.clientX - k.left) / k.width, P = r + (e - r) * R, A = Math.round(P / t) * t;
    x(A);
  };
  ut(() => (u && (window.addEventListener("mousemove", b), window.addEventListener("mouseup", w)), () => {
    window.removeEventListener("mousemove", b), window.removeEventListener("mouseup", w);
  }), [u]);
  const v = (f - r) / (e - r) * 100;
  return /* @__PURE__ */ M.jsxs("div", { className: xe("relative w-full", n), children: [
    /* @__PURE__ */ M.jsxs(
      "div",
      {
        ref: p,
        className: xe(
          "relative h-2 bg-gray-200 rounded-full cursor-pointer",
          o && "opacity-50 cursor-not-allowed"
        ),
        onMouseDown: m,
        children: [
          /* @__PURE__ */ M.jsx(
            "div",
            {
              className: "absolute h-full bg-primary rounded-full",
              style: { width: `${v}%` }
            }
          ),
          /* @__PURE__ */ M.jsx(
            "div",
            {
              className: xe(
                "absolute top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full shadow-md",
                "border-2 border-primary",
                o && "cursor-not-allowed"
              ),
              style: { left: `${v}%`, transform: "translate(-50%, -50%)" }
            }
          )
        ]
      }
    ),
    c.length > 0 && /* @__PURE__ */ M.jsx("div", { className: "flex justify-between mt-2", children: c.map((S) => /* @__PURE__ */ M.jsx(
      "div",
      {
        className: "text-xs text-gray-500",
        style: { left: `${(S.value - r) / (e - r) * 100}%` },
        children: S.label
      },
      S.value
    )) }),
    l && /* @__PURE__ */ M.jsx("div", { className: "mt-2 text-sm text-gray-600", children: f })
  ] });
}, tu = {
  sm: "w-4 h-4",
  md: "w-6 h-6",
  lg: "w-8 h-8"
}, iu = {
  primary: "text-primary",
  warning: "text-warning-500",
  default: "text-default-400"
}, kg = ({
  rating: r,
  maxRating: e = 5,
  size: t = "md",
  color: i = "primary",
  readOnly: s = !1,
  onRatingChange: a,
  className: n
}) => {
  const [o, l] = Ie(null), c = (g) => {
    s || l(g);
  }, h = () => {
    s || l(null);
  }, d = (g) => {
    !s && a && a(g);
  }, u = o !== null ? o : r;
  return /* @__PURE__ */ M.jsx("div", { className: ie("flex items-center gap-1", n), children: [...Array(e)].map((g, p) => {
    const f = p + 1, x = f <= u, m = o !== null && f <= o;
    return /* @__PURE__ */ M.jsx(
      "button",
      {
        className: ie(
          "transition-colors duration-200",
          tu[t],
          x || m ? iu[i] : "text-default-200",
          !s && "cursor-pointer"
        ),
        onMouseEnter: () => c(f),
        onMouseLeave: h,
        onClick: () => d(f),
        disabled: s,
        "aria-label": `Rate ${f} out of ${e}`,
        children: /* @__PURE__ */ M.jsx(
          Ee,
          {
            icon: x || m ? "mdi:star" : "mdi:star-outline",
            className: "w-full h-full"
          }
        )
      },
      p
    );
  }) });
}, su = {
  active: {
    bgColor: "bg-success-500",
    label: "Active"
  },
  inactive: {
    bgColor: "bg-default-400",
    label: "Inactive"
  },
  pending: {
    bgColor: "bg-warning-500",
    label: "Pending"
  },
  warning: {
    bgColor: "bg-warning-500",
    label: "Warning"
  },
  error: {
    bgColor: "bg-danger-500",
    label: "Error"
  }
}, ru = {
  sm: "w-2 h-2",
  md: "w-3 h-3",
  lg: "w-4 h-4"
}, Cg = ({
  status: r,
  size: e = "md",
  withLabel: t = !1,
  className: i
}) => {
  const { bgColor: s, label: a } = su[r], n = ru[e];
  return /* @__PURE__ */ M.jsxs("div", { className: ie("flex items-center gap-2", i), children: [
    /* @__PURE__ */ M.jsx("div", { className: ie("rounded-full animate-pulse", s, n) }),
    t && /* @__PURE__ */ M.jsx("span", { className: "text-sm", children: a })
  ] });
}, Yo = (r, e) => {
  if (e) return e;
  switch (r) {
    case "completed":
      return "mdi:check";
    case "active":
      return "mdi:circle-medium";
    default:
      return "mdi:circle-outline";
  }
}, jo = (r) => {
  switch (r) {
    case "completed":
      return "text-white bg-primary-500 ring-4 ring-primary-50";
    case "active":
      return "text-primary-500 bg-primary-50 ring-4 ring-primary-50";
    default:
      return "text-neutral-400 bg-neutral-50 ring-4 ring-neutral-50";
  }
}, au = ({
  steps: r,
  activeStep: e,
  className: t,
  variant: i = "default"
}) => /* @__PURE__ */ M.jsx("div", { className: ie("flex flex-row items-center w-full justify-between", t), children: r.map((s, a) => {
  const n = a < e ? "completed" : a === e ? "active" : "pending";
  return /* @__PURE__ */ M.jsxs(
    "div",
    {
      className: "flex items-center flex-1",
      children: [
        /* @__PURE__ */ M.jsxs("div", { className: ie(
          "flex flex-col items-center z-10",
          i === "default" ? "gap-4" : "gap-2",
          i === "default" ? "px-5" : "px-3"
        ), children: [
          i === "default" && /* @__PURE__ */ M.jsx(
            "div",
            {
              className: ie(
                "flex h-8 w-8 items-center justify-center rounded-full transition-all duration-200",
                jo(n)
              ),
              children: /* @__PURE__ */ M.jsx(
                Ee,
                {
                  icon: Yo(n, s.icon),
                  className: "h-5 w-5"
                }
              )
            }
          ),
          /* @__PURE__ */ M.jsxs("div", { className: "flex flex-col items-center text-center", children: [
            /* @__PURE__ */ M.jsx(
              "span",
              {
                className: ie(
                  "text-sm font-medium",
                  n === "active" ? "text-primary-500" : n === "completed" ? "text-neutral-900" : "text-neutral-500"
                ),
                children: s.label
              }
            ),
            s.description && /* @__PURE__ */ M.jsx("span", { className: "text-xs text-neutral-500", children: s.description })
          ] })
        ] }),
        a < r.length - 1 && /* @__PURE__ */ M.jsx(
          Jd,
          {
            className: ie(
              "transition-all duration-200",
              a < e ? "bg-primary-500" : "bg-neutral-200"
            )
          }
        )
      ]
    },
    a
  );
}) }), nu = ({
  steps: r,
  activeStep: e,
  className: t,
  variant: i = "default"
}) => /* @__PURE__ */ M.jsx("div", { className: ie("flex flex-col items-start gap-8", t), children: r.map((s, a) => {
  const n = a < e ? "completed" : a === e ? "active" : "pending";
  return /* @__PURE__ */ M.jsxs(
    "div",
    {
      className: "flex flex-row w-full items-center relative",
      children: [
        /* @__PURE__ */ M.jsxs("div", { className: ie(
          "flex flex-row items-center z-10",
          i === "default" ? "gap-4" : "gap-2"
        ), children: [
          i === "default" && /* @__PURE__ */ M.jsx(
            "div",
            {
              className: ie(
                "flex h-8 w-8 items-center justify-center rounded-full transition-all duration-200",
                jo(n)
              ),
              children: /* @__PURE__ */ M.jsx(
                Ee,
                {
                  icon: Yo(n, s.icon),
                  className: "h-5 w-5"
                }
              )
            }
          ),
          /* @__PURE__ */ M.jsxs("div", { className: "flex flex-col items-start", children: [
            /* @__PURE__ */ M.jsx(
              "span",
              {
                className: ie(
                  "text-sm font-medium",
                  n === "active" ? "text-primary-500" : n === "completed" ? "text-neutral-900" : "text-neutral-500"
                ),
                children: s.label
              }
            ),
            s.description && /* @__PURE__ */ M.jsx("span", { className: "text-xs text-neutral-500", children: s.description })
          ] })
        ] }),
        a < r.length - 1 && /* @__PURE__ */ M.jsx(
          "div",
          {
            className: ie(
              "absolute transition-all duration-200",
              i === "default" ? "left-4 w-[1px] top-10 bottom-[-24px]" : "left-0 w-[1px] top-6 bottom-[-24px]",
              a < e ? "bg-primary-500" : "bg-neutral-200"
            )
          }
        )
      ]
    },
    a
  );
}) }), Ag = ({
  orientation: r = "horizontal",
  variant: e = "default",
  ...t
}) => r === "vertical" ? /* @__PURE__ */ M.jsx(nu, { variant: e, ...t }) : /* @__PURE__ */ M.jsx(au, { variant: e, ...t }), Mg = ({
  label: r,
  checked: e = !1,
  disabled: t = !1,
  onChange: i,
  size: s = "md"
}) => {
  const a = (l) => {
    i && i(l.target.checked);
  }, n = {
    sm: "w-8 h-4",
    md: "w-11 h-6",
    lg: "w-14 h-7"
  }, o = {
    sm: "w-3 h-3",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  };
  return /* @__PURE__ */ M.jsxs(
    "label",
    {
      className: xe(
        "inline-flex items-center cursor-pointer",
        t && "opacity-60 cursor-not-allowed"
      ),
      children: [
        /* @__PURE__ */ M.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ M.jsx(
            "input",
            {
              type: "checkbox",
              className: "sr-only",
              checked: e,
              disabled: t,
              onChange: a
            }
          ),
          /* @__PURE__ */ M.jsx(
            "div",
            {
              className: xe(
                "block rounded-full transition-colors duration-200 ease-in-out",
                n[s],
                e ? "bg-primary" : "bg-gray-200 dark:bg-gray-700",
                t && "cursor-not-allowed"
              )
            }
          ),
          /* @__PURE__ */ M.jsx(
            "div",
            {
              className: xe(
                "absolute rounded-full bg-white shadow-sm transition-transform duration-200 ease-in-out",
                o[s],
                e ? s === "sm" ? "translate-x-4" : s === "md" ? "translate-x-5" : "translate-x-7" : "translate-x-0.5",
                "top-1/2 -translate-y-1/2"
              )
            }
          )
        ] }),
        r && /* @__PURE__ */ M.jsx("span", { className: "ml-3 text-sm text-gray-700 dark:text-gray-300", children: r })
      ]
    }
  );
}, Rg = ({
  items: r,
  defaultActiveId: e,
  variant: t = "default",
  size: i = "md",
  className: s,
  tabListClassName: a,
  tabClassName: n,
  contentClassName: o,
  onChange: l
}) => {
  var p, f;
  const [c, h] = Ie(e || ((p = r[0]) == null ? void 0 : p.id) || ""), d = xt((x) => {
    h(x), l == null || l(x);
  }, [l]), u = () => {
    switch (i) {
      case "sm":
        return "text-sm px-3 py-1.5";
      case "lg":
        return "text-lg px-6 py-3";
      default:
        return "text-base px-4 py-2";
    }
  }, g = (x, m) => {
    const b = xe(
      "flex items-center space-x-2 transition-colors",
      "font-medium",
      u(),
      m && "opacity-50 cursor-not-allowed",
      !m && "cursor-pointer"
    );
    switch (t) {
      case "pills":
        return xe(
          b,
          "rounded-full",
          x ? "bg-primary text-white" : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
        );
      case "underline":
        return xe(
          b,
          "border-b-2",
          x ? "border-primary text-primary" : "border-transparent text-gray-600 dark:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"
        );
      default:
        return xe(
          b,
          "border-b-2",
          x ? "border-primary text-primary" : "border-transparent text-gray-600 dark:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"
        );
    }
  };
  return /* @__PURE__ */ M.jsxs("div", { className: xe("w-full", s), children: [
    /* @__PURE__ */ M.jsx(
      "div",
      {
        className: xe(
          "flex space-x-1 border-b border-gray-200 dark:border-gray-700",
          t === "pills" && "space-x-2 border-b-0",
          a
        ),
        children: r.map((x) => {
          const m = x.id === c, b = !!x.disabled;
          return /* @__PURE__ */ M.jsxs(
            "button",
            {
              onClick: () => !b && d(x.id),
              disabled: b,
              className: xe(
                g(m, b),
                n
              ),
              children: [
                x.icon && /* @__PURE__ */ M.jsx(
                  Ee,
                  {
                    icon: x.icon,
                    className: "w-5 h-5 flex-shrink-0"
                  }
                ),
                /* @__PURE__ */ M.jsx("span", { children: x.label })
              ]
            },
            x.id
          );
        })
      }
    ),
    /* @__PURE__ */ M.jsx("div", { className: xe("mt-4", o), children: (f = r.find((x) => x.id === c)) == null ? void 0 : f.content })
  ] });
}, Pg = ({
  variant: r = "p",
  children: e,
  className: t,
  as: i
}) => {
  const s = {
    h1: "text-4xl font-bold",
    h2: "text-3xl font-bold",
    h3: "text-2xl font-bold",
    h4: "text-xl font-bold",
    h5: "text-lg font-bold",
    h6: "text-base font-bold",
    p: "text-base",
    span: "text-base",
    label: "text-sm font-medium",
    heading3: "text-2xl font-bold",
    body1: "text-base",
    display1: "text-5xl font-bold",
    display2: "text-4xl font-bold",
    heading1: "text-4xl font-bold",
    heading2: "text-3xl font-bold",
    heading4: "text-xl font-bold",
    subtitle1: "text-lg font-medium",
    subtitle2: "text-base font-medium",
    body2: "text-sm",
    caption: "text-xs",
    value: "text-base font-medium"
  }, n = i || ((o) => {
    switch (o) {
      case "display1":
      case "display2":
      case "heading1":
      case "heading2":
      case "heading3":
      case "heading4":
        return "h" + o.slice(-1);
      case "body1":
      case "body2":
      case "subtitle1":
      case "subtitle2":
        return "p";
      case "caption":
      case "value":
        return "span";
      default:
        return o;
    }
  })(r);
  return /* @__PURE__ */ M.jsx(n, { className: ie("text-gray-900", s[r], t), children: e });
}, ou = gt(
  "rounded-md border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      fullWidth: !0
    }
  }
), lu = Ue(
  ({
    value: r,
    onChange: e,
    format: t = "12h",
    variant: i = "default",
    size: s = "md",
    disabled: a = !1,
    errorText: n,
    helperText: o,
    label: l,
    required: c = !1,
    labelPlacement: h = "top",
    fullWidth: d = !1,
    className: u,
    placeholder: g = "Select time",
    ...p
  }, f) => {
    const [x, m] = Ie(!1), [b, w] = Ie(r || null), [y, v] = Ie(0), [S, k] = Ie(0), [C, R] = Ie(!0), P = $e(null), A = $e(null), E = $e(null), N = () => {
      if (!x || !A.current || !E.current) return;
      const { bottom: F, left: D, width: Y } = A.current.getBoundingClientRect(), _ = E.current;
      Object.assign(_.style, {
        position: "fixed",
        left: `${D}px`,
        top: `${F + 4}px`,
        width: `${Y}px`,
        maxHeight: `${window.innerHeight - F - 8}px`
      });
    };
    ut(() => {
      const F = () => {
        x && N();
      }, D = () => {
        x && N();
      }, Y = (_) => {
        const H = _.target;
        P.current && !P.current.contains(H) && E.current && !E.current.contains(H) && m(!1);
      };
      return x && (N(), window.addEventListener("scroll", F, !0), window.addEventListener("resize", D)), document.addEventListener("click", Y), () => {
        window.removeEventListener("scroll", F, !0), window.removeEventListener("resize", D), document.removeEventListener("click", Y);
      };
    }, [x]);
    const O = () => {
      const D = `${(t === "12h" ? C ? y : y + 12 : y).toString().padStart(2, "0")}:${S.toString().padStart(2, "0")}`;
      w(D), e == null || e(D), m(!1);
    }, L = () => t === "12h" ? Array.from({ length: 12 }, (F, D) => D + 1) : Array.from({ length: 24 }, (F, D) => D), I = () => Array.from({ length: 60 }, (F, D) => D);
    return /* @__PURE__ */ M.jsxs("div", { ref: P, className: ie("relative", d && "w-full", u), children: [
      l && /* @__PURE__ */ M.jsxs(
        "label",
        {
          className: ie(
            "block text-sm font-medium text-gray-700 mb-1",
            h === "left" && "inline-block mr-2"
          ),
          children: [
            l,
            c && /* @__PURE__ */ M.jsx("span", { className: "text-red-500 ml-1", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ M.jsx("div", { ref: A, children: /* @__PURE__ */ M.jsx(
        "input",
        {
          ref: f,
          type: "text",
          value: b || "",
          placeholder: g,
          onClick: () => !a && m(!x),
          readOnly: !0,
          className: ie(ou({ variant: i, size: s, fullWidth: d })),
          disabled: a,
          ...p
        }
      ) }),
      x && Qt(
        /* @__PURE__ */ M.jsxs(
          "div",
          {
            ref: E,
            className: "fixed z-[9999] bg-white border border-neutral-200 rounded-md shadow-lg w-[280px]",
            children: [
              /* @__PURE__ */ M.jsx("div", { className: "p-4", children: /* @__PURE__ */ M.jsxs("div", { className: "flex flex-col gap-4", children: [
                /* @__PURE__ */ M.jsxs("div", { className: "flex justify-between text-sm font-medium text-neutral-900", children: [
                  /* @__PURE__ */ M.jsx("span", { children: "Hours" }),
                  /* @__PURE__ */ M.jsx("span", { children: "Minutes" }),
                  t === "12h" && /* @__PURE__ */ M.jsx("span", { children: "AM/PM" })
                ] }),
                /* @__PURE__ */ M.jsxs("div", { className: "flex justify-between gap-2", children: [
                  /* @__PURE__ */ M.jsx("div", { className: "w-20 h-[200px] overflow-y-auto scrollbar-thin scrollbar-thumb-neutral-200 scrollbar-track-neutral-50", children: L().map((F) => /* @__PURE__ */ M.jsx(
                    mt,
                    {
                      variant: y === F ? "primary" : "ghost",
                      size: "sm",
                      className: "w-full justify-center",
                      onClick: () => v(F),
                      children: F.toString().padStart(2, "0")
                    },
                    F
                  )) }),
                  /* @__PURE__ */ M.jsx("div", { className: "w-20 h-[200px] overflow-y-auto scrollbar-thin scrollbar-thumb-neutral-200 scrollbar-track-neutral-50", children: I().map((F) => /* @__PURE__ */ M.jsx(
                    mt,
                    {
                      variant: S === F ? "primary" : "ghost",
                      size: "sm",
                      className: "w-full justify-center",
                      onClick: () => k(F),
                      children: F.toString().padStart(2, "0")
                    },
                    F
                  )) }),
                  t === "12h" && /* @__PURE__ */ M.jsxs("div", { className: "w-20 flex flex-col gap-2", children: [
                    /* @__PURE__ */ M.jsx(
                      mt,
                      {
                        variant: C ? "primary" : "ghost",
                        size: "sm",
                        className: "w-full justify-center",
                        onClick: () => R(!0),
                        children: "AM"
                      }
                    ),
                    /* @__PURE__ */ M.jsx(
                      mt,
                      {
                        variant: C ? "ghost" : "primary",
                        size: "sm",
                        className: "w-full justify-center",
                        onClick: () => R(!1),
                        children: "PM"
                      }
                    )
                  ] })
                ] })
              ] }) }),
              /* @__PURE__ */ M.jsx("div", { className: "flex justify-end p-4 border-t border-neutral-200", children: /* @__PURE__ */ M.jsx(
                mt,
                {
                  variant: "primary",
                  size: "sm",
                  onClick: O,
                  children: "Select"
                }
              ) })
            ]
          }
        ),
        document.body
      ),
      n && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-sm text-red-500", children: n }),
      o && !n && /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-sm text-gray-500", children: o })
    ] });
  }
);
lu.displayName = "TimePicker";
const cu = gt(
  "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        primary: "bg-neutral-200 data-[state=checked]:bg-primary-500 focus-visible:ring-primary-500",
        success: "bg-neutral-200 data-[state=checked]:bg-success-500 focus-visible:ring-success-500",
        warning: "bg-neutral-200 data-[state=checked]:bg-warning-500 focus-visible:ring-warning-500",
        danger: "bg-neutral-200 data-[state=checked]:bg-danger-500 focus-visible:ring-danger-500"
      },
      size: {
        sm: "h-4 w-7",
        md: "h-6 w-11",
        lg: "h-7 w-14"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md"
    }
  }
), hu = gt(
  "pointer-events-none block rounded-full bg-white shadow-lg ring-0 transition-transform",
  {
    variants: {
      size: {
        sm: "h-3 w-3 data-[state=checked]:translate-x-3",
        md: "h-5 w-5 data-[state=checked]:translate-x-5",
        lg: "h-6 w-6 data-[state=checked]:translate-x-7"
      }
    },
    defaultVariants: {
      size: "md"
    }
  }
), du = Ue(
  ({
    checked: r = !1,
    onCheckedChange: e,
    variant: t = "primary",
    size: i = "md",
    label: s,
    required: a = !1,
    helperText: n,
    errorText: o,
    error: l = !1,
    className: c,
    ...h
  }, d) => {
    const u = Xe.useId(), g = `${u}-helper`, p = `${u}-error`;
    return /* @__PURE__ */ M.jsxs("div", { className: "inline-flex flex-col gap-1.5", children: [
      /* @__PURE__ */ M.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ M.jsx(
          "button",
          {
            type: "button",
            role: "switch",
            "aria-checked": r,
            "data-state": r ? "checked" : "unchecked",
            onClick: () => e == null ? void 0 : e(!r),
            ref: d,
            className: ie(cu({ variant: l ? "danger" : t, size: i }), c),
            "aria-describedby": l ? p : n ? g : void 0,
            "aria-invalid": l,
            "aria-required": a,
            ...h,
            children: /* @__PURE__ */ M.jsx(
              "span",
              {
                "data-state": r ? "checked" : "unchecked",
                className: ie(
                  hu({ size: i }),
                  r ? "translate-x-5" : "translate-x-1"
                )
              }
            )
          }
        ),
        s && /* @__PURE__ */ M.jsxs(
          "label",
          {
            htmlFor: u,
            className: "text-sm text-neutral-900",
            children: [
              s,
              a && /* @__PURE__ */ M.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
            ]
          }
        )
      ] }),
      l && o && /* @__PURE__ */ M.jsx("p", { className: "text-xs text-danger-500", id: p, children: o }),
      !l && n && /* @__PURE__ */ M.jsx("p", { className: "text-xs text-neutral-500", id: g, children: n })
    ] });
  }
);
du.displayName = "Toggle";
const Lg = ({
  content: r,
  children: e,
  position: t = "top",
  delay: i = 0,
  className: s
}) => {
  const [a, n] = Ie(!1), [o, l] = Ie({ top: 0, left: 0 }), c = $e(null), h = $e(null);
  let d;
  const u = () => {
    if (!c.current || !h.current) return;
    const f = h.current.getBoundingClientRect(), x = c.current.getBoundingClientRect();
    let m = 0, b = 0;
    switch (t) {
      case "top":
        m = f.top - x.height - 8, b = f.left + (f.width - x.width) / 2;
        break;
      case "bottom":
        m = f.bottom + 8, b = f.left + (f.width - x.width) / 2;
        break;
      case "left":
        m = f.top + (f.height - x.height) / 2, b = f.left - x.width - 8;
        break;
      case "right":
        m = f.top + (f.height - x.height) / 2, b = f.right + 8;
        break;
    }
    l({ top: m, left: b });
  };
  ut(() => (a && (u(), window.addEventListener("scroll", u), window.addEventListener("resize", u)), () => {
    window.removeEventListener("scroll", u), window.removeEventListener("resize", u);
  }), [a, t]);
  const g = () => {
    d = setTimeout(() => {
      n(!0);
    }, i);
  }, p = () => {
    clearTimeout(d), n(!1);
  };
  return /* @__PURE__ */ M.jsxs(
    "div",
    {
      ref: h,
      className: "relative inline-block",
      onMouseEnter: g,
      onMouseLeave: p,
      children: [
        e,
        a && /* @__PURE__ */ M.jsxs(
          "div",
          {
            ref: c,
            className: xe(
              "absolute z-50 px-3 py-2 text-sm text-white bg-gray-900 rounded-md shadow-lg",
              "transition-opacity duration-200",
              s
            ),
            style: {
              top: `${o.top}px`,
              left: `${o.left}px`
            },
            children: [
              r,
              /* @__PURE__ */ M.jsx(
                "div",
                {
                  className: xe(
                    "absolute w-2 h-2 bg-gray-900 transform rotate-45",
                    t === "top" && "bottom-[-4px] left-1/2 -translate-x-1/2",
                    t === "bottom" && "top-[-4px] left-1/2 -translate-x-1/2",
                    t === "left" && "right-[-4px] top-1/2 -translate-y-1/2",
                    t === "right" && "left-[-4px] top-1/2 -translate-y-1/2"
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}, uu = gt("flex items-center text-sm", {
  variants: {
    variant: {
      default: "text-neutral-600",
      light: "text-neutral-400",
      dark: "text-neutral-800"
    },
    size: {
      sm: "text-xs",
      md: "text-sm",
      lg: "text-base"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "md"
  }
}), gu = Ue(
  ({
    className: r,
    variant: e = "default",
    size: t = "md",
    items: i,
    separator: s = /* @__PURE__ */ M.jsx(vt, { icon: "mdi:slash-forward", className: "h-4 w-4 flex-shrink-0" }),
    activeLastItem: a = !0,
    ...n
  }, o) => /* @__PURE__ */ M.jsx(
    "nav",
    {
      ref: o,
      className: ie(uu({ variant: e, size: t }), r),
      "aria-label": "Breadcrumb",
      ...n,
      children: /* @__PURE__ */ M.jsx("ol", { className: "flex flex-wrap items-center gap-1.5", children: i.map((l, c) => {
        const h = c === i.length - 1, d = h && a;
        return /* @__PURE__ */ M.jsxs(
          "li",
          {
            className: ie(
              "flex items-center gap-1.5",
              d && "text-primary-500 font-medium"
            ),
            children: [
              l.icon && /* @__PURE__ */ M.jsx(
                vt,
                {
                  icon: l.icon,
                  className: ie(
                    "flex-shrink-0",
                    t === "sm" && "h-3.5 w-3.5",
                    t === "md" && "h-4 w-4",
                    t === "lg" && "h-5 w-5"
                  )
                }
              ),
              l.href && !d ? /* @__PURE__ */ M.jsx(
                "a",
                {
                  href: l.href,
                  className: ie(
                    "transition-colors duration-200",
                    "hover:text-primary-500 hover:underline focus:outline-none",
                    "focus-visible:text-primary-500 focus-visible:underline",
                    "active:text-primary-600"
                  ),
                  children: /* @__PURE__ */ M.jsx("span", { className: "truncate max-w-[200px] inline-block align-bottom", children: l.label })
                }
              ) : /* @__PURE__ */ M.jsx("span", { className: ie(
                "truncate max-w-[200px] inline-block",
                d && "text-primary-500"
              ), children: l.label }),
              !h && /* @__PURE__ */ M.jsx("span", { className: ie(
                "text-neutral-400 flex-shrink-0",
                t === "sm" && "scale-90",
                t === "lg" && "scale-110"
              ), children: s })
            ]
          },
          l.label
        );
      }) })
    }
  )
);
gu.displayName = "Breadcrumbs";
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function Ct(r, e) {
  return typeof r == "function" ? r(e) : r;
}
function et(r, e) {
  return (t) => {
    e.setState((i) => ({
      ...i,
      [r]: Ct(t, i[r])
    }));
  };
}
function ns(r) {
  return r instanceof Function;
}
function fu(r) {
  return Array.isArray(r) && r.every((e) => typeof e == "number");
}
function pu(r, e) {
  const t = [], i = (s) => {
    s.forEach((a) => {
      t.push(a);
      const n = e(a);
      n != null && n.length && i(n);
    });
  };
  return i(r), t;
}
function le(r, e, t) {
  let i = [], s;
  return (a) => {
    let n;
    t.key && t.debug && (n = Date.now());
    const o = r(a);
    if (!(o.length !== i.length || o.some((h, d) => i[d] !== h)))
      return s;
    i = o;
    let c;
    if (t.key && t.debug && (c = Date.now()), s = e(...o), t == null || t.onChange == null || t.onChange(s), t.key && t.debug && t != null && t.debug()) {
      const h = Math.round((Date.now() - n) * 100) / 100, d = Math.round((Date.now() - c) * 100) / 100, u = d / 16, g = (p, f) => {
        for (p = String(p); p.length < f; )
          p = " " + p;
        return p;
      };
      console.info(`%c⏱ ${g(d, 5)} /${g(h, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * u, 120))}deg 100% 31%);`, t == null ? void 0 : t.key);
    }
    return s;
  };
}
function ce(r, e, t, i) {
  return {
    debug: () => {
      var s;
      return (s = r == null ? void 0 : r.debugAll) != null ? s : r[e];
    },
    key: process.env.NODE_ENV === "development" && t,
    onChange: i
  };
}
function xu(r, e, t, i) {
  const s = () => {
    var n;
    return (n = a.getValue()) != null ? n : r.options.renderFallbackValue;
  }, a = {
    id: `${e.id}_${t.id}`,
    row: e,
    column: t,
    getValue: () => e.getValue(i),
    renderValue: s,
    getContext: le(() => [r, t, e, a], (n, o, l, c) => ({
      table: n,
      column: o,
      row: l,
      cell: c,
      getValue: c.getValue,
      renderValue: c.renderValue
    }), ce(r.options, "debugCells", "cell.getContext"))
  };
  return r._features.forEach((n) => {
    n.createCell == null || n.createCell(a, t, e, r);
  }, {}), a;
}
function mu(r, e, t, i) {
  var s, a;
  const o = {
    ...r._getDefaultColumnDef(),
    ...e
  }, l = o.accessorKey;
  let c = (s = (a = o.id) != null ? a : l ? typeof String.prototype.replaceAll == "function" ? l.replaceAll(".", "_") : l.replace(/\./g, "_") : void 0) != null ? s : typeof o.header == "string" ? o.header : void 0, h;
  if (o.accessorFn ? h = o.accessorFn : l && (l.includes(".") ? h = (u) => {
    let g = u;
    for (const f of l.split(".")) {
      var p;
      g = (p = g) == null ? void 0 : p[f], process.env.NODE_ENV !== "production" && g === void 0 && console.warn(`"${f}" in deeply nested key "${l}" returned undefined.`);
    }
    return g;
  } : h = (u) => u[o.accessorKey]), !c)
    throw process.env.NODE_ENV !== "production" ? new Error(o.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header") : new Error();
  let d = {
    id: `${String(c)}`,
    accessorFn: h,
    parent: i,
    depth: t,
    columnDef: o,
    columns: [],
    getFlatColumns: le(() => [!0], () => {
      var u;
      return [d, ...(u = d.columns) == null ? void 0 : u.flatMap((g) => g.getFlatColumns())];
    }, ce(r.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: le(() => [r._getOrderColumnsFn()], (u) => {
      var g;
      if ((g = d.columns) != null && g.length) {
        let p = d.columns.flatMap((f) => f.getLeafColumns());
        return u(p);
      }
      return [d];
    }, ce(r.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const u of r._features)
    u.createColumn == null || u.createColumn(d, r);
  return d;
}
const We = "debugHeaders";
function gn(r, e, t) {
  var i;
  let a = {
    id: (i = t.id) != null ? i : e.id,
    column: e,
    index: t.index,
    isPlaceholder: !!t.isPlaceholder,
    placeholderId: t.placeholderId,
    depth: t.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const n = [], o = (l) => {
        l.subHeaders && l.subHeaders.length && l.subHeaders.map(o), n.push(l);
      };
      return o(a), n;
    },
    getContext: () => ({
      table: r,
      header: a,
      column: e
    })
  };
  return r._features.forEach((n) => {
    n.createHeader == null || n.createHeader(a, r);
  }), a;
}
const bu = {
  createTable: (r) => {
    r.getHeaderGroups = le(() => [r.getAllColumns(), r.getVisibleLeafColumns(), r.getState().columnPinning.left, r.getState().columnPinning.right], (e, t, i, s) => {
      var a, n;
      const o = (a = i == null ? void 0 : i.map((d) => t.find((u) => u.id === d)).filter(Boolean)) != null ? a : [], l = (n = s == null ? void 0 : s.map((d) => t.find((u) => u.id === d)).filter(Boolean)) != null ? n : [], c = t.filter((d) => !(i != null && i.includes(d.id)) && !(s != null && s.includes(d.id)));
      return Hi(e, [...o, ...c, ...l], r);
    }, ce(r.options, We, "getHeaderGroups")), r.getCenterHeaderGroups = le(() => [r.getAllColumns(), r.getVisibleLeafColumns(), r.getState().columnPinning.left, r.getState().columnPinning.right], (e, t, i, s) => (t = t.filter((a) => !(i != null && i.includes(a.id)) && !(s != null && s.includes(a.id))), Hi(e, t, r, "center")), ce(r.options, We, "getCenterHeaderGroups")), r.getLeftHeaderGroups = le(() => [r.getAllColumns(), r.getVisibleLeafColumns(), r.getState().columnPinning.left], (e, t, i) => {
      var s;
      const a = (s = i == null ? void 0 : i.map((n) => t.find((o) => o.id === n)).filter(Boolean)) != null ? s : [];
      return Hi(e, a, r, "left");
    }, ce(r.options, We, "getLeftHeaderGroups")), r.getRightHeaderGroups = le(() => [r.getAllColumns(), r.getVisibleLeafColumns(), r.getState().columnPinning.right], (e, t, i) => {
      var s;
      const a = (s = i == null ? void 0 : i.map((n) => t.find((o) => o.id === n)).filter(Boolean)) != null ? s : [];
      return Hi(e, a, r, "right");
    }, ce(r.options, We, "getRightHeaderGroups")), r.getFooterGroups = le(() => [r.getHeaderGroups()], (e) => [...e].reverse(), ce(r.options, We, "getFooterGroups")), r.getLeftFooterGroups = le(() => [r.getLeftHeaderGroups()], (e) => [...e].reverse(), ce(r.options, We, "getLeftFooterGroups")), r.getCenterFooterGroups = le(() => [r.getCenterHeaderGroups()], (e) => [...e].reverse(), ce(r.options, We, "getCenterFooterGroups")), r.getRightFooterGroups = le(() => [r.getRightHeaderGroups()], (e) => [...e].reverse(), ce(r.options, We, "getRightFooterGroups")), r.getFlatHeaders = le(() => [r.getHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(r.options, We, "getFlatHeaders")), r.getLeftFlatHeaders = le(() => [r.getLeftHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(r.options, We, "getLeftFlatHeaders")), r.getCenterFlatHeaders = le(() => [r.getCenterHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(r.options, We, "getCenterFlatHeaders")), r.getRightFlatHeaders = le(() => [r.getRightHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(r.options, We, "getRightFlatHeaders")), r.getCenterLeafHeaders = le(() => [r.getCenterFlatHeaders()], (e) => e.filter((t) => {
      var i;
      return !((i = t.subHeaders) != null && i.length);
    }), ce(r.options, We, "getCenterLeafHeaders")), r.getLeftLeafHeaders = le(() => [r.getLeftFlatHeaders()], (e) => e.filter((t) => {
      var i;
      return !((i = t.subHeaders) != null && i.length);
    }), ce(r.options, We, "getLeftLeafHeaders")), r.getRightLeafHeaders = le(() => [r.getRightFlatHeaders()], (e) => e.filter((t) => {
      var i;
      return !((i = t.subHeaders) != null && i.length);
    }), ce(r.options, We, "getRightLeafHeaders")), r.getLeafHeaders = le(() => [r.getLeftHeaderGroups(), r.getCenterHeaderGroups(), r.getRightHeaderGroups()], (e, t, i) => {
      var s, a, n, o, l, c;
      return [...(s = (a = e[0]) == null ? void 0 : a.headers) != null ? s : [], ...(n = (o = t[0]) == null ? void 0 : o.headers) != null ? n : [], ...(l = (c = i[0]) == null ? void 0 : c.headers) != null ? l : []].map((h) => h.getLeafHeaders()).flat();
    }, ce(r.options, We, "getLeafHeaders"));
  }
};
function Hi(r, e, t, i) {
  var s, a;
  let n = 0;
  const o = function(u, g) {
    g === void 0 && (g = 1), n = Math.max(n, g), u.filter((p) => p.getIsVisible()).forEach((p) => {
      var f;
      (f = p.columns) != null && f.length && o(p.columns, g + 1);
    }, 0);
  };
  o(r);
  let l = [];
  const c = (u, g) => {
    const p = {
      depth: g,
      id: [i, `${g}`].filter(Boolean).join("_"),
      headers: []
    }, f = [];
    u.forEach((x) => {
      const m = [...f].reverse()[0], b = x.column.depth === p.depth;
      let w, y = !1;
      if (b && x.column.parent ? w = x.column.parent : (w = x.column, y = !0), m && (m == null ? void 0 : m.column) === w)
        m.subHeaders.push(x);
      else {
        const v = gn(t, w, {
          id: [i, g, w.id, x == null ? void 0 : x.id].filter(Boolean).join("_"),
          isPlaceholder: y,
          placeholderId: y ? `${f.filter((S) => S.column === w).length}` : void 0,
          depth: g,
          index: f.length
        });
        v.subHeaders.push(x), f.push(v);
      }
      p.headers.push(x), x.headerGroup = p;
    }), l.push(p), g > 0 && c(f, g - 1);
  }, h = e.map((u, g) => gn(t, u, {
    depth: n,
    index: g
  }));
  c(h, n - 1), l.reverse();
  const d = (u) => u.filter((p) => p.column.getIsVisible()).map((p) => {
    let f = 0, x = 0, m = [0];
    p.subHeaders && p.subHeaders.length ? (m = [], d(p.subHeaders).forEach((w) => {
      let {
        colSpan: y,
        rowSpan: v
      } = w;
      f += y, m.push(v);
    })) : f = 1;
    const b = Math.min(...m);
    return x = x + b, p.colSpan = f, p.rowSpan = x, {
      colSpan: f,
      rowSpan: x
    };
  });
  return d((s = (a = l[0]) == null ? void 0 : a.headers) != null ? s : []), l;
}
const vu = (r, e, t, i, s, a, n) => {
  let o = {
    id: e,
    index: i,
    original: t,
    depth: s,
    parentId: n,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (l) => {
      if (o._valuesCache.hasOwnProperty(l))
        return o._valuesCache[l];
      const c = r.getColumn(l);
      if (c != null && c.accessorFn)
        return o._valuesCache[l] = c.accessorFn(o.original, i), o._valuesCache[l];
    },
    getUniqueValues: (l) => {
      if (o._uniqueValuesCache.hasOwnProperty(l))
        return o._uniqueValuesCache[l];
      const c = r.getColumn(l);
      if (c != null && c.accessorFn)
        return c.columnDef.getUniqueValues ? (o._uniqueValuesCache[l] = c.columnDef.getUniqueValues(o.original, i), o._uniqueValuesCache[l]) : (o._uniqueValuesCache[l] = [o.getValue(l)], o._uniqueValuesCache[l]);
    },
    renderValue: (l) => {
      var c;
      return (c = o.getValue(l)) != null ? c : r.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => pu(o.subRows, (l) => l.subRows),
    getParentRow: () => o.parentId ? r.getRow(o.parentId, !0) : void 0,
    getParentRows: () => {
      let l = [], c = o;
      for (; ; ) {
        const h = c.getParentRow();
        if (!h) break;
        l.push(h), c = h;
      }
      return l.reverse();
    },
    getAllCells: le(() => [r.getAllLeafColumns()], (l) => l.map((c) => xu(r, o, c, c.id)), ce(r.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: le(() => [o.getAllCells()], (l) => l.reduce((c, h) => (c[h.column.id] = h, c), {}), ce(r.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let l = 0; l < r._features.length; l++) {
    const c = r._features[l];
    c == null || c.createRow == null || c.createRow(o, r);
  }
  return o;
}, yu = {
  createColumn: (r, e) => {
    r._getFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, r.id), r.getFacetedRowModel = () => r._getFacetedRowModel ? r._getFacetedRowModel() : e.getPreFilteredRowModel(), r._getFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, r.id), r.getFacetedUniqueValues = () => r._getFacetedUniqueValues ? r._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), r._getFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, r.id), r.getFacetedMinMaxValues = () => {
      if (r._getFacetedMinMaxValues)
        return r._getFacetedMinMaxValues();
    };
  }
}, Xo = (r, e, t) => {
  var i, s;
  const a = t == null || (i = t.toString()) == null ? void 0 : i.toLowerCase();
  return !!(!((s = r.getValue(e)) == null || (s = s.toString()) == null || (s = s.toLowerCase()) == null) && s.includes(a));
};
Xo.autoRemove = (r) => dt(r);
const Bo = (r, e, t) => {
  var i;
  return !!(!((i = r.getValue(e)) == null || (i = i.toString()) == null) && i.includes(t));
};
Bo.autoRemove = (r) => dt(r);
const Wo = (r, e, t) => {
  var i;
  return ((i = r.getValue(e)) == null || (i = i.toString()) == null ? void 0 : i.toLowerCase()) === (t == null ? void 0 : t.toLowerCase());
};
Wo.autoRemove = (r) => dt(r);
const Vo = (r, e, t) => {
  var i;
  return (i = r.getValue(e)) == null ? void 0 : i.includes(t);
};
Vo.autoRemove = (r) => dt(r);
const Go = (r, e, t) => !t.some((i) => {
  var s;
  return !((s = r.getValue(e)) != null && s.includes(i));
});
Go.autoRemove = (r) => dt(r) || !(r != null && r.length);
const $o = (r, e, t) => t.some((i) => {
  var s;
  return (s = r.getValue(e)) == null ? void 0 : s.includes(i);
});
$o.autoRemove = (r) => dt(r) || !(r != null && r.length);
const Uo = (r, e, t) => r.getValue(e) === t;
Uo.autoRemove = (r) => dt(r);
const qo = (r, e, t) => r.getValue(e) == t;
qo.autoRemove = (r) => dt(r);
const Qr = (r, e, t) => {
  let [i, s] = t;
  const a = r.getValue(e);
  return a >= i && a <= s;
};
Qr.resolveFilterValue = (r) => {
  let [e, t] = r, i = typeof e != "number" ? parseFloat(e) : e, s = typeof t != "number" ? parseFloat(t) : t, a = e === null || Number.isNaN(i) ? -1 / 0 : i, n = t === null || Number.isNaN(s) ? 1 / 0 : s;
  if (a > n) {
    const o = a;
    a = n, n = o;
  }
  return [a, n];
};
Qr.autoRemove = (r) => dt(r) || dt(r[0]) && dt(r[1]);
const pt = {
  includesString: Xo,
  includesStringSensitive: Bo,
  equalsString: Wo,
  arrIncludes: Vo,
  arrIncludesAll: Go,
  arrIncludesSome: $o,
  equals: Uo,
  weakEquals: qo,
  inNumberRange: Qr
};
function dt(r) {
  return r == null || r === "";
}
const wu = {
  getDefaultColumnDef: () => ({
    filterFn: "auto"
  }),
  getInitialState: (r) => ({
    columnFilters: [],
    ...r
  }),
  getDefaultOptions: (r) => ({
    onColumnFiltersChange: et("columnFilters", r),
    filterFromLeafRows: !1,
    maxLeafRowFilterDepth: 100
  }),
  createColumn: (r, e) => {
    r.getAutoFilterFn = () => {
      const t = e.getCoreRowModel().flatRows[0], i = t == null ? void 0 : t.getValue(r.id);
      return typeof i == "string" ? pt.includesString : typeof i == "number" ? pt.inNumberRange : typeof i == "boolean" || i !== null && typeof i == "object" ? pt.equals : Array.isArray(i) ? pt.arrIncludes : pt.weakEquals;
    }, r.getFilterFn = () => {
      var t, i;
      return ns(r.columnDef.filterFn) ? r.columnDef.filterFn : r.columnDef.filterFn === "auto" ? r.getAutoFilterFn() : (
        // @ts-ignore
        (t = (i = e.options.filterFns) == null ? void 0 : i[r.columnDef.filterFn]) != null ? t : pt[r.columnDef.filterFn]
      );
    }, r.getCanFilter = () => {
      var t, i, s;
      return ((t = r.columnDef.enableColumnFilter) != null ? t : !0) && ((i = e.options.enableColumnFilters) != null ? i : !0) && ((s = e.options.enableFilters) != null ? s : !0) && !!r.accessorFn;
    }, r.getIsFiltered = () => r.getFilterIndex() > -1, r.getFilterValue = () => {
      var t;
      return (t = e.getState().columnFilters) == null || (t = t.find((i) => i.id === r.id)) == null ? void 0 : t.value;
    }, r.getFilterIndex = () => {
      var t, i;
      return (t = (i = e.getState().columnFilters) == null ? void 0 : i.findIndex((s) => s.id === r.id)) != null ? t : -1;
    }, r.setFilterValue = (t) => {
      e.setColumnFilters((i) => {
        const s = r.getFilterFn(), a = i == null ? void 0 : i.find((h) => h.id === r.id), n = Ct(t, a ? a.value : void 0);
        if (fn(s, n, r)) {
          var o;
          return (o = i == null ? void 0 : i.filter((h) => h.id !== r.id)) != null ? o : [];
        }
        const l = {
          id: r.id,
          value: n
        };
        if (a) {
          var c;
          return (c = i == null ? void 0 : i.map((h) => h.id === r.id ? l : h)) != null ? c : [];
        }
        return i != null && i.length ? [...i, l] : [l];
      });
    };
  },
  createRow: (r, e) => {
    r.columnFilters = {}, r.columnFiltersMeta = {};
  },
  createTable: (r) => {
    r.setColumnFilters = (e) => {
      const t = r.getAllLeafColumns(), i = (s) => {
        var a;
        return (a = Ct(e, s)) == null ? void 0 : a.filter((n) => {
          const o = t.find((l) => l.id === n.id);
          if (o) {
            const l = o.getFilterFn();
            if (fn(l, n.value, o))
              return !1;
          }
          return !0;
        });
      };
      r.options.onColumnFiltersChange == null || r.options.onColumnFiltersChange(i);
    }, r.resetColumnFilters = (e) => {
      var t, i;
      r.setColumnFilters(e ? [] : (t = (i = r.initialState) == null ? void 0 : i.columnFilters) != null ? t : []);
    }, r.getPreFilteredRowModel = () => r.getCoreRowModel(), r.getFilteredRowModel = () => (!r._getFilteredRowModel && r.options.getFilteredRowModel && (r._getFilteredRowModel = r.options.getFilteredRowModel(r)), r.options.manualFiltering || !r._getFilteredRowModel ? r.getPreFilteredRowModel() : r._getFilteredRowModel());
  }
};
function fn(r, e, t) {
  return (r && r.autoRemove ? r.autoRemove(e, t) : !1) || typeof e > "u" || typeof e == "string" && !e;
}
const Su = (r, e, t) => t.reduce((i, s) => {
  const a = s.getValue(r);
  return i + (typeof a == "number" ? a : 0);
}, 0), ku = (r, e, t) => {
  let i;
  return t.forEach((s) => {
    const a = s.getValue(r);
    a != null && (i > a || i === void 0 && a >= a) && (i = a);
  }), i;
}, Cu = (r, e, t) => {
  let i;
  return t.forEach((s) => {
    const a = s.getValue(r);
    a != null && (i < a || i === void 0 && a >= a) && (i = a);
  }), i;
}, Au = (r, e, t) => {
  let i, s;
  return t.forEach((a) => {
    const n = a.getValue(r);
    n != null && (i === void 0 ? n >= n && (i = s = n) : (i > n && (i = n), s < n && (s = n)));
  }), [i, s];
}, Mu = (r, e) => {
  let t = 0, i = 0;
  if (e.forEach((s) => {
    let a = s.getValue(r);
    a != null && (a = +a) >= a && (++t, i += a);
  }), t) return i / t;
}, Ru = (r, e) => {
  if (!e.length)
    return;
  const t = e.map((a) => a.getValue(r));
  if (!fu(t))
    return;
  if (t.length === 1)
    return t[0];
  const i = Math.floor(t.length / 2), s = t.sort((a, n) => a - n);
  return t.length % 2 !== 0 ? s[i] : (s[i - 1] + s[i]) / 2;
}, Pu = (r, e) => Array.from(new Set(e.map((t) => t.getValue(r))).values()), Lu = (r, e) => new Set(e.map((t) => t.getValue(r))).size, Iu = (r, e) => e.length, Xs = {
  sum: Su,
  min: ku,
  max: Cu,
  extent: Au,
  mean: Mu,
  median: Ru,
  unique: Pu,
  uniqueCount: Lu,
  count: Iu
}, Eu = {
  getDefaultColumnDef: () => ({
    aggregatedCell: (r) => {
      var e, t;
      return (e = (t = r.getValue()) == null || t.toString == null ? void 0 : t.toString()) != null ? e : null;
    },
    aggregationFn: "auto"
  }),
  getInitialState: (r) => ({
    grouping: [],
    ...r
  }),
  getDefaultOptions: (r) => ({
    onGroupingChange: et("grouping", r),
    groupedColumnMode: "reorder"
  }),
  createColumn: (r, e) => {
    r.toggleGrouping = () => {
      e.setGrouping((t) => t != null && t.includes(r.id) ? t.filter((i) => i !== r.id) : [...t ?? [], r.id]);
    }, r.getCanGroup = () => {
      var t, i;
      return ((t = r.columnDef.enableGrouping) != null ? t : !0) && ((i = e.options.enableGrouping) != null ? i : !0) && (!!r.accessorFn || !!r.columnDef.getGroupingValue);
    }, r.getIsGrouped = () => {
      var t;
      return (t = e.getState().grouping) == null ? void 0 : t.includes(r.id);
    }, r.getGroupedIndex = () => {
      var t;
      return (t = e.getState().grouping) == null ? void 0 : t.indexOf(r.id);
    }, r.getToggleGroupingHandler = () => {
      const t = r.getCanGroup();
      return () => {
        t && r.toggleGrouping();
      };
    }, r.getAutoAggregationFn = () => {
      const t = e.getCoreRowModel().flatRows[0], i = t == null ? void 0 : t.getValue(r.id);
      if (typeof i == "number")
        return Xs.sum;
      if (Object.prototype.toString.call(i) === "[object Date]")
        return Xs.extent;
    }, r.getAggregationFn = () => {
      var t, i;
      if (!r)
        throw new Error();
      return ns(r.columnDef.aggregationFn) ? r.columnDef.aggregationFn : r.columnDef.aggregationFn === "auto" ? r.getAutoAggregationFn() : (t = (i = e.options.aggregationFns) == null ? void 0 : i[r.columnDef.aggregationFn]) != null ? t : Xs[r.columnDef.aggregationFn];
    };
  },
  createTable: (r) => {
    r.setGrouping = (e) => r.options.onGroupingChange == null ? void 0 : r.options.onGroupingChange(e), r.resetGrouping = (e) => {
      var t, i;
      r.setGrouping(e ? [] : (t = (i = r.initialState) == null ? void 0 : i.grouping) != null ? t : []);
    }, r.getPreGroupedRowModel = () => r.getFilteredRowModel(), r.getGroupedRowModel = () => (!r._getGroupedRowModel && r.options.getGroupedRowModel && (r._getGroupedRowModel = r.options.getGroupedRowModel(r)), r.options.manualGrouping || !r._getGroupedRowModel ? r.getPreGroupedRowModel() : r._getGroupedRowModel());
  },
  createRow: (r, e) => {
    r.getIsGrouped = () => !!r.groupingColumnId, r.getGroupingValue = (t) => {
      if (r._groupingValuesCache.hasOwnProperty(t))
        return r._groupingValuesCache[t];
      const i = e.getColumn(t);
      return i != null && i.columnDef.getGroupingValue ? (r._groupingValuesCache[t] = i.columnDef.getGroupingValue(r.original), r._groupingValuesCache[t]) : r.getValue(t);
    }, r._groupingValuesCache = {};
  },
  createCell: (r, e, t, i) => {
    r.getIsGrouped = () => e.getIsGrouped() && e.id === t.groupingColumnId, r.getIsPlaceholder = () => !r.getIsGrouped() && e.getIsGrouped(), r.getIsAggregated = () => {
      var s;
      return !r.getIsGrouped() && !r.getIsPlaceholder() && !!((s = t.subRows) != null && s.length);
    };
  }
};
function Tu(r, e, t) {
  if (!(e != null && e.length) || !t)
    return r;
  const i = r.filter((a) => !e.includes(a.id));
  return t === "remove" ? i : [...e.map((a) => r.find((n) => n.id === a)).filter(Boolean), ...i];
}
const _u = {
  getInitialState: (r) => ({
    columnOrder: [],
    ...r
  }),
  getDefaultOptions: (r) => ({
    onColumnOrderChange: et("columnOrder", r)
  }),
  createColumn: (r, e) => {
    r.getIndex = le((t) => [bi(e, t)], (t) => t.findIndex((i) => i.id === r.id), ce(e.options, "debugColumns", "getIndex")), r.getIsFirstColumn = (t) => {
      var i;
      return ((i = bi(e, t)[0]) == null ? void 0 : i.id) === r.id;
    }, r.getIsLastColumn = (t) => {
      var i;
      const s = bi(e, t);
      return ((i = s[s.length - 1]) == null ? void 0 : i.id) === r.id;
    };
  },
  createTable: (r) => {
    r.setColumnOrder = (e) => r.options.onColumnOrderChange == null ? void 0 : r.options.onColumnOrderChange(e), r.resetColumnOrder = (e) => {
      var t;
      r.setColumnOrder(e ? [] : (t = r.initialState.columnOrder) != null ? t : []);
    }, r._getOrderColumnsFn = le(() => [r.getState().columnOrder, r.getState().grouping, r.options.groupedColumnMode], (e, t, i) => (s) => {
      let a = [];
      if (!(e != null && e.length))
        a = s;
      else {
        const n = [...e], o = [...s];
        for (; o.length && n.length; ) {
          const l = n.shift(), c = o.findIndex((h) => h.id === l);
          c > -1 && a.push(o.splice(c, 1)[0]);
        }
        a = [...a, ...o];
      }
      return Tu(a, t, i);
    }, ce(r.options, "debugTable", "_getOrderColumnsFn"));
  }
}, Bs = () => ({
  left: [],
  right: []
}), Ou = {
  getInitialState: (r) => ({
    columnPinning: Bs(),
    ...r
  }),
  getDefaultOptions: (r) => ({
    onColumnPinningChange: et("columnPinning", r)
  }),
  createColumn: (r, e) => {
    r.pin = (t) => {
      const i = r.getLeafColumns().map((s) => s.id).filter(Boolean);
      e.setColumnPinning((s) => {
        var a, n;
        if (t === "right") {
          var o, l;
          return {
            left: ((o = s == null ? void 0 : s.left) != null ? o : []).filter((d) => !(i != null && i.includes(d))),
            right: [...((l = s == null ? void 0 : s.right) != null ? l : []).filter((d) => !(i != null && i.includes(d))), ...i]
          };
        }
        if (t === "left") {
          var c, h;
          return {
            left: [...((c = s == null ? void 0 : s.left) != null ? c : []).filter((d) => !(i != null && i.includes(d))), ...i],
            right: ((h = s == null ? void 0 : s.right) != null ? h : []).filter((d) => !(i != null && i.includes(d)))
          };
        }
        return {
          left: ((a = s == null ? void 0 : s.left) != null ? a : []).filter((d) => !(i != null && i.includes(d))),
          right: ((n = s == null ? void 0 : s.right) != null ? n : []).filter((d) => !(i != null && i.includes(d)))
        };
      });
    }, r.getCanPin = () => r.getLeafColumns().some((i) => {
      var s, a, n;
      return ((s = i.columnDef.enablePinning) != null ? s : !0) && ((a = (n = e.options.enableColumnPinning) != null ? n : e.options.enablePinning) != null ? a : !0);
    }), r.getIsPinned = () => {
      const t = r.getLeafColumns().map((o) => o.id), {
        left: i,
        right: s
      } = e.getState().columnPinning, a = t.some((o) => i == null ? void 0 : i.includes(o)), n = t.some((o) => s == null ? void 0 : s.includes(o));
      return a ? "left" : n ? "right" : !1;
    }, r.getPinnedIndex = () => {
      var t, i;
      const s = r.getIsPinned();
      return s ? (t = (i = e.getState().columnPinning) == null || (i = i[s]) == null ? void 0 : i.indexOf(r.id)) != null ? t : -1 : 0;
    };
  },
  createRow: (r, e) => {
    r.getCenterVisibleCells = le(() => [r._getAllVisibleCells(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, i, s) => {
      const a = [...i ?? [], ...s ?? []];
      return t.filter((n) => !a.includes(n.column.id));
    }, ce(e.options, "debugRows", "getCenterVisibleCells")), r.getLeftVisibleCells = le(() => [r._getAllVisibleCells(), e.getState().columnPinning.left], (t, i) => (i ?? []).map((a) => t.find((n) => n.column.id === a)).filter(Boolean).map((a) => ({
      ...a,
      position: "left"
    })), ce(e.options, "debugRows", "getLeftVisibleCells")), r.getRightVisibleCells = le(() => [r._getAllVisibleCells(), e.getState().columnPinning.right], (t, i) => (i ?? []).map((a) => t.find((n) => n.column.id === a)).filter(Boolean).map((a) => ({
      ...a,
      position: "right"
    })), ce(e.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (r) => {
    r.setColumnPinning = (e) => r.options.onColumnPinningChange == null ? void 0 : r.options.onColumnPinningChange(e), r.resetColumnPinning = (e) => {
      var t, i;
      return r.setColumnPinning(e ? Bs() : (t = (i = r.initialState) == null ? void 0 : i.columnPinning) != null ? t : Bs());
    }, r.getIsSomeColumnsPinned = (e) => {
      var t;
      const i = r.getState().columnPinning;
      if (!e) {
        var s, a;
        return !!((s = i.left) != null && s.length || (a = i.right) != null && a.length);
      }
      return !!((t = i[e]) != null && t.length);
    }, r.getLeftLeafColumns = le(() => [r.getAllLeafColumns(), r.getState().columnPinning.left], (e, t) => (t ?? []).map((i) => e.find((s) => s.id === i)).filter(Boolean), ce(r.options, "debugColumns", "getLeftLeafColumns")), r.getRightLeafColumns = le(() => [r.getAllLeafColumns(), r.getState().columnPinning.right], (e, t) => (t ?? []).map((i) => e.find((s) => s.id === i)).filter(Boolean), ce(r.options, "debugColumns", "getRightLeafColumns")), r.getCenterLeafColumns = le(() => [r.getAllLeafColumns(), r.getState().columnPinning.left, r.getState().columnPinning.right], (e, t, i) => {
      const s = [...t ?? [], ...i ?? []];
      return e.filter((a) => !s.includes(a.id));
    }, ce(r.options, "debugColumns", "getCenterLeafColumns"));
  }
};
function zu(r) {
  return r || (typeof document < "u" ? document : null);
}
const Yi = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
}, Ws = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: !1,
  columnSizingStart: []
}), Fu = {
  getDefaultColumnDef: () => Yi,
  getInitialState: (r) => ({
    columnSizing: {},
    columnSizingInfo: Ws(),
    ...r
  }),
  getDefaultOptions: (r) => ({
    columnResizeMode: "onEnd",
    columnResizeDirection: "ltr",
    onColumnSizingChange: et("columnSizing", r),
    onColumnSizingInfoChange: et("columnSizingInfo", r)
  }),
  createColumn: (r, e) => {
    r.getSize = () => {
      var t, i, s;
      const a = e.getState().columnSizing[r.id];
      return Math.min(Math.max((t = r.columnDef.minSize) != null ? t : Yi.minSize, (i = a ?? r.columnDef.size) != null ? i : Yi.size), (s = r.columnDef.maxSize) != null ? s : Yi.maxSize);
    }, r.getStart = le((t) => [t, bi(e, t), e.getState().columnSizing], (t, i) => i.slice(0, r.getIndex(t)).reduce((s, a) => s + a.getSize(), 0), ce(e.options, "debugColumns", "getStart")), r.getAfter = le((t) => [t, bi(e, t), e.getState().columnSizing], (t, i) => i.slice(r.getIndex(t) + 1).reduce((s, a) => s + a.getSize(), 0), ce(e.options, "debugColumns", "getAfter")), r.resetSize = () => {
      e.setColumnSizing((t) => {
        let {
          [r.id]: i,
          ...s
        } = t;
        return s;
      });
    }, r.getCanResize = () => {
      var t, i;
      return ((t = r.columnDef.enableResizing) != null ? t : !0) && ((i = e.options.enableColumnResizing) != null ? i : !0);
    }, r.getIsResizing = () => e.getState().columnSizingInfo.isResizingColumn === r.id;
  },
  createHeader: (r, e) => {
    r.getSize = () => {
      let t = 0;
      const i = (s) => {
        if (s.subHeaders.length)
          s.subHeaders.forEach(i);
        else {
          var a;
          t += (a = s.column.getSize()) != null ? a : 0;
        }
      };
      return i(r), t;
    }, r.getStart = () => {
      if (r.index > 0) {
        const t = r.headerGroup.headers[r.index - 1];
        return t.getStart() + t.getSize();
      }
      return 0;
    }, r.getResizeHandler = (t) => {
      const i = e.getColumn(r.column.id), s = i == null ? void 0 : i.getCanResize();
      return (a) => {
        if (!i || !s || (a.persist == null || a.persist(), Vs(a) && a.touches && a.touches.length > 1))
          return;
        const n = r.getSize(), o = r ? r.getLeafHeaders().map((m) => [m.column.id, m.column.getSize()]) : [[i.id, i.getSize()]], l = Vs(a) ? Math.round(a.touches[0].clientX) : a.clientX, c = {}, h = (m, b) => {
          typeof b == "number" && (e.setColumnSizingInfo((w) => {
            var y, v;
            const S = e.options.columnResizeDirection === "rtl" ? -1 : 1, k = (b - ((y = w == null ? void 0 : w.startOffset) != null ? y : 0)) * S, C = Math.max(k / ((v = w == null ? void 0 : w.startSize) != null ? v : 0), -0.999999);
            return w.columnSizingStart.forEach((R) => {
              let [P, A] = R;
              c[P] = Math.round(Math.max(A + A * C, 0) * 100) / 100;
            }), {
              ...w,
              deltaOffset: k,
              deltaPercentage: C
            };
          }), (e.options.columnResizeMode === "onChange" || m === "end") && e.setColumnSizing((w) => ({
            ...w,
            ...c
          })));
        }, d = (m) => h("move", m), u = (m) => {
          h("end", m), e.setColumnSizingInfo((b) => ({
            ...b,
            isResizingColumn: !1,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        }, g = zu(t), p = {
          moveHandler: (m) => d(m.clientX),
          upHandler: (m) => {
            g == null || g.removeEventListener("mousemove", p.moveHandler), g == null || g.removeEventListener("mouseup", p.upHandler), u(m.clientX);
          }
        }, f = {
          moveHandler: (m) => (m.cancelable && (m.preventDefault(), m.stopPropagation()), d(m.touches[0].clientX), !1),
          upHandler: (m) => {
            var b;
            g == null || g.removeEventListener("touchmove", f.moveHandler), g == null || g.removeEventListener("touchend", f.upHandler), m.cancelable && (m.preventDefault(), m.stopPropagation()), u((b = m.touches[0]) == null ? void 0 : b.clientX);
          }
        }, x = Nu() ? {
          passive: !1
        } : !1;
        Vs(a) ? (g == null || g.addEventListener("touchmove", f.moveHandler, x), g == null || g.addEventListener("touchend", f.upHandler, x)) : (g == null || g.addEventListener("mousemove", p.moveHandler, x), g == null || g.addEventListener("mouseup", p.upHandler, x)), e.setColumnSizingInfo((m) => ({
          ...m,
          startOffset: l,
          startSize: n,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart: o,
          isResizingColumn: i.id
        }));
      };
    };
  },
  createTable: (r) => {
    r.setColumnSizing = (e) => r.options.onColumnSizingChange == null ? void 0 : r.options.onColumnSizingChange(e), r.setColumnSizingInfo = (e) => r.options.onColumnSizingInfoChange == null ? void 0 : r.options.onColumnSizingInfoChange(e), r.resetColumnSizing = (e) => {
      var t;
      r.setColumnSizing(e ? {} : (t = r.initialState.columnSizing) != null ? t : {});
    }, r.resetHeaderSizeInfo = (e) => {
      var t;
      r.setColumnSizingInfo(e ? Ws() : (t = r.initialState.columnSizingInfo) != null ? t : Ws());
    }, r.getTotalSize = () => {
      var e, t;
      return (e = (t = r.getHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, s) => i + s.getSize(), 0)) != null ? e : 0;
    }, r.getLeftTotalSize = () => {
      var e, t;
      return (e = (t = r.getLeftHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, s) => i + s.getSize(), 0)) != null ? e : 0;
    }, r.getCenterTotalSize = () => {
      var e, t;
      return (e = (t = r.getCenterHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, s) => i + s.getSize(), 0)) != null ? e : 0;
    }, r.getRightTotalSize = () => {
      var e, t;
      return (e = (t = r.getRightHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, s) => i + s.getSize(), 0)) != null ? e : 0;
    };
  }
};
let ji = null;
function Nu() {
  if (typeof ji == "boolean") return ji;
  let r = !1;
  try {
    const e = {
      get passive() {
        return r = !0, !1;
      }
    }, t = () => {
    };
    window.addEventListener("test", t, e), window.removeEventListener("test", t);
  } catch {
    r = !1;
  }
  return ji = r, ji;
}
function Vs(r) {
  return r.type === "touchstart";
}
const Du = {
  getInitialState: (r) => ({
    columnVisibility: {},
    ...r
  }),
  getDefaultOptions: (r) => ({
    onColumnVisibilityChange: et("columnVisibility", r)
  }),
  createColumn: (r, e) => {
    r.toggleVisibility = (t) => {
      r.getCanHide() && e.setColumnVisibility((i) => ({
        ...i,
        [r.id]: t ?? !r.getIsVisible()
      }));
    }, r.getIsVisible = () => {
      var t, i;
      const s = r.columns;
      return (t = s.length ? s.some((a) => a.getIsVisible()) : (i = e.getState().columnVisibility) == null ? void 0 : i[r.id]) != null ? t : !0;
    }, r.getCanHide = () => {
      var t, i;
      return ((t = r.columnDef.enableHiding) != null ? t : !0) && ((i = e.options.enableHiding) != null ? i : !0);
    }, r.getToggleVisibilityHandler = () => (t) => {
      r.toggleVisibility == null || r.toggleVisibility(t.target.checked);
    };
  },
  createRow: (r, e) => {
    r._getAllVisibleCells = le(() => [r.getAllCells(), e.getState().columnVisibility], (t) => t.filter((i) => i.column.getIsVisible()), ce(e.options, "debugRows", "_getAllVisibleCells")), r.getVisibleCells = le(() => [r.getLeftVisibleCells(), r.getCenterVisibleCells(), r.getRightVisibleCells()], (t, i, s) => [...t, ...i, ...s], ce(e.options, "debugRows", "getVisibleCells"));
  },
  createTable: (r) => {
    const e = (t, i) => le(() => [i(), i().filter((s) => s.getIsVisible()).map((s) => s.id).join("_")], (s) => s.filter((a) => a.getIsVisible == null ? void 0 : a.getIsVisible()), ce(r.options, "debugColumns", t));
    r.getVisibleFlatColumns = e("getVisibleFlatColumns", () => r.getAllFlatColumns()), r.getVisibleLeafColumns = e("getVisibleLeafColumns", () => r.getAllLeafColumns()), r.getLeftVisibleLeafColumns = e("getLeftVisibleLeafColumns", () => r.getLeftLeafColumns()), r.getRightVisibleLeafColumns = e("getRightVisibleLeafColumns", () => r.getRightLeafColumns()), r.getCenterVisibleLeafColumns = e("getCenterVisibleLeafColumns", () => r.getCenterLeafColumns()), r.setColumnVisibility = (t) => r.options.onColumnVisibilityChange == null ? void 0 : r.options.onColumnVisibilityChange(t), r.resetColumnVisibility = (t) => {
      var i;
      r.setColumnVisibility(t ? {} : (i = r.initialState.columnVisibility) != null ? i : {});
    }, r.toggleAllColumnsVisible = (t) => {
      var i;
      t = (i = t) != null ? i : !r.getIsAllColumnsVisible(), r.setColumnVisibility(r.getAllLeafColumns().reduce((s, a) => ({
        ...s,
        [a.id]: t || !(a.getCanHide != null && a.getCanHide())
      }), {}));
    }, r.getIsAllColumnsVisible = () => !r.getAllLeafColumns().some((t) => !(t.getIsVisible != null && t.getIsVisible())), r.getIsSomeColumnsVisible = () => r.getAllLeafColumns().some((t) => t.getIsVisible == null ? void 0 : t.getIsVisible()), r.getToggleAllColumnsVisibilityHandler = () => (t) => {
      var i;
      r.toggleAllColumnsVisible((i = t.target) == null ? void 0 : i.checked);
    };
  }
};
function bi(r, e) {
  return e ? e === "center" ? r.getCenterVisibleLeafColumns() : e === "left" ? r.getLeftVisibleLeafColumns() : r.getRightVisibleLeafColumns() : r.getVisibleLeafColumns();
}
const Hu = {
  createTable: (r) => {
    r._getGlobalFacetedRowModel = r.options.getFacetedRowModel && r.options.getFacetedRowModel(r, "__global__"), r.getGlobalFacetedRowModel = () => r.options.manualFiltering || !r._getGlobalFacetedRowModel ? r.getPreFilteredRowModel() : r._getGlobalFacetedRowModel(), r._getGlobalFacetedUniqueValues = r.options.getFacetedUniqueValues && r.options.getFacetedUniqueValues(r, "__global__"), r.getGlobalFacetedUniqueValues = () => r._getGlobalFacetedUniqueValues ? r._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), r._getGlobalFacetedMinMaxValues = r.options.getFacetedMinMaxValues && r.options.getFacetedMinMaxValues(r, "__global__"), r.getGlobalFacetedMinMaxValues = () => {
      if (r._getGlobalFacetedMinMaxValues)
        return r._getGlobalFacetedMinMaxValues();
    };
  }
}, Yu = {
  getInitialState: (r) => ({
    globalFilter: void 0,
    ...r
  }),
  getDefaultOptions: (r) => ({
    onGlobalFilterChange: et("globalFilter", r),
    globalFilterFn: "auto",
    getColumnCanGlobalFilter: (e) => {
      var t;
      const i = (t = r.getCoreRowModel().flatRows[0]) == null || (t = t._getAllCellsByColumnId()[e.id]) == null ? void 0 : t.getValue();
      return typeof i == "string" || typeof i == "number";
    }
  }),
  createColumn: (r, e) => {
    r.getCanGlobalFilter = () => {
      var t, i, s, a;
      return ((t = r.columnDef.enableGlobalFilter) != null ? t : !0) && ((i = e.options.enableGlobalFilter) != null ? i : !0) && ((s = e.options.enableFilters) != null ? s : !0) && ((a = e.options.getColumnCanGlobalFilter == null ? void 0 : e.options.getColumnCanGlobalFilter(r)) != null ? a : !0) && !!r.accessorFn;
    };
  },
  createTable: (r) => {
    r.getGlobalAutoFilterFn = () => pt.includesString, r.getGlobalFilterFn = () => {
      var e, t;
      const {
        globalFilterFn: i
      } = r.options;
      return ns(i) ? i : i === "auto" ? r.getGlobalAutoFilterFn() : (e = (t = r.options.filterFns) == null ? void 0 : t[i]) != null ? e : pt[i];
    }, r.setGlobalFilter = (e) => {
      r.options.onGlobalFilterChange == null || r.options.onGlobalFilterChange(e);
    }, r.resetGlobalFilter = (e) => {
      r.setGlobalFilter(e ? void 0 : r.initialState.globalFilter);
    };
  }
}, ju = {
  getInitialState: (r) => ({
    expanded: {},
    ...r
  }),
  getDefaultOptions: (r) => ({
    onExpandedChange: et("expanded", r),
    paginateExpandedRows: !0
  }),
  createTable: (r) => {
    let e = !1, t = !1;
    r._autoResetExpanded = () => {
      var i, s;
      if (!e) {
        r._queue(() => {
          e = !0;
        });
        return;
      }
      if ((i = (s = r.options.autoResetAll) != null ? s : r.options.autoResetExpanded) != null ? i : !r.options.manualExpanding) {
        if (t) return;
        t = !0, r._queue(() => {
          r.resetExpanded(), t = !1;
        });
      }
    }, r.setExpanded = (i) => r.options.onExpandedChange == null ? void 0 : r.options.onExpandedChange(i), r.toggleAllRowsExpanded = (i) => {
      i ?? !r.getIsAllRowsExpanded() ? r.setExpanded(!0) : r.setExpanded({});
    }, r.resetExpanded = (i) => {
      var s, a;
      r.setExpanded(i ? {} : (s = (a = r.initialState) == null ? void 0 : a.expanded) != null ? s : {});
    }, r.getCanSomeRowsExpand = () => r.getPrePaginationRowModel().flatRows.some((i) => i.getCanExpand()), r.getToggleAllRowsExpandedHandler = () => (i) => {
      i.persist == null || i.persist(), r.toggleAllRowsExpanded();
    }, r.getIsSomeRowsExpanded = () => {
      const i = r.getState().expanded;
      return i === !0 || Object.values(i).some(Boolean);
    }, r.getIsAllRowsExpanded = () => {
      const i = r.getState().expanded;
      return typeof i == "boolean" ? i === !0 : !(!Object.keys(i).length || r.getRowModel().flatRows.some((s) => !s.getIsExpanded()));
    }, r.getExpandedDepth = () => {
      let i = 0;
      return (r.getState().expanded === !0 ? Object.keys(r.getRowModel().rowsById) : Object.keys(r.getState().expanded)).forEach((a) => {
        const n = a.split(".");
        i = Math.max(i, n.length);
      }), i;
    }, r.getPreExpandedRowModel = () => r.getSortedRowModel(), r.getExpandedRowModel = () => (!r._getExpandedRowModel && r.options.getExpandedRowModel && (r._getExpandedRowModel = r.options.getExpandedRowModel(r)), r.options.manualExpanding || !r._getExpandedRowModel ? r.getPreExpandedRowModel() : r._getExpandedRowModel());
  },
  createRow: (r, e) => {
    r.toggleExpanded = (t) => {
      e.setExpanded((i) => {
        var s;
        const a = i === !0 ? !0 : !!(i != null && i[r.id]);
        let n = {};
        if (i === !0 ? Object.keys(e.getRowModel().rowsById).forEach((o) => {
          n[o] = !0;
        }) : n = i, t = (s = t) != null ? s : !a, !a && t)
          return {
            ...n,
            [r.id]: !0
          };
        if (a && !t) {
          const {
            [r.id]: o,
            ...l
          } = n;
          return l;
        }
        return i;
      });
    }, r.getIsExpanded = () => {
      var t;
      const i = e.getState().expanded;
      return !!((t = e.options.getIsRowExpanded == null ? void 0 : e.options.getIsRowExpanded(r)) != null ? t : i === !0 || i != null && i[r.id]);
    }, r.getCanExpand = () => {
      var t, i, s;
      return (t = e.options.getRowCanExpand == null ? void 0 : e.options.getRowCanExpand(r)) != null ? t : ((i = e.options.enableExpanding) != null ? i : !0) && !!((s = r.subRows) != null && s.length);
    }, r.getIsAllParentsExpanded = () => {
      let t = !0, i = r;
      for (; t && i.parentId; )
        i = e.getRow(i.parentId, !0), t = i.getIsExpanded();
      return t;
    }, r.getToggleExpandedHandler = () => {
      const t = r.getCanExpand();
      return () => {
        t && r.toggleExpanded();
      };
    };
  }
}, Ar = 0, Mr = 10, Gs = () => ({
  pageIndex: Ar,
  pageSize: Mr
}), Xu = {
  getInitialState: (r) => ({
    ...r,
    pagination: {
      ...Gs(),
      ...r == null ? void 0 : r.pagination
    }
  }),
  getDefaultOptions: (r) => ({
    onPaginationChange: et("pagination", r)
  }),
  createTable: (r) => {
    let e = !1, t = !1;
    r._autoResetPageIndex = () => {
      var i, s;
      if (!e) {
        r._queue(() => {
          e = !0;
        });
        return;
      }
      if ((i = (s = r.options.autoResetAll) != null ? s : r.options.autoResetPageIndex) != null ? i : !r.options.manualPagination) {
        if (t) return;
        t = !0, r._queue(() => {
          r.resetPageIndex(), t = !1;
        });
      }
    }, r.setPagination = (i) => {
      const s = (a) => Ct(i, a);
      return r.options.onPaginationChange == null ? void 0 : r.options.onPaginationChange(s);
    }, r.resetPagination = (i) => {
      var s;
      r.setPagination(i ? Gs() : (s = r.initialState.pagination) != null ? s : Gs());
    }, r.setPageIndex = (i) => {
      r.setPagination((s) => {
        let a = Ct(i, s.pageIndex);
        const n = typeof r.options.pageCount > "u" || r.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : r.options.pageCount - 1;
        return a = Math.max(0, Math.min(a, n)), {
          ...s,
          pageIndex: a
        };
      });
    }, r.resetPageIndex = (i) => {
      var s, a;
      r.setPageIndex(i ? Ar : (s = (a = r.initialState) == null || (a = a.pagination) == null ? void 0 : a.pageIndex) != null ? s : Ar);
    }, r.resetPageSize = (i) => {
      var s, a;
      r.setPageSize(i ? Mr : (s = (a = r.initialState) == null || (a = a.pagination) == null ? void 0 : a.pageSize) != null ? s : Mr);
    }, r.setPageSize = (i) => {
      r.setPagination((s) => {
        const a = Math.max(1, Ct(i, s.pageSize)), n = s.pageSize * s.pageIndex, o = Math.floor(n / a);
        return {
          ...s,
          pageIndex: o,
          pageSize: a
        };
      });
    }, r.setPageCount = (i) => r.setPagination((s) => {
      var a;
      let n = Ct(i, (a = r.options.pageCount) != null ? a : -1);
      return typeof n == "number" && (n = Math.max(-1, n)), {
        ...s,
        pageCount: n
      };
    }), r.getPageOptions = le(() => [r.getPageCount()], (i) => {
      let s = [];
      return i && i > 0 && (s = [...new Array(i)].fill(null).map((a, n) => n)), s;
    }, ce(r.options, "debugTable", "getPageOptions")), r.getCanPreviousPage = () => r.getState().pagination.pageIndex > 0, r.getCanNextPage = () => {
      const {
        pageIndex: i
      } = r.getState().pagination, s = r.getPageCount();
      return s === -1 ? !0 : s === 0 ? !1 : i < s - 1;
    }, r.previousPage = () => r.setPageIndex((i) => i - 1), r.nextPage = () => r.setPageIndex((i) => i + 1), r.firstPage = () => r.setPageIndex(0), r.lastPage = () => r.setPageIndex(r.getPageCount() - 1), r.getPrePaginationRowModel = () => r.getExpandedRowModel(), r.getPaginationRowModel = () => (!r._getPaginationRowModel && r.options.getPaginationRowModel && (r._getPaginationRowModel = r.options.getPaginationRowModel(r)), r.options.manualPagination || !r._getPaginationRowModel ? r.getPrePaginationRowModel() : r._getPaginationRowModel()), r.getPageCount = () => {
      var i;
      return (i = r.options.pageCount) != null ? i : Math.ceil(r.getRowCount() / r.getState().pagination.pageSize);
    }, r.getRowCount = () => {
      var i;
      return (i = r.options.rowCount) != null ? i : r.getPrePaginationRowModel().rows.length;
    };
  }
}, $s = () => ({
  top: [],
  bottom: []
}), Bu = {
  getInitialState: (r) => ({
    rowPinning: $s(),
    ...r
  }),
  getDefaultOptions: (r) => ({
    onRowPinningChange: et("rowPinning", r)
  }),
  createRow: (r, e) => {
    r.pin = (t, i, s) => {
      const a = i ? r.getLeafRows().map((l) => {
        let {
          id: c
        } = l;
        return c;
      }) : [], n = s ? r.getParentRows().map((l) => {
        let {
          id: c
        } = l;
        return c;
      }) : [], o = /* @__PURE__ */ new Set([...n, r.id, ...a]);
      e.setRowPinning((l) => {
        var c, h;
        if (t === "bottom") {
          var d, u;
          return {
            top: ((d = l == null ? void 0 : l.top) != null ? d : []).filter((f) => !(o != null && o.has(f))),
            bottom: [...((u = l == null ? void 0 : l.bottom) != null ? u : []).filter((f) => !(o != null && o.has(f))), ...Array.from(o)]
          };
        }
        if (t === "top") {
          var g, p;
          return {
            top: [...((g = l == null ? void 0 : l.top) != null ? g : []).filter((f) => !(o != null && o.has(f))), ...Array.from(o)],
            bottom: ((p = l == null ? void 0 : l.bottom) != null ? p : []).filter((f) => !(o != null && o.has(f)))
          };
        }
        return {
          top: ((c = l == null ? void 0 : l.top) != null ? c : []).filter((f) => !(o != null && o.has(f))),
          bottom: ((h = l == null ? void 0 : l.bottom) != null ? h : []).filter((f) => !(o != null && o.has(f)))
        };
      });
    }, r.getCanPin = () => {
      var t;
      const {
        enableRowPinning: i,
        enablePinning: s
      } = e.options;
      return typeof i == "function" ? i(r) : (t = i ?? s) != null ? t : !0;
    }, r.getIsPinned = () => {
      const t = [r.id], {
        top: i,
        bottom: s
      } = e.getState().rowPinning, a = t.some((o) => i == null ? void 0 : i.includes(o)), n = t.some((o) => s == null ? void 0 : s.includes(o));
      return a ? "top" : n ? "bottom" : !1;
    }, r.getPinnedIndex = () => {
      var t, i;
      const s = r.getIsPinned();
      if (!s) return -1;
      const a = (t = s === "top" ? e.getTopRows() : e.getBottomRows()) == null ? void 0 : t.map((n) => {
        let {
          id: o
        } = n;
        return o;
      });
      return (i = a == null ? void 0 : a.indexOf(r.id)) != null ? i : -1;
    };
  },
  createTable: (r) => {
    r.setRowPinning = (e) => r.options.onRowPinningChange == null ? void 0 : r.options.onRowPinningChange(e), r.resetRowPinning = (e) => {
      var t, i;
      return r.setRowPinning(e ? $s() : (t = (i = r.initialState) == null ? void 0 : i.rowPinning) != null ? t : $s());
    }, r.getIsSomeRowsPinned = (e) => {
      var t;
      const i = r.getState().rowPinning;
      if (!e) {
        var s, a;
        return !!((s = i.top) != null && s.length || (a = i.bottom) != null && a.length);
      }
      return !!((t = i[e]) != null && t.length);
    }, r._getPinnedRows = (e, t, i) => {
      var s;
      return ((s = r.options.keepPinnedRows) == null || s ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (t ?? []).map((n) => {
          const o = r.getRow(n, !0);
          return o.getIsAllParentsExpanded() ? o : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (t ?? []).map((n) => e.find((o) => o.id === n))
      )).filter(Boolean).map((n) => ({
        ...n,
        position: i
      }));
    }, r.getTopRows = le(() => [r.getRowModel().rows, r.getState().rowPinning.top], (e, t) => r._getPinnedRows(e, t, "top"), ce(r.options, "debugRows", "getTopRows")), r.getBottomRows = le(() => [r.getRowModel().rows, r.getState().rowPinning.bottom], (e, t) => r._getPinnedRows(e, t, "bottom"), ce(r.options, "debugRows", "getBottomRows")), r.getCenterRows = le(() => [r.getRowModel().rows, r.getState().rowPinning.top, r.getState().rowPinning.bottom], (e, t, i) => {
      const s = /* @__PURE__ */ new Set([...t ?? [], ...i ?? []]);
      return e.filter((a) => !s.has(a.id));
    }, ce(r.options, "debugRows", "getCenterRows"));
  }
}, Wu = {
  getInitialState: (r) => ({
    rowSelection: {},
    ...r
  }),
  getDefaultOptions: (r) => ({
    onRowSelectionChange: et("rowSelection", r),
    enableRowSelection: !0,
    enableMultiRowSelection: !0,
    enableSubRowSelection: !0
    // enableGroupingRowSelection: false,
    // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
    // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
  }),
  createTable: (r) => {
    r.setRowSelection = (e) => r.options.onRowSelectionChange == null ? void 0 : r.options.onRowSelectionChange(e), r.resetRowSelection = (e) => {
      var t;
      return r.setRowSelection(e ? {} : (t = r.initialState.rowSelection) != null ? t : {});
    }, r.toggleAllRowsSelected = (e) => {
      r.setRowSelection((t) => {
        e = typeof e < "u" ? e : !r.getIsAllRowsSelected();
        const i = {
          ...t
        }, s = r.getPreGroupedRowModel().flatRows;
        return e ? s.forEach((a) => {
          a.getCanSelect() && (i[a.id] = !0);
        }) : s.forEach((a) => {
          delete i[a.id];
        }), i;
      });
    }, r.toggleAllPageRowsSelected = (e) => r.setRowSelection((t) => {
      const i = typeof e < "u" ? e : !r.getIsAllPageRowsSelected(), s = {
        ...t
      };
      return r.getRowModel().rows.forEach((a) => {
        Rr(s, a.id, i, !0, r);
      }), s;
    }), r.getPreSelectedRowModel = () => r.getCoreRowModel(), r.getSelectedRowModel = le(() => [r.getState().rowSelection, r.getCoreRowModel()], (e, t) => Object.keys(e).length ? Us(r, t) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, ce(r.options, "debugTable", "getSelectedRowModel")), r.getFilteredSelectedRowModel = le(() => [r.getState().rowSelection, r.getFilteredRowModel()], (e, t) => Object.keys(e).length ? Us(r, t) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, ce(r.options, "debugTable", "getFilteredSelectedRowModel")), r.getGroupedSelectedRowModel = le(() => [r.getState().rowSelection, r.getSortedRowModel()], (e, t) => Object.keys(e).length ? Us(r, t) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, ce(r.options, "debugTable", "getGroupedSelectedRowModel")), r.getIsAllRowsSelected = () => {
      const e = r.getFilteredRowModel().flatRows, {
        rowSelection: t
      } = r.getState();
      let i = !!(e.length && Object.keys(t).length);
      return i && e.some((s) => s.getCanSelect() && !t[s.id]) && (i = !1), i;
    }, r.getIsAllPageRowsSelected = () => {
      const e = r.getPaginationRowModel().flatRows.filter((s) => s.getCanSelect()), {
        rowSelection: t
      } = r.getState();
      let i = !!e.length;
      return i && e.some((s) => !t[s.id]) && (i = !1), i;
    }, r.getIsSomeRowsSelected = () => {
      var e;
      const t = Object.keys((e = r.getState().rowSelection) != null ? e : {}).length;
      return t > 0 && t < r.getFilteredRowModel().flatRows.length;
    }, r.getIsSomePageRowsSelected = () => {
      const e = r.getPaginationRowModel().flatRows;
      return r.getIsAllPageRowsSelected() ? !1 : e.filter((t) => t.getCanSelect()).some((t) => t.getIsSelected() || t.getIsSomeSelected());
    }, r.getToggleAllRowsSelectedHandler = () => (e) => {
      r.toggleAllRowsSelected(e.target.checked);
    }, r.getToggleAllPageRowsSelectedHandler = () => (e) => {
      r.toggleAllPageRowsSelected(e.target.checked);
    };
  },
  createRow: (r, e) => {
    r.toggleSelected = (t, i) => {
      const s = r.getIsSelected();
      e.setRowSelection((a) => {
        var n;
        if (t = typeof t < "u" ? t : !s, r.getCanSelect() && s === t)
          return a;
        const o = {
          ...a
        };
        return Rr(o, r.id, t, (n = i == null ? void 0 : i.selectChildren) != null ? n : !0, e), o;
      });
    }, r.getIsSelected = () => {
      const {
        rowSelection: t
      } = e.getState();
      return ea(r, t);
    }, r.getIsSomeSelected = () => {
      const {
        rowSelection: t
      } = e.getState();
      return Pr(r, t) === "some";
    }, r.getIsAllSubRowsSelected = () => {
      const {
        rowSelection: t
      } = e.getState();
      return Pr(r, t) === "all";
    }, r.getCanSelect = () => {
      var t;
      return typeof e.options.enableRowSelection == "function" ? e.options.enableRowSelection(r) : (t = e.options.enableRowSelection) != null ? t : !0;
    }, r.getCanSelectSubRows = () => {
      var t;
      return typeof e.options.enableSubRowSelection == "function" ? e.options.enableSubRowSelection(r) : (t = e.options.enableSubRowSelection) != null ? t : !0;
    }, r.getCanMultiSelect = () => {
      var t;
      return typeof e.options.enableMultiRowSelection == "function" ? e.options.enableMultiRowSelection(r) : (t = e.options.enableMultiRowSelection) != null ? t : !0;
    }, r.getToggleSelectedHandler = () => {
      const t = r.getCanSelect();
      return (i) => {
        var s;
        t && r.toggleSelected((s = i.target) == null ? void 0 : s.checked);
      };
    };
  }
}, Rr = (r, e, t, i, s) => {
  var a;
  const n = s.getRow(e, !0);
  t ? (n.getCanMultiSelect() || Object.keys(r).forEach((o) => delete r[o]), n.getCanSelect() && (r[e] = !0)) : delete r[e], i && (a = n.subRows) != null && a.length && n.getCanSelectSubRows() && n.subRows.forEach((o) => Rr(r, o.id, t, i, s));
};
function Us(r, e) {
  const t = r.getState().rowSelection, i = [], s = {}, a = function(n, o) {
    return n.map((l) => {
      var c;
      const h = ea(l, t);
      if (h && (i.push(l), s[l.id] = l), (c = l.subRows) != null && c.length && (l = {
        ...l,
        subRows: a(l.subRows)
      }), h)
        return l;
    }).filter(Boolean);
  };
  return {
    rows: a(e.rows),
    flatRows: i,
    rowsById: s
  };
}
function ea(r, e) {
  var t;
  return (t = e[r.id]) != null ? t : !1;
}
function Pr(r, e, t) {
  var i;
  if (!((i = r.subRows) != null && i.length)) return !1;
  let s = !0, a = !1;
  return r.subRows.forEach((n) => {
    if (!(a && !s) && (n.getCanSelect() && (ea(n, e) ? a = !0 : s = !1), n.subRows && n.subRows.length)) {
      const o = Pr(n, e);
      o === "all" ? a = !0 : (o === "some" && (a = !0), s = !1);
    }
  }), s ? "all" : a ? "some" : !1;
}
const Lr = /([0-9]+)/gm, Vu = (r, e, t) => Zo(Lt(r.getValue(t)).toLowerCase(), Lt(e.getValue(t)).toLowerCase()), Gu = (r, e, t) => Zo(Lt(r.getValue(t)), Lt(e.getValue(t))), $u = (r, e, t) => ta(Lt(r.getValue(t)).toLowerCase(), Lt(e.getValue(t)).toLowerCase()), Uu = (r, e, t) => ta(Lt(r.getValue(t)), Lt(e.getValue(t))), qu = (r, e, t) => {
  const i = r.getValue(t), s = e.getValue(t);
  return i > s ? 1 : i < s ? -1 : 0;
}, Zu = (r, e, t) => ta(r.getValue(t), e.getValue(t));
function ta(r, e) {
  return r === e ? 0 : r > e ? 1 : -1;
}
function Lt(r) {
  return typeof r == "number" ? isNaN(r) || r === 1 / 0 || r === -1 / 0 ? "" : String(r) : typeof r == "string" ? r : "";
}
function Zo(r, e) {
  const t = r.split(Lr).filter(Boolean), i = e.split(Lr).filter(Boolean);
  for (; t.length && i.length; ) {
    const s = t.shift(), a = i.shift(), n = parseInt(s, 10), o = parseInt(a, 10), l = [n, o].sort();
    if (isNaN(l[0])) {
      if (s > a)
        return 1;
      if (a > s)
        return -1;
      continue;
    }
    if (isNaN(l[1]))
      return isNaN(n) ? -1 : 1;
    if (n > o)
      return 1;
    if (o > n)
      return -1;
  }
  return t.length - i.length;
}
const ui = {
  alphanumeric: Vu,
  alphanumericCaseSensitive: Gu,
  text: $u,
  textCaseSensitive: Uu,
  datetime: qu,
  basic: Zu
}, Ju = {
  getInitialState: (r) => ({
    sorting: [],
    ...r
  }),
  getDefaultColumnDef: () => ({
    sortingFn: "auto",
    sortUndefined: 1
  }),
  getDefaultOptions: (r) => ({
    onSortingChange: et("sorting", r),
    isMultiSortEvent: (e) => e.shiftKey
  }),
  createColumn: (r, e) => {
    r.getAutoSortingFn = () => {
      const t = e.getFilteredRowModel().flatRows.slice(10);
      let i = !1;
      for (const s of t) {
        const a = s == null ? void 0 : s.getValue(r.id);
        if (Object.prototype.toString.call(a) === "[object Date]")
          return ui.datetime;
        if (typeof a == "string" && (i = !0, a.split(Lr).length > 1))
          return ui.alphanumeric;
      }
      return i ? ui.text : ui.basic;
    }, r.getAutoSortDir = () => {
      const t = e.getFilteredRowModel().flatRows[0];
      return typeof (t == null ? void 0 : t.getValue(r.id)) == "string" ? "asc" : "desc";
    }, r.getSortingFn = () => {
      var t, i;
      if (!r)
        throw new Error();
      return ns(r.columnDef.sortingFn) ? r.columnDef.sortingFn : r.columnDef.sortingFn === "auto" ? r.getAutoSortingFn() : (t = (i = e.options.sortingFns) == null ? void 0 : i[r.columnDef.sortingFn]) != null ? t : ui[r.columnDef.sortingFn];
    }, r.toggleSorting = (t, i) => {
      const s = r.getNextSortingOrder(), a = typeof t < "u" && t !== null;
      e.setSorting((n) => {
        const o = n == null ? void 0 : n.find((g) => g.id === r.id), l = n == null ? void 0 : n.findIndex((g) => g.id === r.id);
        let c = [], h, d = a ? t : s === "desc";
        if (n != null && n.length && r.getCanMultiSort() && i ? o ? h = "toggle" : h = "add" : n != null && n.length && l !== n.length - 1 ? h = "replace" : o ? h = "toggle" : h = "replace", h === "toggle" && (a || s || (h = "remove")), h === "add") {
          var u;
          c = [...n, {
            id: r.id,
            desc: d
          }], c.splice(0, c.length - ((u = e.options.maxMultiSortColCount) != null ? u : Number.MAX_SAFE_INTEGER));
        } else h === "toggle" ? c = n.map((g) => g.id === r.id ? {
          ...g,
          desc: d
        } : g) : h === "remove" ? c = n.filter((g) => g.id !== r.id) : c = [{
          id: r.id,
          desc: d
        }];
        return c;
      });
    }, r.getFirstSortDir = () => {
      var t, i;
      return ((t = (i = r.columnDef.sortDescFirst) != null ? i : e.options.sortDescFirst) != null ? t : r.getAutoSortDir() === "desc") ? "desc" : "asc";
    }, r.getNextSortingOrder = (t) => {
      var i, s;
      const a = r.getFirstSortDir(), n = r.getIsSorted();
      return n ? n !== a && ((i = e.options.enableSortingRemoval) == null || i) && // If enableSortRemove, enable in general
      (!(t && (s = e.options.enableMultiRemove) != null) || s) ? !1 : n === "desc" ? "asc" : "desc" : a;
    }, r.getCanSort = () => {
      var t, i;
      return ((t = r.columnDef.enableSorting) != null ? t : !0) && ((i = e.options.enableSorting) != null ? i : !0) && !!r.accessorFn;
    }, r.getCanMultiSort = () => {
      var t, i;
      return (t = (i = r.columnDef.enableMultiSort) != null ? i : e.options.enableMultiSort) != null ? t : !!r.accessorFn;
    }, r.getIsSorted = () => {
      var t;
      const i = (t = e.getState().sorting) == null ? void 0 : t.find((s) => s.id === r.id);
      return i ? i.desc ? "desc" : "asc" : !1;
    }, r.getSortIndex = () => {
      var t, i;
      return (t = (i = e.getState().sorting) == null ? void 0 : i.findIndex((s) => s.id === r.id)) != null ? t : -1;
    }, r.clearSorting = () => {
      e.setSorting((t) => t != null && t.length ? t.filter((i) => i.id !== r.id) : []);
    }, r.getToggleSortingHandler = () => {
      const t = r.getCanSort();
      return (i) => {
        t && (i.persist == null || i.persist(), r.toggleSorting == null || r.toggleSorting(void 0, r.getCanMultiSort() ? e.options.isMultiSortEvent == null ? void 0 : e.options.isMultiSortEvent(i) : !1));
      };
    };
  },
  createTable: (r) => {
    r.setSorting = (e) => r.options.onSortingChange == null ? void 0 : r.options.onSortingChange(e), r.resetSorting = (e) => {
      var t, i;
      r.setSorting(e ? [] : (t = (i = r.initialState) == null ? void 0 : i.sorting) != null ? t : []);
    }, r.getPreSortedRowModel = () => r.getGroupedRowModel(), r.getSortedRowModel = () => (!r._getSortedRowModel && r.options.getSortedRowModel && (r._getSortedRowModel = r.options.getSortedRowModel(r)), r.options.manualSorting || !r._getSortedRowModel ? r.getPreSortedRowModel() : r._getSortedRowModel());
  }
}, Ku = [
  bu,
  Du,
  _u,
  Ou,
  yu,
  wu,
  Hu,
  //depends on ColumnFaceting
  Yu,
  //depends on ColumnFiltering
  Ju,
  Eu,
  //depends on RowSorting
  ju,
  Xu,
  Bu,
  Wu,
  Fu
];
function Qu(r) {
  var e, t;
  process.env.NODE_ENV !== "production" && (r.debugAll || r.debugTable) && console.info("Creating Table Instance...");
  const i = [...Ku, ...(e = r._features) != null ? e : []];
  let s = {
    _features: i
  };
  const a = s._features.reduce((u, g) => Object.assign(u, g.getDefaultOptions == null ? void 0 : g.getDefaultOptions(s)), {}), n = (u) => s.options.mergeOptions ? s.options.mergeOptions(a, u) : {
    ...a,
    ...u
  };
  let l = {
    ...{},
    ...(t = r.initialState) != null ? t : {}
  };
  s._features.forEach((u) => {
    var g;
    l = (g = u.getInitialState == null ? void 0 : u.getInitialState(l)) != null ? g : l;
  });
  const c = [];
  let h = !1;
  const d = {
    _features: i,
    options: {
      ...a,
      ...r
    },
    initialState: l,
    _queue: (u) => {
      c.push(u), h || (h = !0, Promise.resolve().then(() => {
        for (; c.length; )
          c.shift()();
        h = !1;
      }).catch((g) => setTimeout(() => {
        throw g;
      })));
    },
    reset: () => {
      s.setState(s.initialState);
    },
    setOptions: (u) => {
      const g = Ct(u, s.options);
      s.options = n(g);
    },
    getState: () => s.options.state,
    setState: (u) => {
      s.options.onStateChange == null || s.options.onStateChange(u);
    },
    _getRowId: (u, g, p) => {
      var f;
      return (f = s.options.getRowId == null ? void 0 : s.options.getRowId(u, g, p)) != null ? f : `${p ? [p.id, g].join(".") : g}`;
    },
    getCoreRowModel: () => (s._getCoreRowModel || (s._getCoreRowModel = s.options.getCoreRowModel(s)), s._getCoreRowModel()),
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => s.getPaginationRowModel(),
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (u, g) => {
      let p = (g ? s.getPrePaginationRowModel() : s.getRowModel()).rowsById[u];
      if (!p && (p = s.getCoreRowModel().rowsById[u], !p))
        throw process.env.NODE_ENV !== "production" ? new Error(`getRow could not find row with ID: ${u}`) : new Error();
      return p;
    },
    _getDefaultColumnDef: le(() => [s.options.defaultColumn], (u) => {
      var g;
      return u = (g = u) != null ? g : {}, {
        header: (p) => {
          const f = p.header.column.columnDef;
          return f.accessorKey ? f.accessorKey : f.accessorFn ? f.id : null;
        },
        // footer: props => props.header.column.id,
        cell: (p) => {
          var f, x;
          return (f = (x = p.renderValue()) == null || x.toString == null ? void 0 : x.toString()) != null ? f : null;
        },
        ...s._features.reduce((p, f) => Object.assign(p, f.getDefaultColumnDef == null ? void 0 : f.getDefaultColumnDef()), {}),
        ...u
      };
    }, ce(r, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => s.options.columns,
    getAllColumns: le(() => [s._getColumnDefs()], (u) => {
      const g = function(p, f, x) {
        return x === void 0 && (x = 0), p.map((m) => {
          const b = mu(s, m, x, f), w = m;
          return b.columns = w.columns ? g(w.columns, b, x + 1) : [], b;
        });
      };
      return g(u);
    }, ce(r, "debugColumns", "getAllColumns")),
    getAllFlatColumns: le(() => [s.getAllColumns()], (u) => u.flatMap((g) => g.getFlatColumns()), ce(r, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: le(() => [s.getAllFlatColumns()], (u) => u.reduce((g, p) => (g[p.id] = p, g), {}), ce(r, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: le(() => [s.getAllColumns(), s._getOrderColumnsFn()], (u, g) => {
      let p = u.flatMap((f) => f.getLeafColumns());
      return g(p);
    }, ce(r, "debugColumns", "getAllLeafColumns")),
    getColumn: (u) => {
      const g = s._getAllFlatColumnsById()[u];
      return process.env.NODE_ENV !== "production" && !g && console.error(`[Table] Column with id '${u}' does not exist.`), g;
    }
  };
  Object.assign(s, d);
  for (let u = 0; u < s._features.length; u++) {
    const g = s._features[u];
    g == null || g.createTable == null || g.createTable(s);
  }
  return s;
}
function eg() {
  return (r) => le(() => [r.options.data], (e) => {
    const t = {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, i = function(s, a, n) {
      a === void 0 && (a = 0);
      const o = [];
      for (let c = 0; c < s.length; c++) {
        const h = vu(r, r._getRowId(s[c], c, n), s[c], c, a, void 0, n == null ? void 0 : n.id);
        if (t.flatRows.push(h), t.rowsById[h.id] = h, o.push(h), r.options.getSubRows) {
          var l;
          h.originalSubRows = r.options.getSubRows(s[c], c), (l = h.originalSubRows) != null && l.length && (h.subRows = i(h.originalSubRows, a + 1, h));
        }
      }
      return o;
    };
    return t.rows = i(e), t;
  }, ce(r.options, "debugTable", "getRowModel", () => r._autoResetPageIndex()));
}
function tg(r) {
  const e = [], t = (i) => {
    var s;
    e.push(i), (s = i.subRows) != null && s.length && i.getIsExpanded() && i.subRows.forEach(t);
  };
  return r.rows.forEach(t), {
    rows: e,
    flatRows: r.flatRows,
    rowsById: r.rowsById
  };
}
function ig(r) {
  return (e) => le(() => [e.getState().pagination, e.getPrePaginationRowModel(), e.options.paginateExpandedRows ? void 0 : e.getState().expanded], (t, i) => {
    if (!i.rows.length)
      return i;
    const {
      pageSize: s,
      pageIndex: a
    } = t;
    let {
      rows: n,
      flatRows: o,
      rowsById: l
    } = i;
    const c = s * a, h = c + s;
    n = n.slice(c, h);
    let d;
    e.options.paginateExpandedRows ? d = {
      rows: n,
      flatRows: o,
      rowsById: l
    } : d = tg({
      rows: n,
      flatRows: o,
      rowsById: l
    }), d.flatRows = [];
    const u = (g) => {
      d.flatRows.push(g), g.subRows.length && g.subRows.forEach(u);
    };
    return d.rows.forEach(u), d;
  }, ce(e.options, "debugTable", "getPaginationRowModel"));
}
function sg() {
  return (r) => le(() => [r.getState().sorting, r.getPreSortedRowModel()], (e, t) => {
    if (!t.rows.length || !(e != null && e.length))
      return t;
    const i = r.getState().sorting, s = [], a = i.filter((l) => {
      var c;
      return (c = r.getColumn(l.id)) == null ? void 0 : c.getCanSort();
    }), n = {};
    a.forEach((l) => {
      const c = r.getColumn(l.id);
      c && (n[l.id] = {
        sortUndefined: c.columnDef.sortUndefined,
        invertSorting: c.columnDef.invertSorting,
        sortingFn: c.getSortingFn()
      });
    });
    const o = (l) => {
      const c = l.map((h) => ({
        ...h
      }));
      return c.sort((h, d) => {
        for (let g = 0; g < a.length; g += 1) {
          var u;
          const p = a[g], f = n[p.id], x = f.sortUndefined, m = (u = p == null ? void 0 : p.desc) != null ? u : !1;
          let b = 0;
          if (x) {
            const w = h.getValue(p.id), y = d.getValue(p.id), v = w === void 0, S = y === void 0;
            if (v || S) {
              if (x === "first") return v ? -1 : 1;
              if (x === "last") return v ? 1 : -1;
              b = v && S ? 0 : v ? x : -x;
            }
          }
          if (b === 0 && (b = f.sortingFn(h, d, p.id)), b !== 0)
            return m && (b *= -1), f.invertSorting && (b *= -1), b;
        }
        return h.index - d.index;
      }), c.forEach((h) => {
        var d;
        s.push(h), (d = h.subRows) != null && d.length && (h.subRows = o(h.subRows));
      }), c;
    };
    return {
      rows: o(t.rows),
      flatRows: s,
      rowsById: t.rowsById
    };
  }, ce(r.options, "debugTable", "getSortedRowModel", () => r._autoResetPageIndex()));
}
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function pn(r, e) {
  return r ? rg(r) ? /* @__PURE__ */ qs.createElement(r, e) : r : null;
}
function rg(r) {
  return ag(r) || typeof r == "function" || ng(r);
}
function ag(r) {
  return typeof r == "function" && (() => {
    const e = Object.getPrototypeOf(r);
    return e.prototype && e.prototype.isReactComponent;
  })();
}
function ng(r) {
  return typeof r == "object" && typeof r.$$typeof == "symbol" && ["react.memo", "react.forward_ref"].includes(r.$$typeof.description);
}
function og(r) {
  const e = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...r
  }, [t] = qs.useState(() => ({
    current: Qu(e)
  })), [i, s] = qs.useState(() => t.current.initialState);
  return t.current.setOptions((a) => ({
    ...a,
    ...r,
    state: {
      ...i,
      ...r.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (n) => {
      s(n), r.onStateChange == null || r.onStateChange(n);
    }
  })), t.current;
}
const Jo = (r) => {
  const e = {
    header: {
      primary: "bg-primary text-white",
      secondary: "bg-secondary text-white",
      warning: "bg-warning text-white",
      danger: "bg-danger text-white",
      ghost: "bg-gray-100 text-gray-700",
      success: "bg-success text-white"
    },
    row: {
      primary: "hover:bg-primary/5",
      secondary: "hover:bg-secondary/5",
      warning: "hover:bg-warning/5",
      danger: "hover:bg-danger/5",
      ghost: "hover:bg-gray-50",
      success: "hover:bg-success/5"
    },
    border: {
      primary: "border-primary",
      secondary: "border-secondary",
      warning: "border-warning",
      danger: "border-danger",
      ghost: "border-gray-200",
      success: "border-success"
    },
    stripe: {
      primary: "bg-primary/5",
      secondary: "bg-secondary/5",
      warning: "bg-warning/5",
      danger: "bg-danger/5",
      ghost: "bg-gray-50",
      success: "bg-success/5"
    }
  };
  return {
    header: e.header[r],
    row: e.row[r],
    border: e.border[r],
    stripe: e.stripe[r]
  };
}, lg = ({ schema: r, variant: e = "primary" }) => {
  const t = [{ name: "no", label: "No.", accessorKey: "no", type: "number" }, ...r], i = Jo(e);
  return /* @__PURE__ */ M.jsx("div", { className: "bg-white rounded-md", children: /* @__PURE__ */ M.jsx("div", { className: "p-0 w-full max-h-[50vh] overflow-auto rounded-t-md [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]", children: /* @__PURE__ */ M.jsxs("table", { className: "w-full border-spacing-0 border-separate", children: [
    /* @__PURE__ */ M.jsx("thead", { className: ie("border-2 sticky top-0 z-10 rounded-t-md", i.border), children: /* @__PURE__ */ M.jsx("tr", { children: t.map((s, a) => /* @__PURE__ */ M.jsx(
      "th",
      {
        className: ie(
          "text-sm text-wrap border-y p-4 text-left",
          i.header,
          {
            "rounded-tl-md": a === 0,
            "rounded-tr-md": a === t.length - 1
          }
        ),
        children: s.label
      },
      a
    )) }) }),
    /* @__PURE__ */ M.jsx("tbody", { className: "max-h-[50vh]", children: [...Array(5)].map((s, a) => /* @__PURE__ */ M.jsx(
      "tr",
      {
        className: ie("p-3", {
          [i.stripe]: a % 2 !== 0,
          "bg-white": a % 2 === 0
        }),
        children: t.map((n, o) => /* @__PURE__ */ M.jsx(
          "td",
          {
            className: "text-left text-nowrap text-sm p-4",
            children: /* @__PURE__ */ M.jsx(eu, { className: "h-10 w-full rounded-md" })
          },
          `${a}-${o}`
        ))
      },
      a
    )) })
  ] }) }) });
}, Ig = ({
  schema: r,
  data: e,
  className: t,
  headerClassName: i,
  rowClassName: s,
  cellClassName: a,
  emptyState: n,
  isLoading: o,
  loadingState: l,
  showIndex: c = !1,
  pageSize: h = 10,
  pageCount: d = 1,
  currentPage: u = 1,
  totalData: g = 0,
  onPageChange: p,
  onPageSizeChange: f,
  onSortChange: x,
  onRowClick: m,
  showPagination: b = !1,
  variant: w = "primary"
}) => {
  const [y, v] = Ie(() => {
    const P = r.find((A) => A.sortable && A.sort);
    return P ? [{
      id: P.accessorKey.toString(),
      desc: P.sort === "desc"
    }] : [];
  }), S = Xe.useMemo(() => {
    const P = r.map((A) => ({
      accessorKey: A.accessorKey,
      header: A.label,
      enableSorting: !!A.sortable,
      cell: A.render ? ({ row: E }) => {
        var N;
        return (N = A.render) == null ? void 0 : N.call(A, E.original[A.accessorKey], E.original, E.index);
      } : ({ row: E }) => E.original[A.accessorKey] || "-",
      meta: {
        align: A.align || "left"
      }
    }));
    return c ? [{
      accessorKey: "no",
      header: "No.",
      enableSorting: !1,
      cell: ({ row: A }) => (u - 1) * h + A.index + 1,
      meta: {
        align: "left"
      }
    }, ...P] : P;
  }, [r, c, u, h]), k = og({
    data: e,
    columns: S,
    state: {
      sorting: y
    },
    onSortingChange: (P) => {
      const A = typeof P == "function" ? P(y) : P;
      v(A), A.length > 0 ? x == null || x(A[0].desc ? "desc" : "asc", A[0].id) : x == null || x("", "");
    },
    getCoreRowModel: eg(),
    getSortedRowModel: sg(),
    getPaginationRowModel: ig(),
    manualPagination: !0,
    pageCount: d
  }), C = Jo(w);
  if (o)
    return l || /* @__PURE__ */ M.jsx(lg, { schema: r, variant: w });
  const R = (P, A, E) => {
    const N = P.target;
    N.tagName === "BUTTON" || N.tagName === "A" || N.tagName === "INPUT" || N.tagName === "SELECT" || N.closest("button") !== null || N.closest("a") !== null || N.closest("input") !== null || N.closest("select") !== null || m == null || m(A, E);
  };
  return /* @__PURE__ */ M.jsxs("div", { className: "bg-white rounded-md", children: [
    /* @__PURE__ */ M.jsx("div", { className: "p-0 w-full max-h-[50vh] overflow-auto rounded-t-md [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]", children: /* @__PURE__ */ M.jsxs("table", { className: ie("w-full border-spacing-0 border-separate", t), children: [
      /* @__PURE__ */ M.jsx("thead", { className: ie("border-2 sticky top-0 z-10 rounded-t-md", C.border), children: k.getHeaderGroups().map((P) => /* @__PURE__ */ M.jsx("tr", { children: P.headers.map((A, E) => {
        var N, O, L;
        return /* @__PURE__ */ M.jsx(
          "th",
          {
            className: ie(
              "text-sm text-wrap border-y p-4",
              C.header,
              {
                "cursor-pointer": A.column.getCanSort(),
                "rounded-tl-md": E === 0,
                "rounded-tr-md": E === P.headers.length - 1,
                "text-left": ((N = A.column.columnDef.meta) == null ? void 0 : N.align) === "left",
                "text-center": ((O = A.column.columnDef.meta) == null ? void 0 : O.align) === "center",
                "text-right": ((L = A.column.columnDef.meta) == null ? void 0 : L.align) === "right"
              },
              i
            ),
            onClick: A.column.getCanSort() ? A.column.getToggleSortingHandler() : void 0,
            children: /* @__PURE__ */ M.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ M.jsx("span", { className: ie({
                "font-semibold": E === 0
              }), children: pn(A.column.columnDef.header, A.getContext()) }),
              A.column.getCanSort() && /* @__PURE__ */ M.jsx(
                vt,
                {
                  icon: A.column.getIsSorted() ? A.column.getIsSorted() === "desc" ? "mdi:keyboard-arrow-up" : "mdi:keyboard-arrow-down" : "mdi:unfold-more-horizontal",
                  className: ie("h-4 w-4", {
                    "text-white": w !== "ghost",
                    "text-gray-700": w === "ghost"
                  })
                }
              )
            ] })
          },
          A.id
        );
      }) }, P.id)) }),
      /* @__PURE__ */ M.jsx("tbody", { className: "max-h-[50vh]", children: k.getRowModel().rows.length === 0 ? /* @__PURE__ */ M.jsx("tr", { children: /* @__PURE__ */ M.jsx(
        "td",
        {
          colSpan: k.getAllColumns().length,
          className: ie(
            "text-center py-28 border h-full font-bold text-3xl text-default-400 w-full rounded-b-md"
          ),
          children: n || /* @__PURE__ */ M.jsxs("div", { className: "flex mx-auto w-full text-center justify-center gap-3 items-center", children: [
            /* @__PURE__ */ M.jsx("p", { children: "Data Not Found" }),
            /* @__PURE__ */ M.jsx(vt, { icon: "mdi:face-frown-open", size: 34 })
          ] })
        }
      ) }) : k.getRowModel().rows.map((P, A) => /* @__PURE__ */ M.jsx(
        "tr",
        {
          className: ie(
            "p-3",
            C.row,
            {
              [C.stripe]: A % 2 !== 0,
              "bg-white": A % 2 === 0,
              "cursor-pointer": m
            },
            s
          ),
          onClick: (E) => R(E, P.original, A),
          children: P.getVisibleCells().map((E) => {
            var N, O, L;
            return /* @__PURE__ */ M.jsx(
              "td",
              {
                className: ie(
                  "px-4 py-3 text-sm text-gray-900",
                  {
                    "text-left": ((N = E.column.columnDef.meta) == null ? void 0 : N.align) === "left",
                    "text-center": ((O = E.column.columnDef.meta) == null ? void 0 : O.align) === "center",
                    "text-right": ((L = E.column.columnDef.meta) == null ? void 0 : L.align) === "right"
                  },
                  a
                ),
                children: pn(E.column.columnDef.cell, E.getContext())
              },
              E.id
            );
          })
        },
        P.id
      )) })
    ] }) }),
    !!e.length && b && /* @__PURE__ */ M.jsx("div", { className: "p-4 bg-white rounded-b-md", children: /* @__PURE__ */ M.jsx(
      Qd,
      {
        currentPage: u,
        totalPages: d,
        totalData: g,
        onPageChange: p || (() => {
        }),
        perPage: h,
        onPerPageChange: f || (() => {
        }),
        perPageOptions: [5, 10, 20, 50, 100],
        siblingCount: 1
      }
    ) })
  ] });
}, Ko = Ue(
  ({
    className: r,
    variant: e = "default",
    title: t,
    description: i,
    onClose: s,
    icon: a,
    showIcon: n = !0,
    showClose: o = !0,
    ...l
  }, c) => {
    const d = a || (n ? {
      default: "mdi:information",
      success: "mdi:check-circle",
      error: "mdi:alert-circle",
      warning: "mdi:alert",
      info: "mdi:information"
    }[e] : void 0);
    return /* @__PURE__ */ M.jsxs(
      "div",
      {
        ref: c,
        className: ie(
          "flex items-start gap-3 rounded-lg p-4 shadow-lg",
          "border border-gray-200",
          {
            "bg-white": e === "default",
            "bg-success-50": e === "success",
            "bg-danger-50": e === "error",
            "bg-warning-50": e === "warning",
            "bg-info-50": e === "info"
          },
          r
        ),
        ...l,
        children: [
          d && /* @__PURE__ */ M.jsx(
            Ee,
            {
              icon: d,
              className: ie("h-5 w-5 flex-shrink-0", {
                "text-gray-500": e === "default",
                "text-success-500": e === "success",
                "text-danger-500": e === "error",
                "text-warning-500": e === "warning",
                "text-info-500": e === "info"
              })
            }
          ),
          /* @__PURE__ */ M.jsxs("div", { className: "flex-1", children: [
            t && /* @__PURE__ */ M.jsx(
              "h3",
              {
                className: ie("text-sm font-medium", {
                  "text-gray-900": e === "default",
                  "text-success-900": e === "success",
                  "text-danger-900": e === "error",
                  "text-warning-900": e === "warning",
                  "text-info-900": e === "info"
                }),
                children: t
              }
            ),
            i && /* @__PURE__ */ M.jsx(
              "p",
              {
                className: ie("mt-1 text-sm", {
                  "text-gray-500": e === "default",
                  "text-success-700": e === "success",
                  "text-danger-700": e === "error",
                  "text-warning-700": e === "warning",
                  "text-info-700": e === "info"
                }),
                children: i
              }
            )
          ] }),
          o && s && /* @__PURE__ */ M.jsx(
            "button",
            {
              type: "button",
              onClick: s,
              className: ie(
                "ml-4 flex-shrink-0 rounded-md p-1 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2",
                {
                  "text-gray-400 hover:text-gray-500": e === "default",
                  "text-success-400 hover:text-success-500": e === "success",
                  "text-danger-400 hover:text-danger-500": e === "error",
                  "text-warning-400 hover:text-warning-500": e === "warning",
                  "text-info-400 hover:text-info-500": e === "info"
                }
              ),
              children: /* @__PURE__ */ M.jsx(Ee, { icon: "mdi:close", className: "h-5 w-5" })
            }
          )
        ]
      }
    );
  }
);
Ko.displayName = "Toast";
const Qo = kl(void 0), cg = {
  "top-left": "top-4 left-4",
  "top-right": "top-4 right-4",
  "bottom-left": "bottom-4 left-4",
  "bottom-right": "bottom-4 right-4",
  "top-center": "top-4 left-1/2 -translate-x-1/2",
  "bottom-center": "bottom-4 left-1/2 -translate-x-1/2"
}, Eg = ({ children: r }) => {
  const [e, t] = Ie([]), i = xt((n) => {
    t((o) => o.filter((l) => l.id !== n));
  }, []), s = xt((n) => {
    const o = Math.random().toString(36).substr(2, 9), l = n.position || "top-right", c = n.duration || 5e3, h = {
      ...n,
      id: o,
      position: l
    };
    return t((d) => [...d, h]), c > 0 && setTimeout(() => {
      i(o);
    }, c), o;
  }, [i]), a = e.reduce((n, o) => (n[o.position] || (n[o.position] = []), n[o.position].push(o), n), {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": [],
    "top-center": [],
    "bottom-center": []
  });
  return /* @__PURE__ */ M.jsxs(Qo.Provider, { value: { showToast: s, removeToast: i }, children: [
    r,
    Qt(
      /* @__PURE__ */ M.jsx(M.Fragment, { children: Object.entries(a).map(([n, o]) => /* @__PURE__ */ M.jsx(
        "div",
        {
          className: ie(
            "fixed z-50 flex flex-col gap-2 min-w-[320px] max-w-[420px]",
            cg[n],
            n.includes("bottom") ? "flex-col-reverse" : "flex-col"
          ),
          children: o.map((l) => /* @__PURE__ */ M.jsx(
            Ko,
            {
              ...l,
              onClose: () => i(l.id),
              className: "animate-slide-in"
            },
            l.id
          ))
        },
        n
      )) }),
      document.body
    )
  ] });
}, Tg = () => {
  const r = Cl(Qo);
  if (!r)
    throw new Error("useToast must be used within a ToastProvider");
  return r;
}, hg = ({
  label: r,
  value: e,
  icon: t,
  className: i
}) => /* @__PURE__ */ M.jsxs(jn, { className: ie(
  "flex items-center gap-4 rounded-lg w-full bg-white p-4 shadow-sm hover:bg-neutral-50 transition-shadow duration-200",
  i
), children: [
  /* @__PURE__ */ M.jsxs("div", { children: [
    /* @__PURE__ */ M.jsx("p", { className: "text-sm font-medium text-gray-500", children: r }),
    /* @__PURE__ */ M.jsx("p", { className: "mt-1 text-2xl font-semibold text-gray-900", children: e })
  ] }),
  t && /* @__PURE__ */ M.jsx("div", { className: "flex h-12 w-12 items-center justify-center rounded-lg bg-primary-50", children: /* @__PURE__ */ M.jsx(Ee, { icon: t, className: "h-6 w-6 text-primary-600" }) })
] }), _g = ({
  widgets: r,
  className: e
}) => /* @__PURE__ */ M.jsx("div", { className: ie("w-full grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4", e), children: r.map((t, i) => /* @__PURE__ */ M.jsx(hg, { ...t }, i)) });
export {
  gg as Accordion,
  hh as AutoComplete,
  fg as Avatar,
  pg as Badge,
  gu as Breadcrumbs,
  mt as Button,
  jn as Card,
  xg as Chart,
  mg as Checkbox,
  bg as Chip,
  Vd as DatePicker,
  $d as Dialog,
  Zd as DialogActions,
  qd as DialogBody,
  Do as DialogHeader,
  Ud as DialogTitle,
  Jd as Divider,
  vg as FileUpload,
  vt as Icon,
  Yn as Input,
  yg as Notification,
  Qd as Pagination,
  wg as Radio,
  Ho as Select,
  ss as SelectItem,
  eu as Skeleton,
  Sg as Slider,
  kg as StarRating,
  Cg as StatusIndicator,
  Ag as Stepper,
  Mg as Switch,
  Ig as Table,
  Rg as Tabs,
  Pg as Text,
  lu as TimePicker,
  Ko as Toast,
  Eg as ToastProvider,
  du as Toggle,
  Lg as Tooltip,
  hg as WidgetCard,
  _g as WidgetCardGroup,
  dh as buttonVariants,
  uh as cardVariants,
  ie as cn,
  cu as toggleVariants,
  Tg as useToast
};
