import * as Qr from "react";
import He, { forwardRef as Ge, useState as Ee, useRef as Ve, useEffect as ht, useCallback as bt, Children as ba, isValidElement as gr, cloneElement as Rl, createContext as Pl, useContext as Ll } from "react";
import { createPortal as ei } from "react-dom";
var Il = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yn(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function El(s) {
  if (s.__esModule) return s;
  var e = s.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(s).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(s, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return s[i];
      }
    });
  }), t;
}
var es = { exports: {} }, oi = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var va;
function Tl() {
  if (va) return oi;
  va = 1;
  var s = He, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), i = Object.prototype.hasOwnProperty, r = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function n(o, l, c) {
    var h, d = {}, u = null, g = null;
    c !== void 0 && (u = "" + c), l.key !== void 0 && (u = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (h in l) i.call(l, h) && !a.hasOwnProperty(h) && (d[h] = l[h]);
    if (o && o.defaultProps) for (h in l = o.defaultProps, l) d[h] === void 0 && (d[h] = l[h]);
    return { $$typeof: e, type: o, key: u, ref: g, props: d, _owner: r.current };
  }
  return oi.Fragment = t, oi.jsx = n, oi.jsxs = n, oi;
}
var li = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ya;
function _l() {
  return ya || (ya = 1, process.env.NODE_ENV !== "production" && function() {
    var s = He, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), n = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), u = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), p = Symbol.iterator, f = "@@iterator";
    function x(E) {
      if (E === null || typeof E != "object")
        return null;
      var K = p && E[p] || E[f];
      return typeof K == "function" ? K : null;
    }
    var m = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(E) {
      {
        for (var K = arguments.length, se = new Array(K > 1 ? K - 1 : 0), he = 1; he < K; he++)
          se[he - 1] = arguments[he];
        w("error", E, se);
      }
    }
    function w(E, K, se) {
      {
        var he = m.ReactDebugCurrentFrame, we = he.getStackAddendum();
        we !== "" && (K += "%s", se = se.concat([we]));
        var Pe = se.map(function(xe) {
          return String(xe);
        });
        Pe.unshift("Warning: " + K), Function.prototype.apply.call(console[E], console, Pe);
      }
    }
    var y = !1, v = !1, k = !1, S = !1, C = !1, M;
    M = Symbol.for("react.module.reference");
    function R(E) {
      return !!(typeof E == "string" || typeof E == "function" || E === i || E === a || C || E === r || E === c || E === h || S || E === g || y || v || k || typeof E == "object" && E !== null && (E.$$typeof === u || E.$$typeof === d || E.$$typeof === n || E.$$typeof === o || E.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      E.$$typeof === M || E.getModuleId !== void 0));
    }
    function P(E, K, se) {
      var he = E.displayName;
      if (he)
        return he;
      var we = K.displayName || K.name || "";
      return we !== "" ? se + "(" + we + ")" : se;
    }
    function I(E) {
      return E.displayName || "Context";
    }
    function D(E) {
      if (E == null)
        return null;
      if (typeof E.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof E == "function")
        return E.displayName || E.name || null;
      if (typeof E == "string")
        return E;
      switch (E) {
        case i:
          return "Fragment";
        case t:
          return "Portal";
        case a:
          return "Profiler";
        case r:
          return "StrictMode";
        case c:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof E == "object")
        switch (E.$$typeof) {
          case o:
            var K = E;
            return I(K) + ".Consumer";
          case n:
            var se = E;
            return I(se._context) + ".Provider";
          case l:
            return P(E, E.render, "ForwardRef");
          case d:
            var he = E.displayName || null;
            return he !== null ? he : D(E.type) || "Memo";
          case u: {
            var we = E, Pe = we._payload, xe = we._init;
            try {
              return D(xe(Pe));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var N = Object.assign, z = 0, L, T, H, B, _, O, Y;
    function X() {
    }
    X.__reactDisabledLog = !0;
    function V() {
      {
        if (z === 0) {
          L = console.log, T = console.info, H = console.warn, B = console.error, _ = console.group, O = console.groupCollapsed, Y = console.groupEnd;
          var E = {
            configurable: !0,
            enumerable: !0,
            value: X,
            writable: !0
          };
          Object.defineProperties(console, {
            info: E,
            log: E,
            warn: E,
            error: E,
            group: E,
            groupCollapsed: E,
            groupEnd: E
          });
        }
        z++;
      }
    }
    function W() {
      {
        if (z--, z === 0) {
          var E = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: N({}, E, {
              value: L
            }),
            info: N({}, E, {
              value: T
            }),
            warn: N({}, E, {
              value: H
            }),
            error: N({}, E, {
              value: B
            }),
            group: N({}, E, {
              value: _
            }),
            groupCollapsed: N({}, E, {
              value: O
            }),
            groupEnd: N({}, E, {
              value: Y
            })
          });
        }
        z < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var G = m.ReactCurrentDispatcher, U;
    function Z(E, K, se) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (we) {
            var he = we.stack.trim().match(/\n( *(at )?)/);
            U = he && he[1] || "";
          }
        return `
` + U + E;
      }
    }
    var re = !1, ee;
    {
      var de = typeof WeakMap == "function" ? WeakMap : Map;
      ee = new de();
    }
    function q(E, K) {
      if (!E || re)
        return "";
      {
        var se = ee.get(E);
        if (se !== void 0)
          return se;
      }
      var he;
      re = !0;
      var we = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Pe;
      Pe = G.current, G.current = null, V();
      try {
        if (K) {
          var xe = function() {
            throw Error();
          };
          if (Object.defineProperty(xe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(xe, []);
            } catch (Ke) {
              he = Ke;
            }
            Reflect.construct(E, [], xe);
          } else {
            try {
              xe.call();
            } catch (Ke) {
              he = Ke;
            }
            E.call(xe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ke) {
            he = Ke;
          }
          E();
        }
      } catch (Ke) {
        if (Ke && he && typeof Ke.stack == "string") {
          for (var pe = Ke.stack.split(`
`), $e = he.stack.split(`
`), Fe = pe.length - 1, Ne = $e.length - 1; Fe >= 1 && Ne >= 0 && pe[Fe] !== $e[Ne]; )
            Ne--;
          for (; Fe >= 1 && Ne >= 0; Fe--, Ne--)
            if (pe[Fe] !== $e[Ne]) {
              if (Fe !== 1 || Ne !== 1)
                do
                  if (Fe--, Ne--, Ne < 0 || pe[Fe] !== $e[Ne]) {
                    var at = `
` + pe[Fe].replace(" at new ", " at ");
                    return E.displayName && at.includes("<anonymous>") && (at = at.replace("<anonymous>", E.displayName)), typeof E == "function" && ee.set(E, at), at;
                  }
                while (Fe >= 1 && Ne >= 0);
              break;
            }
        }
      } finally {
        re = !1, G.current = Pe, W(), Error.prepareStackTrace = we;
      }
      var Wt = E ? E.displayName || E.name : "", Et = Wt ? Z(Wt) : "";
      return typeof E == "function" && ee.set(E, Et), Et;
    }
    function ne(E, K, se) {
      return q(E, !1);
    }
    function _e(E) {
      var K = E.prototype;
      return !!(K && K.isReactComponent);
    }
    function Be(E, K, se) {
      if (E == null)
        return "";
      if (typeof E == "function")
        return q(E, _e(E));
      if (typeof E == "string")
        return Z(E);
      switch (E) {
        case c:
          return Z("Suspense");
        case h:
          return Z("SuspenseList");
      }
      if (typeof E == "object")
        switch (E.$$typeof) {
          case l:
            return ne(E.render);
          case d:
            return Be(E.type, K, se);
          case u: {
            var he = E, we = he._payload, Pe = he._init;
            try {
              return Be(Pe(we), K, se);
            } catch {
            }
          }
        }
      return "";
    }
    var Ze = Object.prototype.hasOwnProperty, pt = {}, Oi = m.ReactDebugCurrentFrame;
    function zi(E) {
      if (E) {
        var K = E._owner, se = Be(E.type, E._source, K ? K.type : null);
        Oi.setExtraStackFrame(se);
      } else
        Oi.setExtraStackFrame(null);
    }
    function al(E, K, se, he, we) {
      {
        var Pe = Function.call.bind(Ze);
        for (var xe in E)
          if (Pe(E, xe)) {
            var pe = void 0;
            try {
              if (typeof E[xe] != "function") {
                var $e = Error((he || "React class") + ": " + se + " type `" + xe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof E[xe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $e.name = "Invariant Violation", $e;
              }
              pe = E[xe](K, xe, he, se, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Fe) {
              pe = Fe;
            }
            pe && !(pe instanceof Error) && (zi(we), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", he || "React class", se, xe, typeof pe), zi(null)), pe instanceof Error && !(pe.message in pt) && (pt[pe.message] = !0, zi(we), b("Failed %s type: %s", se, pe.message), zi(null));
          }
      }
    }
    var nl = Array.isArray;
    function lr(E) {
      return nl(E);
    }
    function ol(E) {
      {
        var K = typeof Symbol == "function" && Symbol.toStringTag, se = K && E[Symbol.toStringTag] || E.constructor.name || "Object";
        return se;
      }
    }
    function ll(E) {
      try {
        return na(E), !1;
      } catch {
        return !0;
      }
    }
    function na(E) {
      return "" + E;
    }
    function oa(E) {
      if (ll(E))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ol(E)), na(E);
    }
    var la = m.ReactCurrentOwner, cl = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ca, ha;
    function hl(E) {
      if (Ze.call(E, "ref")) {
        var K = Object.getOwnPropertyDescriptor(E, "ref").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return E.ref !== void 0;
    }
    function dl(E) {
      if (Ze.call(E, "key")) {
        var K = Object.getOwnPropertyDescriptor(E, "key").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return E.key !== void 0;
    }
    function ul(E, K) {
      typeof E.ref == "string" && la.current;
    }
    function gl(E, K) {
      {
        var se = function() {
          ca || (ca = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        se.isReactWarning = !0, Object.defineProperty(E, "key", {
          get: se,
          configurable: !0
        });
      }
    }
    function fl(E, K) {
      {
        var se = function() {
          ha || (ha = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        se.isReactWarning = !0, Object.defineProperty(E, "ref", {
          get: se,
          configurable: !0
        });
      }
    }
    var pl = function(E, K, se, he, we, Pe, xe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: E,
        key: K,
        ref: se,
        props: xe,
        // Record the component responsible for creating this element.
        _owner: Pe
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: he
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: we
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function xl(E, K, se, he, we) {
      {
        var Pe, xe = {}, pe = null, $e = null;
        se !== void 0 && (oa(se), pe = "" + se), dl(K) && (oa(K.key), pe = "" + K.key), hl(K) && ($e = K.ref, ul(K, we));
        for (Pe in K)
          Ze.call(K, Pe) && !cl.hasOwnProperty(Pe) && (xe[Pe] = K[Pe]);
        if (E && E.defaultProps) {
          var Fe = E.defaultProps;
          for (Pe in Fe)
            xe[Pe] === void 0 && (xe[Pe] = Fe[Pe]);
        }
        if (pe || $e) {
          var Ne = typeof E == "function" ? E.displayName || E.name || "Unknown" : E;
          pe && gl(xe, Ne), $e && fl(xe, Ne);
        }
        return pl(E, pe, $e, we, he, la.current, xe);
      }
    }
    var cr = m.ReactCurrentOwner, da = m.ReactDebugCurrentFrame;
    function Bt(E) {
      if (E) {
        var K = E._owner, se = Be(E.type, E._source, K ? K.type : null);
        da.setExtraStackFrame(se);
      } else
        da.setExtraStackFrame(null);
    }
    var hr;
    hr = !1;
    function dr(E) {
      return typeof E == "object" && E !== null && E.$$typeof === e;
    }
    function ua() {
      {
        if (cr.current) {
          var E = D(cr.current.type);
          if (E)
            return `

Check the render method of \`` + E + "`.";
        }
        return "";
      }
    }
    function ml(E) {
      return "";
    }
    var ga = {};
    function bl(E) {
      {
        var K = ua();
        if (!K) {
          var se = typeof E == "string" ? E : E.displayName || E.name;
          se && (K = `

Check the top-level render call using <` + se + ">.");
        }
        return K;
      }
    }
    function fa(E, K) {
      {
        if (!E._store || E._store.validated || E.key != null)
          return;
        E._store.validated = !0;
        var se = bl(K);
        if (ga[se])
          return;
        ga[se] = !0;
        var he = "";
        E && E._owner && E._owner !== cr.current && (he = " It was passed a child from " + D(E._owner.type) + "."), Bt(E), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', se, he), Bt(null);
      }
    }
    function pa(E, K) {
      {
        if (typeof E != "object")
          return;
        if (lr(E))
          for (var se = 0; se < E.length; se++) {
            var he = E[se];
            dr(he) && fa(he, K);
          }
        else if (dr(E))
          E._store && (E._store.validated = !0);
        else if (E) {
          var we = x(E);
          if (typeof we == "function" && we !== E.entries)
            for (var Pe = we.call(E), xe; !(xe = Pe.next()).done; )
              dr(xe.value) && fa(xe.value, K);
        }
      }
    }
    function vl(E) {
      {
        var K = E.type;
        if (K == null || typeof K == "string")
          return;
        var se;
        if (typeof K == "function")
          se = K.propTypes;
        else if (typeof K == "object" && (K.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        K.$$typeof === d))
          se = K.propTypes;
        else
          return;
        if (se) {
          var he = D(K);
          al(se, E.props, "prop", he, E);
        } else if (K.PropTypes !== void 0 && !hr) {
          hr = !0;
          var we = D(K);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", we || "Unknown");
        }
        typeof K.getDefaultProps == "function" && !K.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yl(E) {
      {
        for (var K = Object.keys(E.props), se = 0; se < K.length; se++) {
          var he = K[se];
          if (he !== "children" && he !== "key") {
            Bt(E), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", he), Bt(null);
            break;
          }
        }
        E.ref !== null && (Bt(E), b("Invalid attribute `ref` supplied to `React.Fragment`."), Bt(null));
      }
    }
    var xa = {};
    function ma(E, K, se, he, we, Pe) {
      {
        var xe = R(E);
        if (!xe) {
          var pe = "";
          (E === void 0 || typeof E == "object" && E !== null && Object.keys(E).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var $e = ml();
          $e ? pe += $e : pe += ua();
          var Fe;
          E === null ? Fe = "null" : lr(E) ? Fe = "array" : E !== void 0 && E.$$typeof === e ? (Fe = "<" + (D(E.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : Fe = typeof E, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Fe, pe);
        }
        var Ne = xl(E, K, se, we, Pe);
        if (Ne == null)
          return Ne;
        if (xe) {
          var at = K.children;
          if (at !== void 0)
            if (he)
              if (lr(at)) {
                for (var Wt = 0; Wt < at.length; Wt++)
                  pa(at[Wt], E);
                Object.freeze && Object.freeze(at);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              pa(at, E);
        }
        if (Ze.call(K, "key")) {
          var Et = D(E), Ke = Object.keys(K).filter(function(Ml) {
            return Ml !== "key";
          }), ur = Ke.length > 0 ? "{key: someKey, " + Ke.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!xa[Et + ur]) {
            var Al = Ke.length > 0 ? "{" + Ke.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ur, Et, Al, Et), xa[Et + ur] = !0;
          }
        }
        return E === i ? yl(Ne) : vl(Ne), Ne;
      }
    }
    function wl(E, K, se) {
      return ma(E, K, se, !0);
    }
    function kl(E, K, se) {
      return ma(E, K, se, !1);
    }
    var Sl = kl, Cl = wl;
    li.Fragment = i, li.jsx = Sl, li.jsxs = Cl;
  }()), li;
}
process.env.NODE_ENV === "production" ? es.exports = Tl() : es.exports = _l();
var A = es.exports;
function wn(s) {
  var e, t, i = "";
  if (typeof s == "string" || typeof s == "number") i += s;
  else if (typeof s == "object") if (Array.isArray(s)) {
    var r = s.length;
    for (e = 0; e < r; e++) s[e] && (t = wn(s[e])) && (i && (i += " "), i += t);
  } else for (t in s) s[t] && (i && (i += " "), i += t);
  return i;
}
function ve() {
  for (var s, e, t = 0, i = "", r = arguments.length; t < r; t++) (s = arguments[t]) && (e = wn(s)) && (i && (i += " "), i += e);
  return i;
}
const wa = (s) => typeof s == "boolean" ? `${s}` : s === 0 ? "0" : s, ka = ve, rt = (s, e) => (t) => {
  var i;
  if ((e == null ? void 0 : e.variants) == null) return ka(s, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
  const { variants: r, defaultVariants: a } = e, n = Object.keys(r).map((c) => {
    const h = t == null ? void 0 : t[c], d = a == null ? void 0 : a[c];
    if (h === null) return null;
    const u = wa(h) || wa(d);
    return r[c][u];
  }), o = t && Object.entries(t).reduce((c, h) => {
    let [d, u] = h;
    return u === void 0 || (c[d] = u), c;
  }, {}), l = e == null || (i = e.compoundVariants) === null || i === void 0 ? void 0 : i.reduce((c, h) => {
    let { class: d, className: u, ...g } = h;
    return Object.entries(g).every((p) => {
      let [f, x] = p;
      return Array.isArray(x) ? x.includes({
        ...a,
        ...o
      }[f]) : {
        ...a,
        ...o
      }[f] === x;
    }) ? [
      ...c,
      d,
      u
    ] : c;
  }, []);
  return ka(s, n, l, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
}, Os = "-", Ol = (s) => {
  const e = Fl(s), {
    conflictingClassGroups: t,
    conflictingClassGroupModifiers: i
  } = s;
  return {
    getClassGroupId: (n) => {
      const o = n.split(Os);
      return o[0] === "" && o.length !== 1 && o.shift(), kn(o, e) || zl(n);
    },
    getConflictingClassGroupIds: (n, o) => {
      const l = t[n] || [];
      return o && i[n] ? [...l, ...i[n]] : l;
    }
  };
}, kn = (s, e) => {
  var n;
  if (s.length === 0)
    return e.classGroupId;
  const t = s[0], i = e.nextPart.get(t), r = i ? kn(s.slice(1), i) : void 0;
  if (r)
    return r;
  if (e.validators.length === 0)
    return;
  const a = s.join(Os);
  return (n = e.validators.find(({
    validator: o
  }) => o(a))) == null ? void 0 : n.classGroupId;
}, Sa = /^\[(.+)\]$/, zl = (s) => {
  if (Sa.test(s)) {
    const e = Sa.exec(s)[1], t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (t)
      return "arbitrary.." + t;
  }
}, Fl = (s) => {
  const {
    theme: e,
    prefix: t
  } = s, i = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Dl(Object.entries(s.classGroups), t).forEach(([a, n]) => {
    ts(n, i, a, e);
  }), i;
}, ts = (s, e, t, i) => {
  s.forEach((r) => {
    if (typeof r == "string") {
      const a = r === "" ? e : Ca(e, r);
      a.classGroupId = t;
      return;
    }
    if (typeof r == "function") {
      if (Nl(r)) {
        ts(r(i), e, t, i);
        return;
      }
      e.validators.push({
        validator: r,
        classGroupId: t
      });
      return;
    }
    Object.entries(r).forEach(([a, n]) => {
      ts(n, Ca(e, a), t, i);
    });
  });
}, Ca = (s, e) => {
  let t = s;
  return e.split(Os).forEach((i) => {
    t.nextPart.has(i) || t.nextPart.set(i, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), t = t.nextPart.get(i);
  }), t;
}, Nl = (s) => s.isThemeGetter, Dl = (s, e) => e ? s.map(([t, i]) => {
  const r = i.map((a) => typeof a == "string" ? e + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([n, o]) => [e + n, o])) : a);
  return [t, r];
}) : s, Hl = (s) => {
  if (s < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  const r = (a, n) => {
    t.set(a, n), e++, e > s && (e = 0, i = t, t = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let n = t.get(a);
      if (n !== void 0)
        return n;
      if ((n = i.get(a)) !== void 0)
        return r(a, n), n;
    },
    set(a, n) {
      t.has(a) ? t.set(a, n) : r(a, n);
    }
  };
}, Sn = "!", jl = (s) => {
  const {
    separator: e,
    experimentalParseClassName: t
  } = s, i = e.length === 1, r = e[0], a = e.length, n = (o) => {
    const l = [];
    let c = 0, h = 0, d;
    for (let x = 0; x < o.length; x++) {
      let m = o[x];
      if (c === 0) {
        if (m === r && (i || o.slice(x, x + a) === e)) {
          l.push(o.slice(h, x)), h = x + a;
          continue;
        }
        if (m === "/") {
          d = x;
          continue;
        }
      }
      m === "[" ? c++ : m === "]" && c--;
    }
    const u = l.length === 0 ? o : o.substring(h), g = u.startsWith(Sn), p = g ? u.substring(1) : u, f = d && d > h ? d - h : void 0;
    return {
      modifiers: l,
      hasImportantModifier: g,
      baseClassName: p,
      maybePostfixModifierPosition: f
    };
  };
  return t ? (o) => t({
    className: o,
    parseClassName: n
  }) : n;
}, Yl = (s) => {
  if (s.length <= 1)
    return s;
  const e = [];
  let t = [];
  return s.forEach((i) => {
    i[0] === "[" ? (e.push(...t.sort(), i), t = []) : t.push(i);
  }), e.push(...t.sort()), e;
}, Xl = (s) => ({
  cache: Hl(s.cacheSize),
  parseClassName: jl(s),
  ...Ol(s)
}), Bl = /\s+/, Wl = (s, e) => {
  const {
    parseClassName: t,
    getClassGroupId: i,
    getConflictingClassGroupIds: r
  } = e, a = [], n = s.trim().split(Bl);
  let o = "";
  for (let l = n.length - 1; l >= 0; l -= 1) {
    const c = n[l], {
      modifiers: h,
      hasImportantModifier: d,
      baseClassName: u,
      maybePostfixModifierPosition: g
    } = t(c);
    let p = !!g, f = i(p ? u.substring(0, g) : u);
    if (!f) {
      if (!p) {
        o = c + (o.length > 0 ? " " + o : o);
        continue;
      }
      if (f = i(u), !f) {
        o = c + (o.length > 0 ? " " + o : o);
        continue;
      }
      p = !1;
    }
    const x = Yl(h).join(":"), m = d ? x + Sn : x, b = m + f;
    if (a.includes(b))
      continue;
    a.push(b);
    const w = r(f, p);
    for (let y = 0; y < w.length; ++y) {
      const v = w[y];
      a.push(m + v);
    }
    o = c + (o.length > 0 ? " " + o : o);
  }
  return o;
};
function Vl() {
  let s = 0, e, t, i = "";
  for (; s < arguments.length; )
    (e = arguments[s++]) && (t = Cn(e)) && (i && (i += " "), i += t);
  return i;
}
const Cn = (s) => {
  if (typeof s == "string")
    return s;
  let e, t = "";
  for (let i = 0; i < s.length; i++)
    s[i] && (e = Cn(s[i])) && (t && (t += " "), t += e);
  return t;
};
function Gl(s, ...e) {
  let t, i, r, a = n;
  function n(l) {
    const c = e.reduce((h, d) => d(h), s());
    return t = Xl(c), i = t.cache.get, r = t.cache.set, a = o, o(l);
  }
  function o(l) {
    const c = i(l);
    if (c)
      return c;
    const h = Wl(l, t);
    return r(l, h), h;
  }
  return function() {
    return a(Vl.apply(null, arguments));
  };
}
const Te = (s) => {
  const e = (t) => t[s] || [];
  return e.isThemeGetter = !0, e;
}, An = /^\[(?:([a-z-]+):)?(.+)\]$/i, $l = /^\d+\/\d+$/, Ul = /* @__PURE__ */ new Set(["px", "full", "screen"]), ql = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Zl = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Kl = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Jl = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Ql = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, xt = (s) => Ut(s) || Ul.has(s) || $l.test(s), kt = (s) => ti(s, "length", oc), Ut = (s) => !!s && !Number.isNaN(Number(s)), fr = (s) => ti(s, "number", Ut), ci = (s) => !!s && Number.isInteger(Number(s)), ec = (s) => s.endsWith("%") && Ut(s.slice(0, -1)), ge = (s) => An.test(s), St = (s) => ql.test(s), tc = /* @__PURE__ */ new Set(["length", "size", "percentage"]), ic = (s) => ti(s, tc, Mn), rc = (s) => ti(s, "position", Mn), sc = /* @__PURE__ */ new Set(["image", "url"]), ac = (s) => ti(s, sc, cc), nc = (s) => ti(s, "", lc), hi = () => !0, ti = (s, e, t) => {
  const i = An.exec(s);
  return i ? i[1] ? typeof e == "string" ? i[1] === e : e.has(i[1]) : t(i[2]) : !1;
}, oc = (s) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Zl.test(s) && !Kl.test(s)
), Mn = () => !1, lc = (s) => Jl.test(s), cc = (s) => Ql.test(s), hc = () => {
  const s = Te("colors"), e = Te("spacing"), t = Te("blur"), i = Te("brightness"), r = Te("borderColor"), a = Te("borderRadius"), n = Te("borderSpacing"), o = Te("borderWidth"), l = Te("contrast"), c = Te("grayscale"), h = Te("hueRotate"), d = Te("invert"), u = Te("gap"), g = Te("gradientColorStops"), p = Te("gradientColorStopPositions"), f = Te("inset"), x = Te("margin"), m = Te("opacity"), b = Te("padding"), w = Te("saturate"), y = Te("scale"), v = Te("sepia"), k = Te("skew"), S = Te("space"), C = Te("translate"), M = () => ["auto", "contain", "none"], R = () => ["auto", "hidden", "clip", "visible", "scroll"], P = () => ["auto", ge, e], I = () => [ge, e], D = () => ["", xt, kt], N = () => ["auto", Ut, ge], z = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], L = () => ["solid", "dashed", "dotted", "double", "none"], T = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], H = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], B = () => ["", "0", ge], _ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], O = () => [Ut, ge];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [hi],
      spacing: [xt, kt],
      blur: ["none", "", St, ge],
      brightness: O(),
      borderColor: [s],
      borderRadius: ["none", "", "full", St, ge],
      borderSpacing: I(),
      borderWidth: D(),
      contrast: O(),
      grayscale: B(),
      hueRotate: O(),
      invert: B(),
      gap: I(),
      gradientColorStops: [s],
      gradientColorStopPositions: [ec, kt],
      inset: P(),
      margin: P(),
      opacity: O(),
      padding: I(),
      saturate: O(),
      scale: O(),
      sepia: B(),
      skew: O(),
      space: I(),
      translate: I()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ge]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [St]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": _()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": _()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...z(), ge]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: R()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": R()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": R()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: M()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": M()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": M()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [f]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [f]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [f]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [f]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [f]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [f]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [f]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [f]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [f]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ci, ge]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: P()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ge]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: B()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: B()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ci, ge]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [hi]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ci, ge]
        }, ge]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": N()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": N()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [hi]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ci, ge]
        }, ge]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": N()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": N()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ge]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ge]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [u]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [u]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [u]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...H()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...H(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...H(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [b]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [b]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [b]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [b]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [b]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [b]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [b]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [b]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [b]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [x]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [x]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [x]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [x]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [x]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [x]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [x]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [x]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [x]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [S]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [S]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ge, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ge, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ge, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [St]
        }, St]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ge, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ge, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ge, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ge, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", St, kt]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", fr]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [hi]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ge]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Ut, fr]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", xt, ge]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ge]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ge]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [s]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [m]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [s]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [m]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...L(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", xt, kt]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", xt, ge]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [s]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: I()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ge]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ge]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [m]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...z(), rc]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", ic]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, ac]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [s]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [g]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [g]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [g]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [o]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [o]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [o]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [o]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [o]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [o]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [o]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [o]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [o]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [m]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...L(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [o]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [o]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [m]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: L()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [r]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [r]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [r]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [r]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [r]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [r]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [r]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [r]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [r]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [r]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...L()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [xt, ge]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [xt, kt]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [s]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: D()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [s]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [m]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [xt, kt]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [s]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", St, nc]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [hi]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [m]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...T(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": T()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [t]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [i]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", St, ge]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [h]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [w]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [v]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [t]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [i]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [h]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [m]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [w]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [v]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [n]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [n]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [n]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ge]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: O()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ge]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: O()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ge]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [y]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [y]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [y]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ci, ge]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [C]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [C]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [k]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [k]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ge]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", s]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ge]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [s]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": I()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": I()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": I()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": I()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": I()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": I()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": I()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": I()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": I()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": I()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": I()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": I()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": I()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": I()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": I()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": I()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": I()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": I()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ge]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [s, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [xt, kt, fr]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [s, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Zt = /* @__PURE__ */ Gl(hc);
function Q(...s) {
  return Zt(ve(s));
}
const pi = /^[a-z0-9]+(-[a-z0-9]+)*$/, ir = (s, e, t, i = "") => {
  const r = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (r.length < 2 || r.length > 3)
      return null;
    i = r.shift().slice(1);
  }
  if (r.length > 3 || !r.length)
    return null;
  if (r.length > 1) {
    const o = r.pop(), l = r.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: r.length > 0 ? r[0] : i,
      prefix: l,
      name: o
    };
    return e && !Bi(c) ? null : c;
  }
  const a = r[0], n = a.split("-");
  if (n.length > 1) {
    const o = {
      provider: i,
      prefix: n.shift(),
      name: n.join("-")
    };
    return e && !Bi(o) ? null : o;
  }
  if (t && i === "") {
    const o = {
      provider: i,
      prefix: "",
      name: a
    };
    return e && !Bi(o, t) ? null : o;
  }
  return null;
}, Bi = (s, e) => s ? !!((s.provider === "" || s.provider.match(pi)) && (e && s.prefix === "" || s.prefix.match(pi)) && s.name.match(pi)) : !1, Rn = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Zi = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), zs = Object.freeze({
  ...Rn,
  ...Zi
}), is = Object.freeze({
  ...zs,
  body: "",
  hidden: !1
});
function dc(s, e) {
  const t = {};
  !s.hFlip != !e.hFlip && (t.hFlip = !0), !s.vFlip != !e.vFlip && (t.vFlip = !0);
  const i = ((s.rotate || 0) + (e.rotate || 0)) % 4;
  return i && (t.rotate = i), t;
}
function Aa(s, e) {
  const t = dc(s, e);
  for (const i in is)
    i in Zi ? i in s && !(i in t) && (t[i] = Zi[i]) : i in e ? t[i] = e[i] : i in s && (t[i] = s[i]);
  return t;
}
function uc(s, e) {
  const t = s.icons, i = s.aliases || /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function a(n) {
    if (t[n])
      return r[n] = [];
    if (!(n in r)) {
      r[n] = null;
      const o = i[n] && i[n].parent, l = o && a(o);
      l && (r[n] = [o].concat(l));
    }
    return r[n];
  }
  return Object.keys(t).concat(Object.keys(i)).forEach(a), r;
}
function gc(s, e, t) {
  const i = s.icons, r = s.aliases || /* @__PURE__ */ Object.create(null);
  let a = {};
  function n(o) {
    a = Aa(
      i[o] || r[o],
      a
    );
  }
  return n(e), t.forEach(n), Aa(s, a);
}
function Pn(s, e) {
  const t = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return t;
  s.not_found instanceof Array && s.not_found.forEach((r) => {
    e(r, null), t.push(r);
  });
  const i = uc(s);
  for (const r in i) {
    const a = i[r];
    a && (e(r, gc(s, r, a)), t.push(r));
  }
  return t;
}
const fc = {
  provider: "",
  aliases: {},
  not_found: {},
  ...Rn
};
function pr(s, e) {
  for (const t in e)
    if (t in s && typeof s[t] != typeof e[t])
      return !1;
  return !0;
}
function Ln(s) {
  if (typeof s != "object" || s === null)
    return null;
  const e = s;
  if (typeof e.prefix != "string" || !s.icons || typeof s.icons != "object" || !pr(s, fc))
    return null;
  const t = e.icons;
  for (const r in t) {
    const a = t[r];
    if (!r.match(pi) || typeof a.body != "string" || !pr(
      a,
      is
    ))
      return null;
  }
  const i = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const r in i) {
    const a = i[r], n = a.parent;
    if (!r.match(pi) || typeof n != "string" || !t[n] && !i[n] || !pr(
      a,
      is
    ))
      return null;
  }
  return e;
}
const Ma = /* @__PURE__ */ Object.create(null);
function pc(s, e) {
  return {
    provider: s,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Ht(s, e) {
  const t = Ma[s] || (Ma[s] = /* @__PURE__ */ Object.create(null));
  return t[e] || (t[e] = pc(s, e));
}
function Fs(s, e) {
  return Ln(e) ? Pn(e, (t, i) => {
    i ? s.icons[t] = i : s.missing.add(t);
  }) : [];
}
function xc(s, e, t) {
  try {
    if (typeof t.body == "string")
      return s.icons[e] = { ...t }, !0;
  } catch {
  }
  return !1;
}
let yi = !1;
function In(s) {
  return typeof s == "boolean" && (yi = s), yi;
}
function mc(s) {
  const e = typeof s == "string" ? ir(s, !0, yi) : s;
  if (e) {
    const t = Ht(e.provider, e.prefix), i = e.name;
    return t.icons[i] || (t.missing.has(i) ? null : void 0);
  }
}
function bc(s, e) {
  const t = ir(s, !0, yi);
  if (!t)
    return !1;
  const i = Ht(t.provider, t.prefix);
  return xc(i, t.name, e);
}
function vc(s, e) {
  if (typeof s != "object")
    return !1;
  if (typeof e != "string" && (e = s.provider || ""), yi && !e && !s.prefix) {
    let r = !1;
    return Ln(s) && (s.prefix = "", Pn(s, (a, n) => {
      n && bc(a, n) && (r = !0);
    })), r;
  }
  const t = s.prefix;
  if (!Bi({
    provider: e,
    prefix: t,
    name: "a"
  }))
    return !1;
  const i = Ht(e, t);
  return !!Fs(i, s);
}
const En = Object.freeze({
  width: null,
  height: null
}), Tn = Object.freeze({
  // Dimensions
  ...En,
  // Transformations
  ...Zi
}), yc = /(-?[0-9.]*[0-9]+[0-9.]*)/g, wc = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Ra(s, e, t) {
  if (e === 1)
    return s;
  if (t = t || 100, typeof s == "number")
    return Math.ceil(s * e * t) / t;
  if (typeof s != "string")
    return s;
  const i = s.split(yc);
  if (i === null || !i.length)
    return s;
  const r = [];
  let a = i.shift(), n = wc.test(a);
  for (; ; ) {
    if (n) {
      const o = parseFloat(a);
      isNaN(o) ? r.push(a) : r.push(Math.ceil(o * e * t) / t);
    } else
      r.push(a);
    if (a = i.shift(), a === void 0)
      return r.join("");
    n = !n;
  }
}
const kc = (s) => s === "unset" || s === "undefined" || s === "none";
function Sc(s, e) {
  const t = {
    ...zs,
    ...s
  }, i = {
    ...Tn,
    ...e
  }, r = {
    left: t.left,
    top: t.top,
    width: t.width,
    height: t.height
  };
  let a = t.body;
  [t, i].forEach((p) => {
    const f = [], x = p.hFlip, m = p.vFlip;
    let b = p.rotate;
    x ? m ? b += 2 : (f.push(
      "translate(" + (r.width + r.left).toString() + " " + (0 - r.top).toString() + ")"
    ), f.push("scale(-1 1)"), r.top = r.left = 0) : m && (f.push(
      "translate(" + (0 - r.left).toString() + " " + (r.height + r.top).toString() + ")"
    ), f.push("scale(1 -1)"), r.top = r.left = 0);
    let w;
    switch (b < 0 && (b -= Math.floor(b / 4) * 4), b = b % 4, b) {
      case 1:
        w = r.height / 2 + r.top, f.unshift(
          "rotate(90 " + w.toString() + " " + w.toString() + ")"
        );
        break;
      case 2:
        f.unshift(
          "rotate(180 " + (r.width / 2 + r.left).toString() + " " + (r.height / 2 + r.top).toString() + ")"
        );
        break;
      case 3:
        w = r.width / 2 + r.left, f.unshift(
          "rotate(-90 " + w.toString() + " " + w.toString() + ")"
        );
        break;
    }
    b % 2 === 1 && (r.left !== r.top && (w = r.left, r.left = r.top, r.top = w), r.width !== r.height && (w = r.width, r.width = r.height, r.height = w)), f.length && (a = '<g transform="' + f.join(" ") + '">' + a + "</g>");
  });
  const n = i.width, o = i.height, l = r.width, c = r.height;
  let h, d;
  n === null ? (d = o === null ? "1em" : o === "auto" ? c : o, h = Ra(d, l / c)) : (h = n === "auto" ? l : n, d = o === null ? Ra(h, c / l) : o === "auto" ? c : o);
  const u = {}, g = (p, f) => {
    kc(f) || (u[p] = f.toString());
  };
  return g("width", h), g("height", d), u.viewBox = r.left.toString() + " " + r.top.toString() + " " + l.toString() + " " + c.toString(), {
    attributes: u,
    body: a
  };
}
const Cc = /\sid="(\S+)"/g, Ac = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let Mc = 0;
function Rc(s, e = Ac) {
  const t = [];
  let i;
  for (; i = Cc.exec(s); )
    t.push(i[1]);
  if (!t.length)
    return s;
  const r = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return t.forEach((a) => {
    const n = typeof e == "function" ? e(a) : e + (Mc++).toString(), o = a.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + o + ')([")]|\\.[a-z])', "g"),
      "$1" + n + r + "$3"
    );
  }), s = s.replace(new RegExp(r, "g"), ""), s;
}
const rs = /* @__PURE__ */ Object.create(null);
function Pc(s, e) {
  rs[s] = e;
}
function ss(s) {
  return rs[s] || rs[""];
}
function Ns(s) {
  let e;
  if (typeof s.resources == "string")
    e = [s.resources];
  else if (e = s.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const Ds = /* @__PURE__ */ Object.create(null), di = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Wi = [];
for (; di.length > 0; )
  di.length === 1 || Math.random() > 0.5 ? Wi.push(di.shift()) : Wi.push(di.pop());
Ds[""] = Ns({
  resources: ["https://api.iconify.design"].concat(Wi)
});
function Lc(s, e) {
  const t = Ns(e);
  return t === null ? !1 : (Ds[s] = t, !0);
}
function Hs(s) {
  return Ds[s];
}
const Ic = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let Pa = Ic();
function Ec(s, e) {
  const t = Hs(s);
  if (!t)
    return 0;
  let i;
  if (!t.maxURL)
    i = 0;
  else {
    let r = 0;
    t.resources.forEach((n) => {
      r = Math.max(r, n.length);
    });
    const a = e + ".json?icons=";
    i = t.maxURL - r - t.path.length - a.length;
  }
  return i;
}
function Tc(s) {
  return s === 404;
}
const _c = (s, e, t) => {
  const i = [], r = Ec(s, e), a = "icons";
  let n = {
    type: a,
    provider: s,
    prefix: e,
    icons: []
  }, o = 0;
  return t.forEach((l, c) => {
    o += l.length + 1, o >= r && c > 0 && (i.push(n), n = {
      type: a,
      provider: s,
      prefix: e,
      icons: []
    }, o = l.length), n.icons.push(l);
  }), i.push(n), i;
};
function Oc(s) {
  if (typeof s == "string") {
    const e = Hs(s);
    if (e)
      return e.path;
  }
  return "/";
}
const zc = (s, e, t) => {
  if (!Pa) {
    t("abort", 424);
    return;
  }
  let i = Oc(e.provider);
  switch (e.type) {
    case "icons": {
      const a = e.prefix, o = e.icons.join(","), l = new URLSearchParams({
        icons: o
      });
      i += a + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const a = e.uri;
      i += a.slice(0, 1) === "/" ? a.slice(1) : a;
      break;
    }
    default:
      t("abort", 400);
      return;
  }
  let r = 503;
  Pa(s + i).then((a) => {
    const n = a.status;
    if (n !== 200) {
      setTimeout(() => {
        t(Tc(n) ? "abort" : "next", n);
      });
      return;
    }
    return r = 501, a.json();
  }).then((a) => {
    if (typeof a != "object" || a === null) {
      setTimeout(() => {
        a === 404 ? t("abort", a) : t("next", r);
      });
      return;
    }
    setTimeout(() => {
      t("success", a);
    });
  }).catch(() => {
    t("next", r);
  });
}, Fc = {
  prepare: _c,
  send: zc
};
function Nc(s) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, t = /* @__PURE__ */ Object.create(null);
  s.sort((r, a) => r.provider !== a.provider ? r.provider.localeCompare(a.provider) : r.prefix !== a.prefix ? r.prefix.localeCompare(a.prefix) : r.name.localeCompare(a.name));
  let i = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((r) => {
    if (i.name === r.name && i.prefix === r.prefix && i.provider === r.provider)
      return;
    i = r;
    const a = r.provider, n = r.prefix, o = r.name, l = t[a] || (t[a] = /* @__PURE__ */ Object.create(null)), c = l[n] || (l[n] = Ht(a, n));
    let h;
    o in c.icons ? h = e.loaded : n === "" || c.missing.has(o) ? h = e.missing : h = e.pending;
    const d = {
      provider: a,
      prefix: n,
      name: o
    };
    h.push(d);
  }), e;
}
function _n(s, e) {
  s.forEach((t) => {
    const i = t.loaderCallbacks;
    i && (t.loaderCallbacks = i.filter((r) => r.id !== e));
  });
}
function Dc(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const e = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let t = !1;
    const i = s.provider, r = s.prefix;
    e.forEach((a) => {
      const n = a.icons, o = n.pending.length;
      n.pending = n.pending.filter((l) => {
        if (l.prefix !== r)
          return !0;
        const c = l.name;
        if (s.icons[c])
          n.loaded.push({
            provider: i,
            prefix: r,
            name: c
          });
        else if (s.missing.has(c))
          n.missing.push({
            provider: i,
            prefix: r,
            name: c
          });
        else
          return t = !0, !0;
        return !1;
      }), n.pending.length !== o && (t || _n([s], a.id), a.callback(
        n.loaded.slice(0),
        n.missing.slice(0),
        n.pending.slice(0),
        a.abort
      ));
    });
  }));
}
let Hc = 0;
function jc(s, e, t) {
  const i = Hc++, r = _n.bind(null, t, i);
  if (!e.pending.length)
    return r;
  const a = {
    id: i,
    icons: e,
    callback: s,
    abort: r
  };
  return t.forEach((n) => {
    (n.loaderCallbacks || (n.loaderCallbacks = [])).push(a);
  }), r;
}
function Yc(s, e = !0, t = !1) {
  const i = [];
  return s.forEach((r) => {
    const a = typeof r == "string" ? ir(r, e, t) : r;
    a && i.push(a);
  }), i;
}
var Xc = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function Bc(s, e, t, i) {
  const r = s.resources.length, a = s.random ? Math.floor(Math.random() * r) : s.index;
  let n;
  if (s.random) {
    let k = s.resources.slice(0);
    for (n = []; k.length > 1; ) {
      const S = Math.floor(Math.random() * k.length);
      n.push(k[S]), k = k.slice(0, S).concat(k.slice(S + 1));
    }
    n = n.concat(k);
  } else
    n = s.resources.slice(a).concat(s.resources.slice(0, a));
  const o = Date.now();
  let l = "pending", c = 0, h, d = null, u = [], g = [];
  typeof i == "function" && g.push(i);
  function p() {
    d && (clearTimeout(d), d = null);
  }
  function f() {
    l === "pending" && (l = "aborted"), p(), u.forEach((k) => {
      k.status === "pending" && (k.status = "aborted");
    }), u = [];
  }
  function x(k, S) {
    S && (g = []), typeof k == "function" && g.push(k);
  }
  function m() {
    return {
      startTime: o,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: u.length,
      subscribe: x,
      abort: f
    };
  }
  function b() {
    l = "failed", g.forEach((k) => {
      k(void 0, h);
    });
  }
  function w() {
    u.forEach((k) => {
      k.status === "pending" && (k.status = "aborted");
    }), u = [];
  }
  function y(k, S, C) {
    const M = S !== "success";
    switch (u = u.filter((R) => R !== k), l) {
      case "pending":
        break;
      case "failed":
        if (M || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (S === "abort") {
      h = C, b();
      return;
    }
    if (M) {
      h = C, u.length || (n.length ? v() : b());
      return;
    }
    if (p(), w(), !s.random) {
      const R = s.resources.indexOf(k.resource);
      R !== -1 && R !== s.index && (s.index = R);
    }
    l = "completed", g.forEach((R) => {
      R(C);
    });
  }
  function v() {
    if (l !== "pending")
      return;
    p();
    const k = n.shift();
    if (k === void 0) {
      if (u.length) {
        d = setTimeout(() => {
          p(), l === "pending" && (w(), b());
        }, s.timeout);
        return;
      }
      b();
      return;
    }
    const S = {
      status: "pending",
      resource: k,
      callback: (C, M) => {
        y(S, C, M);
      }
    };
    u.push(S), c++, d = setTimeout(v, s.rotate), t(k, e, S.callback);
  }
  return setTimeout(v), m;
}
function On(s) {
  const e = {
    ...Xc,
    ...s
  };
  let t = [];
  function i() {
    t = t.filter((o) => o().status === "pending");
  }
  function r(o, l, c) {
    const h = Bc(
      e,
      o,
      l,
      (d, u) => {
        i(), c && c(d, u);
      }
    );
    return t.push(h), h;
  }
  function a(o) {
    return t.find((l) => o(l)) || null;
  }
  return {
    query: r,
    find: a,
    setIndex: (o) => {
      e.index = o;
    },
    getIndex: () => e.index,
    cleanup: i
  };
}
function La() {
}
const xr = /* @__PURE__ */ Object.create(null);
function Wc(s) {
  if (!xr[s]) {
    const e = Hs(s);
    if (!e)
      return;
    const t = On(e), i = {
      config: e,
      redundancy: t
    };
    xr[s] = i;
  }
  return xr[s];
}
function Vc(s, e, t) {
  let i, r;
  if (typeof s == "string") {
    const a = ss(s);
    if (!a)
      return t(void 0, 424), La;
    r = a.send;
    const n = Wc(s);
    n && (i = n.redundancy);
  } else {
    const a = Ns(s);
    if (a) {
      i = On(a);
      const n = s.resources ? s.resources[0] : "", o = ss(n);
      o && (r = o.send);
    }
  }
  return !i || !r ? (t(void 0, 424), La) : i.query(e, r, t)().abort;
}
const Ia = "iconify2", wi = "iconify", zn = wi + "-count", Ea = wi + "-version", Fn = 36e5, Gc = 168;
function as(s, e) {
  try {
    return s.getItem(e);
  } catch {
  }
}
function js(s, e, t) {
  try {
    return s.setItem(e, t), !0;
  } catch {
  }
}
function Ta(s, e) {
  try {
    s.removeItem(e);
  } catch {
  }
}
function ns(s, e) {
  return js(s, zn, e.toString());
}
function os(s) {
  return parseInt(as(s, zn)) || 0;
}
const rr = {
  local: !0,
  session: !0
}, Nn = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Ys = !1;
function $c(s) {
  Ys = s;
}
let Fi = typeof window > "u" ? {} : window;
function Dn(s) {
  const e = s + "Storage";
  try {
    if (Fi && Fi[e] && typeof Fi[e].length == "number")
      return Fi[e];
  } catch {
  }
  rr[s] = !1;
}
function Hn(s, e) {
  const t = Dn(s);
  if (!t)
    return;
  const i = as(t, Ea);
  if (i !== Ia) {
    if (i) {
      const o = os(t);
      for (let l = 0; l < o; l++)
        Ta(t, wi + l.toString());
    }
    js(t, Ea, Ia), ns(t, 0);
    return;
  }
  const r = Math.floor(Date.now() / Fn) - Gc, a = (o) => {
    const l = wi + o.toString(), c = as(t, l);
    if (typeof c == "string") {
      try {
        const h = JSON.parse(c);
        if (typeof h == "object" && typeof h.cached == "number" && h.cached > r && typeof h.provider == "string" && typeof h.data == "object" && typeof h.data.prefix == "string" && // Valid item: run callback
        e(h, o))
          return !0;
      } catch {
      }
      Ta(t, l);
    }
  };
  let n = os(t);
  for (let o = n - 1; o >= 0; o--)
    a(o) || (o === n - 1 ? (n--, ns(t, n)) : Nn[s].add(o));
}
function jn() {
  if (!Ys) {
    $c(!0);
    for (const s in rr)
      Hn(s, (e) => {
        const t = e.data, i = e.provider, r = t.prefix, a = Ht(
          i,
          r
        );
        if (!Fs(a, t).length)
          return !1;
        const n = t.lastModified || -1;
        return a.lastModifiedCached = a.lastModifiedCached ? Math.min(a.lastModifiedCached, n) : n, !0;
      });
  }
}
function Uc(s, e) {
  const t = s.lastModifiedCached;
  if (
    // Matches or newer
    t && t >= e
  )
    return t === e;
  if (s.lastModifiedCached = e, t)
    for (const i in rr)
      Hn(i, (r) => {
        const a = r.data;
        return r.provider !== s.provider || a.prefix !== s.prefix || a.lastModified === e;
      });
  return !0;
}
function qc(s, e) {
  Ys || jn();
  function t(i) {
    let r;
    if (!rr[i] || !(r = Dn(i)))
      return;
    const a = Nn[i];
    let n;
    if (a.size)
      a.delete(n = Array.from(a).shift());
    else if (n = os(r), !ns(r, n + 1))
      return;
    const o = {
      cached: Math.floor(Date.now() / Fn),
      provider: s.provider,
      data: e
    };
    return js(
      r,
      wi + n.toString(),
      JSON.stringify(o)
    );
  }
  e.lastModified && !Uc(s, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), t("local") || t("session"));
}
function _a() {
}
function Zc(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, Dc(s);
  }));
}
function Kc(s, e) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(e).sort() : s.iconsToLoad = e, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: t, prefix: i } = s, r = s.iconsToLoad;
    delete s.iconsToLoad;
    let a;
    if (!r || !(a = ss(t)))
      return;
    a.prepare(t, i, r).forEach((o) => {
      Vc(t, o, (l) => {
        if (typeof l != "object")
          o.icons.forEach((c) => {
            s.missing.add(c);
          });
        else
          try {
            const c = Fs(
              s,
              l
            );
            if (!c.length)
              return;
            const h = s.pendingIcons;
            h && c.forEach((d) => {
              h.delete(d);
            }), qc(s, l);
          } catch (c) {
            console.error(c);
          }
        Zc(s);
      });
    });
  }));
}
const Jc = (s, e) => {
  const t = Yc(s, !0, In()), i = Nc(t);
  if (!i.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        i.loaded,
        i.missing,
        i.pending,
        _a
      );
    }), () => {
      l = !1;
    };
  }
  const r = /* @__PURE__ */ Object.create(null), a = [];
  let n, o;
  return i.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === o && c === n)
      return;
    n = c, o = h, a.push(Ht(c, h));
    const d = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
    d[h] || (d[h] = []);
  }), i.pending.forEach((l) => {
    const { provider: c, prefix: h, name: d } = l, u = Ht(c, h), g = u.pendingIcons || (u.pendingIcons = /* @__PURE__ */ new Set());
    g.has(d) || (g.add(d), r[c][h].push(d));
  }), a.forEach((l) => {
    const { provider: c, prefix: h } = l;
    r[c][h].length && Kc(l, r[c][h]);
  }), e ? jc(e, i, a) : _a;
};
function Qc(s, e) {
  const t = {
    ...s
  };
  for (const i in e) {
    const r = e[i], a = typeof r;
    i in En ? (r === null || r && (a === "string" || a === "number")) && (t[i] = r) : a === typeof t[i] && (t[i] = i === "rotate" ? r % 4 : r);
  }
  return t;
}
const eh = /[\s,]+/;
function th(s, e) {
  e.split(eh).forEach((t) => {
    switch (t.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function ih(s, e = 0) {
  const t = s.replace(/^-?[0-9.]*/, "");
  function i(r) {
    for (; r < 0; )
      r += 4;
    return r % 4;
  }
  if (t === "") {
    const r = parseInt(s);
    return isNaN(r) ? 0 : i(r);
  } else if (t !== s) {
    let r = 0;
    switch (t) {
      case "%":
        r = 25;
        break;
      case "deg":
        r = 90;
    }
    if (r) {
      let a = parseFloat(s.slice(0, s.length - t.length));
      return isNaN(a) ? 0 : (a = a / r, a % 1 === 0 ? i(a) : 0);
    }
  }
  return e;
}
function rh(s, e) {
  let t = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const i in e)
    t += " " + i + '="' + e[i] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + t + ">" + s + "</svg>";
}
function sh(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function ah(s) {
  return "data:image/svg+xml," + sh(s);
}
function nh(s) {
  return 'url("' + ah(s) + '")';
}
let xi;
function oh() {
  try {
    xi = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    xi = null;
  }
}
function lh(s) {
  return xi === void 0 && oh(), xi ? xi.createHTML(s) : s;
}
const Yn = {
  ...Tn,
  inline: !1
}, ch = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, hh = {
  display: "inline-block"
}, ls = {
  backgroundColor: "currentColor"
}, Xn = {
  backgroundColor: "transparent"
}, Oa = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, za = {
  WebkitMask: ls,
  mask: ls,
  background: Xn
};
for (const s in za) {
  const e = za[s];
  for (const t in Oa)
    e[s + t] = Oa[t];
}
const dh = {
  ...Yn,
  inline: !0
};
function Fa(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const uh = (s, e, t, i) => {
  const r = t ? dh : Yn, a = Qc(r, e), n = e.mode || "svg", o = {}, l = e.style || {}, c = {
    ...n === "svg" ? ch : {},
    ref: i
  };
  for (let m in e) {
    const b = e[m];
    if (b !== void 0)
      switch (m) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          a[m] = b === !0 || b === "true" || b === 1;
          break;
        case "flip":
          typeof b == "string" && th(a, b);
          break;
        case "color":
          o.color = b;
          break;
        case "rotate":
          typeof b == "string" ? a[m] = ih(b) : typeof b == "number" && (a[m] = b);
          break;
        case "ariaHidden":
        case "aria-hidden":
          b !== !0 && b !== "true" && delete c["aria-hidden"];
          break;
        default:
          r[m] === void 0 && (c[m] = b);
      }
  }
  const h = Sc(s, a), d = h.attributes;
  if (a.inline && (o.verticalAlign = "-0.125em"), n === "svg") {
    c.style = {
      ...o,
      ...l
    }, Object.assign(c, d);
    let m = 0, b = e.id;
    return typeof b == "string" && (b = b.replace(/-/g, "_")), c.dangerouslySetInnerHTML = {
      __html: lh(Rc(h.body, b ? () => b + "ID" + m++ : "iconifyReact"))
    }, He.createElement("svg", c);
  }
  const { body: u, width: g, height: p } = s, f = n === "mask" || (n === "bg" ? !1 : u.indexOf("currentColor") !== -1), x = rh(u, {
    ...d,
    width: g + "",
    height: p + ""
  });
  return c.style = {
    ...o,
    "--svg": nh(x),
    width: Fa(d.width),
    height: Fa(d.height),
    ...hh,
    ...f ? ls : Xn,
    ...l
  }, He.createElement("span", c);
};
In(!0);
Pc("", Fc);
if (typeof document < "u" && typeof window < "u") {
  jn();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const e = s.IconifyPreload, t = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((i) => {
      try {
        // Check if item is an object and not null/array
        (typeof i != "object" || i === null || i instanceof Array || // Check for 'icons' and 'prefix'
        typeof i.icons != "object" || typeof i.prefix != "string" || // Add icon set
        !vc(i)) && console.error(t);
      } catch {
        console.error(t);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const e = s.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let t in e) {
        const i = "IconifyProviders[" + t + "] is invalid.";
        try {
          const r = e[t];
          if (typeof r != "object" || !r || r.resources === void 0)
            continue;
          Lc(t, r) || console.error(i);
        } catch {
          console.error(i);
        }
      }
  }
}
class Bn extends He.Component {
  constructor(e) {
    super(e), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(e) {
    this.state.icon !== e && this.setState({
      icon: e
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(e) {
    const t = this.state, i = this.props.icon;
    if (typeof i == "object" && i !== null && typeof i.body == "string") {
      this._icon = "", this._abortLoading(), (e || t.icon === null) && this._setData({
        data: i
      });
      return;
    }
    let r;
    if (typeof i != "string" || (r = ir(i, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const a = mc(r);
    if (!a) {
      (!this._loading || this._loading.name !== i) && (this._abortLoading(), this._icon = "", this._setData(null), a !== null && (this._loading = {
        name: i,
        abort: Jc([r], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== i || t.icon === null) {
      this._abortLoading(), this._icon = i;
      const n = ["iconify"];
      r.prefix !== "" && n.push("iconify--" + r.prefix), r.provider !== "" && n.push("iconify--" + r.provider), this._setData({
        data: a,
        classes: n
      }), this.props.onLoad && this.props.onLoad(i);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(e) {
    e.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const e = this.props, t = this.state.icon;
    if (t === null)
      return e.children ? e.children : He.createElement("span", {});
    let i = e;
    return t.classes && (i = {
      ...e,
      className: (typeof e.className == "string" ? e.className + " " : "") + t.classes.join(" ")
    }), uh({
      ...zs,
      ...t.data
    }, i, e._inline, e._ref);
  }
}
const Le = He.forwardRef(function(e, t) {
  const i = {
    ...e,
    _ref: t,
    _inline: !1
  };
  return He.createElement(Bn, i);
});
He.forwardRef(function(e, t) {
  const i = {
    ...e,
    _ref: t,
    _inline: !0
  };
  return He.createElement(Bn, i);
});
const gh = rt(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "md",
      fullWidth: !0
    }
  }
), Wn = Ge(
  ({
    className: s,
    variant: e = "default",
    size: t = "md",
    rounded: i = "md",
    error: r = !1,
    errorText: a,
    helperText: n,
    label: o,
    required: l = !1,
    labelPlacement: c = "top",
    fullWidth: h = !1,
    leftIcon: d,
    rightIcon: u,
    id: g,
    ...p
  }, f) => {
    const x = g || He.useId(), m = `${x}-helper`, b = `${x}-error`, w = /* @__PURE__ */ A.jsxs("div", { className: Q("relative", !h && "inline-block"), children: [
      d && /* @__PURE__ */ A.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ A.jsx(Le, { icon: d, className: "w-4 h-4" }) }),
      /* @__PURE__ */ A.jsx(
        "input",
        {
          id: x,
          type: "text",
          ref: f,
          className: Q(
            gh({ variant: r ? "error" : e, size: t, rounded: i, fullWidth: h }),
            d && "pl-10",
            u && "pr-10",
            s
          ),
          "aria-describedby": r ? b : n ? m : void 0,
          "aria-invalid": r,
          "aria-required": l,
          ...p
        }
      ),
      u && /* @__PURE__ */ A.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ A.jsx(Le, { icon: u, className: "w-4 h-4" }) })
    ] }), y = /* @__PURE__ */ A.jsxs(A.Fragment, { children: [
      r && a && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-xs text-danger-500", id: b, children: a }),
      !r && n && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-xs text-neutral-500", id: m, children: n })
    ] });
    return c === "left" ? /* @__PURE__ */ A.jsx("div", { className: Q(h ? "w-full" : "inline-block", s), children: /* @__PURE__ */ A.jsxs("div", { className: "flex items-start gap-4", children: [
      o && /* @__PURE__ */ A.jsxs(
        "label",
        {
          htmlFor: x,
          className: "block text-sm text-neutral-900 pt-2",
          children: [
            o,
            l && /* @__PURE__ */ A.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ A.jsxs("div", { className: Q("flex-1", !h && "inline-block"), children: [
        w,
        y
      ] })
    ] }) }) : /* @__PURE__ */ A.jsxs("div", { className: Q(h ? "w-full" : "inline-block", s), children: [
      o && /* @__PURE__ */ A.jsxs(
        "label",
        {
          htmlFor: x,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            o,
            l && /* @__PURE__ */ A.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
          ]
        }
      ),
      w,
      y
    ] });
  }
);
Wn.displayName = "Input";
const sr = He.forwardRef(
  ({ className: s, children: e, selected: t, disabled: i, ...r }, a) => /* @__PURE__ */ A.jsx(
    "div",
    {
      ref: a,
      className: Q(
        "relative flex w-full cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors",
        "hover:bg-primary-50",
        t && "bg-primary-50 text-primary-900",
        i && "pointer-events-none opacity-50",
        s
      ),
      ...r,
      children: e
    }
  )
);
sr.displayName = "SelectItem";
const mr = "autocomplete-dropdown-opened", fh = rt(
  "fixed z-[9999] min-w-[8rem] rounded-md border border-neutral-200 bg-white py-1 shadow-lg",
  {
    variants: {
      position: {
        bottom: "top-full",
        top: "bottom-full"
      }
    },
    defaultVariants: {
      position: "bottom"
    }
  }
), ph = Ge(
  ({
    className: s,
    options: e,
    onSelect: t,
    isOpen: i,
    dropdownPosition: r = "bottom",
    loading: a = !1,
    renderOption: n,
    variant: o = "default",
    size: l = "md",
    rounded: c = "md",
    leftIcon: h,
    rightIcon: d,
    error: u = !1,
    errorText: g,
    helperText: p,
    label: f,
    required: x = !1,
    labelPlacement: m = "top",
    fullWidth: b = !1,
    value: w,
    onChange: y,
    onFocus: v,
    onBlur: k,
    showClear: S = !1,
    onClear: C,
    ...M
  }, R) => {
    const [P, I] = Ee(!1), [D, N] = Ee(w || ""), z = Ve(null), L = Ve(null), T = Ve(null), H = i !== void 0, _ = `autocomplete-${He.useId().replace(/:/g, "")}`, O = () => {
      if (!P || !L.current || !T.current) return;
      const { bottom: q, top: ne, left: _e, width: Be } = L.current.getBoundingClientRect(), Ze = T.current, pt = {
        position: "fixed",
        left: `${_e}px`,
        width: `${Be}px`
      }, Oi = r === "bottom" ? {
        ...pt,
        top: `${q + 4}px`,
        maxHeight: `${window.innerHeight - q - 8}px`
      } : {
        ...pt,
        bottom: `${window.innerHeight - ne + 4}px`,
        maxHeight: `${ne - 8}px`
      };
      Object.assign(Ze.style, Oi);
    };
    ht(() => {
      N(w || "");
    }, [w]), ht(() => {
      const q = () => {
        P && O();
      }, ne = () => {
        P && O();
      }, _e = (Ze) => {
        Ze.detail.id !== _ && I(!1);
      }, Be = (Ze) => {
        const pt = Ze.target;
        z.current && !z.current.contains(pt) && T.current && !T.current.contains(pt) && I(!1);
      };
      return P && (O(), window.addEventListener("scroll", q, !0), window.addEventListener("resize", ne)), document.addEventListener(mr, _e), document.addEventListener("click", Be), () => {
        window.removeEventListener("scroll", q, !0), window.removeEventListener("resize", ne), document.removeEventListener(mr, _e), document.removeEventListener("click", Be);
      };
    }, [P, _]);
    const Y = (q) => {
      const { value: ne } = q.target;
      if (N(ne), !ne.trim()) {
        I(!1);
        return;
      }
      I(!0), y == null || y(q);
    }, X = (q) => {
      q.stopPropagation(), N(""), C == null || C();
      const ne = new Event("change");
      ne.target = { value: "" }, y == null || y(ne);
    }, V = (q) => {
      var Ze;
      if (!q) return;
      const { value: ne, label: _e } = q;
      N(_e), I(!1), t == null || t(ne);
      const Be = new CustomEvent("autocomplete-select", {
        detail: { selectedOption: q }
      });
      (Ze = L.current) == null || Ze.dispatchEvent(Be);
    }, W = (q) => {
      H || (document.dispatchEvent(
        new CustomEvent(mr, {
          detail: { id: _ }
        })
      ), I(!0)), v == null || v(q);
    }, G = (q) => {
      k == null || k(q);
    }, U = e.filter(
      ({ label: q }) => q.toLowerCase().includes((D || "").toLowerCase().trim())
    ), Z = H ? i : P, re = S && D && !M.disabled && !M.readOnly, ee = re ? "mdi:close" : d, de = () => {
      if (!Z) return null;
      const q = /* @__PURE__ */ A.jsx(
        "div",
        {
          ref: T,
          className: Q(
            fh({ position: r }),
            "overflow-auto"
          ),
          onClick: (ne) => ne.stopPropagation(),
          children: a ? /* @__PURE__ */ A.jsx("div", { className: "flex items-center justify-center py-2", children: /* @__PURE__ */ A.jsx("div", { className: "h-4 w-4 animate-spin rounded-full border-2 border-primary-500 border-t-transparent" }) }) : U.length > 0 ? U.map((ne) => /* @__PURE__ */ A.jsx(
            sr,
            {
              value: ne.value,
              selected: ne.label === D,
              onClick: () => V(ne),
              children: n ? n(ne) : ne.label
            },
            ne.value
          )) : /* @__PURE__ */ A.jsx("div", { className: "px-2 py-2 text-sm text-neutral-500", children: "No options found" })
        }
      );
      return ei(q, document.body);
    };
    return /* @__PURE__ */ A.jsxs("div", { ref: z, className: Q("relative", b ? "w-full" : "inline-block"), children: [
      /* @__PURE__ */ A.jsx("div", { ref: L, className: Q(!b && "inline-block"), children: /* @__PURE__ */ A.jsx(
        Wn,
        {
          ref: R,
          value: D,
          onChange: Y,
          onFocus: W,
          onBlur: G,
          variant: o,
          size: l,
          rounded: c,
          leftIcon: h,
          rightIcon: ee,
          error: u,
          errorText: g,
          helperText: p,
          label: f,
          required: x,
          labelPlacement: m,
          fullWidth: b,
          className: s,
          ...M,
          onClick: re ? X : M.onClick
        }
      ) }),
      de()
    ] });
  }
);
ph.displayName = "AutoComplete";
const Rg = ({
  items: s,
  multiple: e = !1,
  defaultOpenIds: t = [],
  icon: i = "mdi:chevron-down",
  iconPosition: r = "right",
  className: a,
  itemClassName: n,
  headerClassName: o,
  contentClassName: l
}) => {
  const [c, h] = Ee(t), d = (u) => {
    h(
      e ? (g) => g.includes(u) ? g.filter((p) => p !== u) : [...g, u] : (g) => g.includes(u) ? [] : [u]
    );
  };
  return /* @__PURE__ */ A.jsx("div", { className: ve("w-full space-y-2", a), children: s.map((u) => {
    const g = c.includes(u.id), p = !!u.disabled;
    return /* @__PURE__ */ A.jsxs(
      "div",
      {
        className: ve(
          "border rounded-lg overflow-hidden",
          "bg-white",
          "border-gray-200",
          n
        ),
        children: [
          /* @__PURE__ */ A.jsxs(
            "button",
            {
              onClick: () => !p && d(u.id),
              disabled: p,
              className: ve(
                "w-full flex items-center justify-between p-4",
                "text-left transition-colors",
                "hover:bg-primary-50",
                p && "opacity-50 cursor-not-allowed",
                o
              ),
              children: [
                r === "left" && /* @__PURE__ */ A.jsx(
                  "div",
                  {
                    className: ve(
                      "mr-3 transition-transform duration-200",
                      g && "rotate-180"
                    ),
                    children: /* @__PURE__ */ A.jsx(Le, { icon: i, className: "w-5 h-5" })
                  }
                ),
                /* @__PURE__ */ A.jsx("div", { className: "flex-1", children: u.title }),
                r === "right" && /* @__PURE__ */ A.jsx(
                  "div",
                  {
                    className: ve(
                      "ml-3 transition-transform duration-200",
                      g && "rotate-180"
                    ),
                    children: /* @__PURE__ */ A.jsx(Le, { icon: i, className: "w-5 h-5" })
                  }
                )
              ]
            }
          ),
          g && /* @__PURE__ */ A.jsx(
            "div",
            {
              className: ve(
                "p-4 border-t border-gray-200",
                l
              ),
              children: u.content
            }
          )
        ]
      },
      u.id
    );
  }) });
}, Pg = ({
  src: s,
  alt: e = "avatar",
  size: t = "medium",
  shape: i = "circle",
  className: r = ""
}) => {
  const a = {
    small: "w-8 h-8",
    medium: "w-12 h-12",
    large: "w-16 h-16"
  }, n = {
    circle: "rounded-full",
    square: "rounded-lg"
  }, o = Zt(
    "inline-flex items-center justify-center overflow-hidden bg-gray-200",
    a[t],
    n[i],
    r
  );
  return /* @__PURE__ */ A.jsx("div", { className: o, children: s ? /* @__PURE__ */ A.jsx("img", { src: s, alt: e, className: "w-full h-full object-cover" }) : /* @__PURE__ */ A.jsx(
    "svg",
    {
      className: "w-6 h-6 text-gray-500",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ A.jsx(
        "path",
        {
          d: "M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z",
          fill: "currentColor"
        }
      )
    }
  ) });
}, Lg = ({
  children: s,
  variant: e = "primary",
  size: t = "medium",
  rounded: i = "md",
  className: r = ""
}) => {
  const a = {
    primary: "bg-blue-100 text-blue-800",
    secondary: "bg-gray-100 text-gray-800",
    success: "bg-green-100 text-green-800",
    warning: "bg-yellow-100 text-yellow-800",
    error: "bg-red-100 text-red-800"
  }, n = {
    small: "px-2 py-0.5 text-xs",
    medium: "px-2.5 py-1 text-sm",
    large: "px-3 py-1.5 text-base"
  }, o = {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded-md",
    lg: "rounded-lg",
    full: "rounded-full"
  }, l = Zt(
    "inline-flex items-center font-medium",
    a[e],
    n[t],
    o[i],
    r
  );
  return /* @__PURE__ */ A.jsx("span", { className: l, children: s });
}, xh = rt(
  "inline-flex items-center justify-center gap-2 font-medium transition-all duration-200 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed",
  {
    variants: {
      variant: {
        primary: "bg-primary-500 text-white hover:bg-primary-600 active:bg-primary-700 shadow-sm hover:shadow-md active:shadow-none",
        secondary: "bg-secondary-500 text-white hover:bg-secondary-600 active:bg-secondary-700 shadow-sm hover:shadow-md active:shadow-none",
        outline: "border border-neutral-300 text-primary-500 hover:bg-primary-50 active:bg-primary-100 hover:border-primary-500",
        "outline-primary": "border border-primary-600 text-primary-600 hover:bg-primary-50",
        "outline-secondary": "border border-secondary-600 text-secondary-600 hover:bg-secondary-50",
        "outline-success": "border border-success-600 text-success-600 hover:bg-success-50",
        "outline-warning": "border border-warning-600 text-warning-600 hover:bg-warning-50",
        "outline-danger": "border border-danger-600 text-danger-600 hover:bg-danger-50",
        ghost: "text-primary-500 hover:bg-primary-50 active:bg-primary-100",
        link: "text-primary-500 hover:underline p-0",
        success: "bg-success-500 text-white hover:bg-success-600 active:bg-success-700 shadow-sm hover:shadow-md active:shadow-none",
        warning: "bg-warning-500 text-white hover:bg-warning-600 active:bg-warning-700 shadow-sm hover:shadow-md active:shadow-none",
        danger: "bg-danger-500 text-white hover:bg-danger-600 active:bg-danger-700 shadow-sm hover:shadow-md active:shadow-none"
      },
      size: {
        xs: "text-xs px-2 py-1",
        sm: "text-sm px-3 py-1.5",
        md: "text-base px-4 py-2",
        lg: "text-lg px-5 py-2.5"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full"
      },
      isIconOnly: {
        true: "p-2 aspect-square"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      rounded: "none",
      fullWidth: !1,
      isIconOnly: !1
    }
  }
), et = Ge(
  ({
    className: s,
    variant: e = "primary",
    size: t = "md",
    rounded: i = "md",
    fullWidth: r = !1,
    isLoading: a = !1,
    leftIcon: n,
    rightIcon: o,
    isIconOnly: l = !1,
    children: c,
    ...h
  }, d) => {
    const g = l || !!(n || o) && !c;
    return /* @__PURE__ */ A.jsxs(
      "button",
      {
        className: Q(
          xh({
            variant: e,
            size: t,
            rounded: g ? "full" : i,
            fullWidth: r,
            isIconOnly: g,
            className: s
          })
        ),
        ref: d,
        disabled: h.disabled || a,
        ...h,
        children: [
          a && /* @__PURE__ */ A.jsx("span", { className: "animate-spin inline-block w-4 h-4 border-2 border-current border-r-transparent rounded-full" }),
          !a && n && /* @__PURE__ */ A.jsx(Le, { icon: n, className: "w-4 h-4" }),
          c && /* @__PURE__ */ A.jsx("span", { children: c }),
          !a && o && /* @__PURE__ */ A.jsx(Le, { icon: o, className: "w-4 h-4" })
        ]
      }
    );
  }
);
et.displayName = "Button";
const mh = rt(
  "border bg-card text-card-foreground",
  {
    variants: {
      variant: {
        default: "border-border shadow-sm",
        elevated: "border-border shadow-lg",
        outline: "border-border bg-transparent",
        ghost: "border-transparent bg-transparent"
      },
      padding: {
        none: "p-0",
        sm: "p-4",
        md: "p-6",
        lg: "p-8"
      },
      shadow: {
        none: "",
        sm: "shadow-sm",
        md: "shadow-md",
        lg: "shadow-lg",
        xl: "shadow-xl"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        xl: "rounded-xl",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      padding: "md",
      shadow: "sm",
      rounded: "md"
    }
  }
), Vn = Ge(
  ({
    className: s,
    variant: e = "default",
    padding: t = "md",
    shadow: i = "none",
    rounded: r = "md",
    asChild: a = !1,
    ...n
  }, o) => /* @__PURE__ */ A.jsx(
    "div",
    {
      className: Q(mh({ variant: e, padding: t, shadow: i, rounded: r, className: s })),
      ref: o,
      ...n
    }
  )
);
Vn.displayName = "Card";
var Gn = {};
/*!
 * ApexCharts v4.7.0
 * (c) 2018-2025 ApexCharts
 * Released under the MIT License.
 */
function cs(s, e) {
  (e == null || e > s.length) && (e = s.length);
  for (var t = 0, i = Array(e); t < e; t++) i[t] = s[t];
  return i;
}
function $n(s) {
  if (s === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function te(s, e) {
  if (!(s instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function Na(s, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(s, Zn(i.key), i);
  }
}
function ie(s, e, t) {
  return e && Na(s.prototype, e), t && Na(s, t), Object.defineProperty(s, "prototype", { writable: !1 }), s;
}
function fi(s, e) {
  var t = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
  if (!t) {
    if (Array.isArray(s) || (t = Xs(s)) || e) {
      t && (s = t);
      var i = 0, r = function() {
      };
      return { s: r, n: function() {
        return i >= s.length ? { done: !0 } : { done: !1, value: s[i++] };
      }, e: function(l) {
        throw l;
      }, f: r };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, n = !0, o = !1;
  return { s: function() {
    t = t.call(s);
  }, n: function() {
    var l = t.next();
    return n = l.done, l;
  }, e: function(l) {
    o = !0, a = l;
  }, f: function() {
    try {
      n || t.return == null || t.return();
    } finally {
      if (o) throw a;
    }
  } };
}
function Pi(s) {
  var e = Un();
  return function() {
    var t, i = Ji(s);
    if (e) {
      var r = Ji(this).constructor;
      t = Reflect.construct(i, arguments, r);
    } else t = i.apply(this, arguments);
    return function(a, n) {
      if (n && (typeof n == "object" || typeof n == "function")) return n;
      if (n !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
      return $n(a);
    }(this, t);
  };
}
function Ki(s, e, t) {
  return (e = Zn(e)) in s ? Object.defineProperty(s, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : s[e] = t, s;
}
function Ji(s) {
  return Ji = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Ji(s);
}
function Li(s, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(e && e.prototype, { constructor: { value: s, writable: !0, configurable: !0 } }), Object.defineProperty(s, "prototype", { writable: !1 }), e && hs(s, e);
}
function Un() {
  try {
    var s = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Un = function() {
    return !!s;
  })();
}
function Da(s, e) {
  var t = Object.keys(s);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(s);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(s, r).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function J(s) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Da(Object(t), !0).forEach(function(i) {
      Ki(s, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : Da(Object(t)).forEach(function(i) {
      Object.defineProperty(s, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return s;
}
function hs(s, e) {
  return hs = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, i) {
    return t.__proto__ = i, t;
  }, hs(s, e);
}
function qn(s, e) {
  return function(t) {
    if (Array.isArray(t)) return t;
  }(s) || function(t, i) {
    var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r != null) {
      var a, n, o, l, c = [], h = !0, d = !1;
      try {
        if (o = (r = r.call(t)).next, i === 0) {
          if (Object(r) !== r) return;
          h = !1;
        } else for (; !(h = (a = o.call(r)).done) && (c.push(a.value), c.length !== i); h = !0) ;
      } catch (u) {
        d = !0, n = u;
      } finally {
        try {
          if (!h && r.return != null && (l = r.return(), Object(l) !== l)) return;
        } finally {
          if (d) throw n;
        }
      }
      return c;
    }
  }(s, e) || Xs(s, e) || function() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function De(s) {
  return function(e) {
    if (Array.isArray(e)) return cs(e);
  }(s) || function(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }(s) || Xs(s) || function() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function Zn(s) {
  var e = function(t, i) {
    if (typeof t != "object" || !t) return t;
    var r = t[Symbol.toPrimitive];
    if (r !== void 0) {
      var a = r.call(t, i);
      if (typeof a != "object") return a;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (i === "string" ? String : Number)(t);
  }(s, "string");
  return typeof e == "symbol" ? e : e + "";
}
function Kt(s) {
  return Kt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Kt(s);
}
function Xs(s, e) {
  if (s) {
    if (typeof s == "string") return cs(s, e);
    var t = {}.toString.call(s).slice(8, -1);
    return t === "Object" && s.constructor && (t = s.constructor.name), t === "Map" || t === "Set" ? Array.from(s) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? cs(s, e) : void 0;
  }
}
var F = function() {
  function s() {
    te(this, s);
  }
  return ie(s, [{ key: "shadeRGBColor", value: function(e, t) {
    var i = t.split(","), r = e < 0 ? 0 : 255, a = e < 0 ? -1 * e : e, n = parseInt(i[0].slice(4), 10), o = parseInt(i[1], 10), l = parseInt(i[2], 10);
    return "rgb(" + (Math.round((r - n) * a) + n) + "," + (Math.round((r - o) * a) + o) + "," + (Math.round((r - l) * a) + l) + ")";
  } }, { key: "shadeHexColor", value: function(e, t) {
    var i = parseInt(t.slice(1), 16), r = e < 0 ? 0 : 255, a = e < 0 ? -1 * e : e, n = i >> 16, o = i >> 8 & 255, l = 255 & i;
    return "#" + (16777216 + 65536 * (Math.round((r - n) * a) + n) + 256 * (Math.round((r - o) * a) + o) + (Math.round((r - l) * a) + l)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(e, t) {
    return s.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t);
  } }], [{ key: "bind", value: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  } }, { key: "isObject", value: function(e) {
    return e && Kt(e) === "object" && !Array.isArray(e) && e != null;
  } }, { key: "is", value: function(e, t) {
    return Object.prototype.toString.call(t) === "[object " + e + "]";
  } }, { key: "isSafari", value: function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  } }, { key: "listToArray", value: function(e) {
    var t, i = [];
    for (t = 0; t < e.length; t++) i[t] = e[t];
    return i;
  } }, { key: "extend", value: function(e, t) {
    var i = this;
    typeof Object.assign != "function" && (Object.assign = function(a) {
      if (a == null) throw new TypeError("Cannot convert undefined or null to object");
      for (var n = Object(a), o = 1; o < arguments.length; o++) {
        var l = arguments[o];
        if (l != null) for (var c in l) l.hasOwnProperty(c) && (n[c] = l[c]);
      }
      return n;
    });
    var r = Object.assign({}, e);
    return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach(function(a) {
      i.isObject(t[a]) && a in e ? r[a] = i.extend(e[a], t[a]) : Object.assign(r, Ki({}, a, t[a]));
    }), r;
  } }, { key: "extendArray", value: function(e, t) {
    var i = [];
    return e.map(function(r) {
      i.push(s.extend(t, r));
    }), e = i;
  } }, { key: "monthMod", value: function(e) {
    return e % 12;
  } }, { key: "clone", value: function(e) {
    var t, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new WeakMap();
    if (e === null || Kt(e) !== "object") return e;
    if (i.has(e)) return i.get(e);
    if (Array.isArray(e)) {
      t = [], i.set(e, t);
      for (var r = 0; r < e.length; r++) t[r] = this.clone(e[r], i);
    } else if (e instanceof Date) t = new Date(e.getTime());
    else for (var a in t = {}, i.set(e, t), e) e.hasOwnProperty(a) && (t[a] = this.clone(e[a], i));
    return t;
  } }, { key: "log10", value: function(e) {
    return Math.log(e) / Math.LN10;
  } }, { key: "roundToBase10", value: function(e) {
    return Math.pow(10, Math.floor(Math.log10(e)));
  } }, { key: "roundToBase", value: function(e, t) {
    return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)));
  } }, { key: "parseNumber", value: function(e) {
    return e === null ? e : parseFloat(e);
  } }, { key: "stripNumber", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t));
  } }, { key: "randomId", value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: "noExponents", value: function(e) {
    return e.toString().includes("e") ? Math.round(e) : e;
  } }, { key: "elementExists", value: function(e) {
    return !(!e || !e.isConnected);
  } }, { key: "getDimensions", value: function(e) {
    var t = getComputedStyle(e, null), i = e.clientHeight, r = e.clientWidth;
    return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), [r -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), i];
  } }, { key: "getBoundingClientRect", value: function(e) {
    var t = e.getBoundingClientRect();
    return { top: t.top, right: t.right, bottom: t.bottom, left: t.left, width: e.clientWidth, height: e.clientHeight, x: t.left, y: t.top };
  } }, { key: "getLargestStringFromArr", value: function(e) {
    return e.reduce(function(t, i) {
      return Array.isArray(i) && (i = i.reduce(function(r, a) {
        return r.length > a.length ? r : a;
      })), t.length > i.length ? t : i;
    }, 0);
  } }, { key: "hexToRgba", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
    e.substring(0, 1) !== "#" && (e = "#999999");
    var i = e.replace("#", "");
    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
    for (var r = 0; r < i.length; r++) i[r] = parseInt(i[r].length === 1 ? i[r] + i[r] : i[r], 16);
    return t !== void 0 && i.push(t), "rgba(" + i.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(e) {
    return parseFloat(e.replace(/^.*,(.+)\)/, "$1"));
  } }, { key: "rgb2hex", value: function(e) {
    return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && e.length === 4 ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(e) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e);
  } }, { key: "getPolygonPos", value: function(e, t) {
    for (var i = [], r = 2 * Math.PI / t, a = 0; a < t; a++) {
      var n = {};
      n.x = e * Math.sin(a * r), n.y = -e * Math.cos(a * r), i.push(n);
    }
    return i;
  } }, { key: "polarToCartesian", value: function(e, t, i, r) {
    var a = (r - 90) * Math.PI / 180;
    return { x: e + i * Math.cos(a), y: t + i * Math.sin(a) };
  } }, { key: "escapeString", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i = e.toString().slice();
    return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t);
  } }, { key: "negToZero", value: function(e) {
    return e < 0 ? 0 : e;
  } }, { key: "moveIndexInArray", value: function(e, t, i) {
    if (i >= e.length) for (var r = i - e.length + 1; r--; ) e.push(void 0);
    return e.splice(i, 0, e.splice(t, 1)[0]), e;
  } }, { key: "extractNumber", value: function(e) {
    return parseFloat(e.replace(/[^\d.]*/g, ""));
  } }, { key: "findAncestor", value: function(e, t) {
    for (; (e = e.parentElement) && !e.classList.contains(t); ) ;
    return e;
  } }, { key: "setELstyles", value: function(e, t) {
    for (var i in t) t.hasOwnProperty(i) && (e.style.key = t[i]);
  } }, { key: "preciseAddition", value: function(e, t) {
    var i = (String(e).split(".")[1] || "").length, r = (String(t).split(".")[1] || "").length, a = Math.pow(10, Math.max(i, r));
    return (Math.round(e * a) + Math.round(t * a)) / a;
  } }, { key: "isNumber", value: function(e) {
    return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10));
  } }, { key: "isFloat", value: function(e) {
    return Number(e) === e && e % 1 != 0;
  } }, { key: "isMsEdge", value: function() {
    var e = window.navigator.userAgent, t = e.indexOf("Edge/");
    return t > 0 && parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
  } }, { key: "getGCD", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7, r = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    for (e = Math.round(Math.abs(e) * r), t = Math.round(Math.abs(t) * r); t; ) {
      var a = t;
      t = e % t, e = a;
    }
    return e / r;
  } }, { key: "getPrimeFactors", value: function(e) {
    for (var t = [], i = 2; e >= 2; ) e % i == 0 ? (t.push(i), e /= i) : i++;
    return t;
  } }, { key: "mod", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 7, r = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    return (e = Math.round(Math.abs(e) * r)) % (t = Math.round(Math.abs(t) * r)) / r;
  } }]), s;
}(), ii = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "animateLine", value: function(e, t, i, r) {
    e.attr(t).animate(r).attr(i);
  } }, { key: "animateMarker", value: function(e, t, i, r) {
    e.attr({ opacity: 0 }).animate(t).attr({ opacity: 1 }).after(function() {
      r();
    });
  } }, { key: "animateRect", value: function(e, t, i, r, a) {
    e.attr(t).animate(r).attr(i).after(function() {
      return a();
    });
  } }, { key: "animatePathsGradually", value: function(e) {
    var t = e.el, i = e.realIndex, r = e.j, a = e.fill, n = e.pathFrom, o = e.pathTo, l = e.speed, c = e.delay, h = this.w, d = 0;
    h.config.chart.animations.animateGradually.enabled && (d = h.config.chart.animations.animateGradually.delay), h.config.chart.animations.dynamicAnimation.enabled && h.globals.dataChanged && h.config.chart.type !== "bar" && (d = 0), this.morphSVG(t, i, r, h.config.chart.type !== "line" || h.globals.comboCharts ? a : "stroke", n, o, l, c * d);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach(function(e) {
      var t = e.el;
      t.classList.remove("apexcharts-element-hidden"), t.classList.add("apexcharts-hidden-element-shown");
    });
  } }, { key: "animationCompleted", value: function(e) {
    var t = this.w;
    t.globals.animationEnded || (t.globals.animationEnded = !0, this.showDelayedElements(), typeof t.config.chart.events.animationEnd == "function" && t.config.chart.events.animationEnd(this.ctx, { el: e, w: t }));
  } }, { key: "morphSVG", value: function(e, t, i, r, a, n, o, l) {
    var c = this, h = this.w;
    a || (a = e.attr("pathFrom")), n || (n = e.attr("pathTo"));
    var d = function(u) {
      return h.config.chart.type === "radar" && (o = 1), "M 0 ".concat(h.globals.gridHeight);
    };
    (!a || a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = d()), (!n.trim() || n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = d()), h.globals.shouldAnimate || (o = 1), e.plot(a).animate(1, l).plot(a).animate(o, l).plot(n).after(function() {
      F.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && c.animationCompleted(e) : r !== "none" && h.globals.shouldAnimate && (!h.globals.comboCharts && t === h.globals.series.length - 1 || h.globals.comboCharts) && c.animationCompleted(e), c.showDelayedElements();
    });
  } }]), s;
}();
const ds = {}, Kn = [];
function fe(s, e) {
  if (Array.isArray(s)) for (const t of s) fe(t, e);
  else if (typeof s != "object") Jn(Object.getOwnPropertyNames(e)), ds[s] = Object.assign(ds[s] || {}, e);
  else for (const t in s) fe(t, s[t]);
}
function Je(s) {
  return ds[s] || {};
}
function Jn(s) {
  Kn.push(...s);
}
function Bs(s, e) {
  let t;
  const i = s.length, r = [];
  for (t = 0; t < i; t++) r.push(e(s[t]));
  return r;
}
function br(s) {
  return s % 360 * Math.PI / 180;
}
function ri(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function si(s, e, t, i) {
  return e != null && t != null || (i = i || s.bbox(), e == null ? e = i.width / i.height * t : t == null && (t = i.height / i.width * e)), { width: e, height: t };
}
function us(s, e) {
  const t = s.origin;
  let i = s.ox != null ? s.ox : s.originX != null ? s.originX : "center", r = s.oy != null ? s.oy : s.originY != null ? s.originY : "center";
  t != null && ([i, r] = Array.isArray(t) ? t : typeof t == "object" ? [t.x, t.y] : [t, t]);
  const a = typeof i == "string", n = typeof r == "string";
  if (a || n) {
    const { height: o, width: l, x: c, y: h } = e.bbox();
    a && (i = i.includes("left") ? c : i.includes("right") ? c + l : c + l / 2), n && (r = r.includes("top") ? h : r.includes("bottom") ? h + o : h + o / 2);
  }
  return [i, r];
}
const bh = /* @__PURE__ */ new Set(["desc", "metadata", "title"]), gs = (s) => bh.has(s.nodeName), Qn = (s, e, t = {}) => {
  const i = { ...e };
  for (const r in i) i[r].valueOf() === t[r] && delete i[r];
  Object.keys(i).length ? s.node.setAttribute("data-svgjs", JSON.stringify(i)) : (s.node.removeAttribute("data-svgjs"), s.node.removeAttribute("svgjs:data"));
}, Ws = "http://www.w3.org/2000/svg", vr = "http://www.w3.org/2000/xmlns/", ai = "http://www.w3.org/1999/xlink", me = { window: typeof window > "u" ? null : window, document: typeof document > "u" ? null : document };
function Ii() {
  return me.window;
}
let Vs = class {
};
const Dt = {}, Gs = "___SYMBOL___ROOT___";
function ki(s, e = Ws) {
  return me.document.createElementNS(e, s);
}
function Ue(s, e = !1) {
  if (s instanceof Vs) return s;
  if (typeof s == "object") return yr(s);
  if (s == null) return new Dt[Gs]();
  if (typeof s == "string" && s.charAt(0) !== "<") return yr(me.document.querySelector(s));
  const t = e ? me.document.createElement("div") : ki("svg");
  return t.innerHTML = s, s = yr(t.firstChild), t.removeChild(t.firstChild), s;
}
function Re(s, e) {
  return e && (e instanceof me.window.Node || e.ownerDocument && e instanceof e.ownerDocument.defaultView.Node) ? e : ki(s);
}
function ot(s) {
  if (!s) return null;
  if (s.instance instanceof Vs) return s.instance;
  if (s.nodeName === "#document-fragment") return new Dt.Fragment(s);
  let e = ri(s.nodeName || "Dom");
  return e === "LinearGradient" || e === "RadialGradient" ? e = "Gradient" : Dt[e] || (e = "Dom"), new Dt[e](s);
}
let yr = ot;
function be(s, e = s.name, t = !1) {
  return Dt[e] = s, t && (Dt[Gs] = s), Jn(Object.getOwnPropertyNames(s.prototype)), s;
}
let vh = 1e3;
function eo(s) {
  return "Svgjs" + ri(s) + vh++;
}
function to(s) {
  for (let e = s.children.length - 1; e >= 0; e--) to(s.children[e]);
  return s.id && (s.id = eo(s.nodeName)), s;
}
function oe(s, e) {
  let t, i;
  for (i = (s = Array.isArray(s) ? s : [s]).length - 1; i >= 0; i--) for (t in e) s[i].prototype[t] = e[t];
}
function Me(s) {
  return function(...e) {
    const t = e[e.length - 1];
    return !t || t.constructor !== Object || t instanceof Array ? s.apply(this, e) : s.apply(this, e.slice(0, -1)).attr(t);
  };
}
fe("Dom", { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const s = this.position();
  return this.parent().add(this.remove(), s + 1), this;
}, backward: function() {
  const s = this.position();
  return this.parent().add(this.remove(), s ? s - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(s) {
  (s = Ue(s)).remove();
  const e = this.position();
  return this.parent().add(s, e), this;
}, after: function(s) {
  (s = Ue(s)).remove();
  const e = this.position();
  return this.parent().add(s, e + 1), this;
}, insertBefore: function(s) {
  return (s = Ue(s)).before(this), this;
}, insertAfter: function(s) {
  return (s = Ue(s)).after(this), this;
} });
const io = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, yh = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, wh = /rgb\((\d+),(\d+),(\d+)\)/, kh = /(#[a-z_][a-z0-9\-_]*)/i, Sh = /\)\s*,?\s*/, Ch = /\s/g, Ha = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i, ja = /^rgb\(/, Ya = /^(\s+)?$/, Xa = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Ah = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, wt = /[\s,]+/, $s = /[MLHVCSQTAZ]/i;
function Mh(s) {
  const e = Math.round(s), t = Math.max(0, Math.min(255, e)).toString(16);
  return t.length === 1 ? "0" + t : t;
}
function Vt(s, e) {
  for (let t = e.length; t--; ) if (s[e[t]] == null) return !1;
  return !0;
}
function wr(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + 6 * (e - s) * t : t < 0.5 ? e : t < 2 / 3 ? s + (e - s) * (2 / 3 - t) * 6 : s;
}
fe("Dom", { classes: function() {
  const s = this.attr("class");
  return s == null ? [] : s.trim().split(wt);
}, hasClass: function(s) {
  return this.classes().indexOf(s) !== -1;
}, addClass: function(s) {
  if (!this.hasClass(s)) {
    const e = this.classes();
    e.push(s), this.attr("class", e.join(" "));
  }
  return this;
}, removeClass: function(s) {
  return this.hasClass(s) && this.attr("class", this.classes().filter(function(e) {
    return e !== s;
  }).join(" ")), this;
}, toggleClass: function(s) {
  return this.hasClass(s) ? this.removeClass(s) : this.addClass(s);
} }), fe("Dom", { css: function(s, e) {
  const t = {};
  if (arguments.length === 0) return this.node.style.cssText.split(/\s*;\s*/).filter(function(i) {
    return !!i.length;
  }).forEach(function(i) {
    const r = i.split(/\s*:\s*/);
    t[r[0]] = r[1];
  }), t;
  if (arguments.length < 2) {
    if (Array.isArray(s)) {
      for (const i of s) {
        const r = i;
        t[i] = this.node.style.getPropertyValue(r);
      }
      return t;
    }
    if (typeof s == "string") return this.node.style.getPropertyValue(s);
    if (typeof s == "object") for (const i in s) this.node.style.setProperty(i, s[i] == null || Ya.test(s[i]) ? "" : s[i]);
  }
  return arguments.length === 2 && this.node.style.setProperty(s, e == null || Ya.test(e) ? "" : e), this;
}, show: function() {
  return this.css("display", "");
}, hide: function() {
  return this.css("display", "none");
}, visible: function() {
  return this.css("display") !== "none";
} }), fe("Dom", { data: function(s, e, t) {
  if (s == null) return this.data(Bs(function(i, r) {
    let a;
    const n = i.length, o = [];
    for (a = 0; a < n; a++) r(i[a]) && o.push(i[a]);
    return o;
  }(this.node.attributes, (i) => i.nodeName.indexOf("data-") === 0), (i) => i.nodeName.slice(5)));
  if (s instanceof Array) {
    const i = {};
    for (const r of s) i[r] = this.data(r);
    return i;
  }
  if (typeof s == "object") for (e in s) this.data(e, s[e]);
  else if (arguments.length < 2) try {
    return JSON.parse(this.attr("data-" + s));
  } catch {
    return this.attr("data-" + s);
  }
  else this.attr("data-" + s, e === null ? null : t === !0 || typeof e == "string" || typeof e == "number" ? e : JSON.stringify(e));
  return this;
} }), fe("Dom", { remember: function(s, e) {
  if (typeof arguments[0] == "object") for (const t in s) this.remember(t, s[t]);
  else {
    if (arguments.length === 1) return this.memory()[s];
    this.memory()[s] = e;
  }
  return this;
}, forget: function() {
  if (arguments.length === 0) this._memory = {};
  else for (let s = arguments.length - 1; s >= 0; s--) delete this.memory()[arguments[s]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });
class Ae {
  constructor(...e) {
    this.init(...e);
  }
  static isColor(e) {
    return e && (e instanceof Ae || this.isRgb(e) || this.test(e));
  }
  static isRgb(e) {
    return e && typeof e.r == "number" && typeof e.g == "number" && typeof e.b == "number";
  }
  static random(e = "vibrant", t) {
    const { random: i, round: r, sin: a, PI: n } = Math;
    if (e === "vibrant") {
      const o = 24 * i() + 57, l = 38 * i() + 45, c = 360 * i();
      return new Ae(o, l, c, "lch");
    }
    if (e === "sine") {
      const o = r(80 * a(2 * n * (t = t ?? i()) / 0.5 + 0.01) + 150), l = r(50 * a(2 * n * t / 0.5 + 4.6) + 200), c = r(100 * a(2 * n * t / 0.5 + 2.3) + 150);
      return new Ae(o, l, c);
    }
    if (e === "pastel") {
      const o = 8 * i() + 86, l = 17 * i() + 9, c = 360 * i();
      return new Ae(o, l, c, "lch");
    }
    if (e === "dark") {
      const o = 10 + 10 * i(), l = 50 * i() + 86, c = 360 * i();
      return new Ae(o, l, c, "lch");
    }
    if (e === "rgb") {
      const o = 255 * i(), l = 255 * i(), c = 255 * i();
      return new Ae(o, l, c);
    }
    if (e === "lab") {
      const o = 100 * i(), l = 256 * i() - 128, c = 256 * i() - 128;
      return new Ae(o, l, c, "lab");
    }
    if (e === "grey") {
      const o = 255 * i();
      return new Ae(o, o, o);
    }
    throw new Error("Unsupported random color mode");
  }
  static test(e) {
    return typeof e == "string" && (Ha.test(e) || ja.test(e));
  }
  cmyk() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [r, a, n] = [e, t, i].map((l) => l / 255), o = Math.min(1 - r, 1 - a, 1 - n);
    return o === 1 ? new Ae(0, 0, 0, 1, "cmyk") : new Ae((1 - r - o) / (1 - o), (1 - a - o) / (1 - o), (1 - n - o) / (1 - o), o, "cmyk");
  }
  hsl() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [r, a, n] = [e, t, i].map((u) => u / 255), o = Math.max(r, a, n), l = Math.min(r, a, n), c = (o + l) / 2, h = o === l, d = o - l;
    return new Ae(360 * (h ? 0 : o === r ? ((a - n) / d + (a < n ? 6 : 0)) / 6 : o === a ? ((n - r) / d + 2) / 6 : o === n ? ((r - a) / d + 4) / 6 : 0), 100 * (h ? 0 : c > 0.5 ? d / (2 - o - l) : d / (o + l)), 100 * c, "hsl");
  }
  init(e = 0, t = 0, i = 0, r = 0, a = "rgb") {
    if (e = e || 0, this.space) for (const d in this.space) delete this[this.space[d]];
    if (typeof e == "number") a = typeof r == "string" ? r : a, r = typeof r == "string" ? 0 : r, Object.assign(this, { _a: e, _b: t, _c: i, _d: r, space: a });
    else if (e instanceof Array) this.space = t || (typeof e[3] == "string" ? e[3] : e[4]) || "rgb", Object.assign(this, { _a: e[0], _b: e[1], _c: e[2], _d: e[3] || 0 });
    else if (e instanceof Object) {
      const d = function(u, g) {
        const p = Vt(u, "rgb") ? { _a: u.r, _b: u.g, _c: u.b, _d: 0, space: "rgb" } : Vt(u, "xyz") ? { _a: u.x, _b: u.y, _c: u.z, _d: 0, space: "xyz" } : Vt(u, "hsl") ? { _a: u.h, _b: u.s, _c: u.l, _d: 0, space: "hsl" } : Vt(u, "lab") ? { _a: u.l, _b: u.a, _c: u.b, _d: 0, space: "lab" } : Vt(u, "lch") ? { _a: u.l, _b: u.c, _c: u.h, _d: 0, space: "lch" } : Vt(u, "cmyk") ? { _a: u.c, _b: u.m, _c: u.y, _d: u.k, space: "cmyk" } : { _a: 0, _b: 0, _c: 0, space: "rgb" };
        return p.space = g || p.space, p;
      }(e, t);
      Object.assign(this, d);
    } else if (typeof e == "string") if (ja.test(e)) {
      const d = e.replace(Ch, ""), [u, g, p] = wh.exec(d).slice(1, 4).map((f) => parseInt(f));
      Object.assign(this, { _a: u, _b: g, _c: p, _d: 0, space: "rgb" });
    } else {
      if (!Ha.test(e)) throw Error("Unsupported string format, can't construct Color");
      {
        const d = (f) => parseInt(f, 16), [, u, g, p] = yh.exec(function(f) {
          return f.length === 4 ? ["#", f.substring(1, 2), f.substring(1, 2), f.substring(2, 3), f.substring(2, 3), f.substring(3, 4), f.substring(3, 4)].join("") : f;
        }(e)).map(d);
        Object.assign(this, { _a: u, _b: g, _c: p, _d: 0, space: "rgb" });
      }
    }
    const { _a: n, _b: o, _c: l, _d: c } = this, h = this.space === "rgb" ? { r: n, g: o, b: l } : this.space === "xyz" ? { x: n, y: o, z: l } : this.space === "hsl" ? { h: n, s: o, l } : this.space === "lab" ? { l: n, a: o, b: l } : this.space === "lch" ? { l: n, c: o, h: l } : this.space === "cmyk" ? { c: n, m: o, y: l, k: c } : {};
    Object.assign(this, h);
  }
  lab() {
    const { x: e, y: t, z: i } = this.xyz();
    return new Ae(116 * t - 16, 500 * (e - t), 200 * (t - i), "lab");
  }
  lch() {
    const { l: e, a: t, b: i } = this.lab(), r = Math.sqrt(t ** 2 + i ** 2);
    let a = 180 * Math.atan2(i, t) / Math.PI;
    return a < 0 && (a *= -1, a = 360 - a), new Ae(e, r, a, "lch");
  }
  rgb() {
    if (this.space === "rgb") return this;
    if ((e = this.space) === "lab" || e === "xyz" || e === "lch") {
      let { x: t, y: i, z: r } = this;
      if (this.space === "lab" || this.space === "lch") {
        let { l: g, a: p, b: f } = this;
        if (this.space === "lch") {
          const { c: k, h: S } = this, C = Math.PI / 180;
          p = k * Math.cos(C * S), f = k * Math.sin(C * S);
        }
        const x = (g + 16) / 116, m = p / 500 + x, b = x - f / 200, w = 16 / 116, y = 8856e-6, v = 7.787;
        t = 0.95047 * (m ** 3 > y ? m ** 3 : (m - w) / v), i = 1 * (x ** 3 > y ? x ** 3 : (x - w) / v), r = 1.08883 * (b ** 3 > y ? b ** 3 : (b - w) / v);
      }
      const a = 3.2406 * t + -1.5372 * i + -0.4986 * r, n = -0.9689 * t + 1.8758 * i + 0.0415 * r, o = 0.0557 * t + -0.204 * i + 1.057 * r, l = Math.pow, c = 31308e-7, h = a > c ? 1.055 * l(a, 1 / 2.4) - 0.055 : 12.92 * a, d = n > c ? 1.055 * l(n, 1 / 2.4) - 0.055 : 12.92 * n, u = o > c ? 1.055 * l(o, 1 / 2.4) - 0.055 : 12.92 * o;
      return new Ae(255 * h, 255 * d, 255 * u);
    }
    if (this.space === "hsl") {
      let { h: t, s: i, l: r } = this;
      if (t /= 360, i /= 100, r /= 100, i === 0)
        return r *= 255, new Ae(r, r, r);
      const a = r < 0.5 ? r * (1 + i) : r + i - r * i, n = 2 * r - a, o = 255 * wr(n, a, t + 1 / 3), l = 255 * wr(n, a, t), c = 255 * wr(n, a, t - 1 / 3);
      return new Ae(o, l, c);
    }
    if (this.space === "cmyk") {
      const { c: t, m: i, y: r, k: a } = this, n = 255 * (1 - Math.min(1, t * (1 - a) + a)), o = 255 * (1 - Math.min(1, i * (1 - a) + a)), l = 255 * (1 - Math.min(1, r * (1 - a) + a));
      return new Ae(n, o, l);
    }
    return this;
    var e;
  }
  toArray() {
    const { _a: e, _b: t, _c: i, _d: r, space: a } = this;
    return [e, t, i, r, a];
  }
  toHex() {
    const [e, t, i] = this._clamped().map(Mh);
    return `#${e}${t}${i}`;
  }
  toRgb() {
    const [e, t, i] = this._clamped();
    return `rgb(${e},${t},${i})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: e, _b: t, _c: i } = this.rgb(), [r, a, n] = [e, t, i].map((x) => x / 255), o = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, l = a > 0.04045 ? Math.pow((a + 0.055) / 1.055, 2.4) : a / 12.92, c = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, h = (0.4124 * o + 0.3576 * l + 0.1805 * c) / 0.95047, d = (0.2126 * o + 0.7152 * l + 0.0722 * c) / 1, u = (0.0193 * o + 0.1192 * l + 0.9505 * c) / 1.08883, g = h > 8856e-6 ? Math.pow(h, 1 / 3) : 7.787 * h + 16 / 116, p = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, f = u > 8856e-6 ? Math.pow(u, 1 / 3) : 7.787 * u + 16 / 116;
    return new Ae(g, p, f, "xyz");
  }
  _clamped() {
    const { _a: e, _b: t, _c: i } = this.rgb(), { max: r, min: a, round: n } = Math;
    return [e, t, i].map((o) => r(0, a(n(o), 255)));
  }
}
class ye {
  constructor(...e) {
    this.init(...e);
  }
  clone() {
    return new ye(this);
  }
  init(e, t) {
    const a = Array.isArray(e) ? { x: e[0], y: e[1] } : typeof e == "object" ? { x: e.x, y: e.y } : { x: e, y: t };
    return this.x = a.x == null ? 0 : a.x, this.y = a.y == null ? 0 : a.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(e) {
    return this.clone().transformO(e);
  }
  transformO(e) {
    ae.isMatrixLike(e) || (e = new ae(e));
    const { x: t, y: i } = this;
    return this.x = e.a * t + e.c * i + e.e, this.y = e.b * t + e.d * i + e.f, this;
  }
}
function Gt(s, e, t) {
  return Math.abs(e - s) < 1e-6;
}
class ae {
  constructor(...e) {
    this.init(...e);
  }
  static formatTransforms(e) {
    const t = e.flip === "both" || e.flip === !0, i = e.flip && (t || e.flip === "x") ? -1 : 1, r = e.flip && (t || e.flip === "y") ? -1 : 1, a = e.skew && e.skew.length ? e.skew[0] : isFinite(e.skew) ? e.skew : isFinite(e.skewX) ? e.skewX : 0, n = e.skew && e.skew.length ? e.skew[1] : isFinite(e.skew) ? e.skew : isFinite(e.skewY) ? e.skewY : 0, o = e.scale && e.scale.length ? e.scale[0] * i : isFinite(e.scale) ? e.scale * i : isFinite(e.scaleX) ? e.scaleX * i : i, l = e.scale && e.scale.length ? e.scale[1] * r : isFinite(e.scale) ? e.scale * r : isFinite(e.scaleY) ? e.scaleY * r : r, c = e.shear || 0, h = e.rotate || e.theta || 0, d = new ye(e.origin || e.around || e.ox || e.originX, e.oy || e.originY), u = d.x, g = d.y, p = new ye(e.position || e.px || e.positionX || NaN, e.py || e.positionY || NaN), f = p.x, x = p.y, m = new ye(e.translate || e.tx || e.translateX, e.ty || e.translateY), b = m.x, w = m.y, y = new ye(e.relative || e.rx || e.relativeX, e.ry || e.relativeY);
    return { scaleX: o, scaleY: l, skewX: a, skewY: n, shear: c, theta: h, rx: y.x, ry: y.y, tx: b, ty: w, ox: u, oy: g, px: f, py: x };
  }
  static fromArray(e) {
    return { a: e[0], b: e[1], c: e[2], d: e[3], e: e[4], f: e[5] };
  }
  static isMatrixLike(e) {
    return e.a != null || e.b != null || e.c != null || e.d != null || e.e != null || e.f != null;
  }
  static matrixMultiply(e, t, i) {
    const r = e.a * t.a + e.c * t.b, a = e.b * t.a + e.d * t.b, n = e.a * t.c + e.c * t.d, o = e.b * t.c + e.d * t.d, l = e.e + e.a * t.e + e.c * t.f, c = e.f + e.b * t.e + e.d * t.f;
    return i.a = r, i.b = a, i.c = n, i.d = o, i.e = l, i.f = c, i;
  }
  around(e, t, i) {
    return this.clone().aroundO(e, t, i);
  }
  aroundO(e, t, i) {
    const r = e || 0, a = t || 0;
    return this.translateO(-r, -a).lmultiplyO(i).translateO(r, a);
  }
  clone() {
    return new ae(this);
  }
  decompose(e = 0, t = 0) {
    const i = this.a, r = this.b, a = this.c, n = this.d, o = this.e, l = this.f, c = i * n - r * a, h = c > 0 ? 1 : -1, d = h * Math.sqrt(i * i + r * r), u = Math.atan2(h * r, h * i), g = 180 / Math.PI * u, p = Math.cos(u), f = Math.sin(u), x = (i * a + r * n) / c, m = a * d / (x * i - r) || n * d / (x * r + i);
    return { scaleX: d, scaleY: m, shear: x, rotate: g, translateX: o - e + e * p * d + t * (x * p * d - f * m), translateY: l - t + e * f * d + t * (x * f * d + p * m), originX: e, originY: t, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(e) {
    if (e === this) return !0;
    const t = new ae(e);
    return Gt(this.a, t.a) && Gt(this.b, t.b) && Gt(this.c, t.c) && Gt(this.d, t.d) && Gt(this.e, t.e) && Gt(this.f, t.f);
  }
  flip(e, t) {
    return this.clone().flipO(e, t);
  }
  flipO(e, t) {
    return e === "x" ? this.scaleO(-1, 1, t, 0) : e === "y" ? this.scaleO(1, -1, 0, t) : this.scaleO(-1, -1, e, t || e);
  }
  init(e) {
    const t = ae.fromArray([1, 0, 0, 1, 0, 0]);
    return e = e instanceof Xe ? e.matrixify() : typeof e == "string" ? ae.fromArray(e.split(wt).map(parseFloat)) : Array.isArray(e) ? ae.fromArray(e) : typeof e == "object" && ae.isMatrixLike(e) ? e : typeof e == "object" ? new ae().transform(e) : arguments.length === 6 ? ae.fromArray([].slice.call(arguments)) : t, this.a = e.a != null ? e.a : t.a, this.b = e.b != null ? e.b : t.b, this.c = e.c != null ? e.c : t.c, this.d = e.d != null ? e.d : t.d, this.e = e.e != null ? e.e : t.e, this.f = e.f != null ? e.f : t.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const e = this.a, t = this.b, i = this.c, r = this.d, a = this.e, n = this.f, o = e * r - t * i;
    if (!o) throw new Error("Cannot invert " + this);
    const l = r / o, c = -t / o, h = -i / o, d = e / o, u = -(l * a + h * n), g = -(c * a + d * n);
    return this.a = l, this.b = c, this.c = h, this.d = d, this.e = u, this.f = g, this;
  }
  lmultiply(e) {
    return this.clone().lmultiplyO(e);
  }
  lmultiplyO(e) {
    const t = e instanceof ae ? e : new ae(e);
    return ae.matrixMultiply(t, this, this);
  }
  multiply(e) {
    return this.clone().multiplyO(e);
  }
  multiplyO(e) {
    const t = e instanceof ae ? e : new ae(e);
    return ae.matrixMultiply(this, t, this);
  }
  rotate(e, t, i) {
    return this.clone().rotateO(e, t, i);
  }
  rotateO(e, t = 0, i = 0) {
    e = br(e);
    const r = Math.cos(e), a = Math.sin(e), { a: n, b: o, c: l, d: c, e: h, f: d } = this;
    return this.a = n * r - o * a, this.b = o * r + n * a, this.c = l * r - c * a, this.d = c * r + l * a, this.e = h * r - d * a + i * a - t * r + t, this.f = d * r + h * a - t * a - i * r + i, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(e, t = e, i = 0, r = 0) {
    arguments.length === 3 && (r = i, i = t, t = e);
    const { a, b: n, c: o, d: l, e: c, f: h } = this;
    return this.a = a * e, this.b = n * t, this.c = o * e, this.d = l * t, this.e = c * e - i * e + i, this.f = h * t - r * t + r, this;
  }
  shear(e, t, i) {
    return this.clone().shearO(e, t, i);
  }
  shearO(e, t = 0, i = 0) {
    const { a: r, b: a, c: n, d: o, e: l, f: c } = this;
    return this.a = r + a * e, this.c = n + o * e, this.e = l + c * e - i * e, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(e, t = e, i = 0, r = 0) {
    arguments.length === 3 && (r = i, i = t, t = e), e = br(e), t = br(t);
    const a = Math.tan(e), n = Math.tan(t), { a: o, b: l, c, d: h, e: d, f: u } = this;
    return this.a = o + l * a, this.b = l + o * n, this.c = c + h * a, this.d = h + c * n, this.e = d + u * a - r * a, this.f = u + d * n - i * n, this;
  }
  skewX(e, t, i) {
    return this.skew(e, 0, t, i);
  }
  skewY(e, t, i) {
    return this.skew(0, e, t, i);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  transform(e) {
    if (ae.isMatrixLike(e))
      return new ae(e).multiplyO(this);
    const t = ae.formatTransforms(e), { x: i, y: r } = new ye(t.ox, t.oy).transform(this), a = new ae().translateO(t.rx, t.ry).lmultiplyO(this).translateO(-i, -r).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(i, r);
    if (isFinite(t.px) || isFinite(t.py)) {
      const n = new ye(i, r).transform(a), o = isFinite(t.px) ? t.px - n.x : 0, l = isFinite(t.py) ? t.py - n.y : 0;
      a.translateO(o, l);
    }
    return a.translateO(t.tx, t.ty), a;
  }
  translate(e, t) {
    return this.clone().translateO(e, t);
  }
  translateO(e, t) {
    return this.e += e || 0, this.f += t || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
}
function Ct() {
  if (!Ct.nodes) {
    const s = Ue().size(2, 0);
    s.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";"), s.attr("focusable", "false"), s.attr("aria-hidden", "true");
    const e = s.path().node;
    Ct.nodes = { svg: s, path: e };
  }
  if (!Ct.nodes.svg.node.parentNode) {
    const s = me.document.body || me.document.documentElement;
    Ct.nodes.svg.addTo(s);
  }
  return Ct.nodes;
}
function ro(s) {
  return !(s.width || s.height || s.x || s.y);
}
be(ae, "Matrix");
class Oe {
  constructor(...e) {
    this.init(...e);
  }
  addOffset() {
    return this.x += me.window.pageXOffset, this.y += me.window.pageYOffset, new Oe(this);
  }
  init(e) {
    return e = typeof e == "string" ? e.split(wt).map(parseFloat) : Array.isArray(e) ? e : typeof e == "object" ? [e.left != null ? e.left : e.x, e.top != null ? e.top : e.y, e.width, e.height] : arguments.length === 4 ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = e[0] || 0, this.y = e[1] || 0, this.width = this.w = e[2] || 0, this.height = this.h = e[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return ro(this);
  }
  merge(e) {
    const t = Math.min(this.x, e.x), i = Math.min(this.y, e.y), r = Math.max(this.x + this.width, e.x + e.width) - t, a = Math.max(this.y + this.height, e.y + e.height) - i;
    return new Oe(t, i, r, a);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(e) {
    e instanceof ae || (e = new ae(e));
    let t = 1 / 0, i = -1 / 0, r = 1 / 0, a = -1 / 0;
    return [new ye(this.x, this.y), new ye(this.x2, this.y), new ye(this.x, this.y2), new ye(this.x2, this.y2)].forEach(function(n) {
      n = n.transform(e), t = Math.min(t, n.x), i = Math.max(i, n.x), r = Math.min(r, n.y), a = Math.max(a, n.y);
    }), new Oe(t, r, i - t, a - r);
  }
}
function Ba(s, e, t) {
  let i;
  try {
    if (i = e(s.node), ro(i) && (r = s.node) !== me.document && !(me.document.documentElement.contains || function(a) {
      for (; a.parentNode; ) a = a.parentNode;
      return a === me.document;
    }).call(me.document.documentElement, r)) throw new Error("Element not in the dom");
  } catch {
    i = t(s);
  }
  var r;
  return i;
}
fe({ viewbox: { viewbox(s, e, t, i) {
  return s == null ? new Oe(this.attr("viewBox")) : this.attr("viewBox", new Oe(s, e, t, i));
}, zoom(s, e) {
  let { width: t, height: i } = this.attr(["width", "height"]);
  if ((t || i) && typeof t != "string" && typeof i != "string" || (t = this.node.clientWidth, i = this.node.clientHeight), !t || !i) throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
  const r = this.viewbox(), a = t / r.width, n = i / r.height, o = Math.min(a, n);
  if (s == null) return o;
  let l = o / s;
  l === 1 / 0 && (l = Number.MAX_SAFE_INTEGER / 100), e = e || new ye(t / 2 / a + r.x, i / 2 / n + r.y);
  const c = new Oe(r).transform(new ae({ scale: l, origin: e }));
  return this.viewbox(c);
} } }), be(Oe, "Box");
class jt extends Array {
  constructor(e = [], ...t) {
    if (super(e, ...t), typeof e == "number") return this;
    this.length = 0, this.push(...e);
  }
}
oe([jt], { each(s, ...e) {
  return typeof s == "function" ? this.map((t, i, r) => s.call(t, t, i, r)) : this.map((t) => t[s](...e));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
const Rh = ["toArray", "constructor", "each"];
function Xt(s, e) {
  return new jt(Bs((e || me.document).querySelectorAll(s), function(t) {
    return ot(t);
  }));
}
jt.extend = function(s) {
  s = s.reduce((e, t) => (Rh.includes(t) || t[0] === "_" || (t in Array.prototype && (e["$" + t] = Array.prototype[t]), e[t] = function(...i) {
    return this.each(t, ...i);
  }), e), {}), oe([jt], s);
};
let Ph = 0;
const so = {};
function ao(s) {
  let e = s.getEventHolder();
  return e === me.window && (e = so), e.events || (e.events = {}), e.events;
}
function Us(s) {
  return s.getEventTarget();
}
function vt(s, e, t, i, r) {
  const a = t.bind(i || s), n = Ue(s), o = ao(n), l = Us(n);
  e = Array.isArray(e) ? e : e.split(wt), t._svgjsListenerId || (t._svgjsListenerId = ++Ph), e.forEach(function(c) {
    const h = c.split(".")[0], d = c.split(".")[1] || "*";
    o[h] = o[h] || {}, o[h][d] = o[h][d] || {}, o[h][d][t._svgjsListenerId] = a, l.addEventListener(h, a, r || !1);
  });
}
function lt(s, e, t, i) {
  const r = Ue(s), a = ao(r), n = Us(r);
  (typeof t != "function" || (t = t._svgjsListenerId)) && (e = Array.isArray(e) ? e : (e || "").split(wt)).forEach(function(o) {
    const l = o && o.split(".")[0], c = o && o.split(".")[1];
    let h, d;
    if (t) a[l] && a[l][c || "*"] && (n.removeEventListener(l, a[l][c || "*"][t], i || !1), delete a[l][c || "*"][t]);
    else if (l && c) {
      if (a[l] && a[l][c]) {
        for (d in a[l][c]) lt(n, [l, c].join("."), d);
        delete a[l][c];
      }
    } else if (c) for (o in a) for (h in a[o]) c === h && lt(n, [o, c].join("."));
    else if (l) {
      if (a[l]) {
        for (h in a[l]) lt(n, [l, h].join("."));
        delete a[l];
      }
    } else {
      for (o in a) lt(n, o);
      (function(u) {
        let g = u.getEventHolder();
        g === me.window && (g = so), g.events && (g.events = {});
      })(r);
    }
  });
}
class Ei extends Vs {
  addEventListener() {
  }
  dispatch(e, t, i) {
    return function(r, a, n, o) {
      const l = Us(r);
      return a instanceof me.window.Event || (a = new me.window.CustomEvent(a, { detail: n, cancelable: !0, ...o })), l.dispatchEvent(a), a;
    }(this, e, t, i);
  }
  dispatchEvent(e) {
    const t = this.getEventHolder().events;
    if (!t) return !0;
    const i = t[e.type];
    for (const r in i) for (const a in i[r]) i[r][a](e);
    return !e.defaultPrevented;
  }
  fire(e, t, i) {
    return this.dispatch(e, t, i), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(e, t, i) {
    return lt(this, e, t, i), this;
  }
  on(e, t, i, r) {
    return vt(this, e, t, i, r), this;
  }
  removeEventListener() {
  }
}
function Wa() {
}
be(Ei, "EventTarget");
const kr = 400, Lh = ">", Ih = 0, Eh = { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "text-anchor": "start" };
class Yt extends Array {
  constructor(...e) {
    super(...e), this.init(...e);
  }
  clone() {
    return new this.constructor(this);
  }
  init(e) {
    return typeof e == "number" || (this.length = 0, this.push(...this.parse(e))), this;
  }
  parse(e = []) {
    return e instanceof Array ? e : e.trim().split(wt).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  valueOf() {
    const e = [];
    return e.push(...this), e;
  }
}
class ue {
  constructor(...e) {
    this.init(...e);
  }
  convert(e) {
    return new ue(this.value, e);
  }
  divide(e) {
    return e = new ue(e), new ue(this / e, this.unit || e.unit);
  }
  init(e, t) {
    return t = Array.isArray(e) ? e[1] : t, e = Array.isArray(e) ? e[0] : e, this.value = 0, this.unit = t || "", typeof e == "number" ? this.value = isNaN(e) ? 0 : isFinite(e) ? e : e < 0 ? -34e37 : 34e37 : typeof e == "string" ? (t = e.match(io)) && (this.value = parseFloat(t[1]), t[5] === "%" ? this.value /= 100 : t[5] === "s" && (this.value *= 1e3), this.unit = t[5]) : e instanceof ue && (this.value = e.valueOf(), this.unit = e.unit), this;
  }
  minus(e) {
    return e = new ue(e), new ue(this - e, this.unit || e.unit);
  }
  plus(e) {
    return e = new ue(e), new ue(this + e, this.unit || e.unit);
  }
  times(e) {
    return e = new ue(e), new ue(this * e, this.unit || e.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return (this.unit === "%" ? ~~(1e8 * this.value) / 1e6 : this.unit === "s" ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
}
const Th = /* @__PURE__ */ new Set(["fill", "stroke", "color", "bgcolor", "stop-color", "flood-color", "lighting-color"]), no = [];
class Rt extends Ei {
  constructor(e, t) {
    super(), this.node = e, this.type = e.nodeName, t && e !== t && this.attr(t);
  }
  add(e, t) {
    return (e = Ue(e)).removeNamespace && this.node instanceof me.window.SVGElement && e.removeNamespace(), t == null ? this.node.appendChild(e.node) : e.node !== this.node.childNodes[t] && this.node.insertBefore(e.node, this.node.childNodes[t]), this;
  }
  addTo(e, t) {
    return Ue(e).put(this, t);
  }
  children() {
    return new jt(Bs(this.node.children, function(e) {
      return ot(e);
    }));
  }
  clear() {
    for (; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(e = !0, t = !0) {
    this.writeDataToDom();
    let i = this.node.cloneNode(e);
    return t && (i = to(i)), new this.constructor(i);
  }
  each(e, t) {
    const i = this.children();
    let r, a;
    for (r = 0, a = i.length; r < a; r++) e.apply(i[r], [r, i]), t && i[r].each(e, t);
    return this;
  }
  element(e, t) {
    return this.put(new Rt(ki(e), t));
  }
  first() {
    return ot(this.node.firstChild);
  }
  get(e) {
    return ot(this.node.childNodes[e]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(e) {
    return this.index(e) >= 0;
  }
  html(e, t) {
    return this.xml(e, t, "http://www.w3.org/1999/xhtml");
  }
  id(e) {
    return e !== void 0 || this.node.id || (this.node.id = eo(this.type)), this.attr("id", e);
  }
  index(e) {
    return [].slice.call(this.node.childNodes).indexOf(e.node);
  }
  last() {
    return ot(this.node.lastChild);
  }
  matches(e) {
    const t = this.node, i = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return i && i.call(t, e);
  }
  parent(e) {
    let t = this;
    if (!t.node.parentNode) return null;
    if (t = ot(t.node.parentNode), !e) return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e) return t;
    while (t = ot(t.node.parentNode));
    return t;
  }
  put(e, t) {
    return e = Ue(e), this.add(e, t), e;
  }
  putIn(e, t) {
    return Ue(e).add(this, t);
  }
  remove() {
    return this.parent() && this.parent().removeElement(this), this;
  }
  removeElement(e) {
    return this.node.removeChild(e.node), this;
  }
  replace(e) {
    return e = Ue(e), this.node.parentNode && this.node.parentNode.replaceChild(e.node, this.node), e;
  }
  round(e = 2, t = null) {
    const i = 10 ** e, r = this.attr(t);
    for (const a in r) typeof r[a] == "number" && (r[a] = Math.round(r[a] * i) / i);
    return this.attr(r), this;
  }
  svg(e, t) {
    return this.xml(e, t, Ws);
  }
  toString() {
    return this.id();
  }
  words(e) {
    return this.node.textContent = e, this;
  }
  wrap(e) {
    const t = this.parent();
    if (!t) return this.addTo(e);
    const i = t.index(this);
    return t.put(e, i).put(this);
  }
  writeDataToDom() {
    return this.each(function() {
      this.writeDataToDom();
    }), this;
  }
  xml(e, t, i) {
    if (typeof e == "boolean" && (i = t, t = e, e = null), e == null || typeof e == "function") {
      t = t == null || t, this.writeDataToDom();
      let o = this;
      if (e != null) {
        if (o = ot(o.node.cloneNode(!0)), t) {
          const l = e(o);
          if (o = l || o, l === !1) return "";
        }
        o.each(function() {
          const l = e(this), c = l || this;
          l === !1 ? this.remove() : l && this !== c && this.replace(c);
        }, !0);
      }
      return t ? o.node.outerHTML : o.node.innerHTML;
    }
    t = t != null && t;
    const r = ki("wrapper", i), a = me.document.createDocumentFragment();
    r.innerHTML = e;
    for (let o = r.children.length; o--; ) a.appendChild(r.firstElementChild);
    const n = this.parent();
    return t ? this.replace(a) && n : this.add(a);
  }
}
oe(Rt, { attr: function(s, e, t) {
  if (s == null) {
    s = {}, e = this.node.attributes;
    for (const i of e) s[i.nodeName] = Xa.test(i.nodeValue) ? parseFloat(i.nodeValue) : i.nodeValue;
    return s;
  }
  if (s instanceof Array) return s.reduce((i, r) => (i[r] = this.attr(r), i), {});
  if (typeof s == "object" && s.constructor === Object) for (e in s) this.attr(e, s[e]);
  else if (e === null) this.node.removeAttribute(s);
  else {
    if (e == null) return (e = this.node.getAttribute(s)) == null ? Eh[s] : Xa.test(e) ? parseFloat(e) : e;
    typeof (e = no.reduce((i, r) => r(s, i, this), e)) == "number" ? e = new ue(e) : Th.has(s) && Ae.isColor(e) ? e = new Ae(e) : e.constructor === Array && (e = new Yt(e)), s === "leading" ? this.leading && this.leading(e) : typeof t == "string" ? this.node.setAttributeNS(t, s, e.toString()) : this.node.setAttribute(s, e.toString()), !this.rebuild || s !== "font-size" && s !== "x" || this.rebuild();
  }
  return this;
}, find: function(s) {
  return Xt(s, this.node);
}, findOne: function(s) {
  return ot(this.node.querySelector(s));
} }), be(Rt, "Dom");
let Xe = class extends Rt {
  constructor(s, e) {
    super(s, e), this.dom = {}, this.node.instance = this, (s.hasAttribute("data-svgjs") || s.hasAttribute("svgjs:data")) && this.setData(JSON.parse(s.getAttribute("data-svgjs")) ?? JSON.parse(s.getAttribute("svgjs:data")) ?? {});
  }
  center(s, e) {
    return this.cx(s).cy(e);
  }
  cx(s) {
    return s == null ? this.x() + this.width() / 2 : this.x(s - this.width() / 2);
  }
  cy(s) {
    return s == null ? this.y() + this.height() / 2 : this.y(s - this.height() / 2);
  }
  defs() {
    const s = this.root();
    return s && s.defs();
  }
  dmove(s, e) {
    return this.dx(s).dy(e);
  }
  dx(s = 0) {
    return this.x(new ue(s).plus(this.x()));
  }
  dy(s = 0) {
    return this.y(new ue(s).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(s) {
    return this.attr("height", s);
  }
  move(s, e) {
    return this.x(s).y(e);
  }
  parents(s = this.root()) {
    const e = typeof s == "string";
    e || (s = Ue(s));
    const t = new jt();
    let i = this;
    for (; (i = i.parent()) && i.node !== me.document && i.nodeName !== "#document-fragment" && (t.push(i), e || i.node !== s.node) && (!e || !i.matches(s)); ) if (i.node === this.root().node) return null;
    return t;
  }
  reference(s) {
    if (!(s = this.attr(s))) return null;
    const e = (s + "").match(kh);
    return e ? Ue(e[1]) : null;
  }
  root() {
    const s = this.parent(function(e) {
      return Dt[e];
    }(Gs));
    return s && s.root();
  }
  setData(s) {
    return this.dom = s, this;
  }
  size(s, e) {
    const t = si(this, s, e);
    return this.width(new ue(t.width)).height(new ue(t.height));
  }
  width(s) {
    return this.attr("width", s);
  }
  writeDataToDom() {
    return Qn(this, this.dom), super.writeDataToDom();
  }
  x(s) {
    return this.attr("x", s);
  }
  y(s) {
    return this.attr("y", s);
  }
};
oe(Xe, { bbox: function() {
  const s = Ba(this, (e) => e.getBBox(), (e) => {
    try {
      const t = e.clone().addTo(Ct().svg).show(), i = t.node.getBBox();
      return t.remove(), i;
    } catch (t) {
      throw new Error(`Getting bbox of element "${e.node.nodeName}" is not possible: ${t.toString()}`);
    }
  });
  return new Oe(s);
}, rbox: function(s) {
  const e = Ba(this, (i) => i.getBoundingClientRect(), (i) => {
    throw new Error(`Getting rbox of element "${i.node.nodeName}" is not possible`);
  }), t = new Oe(e);
  return s ? t.transform(s.screenCTM().inverseO()) : t.addOffset();
}, inside: function(s, e) {
  const t = this.bbox();
  return s > t.x && e > t.y && s < t.x + t.width && e < t.y + t.height;
}, point: function(s, e) {
  return new ye(s, e).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new ae(this.node.getCTM());
}, screenCTM: function() {
  try {
    if (typeof this.isRoot == "function" && !this.isRoot()) {
      const s = this.rect(1, 1), e = s.node.getScreenCTM();
      return s.remove(), new ae(e);
    }
    return new ae(this.node.getScreenCTM());
  } catch {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new ae();
  }
} }), be(Xe, "Element");
const ui = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(s, e) {
  return e === "color" ? s : s + "-" + e;
} };
["fill", "stroke"].forEach(function(s) {
  const e = {};
  let t;
  e[s] = function(i) {
    if (i === void 0) return this.attr(s);
    if (typeof i == "string" || i instanceof Ae || Ae.isRgb(i) || i instanceof Xe) this.attr(s, i);
    else for (t = ui[s].length - 1; t >= 0; t--) i[ui[s][t]] != null && this.attr(ui.prefix(s, ui[s][t]), i[ui[s][t]]);
    return this;
  }, fe(["Element", "Runner"], e);
}), fe(["Element", "Runner"], { matrix: function(s, e, t, i, r, a) {
  return s == null ? new ae(this) : this.attr("transform", new ae(s, e, t, i, r, a));
}, rotate: function(s, e, t) {
  return this.transform({ rotate: s, ox: e, oy: t }, !0);
}, skew: function(s, e, t, i) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ skew: s, ox: e, oy: t }, !0) : this.transform({ skew: [s, e], ox: t, oy: i }, !0);
}, shear: function(s, e, t) {
  return this.transform({ shear: s, ox: e, oy: t }, !0);
}, scale: function(s, e, t, i) {
  return arguments.length === 1 || arguments.length === 3 ? this.transform({ scale: s, ox: e, oy: t }, !0) : this.transform({ scale: [s, e], ox: t, oy: i }, !0);
}, translate: function(s, e) {
  return this.transform({ translate: [s, e] }, !0);
}, relative: function(s, e) {
  return this.transform({ relative: [s, e] }, !0);
}, flip: function(s = "both", e = "center") {
  return "xybothtrue".indexOf(s) === -1 && (e = s, s = "both"), this.transform({ flip: s, origin: e }, !0);
}, opacity: function(s) {
  return this.attr("opacity", s);
} }), fe("radius", { radius: function(s, e = s) {
  return (this._element || this).type === "radialGradient" ? this.attr("r", new ue(s)) : this.rx(s).ry(e);
} }), fe("Path", { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(s) {
  return new ye(this.node.getPointAtLength(s));
} }), fe(["Element", "Runner"], { font: function(s, e) {
  if (typeof s == "object") {
    for (e in s) this.font(e, s[e]);
    return this;
  }
  return s === "leading" ? this.leading(e) : s === "anchor" ? this.attr("text-anchor", e) : s === "size" || s === "family" || s === "weight" || s === "stretch" || s === "variant" || s === "style" ? this.attr("font-" + s, e) : this.attr(s, e);
} });
fe("Element", ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel", "contextmenu", "wheel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel"].reduce(function(s, e) {
  return s[e] = function(t) {
    return t === null ? this.off(e) : this.on(e, t), this;
  }, s;
}, {})), fe("Element", { untransform: function() {
  return this.attr("transform", null);
}, matrixify: function() {
  return (this.attr("transform") || "").split(Sh).slice(0, -1).map(function(e) {
    const t = e.trim().split("(");
    return [t[0], t[1].split(wt).map(function(i) {
      return parseFloat(i);
    })];
  }).reverse().reduce(function(e, t) {
    return t[0] === "matrix" ? e.lmultiply(ae.fromArray(t[1])) : e[t[0]].apply(e, t[1]);
  }, new ae());
}, toParent: function(s, e) {
  if (this === s) return this;
  if (gs(this.node)) return this.addTo(s, e);
  const t = this.screenCTM(), i = s.screenCTM().inverse();
  return this.addTo(s, e).untransform().transform(i.multiply(t)), this;
}, toRoot: function(s) {
  return this.toParent(this.root(), s);
}, transform: function(s, e) {
  if (s == null || typeof s == "string") {
    const i = new ae(this).decompose();
    return s == null ? i : i[s];
  }
  ae.isMatrixLike(s) || (s = { ...s, origin: us(s, this) });
  const t = new ae(e === !0 ? this : e || !1).transform(s);
  return this.attr("transform", t);
} });
class qe extends Xe {
  flatten() {
    return this.each(function() {
      if (this instanceof qe) return this.flatten().ungroup();
    }), this;
  }
  ungroup(e = this.parent(), t = e.index(this)) {
    return t = t === -1 ? e.children().length : t, this.each(function(i, r) {
      return r[r.length - i - 1].toParent(e, t);
    }), this.remove();
  }
}
be(qe, "Container");
class ar extends qe {
  constructor(e, t = e) {
    super(Re("defs", e), t);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
}
be(ar, "Defs");
class st extends Xe {
}
function qs(s) {
  return this.attr("rx", s);
}
function Zs(s) {
  return this.attr("ry", s);
}
function oo(s) {
  return s == null ? this.cx() - this.rx() : this.cx(s + this.rx());
}
function lo(s) {
  return s == null ? this.cy() - this.ry() : this.cy(s + this.ry());
}
function co(s) {
  return this.attr("cx", s);
}
function ho(s) {
  return this.attr("cy", s);
}
function uo(s) {
  return s == null ? 2 * this.rx() : this.rx(new ue(s).divide(2));
}
function go(s) {
  return s == null ? 2 * this.ry() : this.ry(new ue(s).divide(2));
}
be(st, "Shape");
var _h = Object.freeze({ __proto__: null, cx: co, cy: ho, height: go, rx: qs, ry: Zs, width: uo, x: oo, y: lo });
class Vi extends st {
  constructor(e, t = e) {
    super(Re("ellipse", e), t);
  }
  size(e, t) {
    const i = si(this, e, t);
    return this.rx(new ue(i.width).divide(2)).ry(new ue(i.height).divide(2));
  }
}
oe(Vi, _h), fe("Container", { ellipse: Me(function(s = 0, e = s) {
  return this.put(new Vi()).size(s, e).move(0, 0);
}) }), be(Vi, "Ellipse");
class fo extends Rt {
  constructor(e = me.document.createDocumentFragment()) {
    super(e);
  }
  xml(e, t, i) {
    if (typeof e == "boolean" && (i = t, t = e, e = null), e == null || typeof e == "function") {
      const r = new Rt(ki("wrapper", i));
      return r.add(this.node.cloneNode(!0)), r.xml(!1, i);
    }
    return super.xml(e, !1, i);
  }
}
function po(s, e) {
  return (this._element || this).type === "radialGradient" ? this.attr({ fx: new ue(s), fy: new ue(e) }) : this.attr({ x1: new ue(s), y1: new ue(e) });
}
function xo(s, e) {
  return (this._element || this).type === "radialGradient" ? this.attr({ cx: new ue(s), cy: new ue(e) }) : this.attr({ x2: new ue(s), y2: new ue(e) });
}
be(fo, "Fragment");
var Oh = Object.freeze({ __proto__: null, from: po, to: xo });
class mi extends qe {
  constructor(e, t) {
    super(Re(e + "Gradient", typeof e == "string" ? null : e), t);
  }
  attr(e, t, i) {
    return e === "transform" && (e = "gradientTransform"), super.attr(e, t, i);
  }
  bbox() {
    return new Oe();
  }
  targets() {
    return Xt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(e) {
    return this.clear(), typeof e == "function" && e.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
oe(mi, Oh), fe({ Container: { gradient(...s) {
  return this.defs().gradient(...s);
} }, Defs: { gradient: Me(function(s, e) {
  return this.put(new mi(s)).update(e);
}) } }), be(mi, "Gradient");
class Si extends qe {
  constructor(e, t = e) {
    super(Re("pattern", e), t);
  }
  attr(e, t, i) {
    return e === "transform" && (e = "patternTransform"), super.attr(e, t, i);
  }
  bbox() {
    return new Oe();
  }
  targets() {
    return Xt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(e) {
    return this.clear(), typeof e == "function" && e.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
fe({ Container: { pattern(...s) {
  return this.defs().pattern(...s);
} }, Defs: { pattern: Me(function(s, e, t) {
  return this.put(new Si()).update(t).attr({ x: 0, y: 0, width: s, height: e, patternUnits: "userSpaceOnUse" });
}) } }), be(Si, "Pattern");
let Gi = class extends st {
  constructor(s, e = s) {
    super(Re("image", s), e);
  }
  load(s, e) {
    if (!s) return this;
    const t = new me.window.Image();
    return vt(t, "load", function(i) {
      const r = this.parent(Si);
      this.width() === 0 && this.height() === 0 && this.size(t.width, t.height), r instanceof Si && r.width() === 0 && r.height() === 0 && r.size(this.width(), this.height()), typeof e == "function" && e.call(this, i);
    }, this), vt(t, "load error", function() {
      lt(t);
    }), this.attr("href", t.src = s, ai);
  }
};
var Va;
Va = function(s, e, t) {
  return s !== "fill" && s !== "stroke" || Ah.test(e) && (e = t.root().defs().image(e)), e instanceof Gi && (e = t.root().defs().pattern(0, 0, (i) => {
    i.add(e);
  })), e;
}, no.push(Va), fe({ Container: { image: Me(function(s, e) {
  return this.put(new Gi()).size(0, 0).load(s, e);
}) } }), be(Gi, "Image");
class Pt extends Yt {
  bbox() {
    let e = -1 / 0, t = -1 / 0, i = 1 / 0, r = 1 / 0;
    return this.forEach(function(a) {
      e = Math.max(a[0], e), t = Math.max(a[1], t), i = Math.min(a[0], i), r = Math.min(a[1], r);
    }), new Oe(i, r, e - i, t - r);
  }
  move(e, t) {
    const i = this.bbox();
    if (e -= i.x, t -= i.y, !isNaN(e) && !isNaN(t)) for (let r = this.length - 1; r >= 0; r--) this[r] = [this[r][0] + e, this[r][1] + t];
    return this;
  }
  parse(e = [0, 0]) {
    const t = [];
    (e = e instanceof Array ? Array.prototype.concat.apply([], e) : e.trim().split(wt).map(parseFloat)).length % 2 != 0 && e.pop();
    for (let i = 0, r = e.length; i < r; i += 2) t.push([e[i], e[i + 1]]);
    return t;
  }
  size(e, t) {
    let i;
    const r = this.bbox();
    for (i = this.length - 1; i >= 0; i--) r.width && (this[i][0] = (this[i][0] - r.x) * e / r.width + r.x), r.height && (this[i][1] = (this[i][1] - r.y) * t / r.height + r.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const e = [];
    for (let t = 0, i = this.length; t < i; t++) e.push(this[t].join(","));
    return e.join(" ");
  }
  transform(e) {
    return this.clone().transformO(e);
  }
  transformO(e) {
    ae.isMatrixLike(e) || (e = new ae(e));
    for (let t = this.length; t--; ) {
      const [i, r] = this[t];
      this[t][0] = e.a * i + e.c * r + e.e, this[t][1] = e.b * i + e.d * r + e.f;
    }
    return this;
  }
}
const zh = Pt;
var Ks = Object.freeze({ __proto__: null, MorphArray: zh, height: function(s) {
  const e = this.bbox();
  return s == null ? e.height : this.size(e.width, s);
}, width: function(s) {
  const e = this.bbox();
  return s == null ? e.width : this.size(s, e.height);
}, x: function(s) {
  return s == null ? this.bbox().x : this.move(s, this.bbox().y);
}, y: function(s) {
  return s == null ? this.bbox().y : this.move(this.bbox().x, s);
} });
let zt = class extends st {
  constructor(s, e = s) {
    super(Re("line", s), e);
  }
  array() {
    return new Pt([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  move(s, e) {
    return this.attr(this.array().move(s, e).toLine());
  }
  plot(s, e, t, i) {
    return s == null ? this.array() : (s = e !== void 0 ? { x1: s, y1: e, x2: t, y2: i } : new Pt(s).toLine(), this.attr(s));
  }
  size(s, e) {
    const t = si(this, s, e);
    return this.attr(this.array().size(t.width, t.height).toLine());
  }
};
oe(zt, Ks), fe({ Container: { line: Me(function(...s) {
  return zt.prototype.plot.apply(this.put(new zt()), s[0] != null ? s : [0, 0, 0, 0]);
}) } }), be(zt, "Line");
let $i = class extends qe {
  constructor(s, e = s) {
    super(Re("marker", s), e);
  }
  height(s) {
    return this.attr("markerHeight", s);
  }
  orient(s) {
    return this.attr("orient", s);
  }
  ref(s, e) {
    return this.attr("refX", s).attr("refY", e);
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
  update(s) {
    return this.clear(), typeof s == "function" && s.call(this, this), this;
  }
  width(s) {
    return this.attr("markerWidth", s);
  }
};
function $t(s, e) {
  return function(t) {
    return t == null ? this[s] : (this[s] = t, e && e.call(this), this);
  };
}
fe({ Container: { marker(...s) {
  return this.defs().marker(...s);
} }, Defs: { marker: Me(function(s, e, t) {
  return this.put(new $i()).size(s, e).ref(s / 2, e / 2).viewbox(0, 0, s, e).attr("orient", "auto").update(t);
}) }, marker: { marker(s, e, t, i) {
  let r = ["marker"];
  return s !== "all" && r.push(s), r = r.join("-"), s = arguments[1] instanceof $i ? arguments[1] : this.defs().marker(e, t, i), this.attr(r, s);
} } }), be($i, "Marker");
const Fh = { "-": function(s) {
  return s;
}, "<>": function(s) {
  return -Math.cos(s * Math.PI) / 2 + 0.5;
}, ">": function(s) {
  return Math.sin(s * Math.PI / 2);
}, "<": function(s) {
  return 1 - Math.cos(s * Math.PI / 2);
}, bezier: function(s, e, t, i) {
  return function(r) {
    return r < 0 ? s > 0 ? e / s * r : t > 0 ? i / t * r : 0 : r > 1 ? t < 1 ? (1 - i) / (1 - t) * r + (i - t) / (1 - t) : s < 1 ? (1 - e) / (1 - s) * r + (e - s) / (1 - s) : 1 : 3 * r * (1 - r) ** 2 * e + 3 * r ** 2 * (1 - r) * i + r ** 3;
  };
}, steps: function(s, e = "end") {
  e = e.split("-").reverse()[0];
  let t = s;
  return e === "none" ? --t : e === "both" && ++t, (i, r = !1) => {
    let a = Math.floor(i * s);
    const n = i * a % 1 == 0;
    return e !== "start" && e !== "both" || ++a, r && n && --a, i >= 0 && a < 0 && (a = 0), i <= 1 && a > t && (a = t), a / t;
  };
} };
class Js {
  done() {
    return !1;
  }
}
class fs extends Js {
  constructor(e = Lh) {
    super(), this.ease = Fh[e] || e;
  }
  step(e, t, i) {
    return typeof e != "number" ? i < 1 ? e : t : e + (t - e) * this.ease(i);
  }
}
class Qi extends Js {
  constructor(e) {
    super(), this.stepper = e;
  }
  done(e) {
    return e.done;
  }
  step(e, t, i, r) {
    return this.stepper(e, t, i, r);
  }
}
function Ga() {
  const s = (this._duration || 500) / 1e3, e = this._overshoot || 0, t = Math.PI, i = Math.log(e / 100 + 1e-10), r = -i / Math.sqrt(t * t + i * i), a = 3.9 / (r * s);
  this.d = 2 * r * a, this.k = a * a;
}
oe(class extends Qi {
  constructor(s = 500, e = 0) {
    super(), this.duration(s).overshoot(e);
  }
  step(s, e, t, i) {
    if (typeof s == "string") return s;
    if (i.done = t === 1 / 0, t === 1 / 0) return e;
    if (t === 0) return s;
    t > 100 && (t = 16), t /= 1e3;
    const r = i.velocity || 0, a = -this.d * r - this.k * (s - e), n = s + r * t + a * t * t / 2;
    return i.velocity = r + a * t, i.done = Math.abs(e - n) + Math.abs(r) < 2e-3, i.done ? e : n;
  }
}, { duration: $t("_duration", Ga), overshoot: $t("_overshoot", Ga) });
oe(class extends Qi {
  constructor(s = 0.1, e = 0.01, t = 0, i = 1e3) {
    super(), this.p(s).i(e).d(t).windup(i);
  }
  step(s, e, t, i) {
    if (typeof s == "string") return s;
    if (i.done = t === 1 / 0, t === 1 / 0) return e;
    if (t === 0) return s;
    const r = e - s;
    let a = (i.integral || 0) + r * t;
    const n = (r - (i.error || 0)) / t, o = this._windup;
    return o !== !1 && (a = Math.max(-o, Math.min(a, o))), i.error = r, i.integral = a, i.done = Math.abs(r) < 1e-3, i.done ? e : s + (this.P * r + this.I * a + this.D * n);
  }
}, { windup: $t("_windup"), p: $t("P"), i: $t("I"), d: $t("D") });
const Nh = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 }, ps = { M: function(s, e, t) {
  return e.x = t.x = s[0], e.y = t.y = s[1], ["M", e.x, e.y];
}, L: function(s, e) {
  return e.x = s[0], e.y = s[1], ["L", s[0], s[1]];
}, H: function(s, e) {
  return e.x = s[0], ["H", s[0]];
}, V: function(s, e) {
  return e.y = s[0], ["V", s[0]];
}, C: function(s, e) {
  return e.x = s[4], e.y = s[5], ["C", s[0], s[1], s[2], s[3], s[4], s[5]];
}, S: function(s, e) {
  return e.x = s[2], e.y = s[3], ["S", s[0], s[1], s[2], s[3]];
}, Q: function(s, e) {
  return e.x = s[2], e.y = s[3], ["Q", s[0], s[1], s[2], s[3]];
}, T: function(s, e) {
  return e.x = s[0], e.y = s[1], ["T", s[0], s[1]];
}, Z: function(s, e, t) {
  return e.x = t.x, e.y = t.y, ["Z"];
}, A: function(s, e) {
  return e.x = s[5], e.y = s[6], ["A", s[0], s[1], s[2], s[3], s[4], s[5], s[6]];
} }, Sr = "mlhvqtcsaz".split("");
for (let s = 0, e = Sr.length; s < e; ++s) ps[Sr[s]] = /* @__PURE__ */ function(t) {
  return function(i, r, a) {
    if (t === "H") i[0] = i[0] + r.x;
    else if (t === "V") i[0] = i[0] + r.y;
    else if (t === "A") i[5] = i[5] + r.x, i[6] = i[6] + r.y;
    else for (let n = 0, o = i.length; n < o; ++n) i[n] = i[n] + (n % 2 ? r.y : r.x);
    return ps[t](i, r, a);
  };
}(Sr[s].toUpperCase());
function xs(s) {
  return s.segment.length && s.segment.length - 1 === Nh[s.segment[0].toUpperCase()];
}
function Dh(s, e) {
  s.inNumber && Tt(s, !1);
  const t = $s.test(e);
  if (t) s.segment = [e];
  else {
    const i = s.lastCommand, r = i.toLowerCase(), a = i === r;
    s.segment = [r === "m" ? a ? "l" : "L" : i];
  }
  return s.inSegment = !0, s.lastCommand = s.segment[0], t;
}
function Tt(s, e) {
  if (!s.inNumber) throw new Error("Parser Error");
  s.number && s.segment.push(parseFloat(s.number)), s.inNumber = e, s.number = "", s.pointSeen = !1, s.hasExponent = !1, xs(s) && ms(s);
}
function ms(s) {
  s.inSegment = !1, s.absolute && (s.segment = function(e) {
    const t = e.segment[0];
    return ps[t](e.segment.slice(1), e.p, e.p0);
  }(s)), s.segments.push(s.segment);
}
function Hh(s) {
  if (!s.segment.length) return !1;
  const e = s.segment[0].toUpperCase() === "A", t = s.segment.length;
  return e && (t === 4 || t === 5);
}
function jh(s) {
  return s.lastToken.toUpperCase() === "E";
}
const Yh = /* @__PURE__ */ new Set([" ", ",", "	", `
`, "\r", "\f"]);
class dt extends Yt {
  bbox() {
    return Ct().path.setAttribute("d", this.toString()), new Oe(Ct.nodes.path.getBBox());
  }
  move(e, t) {
    const i = this.bbox();
    if (e -= i.x, t -= i.y, !isNaN(e) && !isNaN(t)) for (let r, a = this.length - 1; a >= 0; a--) r = this[a][0], r === "M" || r === "L" || r === "T" ? (this[a][1] += e, this[a][2] += t) : r === "H" ? this[a][1] += e : r === "V" ? this[a][1] += t : r === "C" || r === "S" || r === "Q" ? (this[a][1] += e, this[a][2] += t, this[a][3] += e, this[a][4] += t, r === "C" && (this[a][5] += e, this[a][6] += t)) : r === "A" && (this[a][6] += e, this[a][7] += t);
    return this;
  }
  parse(e = "M0 0") {
    return Array.isArray(e) && (e = Array.prototype.concat.apply([], e).toString()), function(t, i = !0) {
      let r = 0, a = "";
      const n = { segment: [], inNumber: !1, number: "", lastToken: "", inSegment: !1, segments: [], pointSeen: !1, hasExponent: !1, absolute: i, p0: new ye(), p: new ye() };
      for (; n.lastToken = a, a = t.charAt(r++); ) if (n.inSegment || !Dh(n, a)) if (a !== ".") if (isNaN(parseInt(a))) if (Yh.has(a)) n.inNumber && Tt(n, !1);
      else if (a !== "-" && a !== "+") if (a.toUpperCase() !== "E") {
        if ($s.test(a)) {
          if (n.inNumber) Tt(n, !1);
          else {
            if (!xs(n)) throw new Error("parser Error");
            ms(n);
          }
          --r;
        }
      } else n.number += a, n.hasExponent = !0;
      else {
        if (n.inNumber && !jh(n)) {
          Tt(n, !1), --r;
          continue;
        }
        n.number += a, n.inNumber = !0;
      }
      else {
        if (n.number === "0" || Hh(n)) {
          n.inNumber = !0, n.number = a, Tt(n, !0);
          continue;
        }
        n.inNumber = !0, n.number += a;
      }
      else {
        if (n.pointSeen || n.hasExponent) {
          Tt(n, !1), --r;
          continue;
        }
        n.inNumber = !0, n.pointSeen = !0, n.number += a;
      }
      return n.inNumber && Tt(n, !1), n.inSegment && xs(n) && ms(n), n.segments;
    }(e);
  }
  size(e, t) {
    const i = this.bbox();
    let r, a;
    for (i.width = i.width === 0 ? 1 : i.width, i.height = i.height === 0 ? 1 : i.height, r = this.length - 1; r >= 0; r--) a = this[r][0], a === "M" || a === "L" || a === "T" ? (this[r][1] = (this[r][1] - i.x) * e / i.width + i.x, this[r][2] = (this[r][2] - i.y) * t / i.height + i.y) : a === "H" ? this[r][1] = (this[r][1] - i.x) * e / i.width + i.x : a === "V" ? this[r][1] = (this[r][1] - i.y) * t / i.height + i.y : a === "C" || a === "S" || a === "Q" ? (this[r][1] = (this[r][1] - i.x) * e / i.width + i.x, this[r][2] = (this[r][2] - i.y) * t / i.height + i.y, this[r][3] = (this[r][3] - i.x) * e / i.width + i.x, this[r][4] = (this[r][4] - i.y) * t / i.height + i.y, a === "C" && (this[r][5] = (this[r][5] - i.x) * e / i.width + i.x, this[r][6] = (this[r][6] - i.y) * t / i.height + i.y)) : a === "A" && (this[r][1] = this[r][1] * e / i.width, this[r][2] = this[r][2] * t / i.height, this[r][6] = (this[r][6] - i.x) * e / i.width + i.x, this[r][7] = (this[r][7] - i.y) * t / i.height + i.y);
    return this;
  }
  toString() {
    return function(e) {
      let t = "";
      for (let i = 0, r = e.length; i < r; i++) t += e[i][0], e[i][1] != null && (t += e[i][1], e[i][2] != null && (t += " ", t += e[i][2], e[i][3] != null && (t += " ", t += e[i][3], t += " ", t += e[i][4], e[i][5] != null && (t += " ", t += e[i][5], t += " ", t += e[i][6], e[i][7] != null && (t += " ", t += e[i][7])))));
      return t + " ";
    }(this);
  }
}
const mo = (s) => {
  const e = typeof s;
  return e === "number" ? ue : e === "string" ? Ae.isColor(s) ? Ae : wt.test(s) ? $s.test(s) ? dt : Yt : io.test(s) ? ue : bs : vs.indexOf(s.constructor) > -1 ? s.constructor : Array.isArray(s) ? Yt : e === "object" ? Ci : bs;
};
class _t {
  constructor(e) {
    this._stepper = e || new fs("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(e) {
    return this._morphObj.morph(this._from, this._to, e, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce(function(e, t) {
      return e && t;
    }, !0);
  }
  from(e) {
    return e == null ? this._from : (this._from = this._set(e), this);
  }
  stepper(e) {
    return e == null ? this._stepper : (this._stepper = e, this);
  }
  to(e) {
    return e == null ? this._to : (this._to = this._set(e), this);
  }
  type(e) {
    return e == null ? this._type : (this._type = e, this);
  }
  _set(e) {
    this._type || this.type(mo(e));
    let t = new this._type(e);
    return this._type === Ae && (t = this._to ? t[this._to[4]]() : this._from ? t[this._from[4]]() : t), this._type === Ci && (t = this._to ? t.align(this._to) : this._from ? t.align(this._from) : t), t = t.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(t.length)).map(Object).map(function(i) {
      return i.done = !0, i;
    }), t;
  }
}
class bs {
  constructor(...e) {
    this.init(...e);
  }
  init(e) {
    return e = Array.isArray(e) ? e[0] : e, this.value = e, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
}
class Ti {
  constructor(...e) {
    this.init(...e);
  }
  init(e) {
    return Array.isArray(e) && (e = { scaleX: e[0], scaleY: e[1], shear: e[2], rotate: e[3], translateX: e[4], translateY: e[5], originX: e[6], originY: e[7] }), Object.assign(this, Ti.defaults, e), this;
  }
  toArray() {
    const e = this;
    return [e.scaleX, e.scaleY, e.shear, e.rotate, e.translateX, e.translateY, e.originX, e.originY];
  }
}
Ti.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
const Xh = (s, e) => s[0] < e[0] ? -1 : s[0] > e[0] ? 1 : 0;
class Ci {
  constructor(...e) {
    this.init(...e);
  }
  align(e) {
    const t = this.values;
    for (let i = 0, r = t.length; i < r; ++i) {
      if (t[i + 1] === e[i + 1]) {
        if (t[i + 1] === Ae && e[i + 7] !== t[i + 7]) {
          const o = e[i + 7], l = new Ae(this.values.splice(i + 3, 5))[o]().toArray();
          this.values.splice(i + 3, 0, ...l);
        }
        i += t[i + 2] + 2;
        continue;
      }
      if (!e[i + 1]) return this;
      const a = new e[i + 1]().toArray(), n = t[i + 2] + 3;
      t.splice(i, n, e[i], e[i + 1], e[i + 2], ...a), i += t[i + 2] + 2;
    }
    return this;
  }
  init(e) {
    if (this.values = [], Array.isArray(e)) return void (this.values = e.slice());
    e = e || {};
    const t = [];
    for (const i in e) {
      const r = mo(e[i]), a = new r(e[i]).toArray();
      t.push([i, r, a.length, ...a]);
    }
    return t.sort(Xh), this.values = t.reduce((i, r) => i.concat(r), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const e = {}, t = this.values;
    for (; t.length; ) {
      const i = t.shift(), r = t.shift(), a = t.shift(), n = t.splice(0, a);
      e[i] = new r(n);
    }
    return e;
  }
}
const vs = [bs, Ti, Ci];
class qt extends st {
  constructor(e, t = e) {
    super(Re("path", e), t);
  }
  array() {
    return this._array || (this._array = new dt(this.attr("d")));
  }
  clear() {
    return delete this._array, this;
  }
  height(e) {
    return e == null ? this.bbox().height : this.size(this.bbox().width, e);
  }
  move(e, t) {
    return this.attr("d", this.array().move(e, t));
  }
  plot(e) {
    return e == null ? this.array() : this.clear().attr("d", typeof e == "string" ? e : this._array = new dt(e));
  }
  size(e, t) {
    const i = si(this, e, t);
    return this.attr("d", this.array().size(i.width, i.height));
  }
  width(e) {
    return e == null ? this.bbox().width : this.size(e, this.bbox().height);
  }
  x(e) {
    return e == null ? this.bbox().x : this.move(e, this.bbox().y);
  }
  y(e) {
    return e == null ? this.bbox().y : this.move(this.bbox().x, e);
  }
}
qt.prototype.MorphArray = dt, fe({ Container: { path: Me(function(s) {
  return this.put(new qt()).plot(s || new dt());
}) } }), be(qt, "Path");
var bo = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new Pt(this.attr("points")));
}, clear: function() {
  return delete this._array, this;
}, move: function(s, e) {
  return this.attr("points", this.array().move(s, e));
}, plot: function(s) {
  return s == null ? this.array() : this.clear().attr("points", typeof s == "string" ? s : this._array = new Pt(s));
}, size: function(s, e) {
  const t = si(this, s, e);
  return this.attr("points", this.array().size(t.width, t.height));
} });
class Ft extends st {
  constructor(e, t = e) {
    super(Re("polygon", e), t);
  }
}
fe({ Container: { polygon: Me(function(s) {
  return this.put(new Ft()).plot(s || new Pt());
}) } }), oe(Ft, Ks), oe(Ft, bo), be(Ft, "Polygon");
class Nt extends st {
  constructor(e, t = e) {
    super(Re("polyline", e), t);
  }
}
fe({ Container: { polyline: Me(function(s) {
  return this.put(new Nt()).plot(s || new Pt());
}) } }), oe(Nt, Ks), oe(Nt, bo), be(Nt, "Polyline");
class Ui extends st {
  constructor(e, t = e) {
    super(Re("rect", e), t);
  }
}
oe(Ui, { rx: qs, ry: Zs }), fe({ Container: { rect: Me(function(s, e) {
  return this.put(new Ui()).size(s, e);
}) } }), be(Ui, "Rect");
class Cr {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  push(e) {
    const t = e.next !== void 0 ? e : { value: e, next: null, prev: null };
    return this._last ? (t.prev = this._last, this._last.next = t, this._last = t) : (this._last = t, this._first = t), t;
  }
  remove(e) {
    e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this._last && (this._last = e.prev), e === this._first && (this._first = e.next), e.prev = null, e.next = null;
  }
  shift() {
    const e = this._first;
    return e ? (this._first = e.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, e.value) : null;
  }
}
const Ce = { nextDraw: null, frames: new Cr(), timeouts: new Cr(), immediates: new Cr(), timer: () => me.window.performance || me.window.Date, transforms: [], frame(s) {
  const e = Ce.frames.push({ run: s });
  return Ce.nextDraw === null && (Ce.nextDraw = me.window.requestAnimationFrame(Ce._draw)), e;
}, timeout(s, e) {
  e = e || 0;
  const t = Ce.timer().now() + e, i = Ce.timeouts.push({ run: s, time: t });
  return Ce.nextDraw === null && (Ce.nextDraw = me.window.requestAnimationFrame(Ce._draw)), i;
}, immediate(s) {
  const e = Ce.immediates.push(s);
  return Ce.nextDraw === null && (Ce.nextDraw = me.window.requestAnimationFrame(Ce._draw)), e;
}, cancelFrame(s) {
  s != null && Ce.frames.remove(s);
}, clearTimeout(s) {
  s != null && Ce.timeouts.remove(s);
}, cancelImmediate(s) {
  s != null && Ce.immediates.remove(s);
}, _draw(s) {
  let e = null;
  const t = Ce.timeouts.last();
  for (; (e = Ce.timeouts.shift()) && (s >= e.time ? e.run() : Ce.timeouts.push(e), e !== t); ) ;
  let i = null;
  const r = Ce.frames.last();
  for (; i !== r && (i = Ce.frames.shift()); ) i.run(s);
  let a = null;
  for (; a = Ce.immediates.shift(); ) a();
  Ce.nextDraw = Ce.timeouts.first() || Ce.frames.first() ? me.window.requestAnimationFrame(Ce._draw) : null;
} }, Bh = function(s) {
  const e = s.start, t = s.runner.duration();
  return { start: e, duration: t, end: e + t, runner: s.runner };
}, Wh = function() {
  const s = me.window;
  return (s.performance || s.Date).now();
};
class vo extends Ei {
  constructor(e = Wh) {
    super(), this._timeSource = e, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const e = this.getLastRunnerInfo(), t = e ? e.runner.duration() : 0;
    return (e ? e.start : this._time) + t;
  }
  getEndTimeOfTimeline() {
    const e = this._runners.map((t) => t.start + t.runner.duration());
    return Math.max(0, ...e);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(e) {
    return this._runners[this._runnerIds.indexOf(e)] || null;
  }
  pause() {
    return this._paused = !0, this._continue();
  }
  persist(e) {
    return e == null ? this._persist : (this._persist = e, this);
  }
  play() {
    return this._paused = !1, this.updateTime()._continue();
  }
  reverse(e) {
    const t = this.speed();
    if (e == null) return this.speed(-t);
    const i = Math.abs(t);
    return this.speed(e ? -i : i);
  }
  schedule(e, t, i) {
    if (e == null) return this._runners.map(Bh);
    let r = 0;
    const a = this.getEndTime();
    if (t = t || 0, i == null || i === "last" || i === "after") r = a;
    else if (i === "absolute" || i === "start") r = t, t = 0;
    else if (i === "now") r = this._time;
    else if (i === "relative") {
      const l = this.getRunnerInfoById(e.id);
      l && (r = l.start + t, t = 0);
    } else {
      if (i !== "with-last") throw new Error('Invalid value for the "when" parameter');
      {
        const l = this.getLastRunnerInfo();
        r = l ? l.start : this._time;
      }
    }
    e.unschedule(), e.timeline(this);
    const n = e.persist(), o = { persist: n === null ? this._persist : n, start: r + t, runner: e };
    return this._lastRunnerId = e.id, this._runners.push(o), this._runners.sort((l, c) => l.start - c.start), this._runnerIds = this._runners.map((l) => l.runner.id), this.updateTime()._continue(), this;
  }
  seek(e) {
    return this.time(this._time + e);
  }
  source(e) {
    return e == null ? this._timeSource : (this._timeSource = e, this);
  }
  speed(e) {
    return e == null ? this._speed : (this._speed = e, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(e) {
    return e == null ? this._time : (this._time = e, this._continue(!0));
  }
  unschedule(e) {
    const t = this._runnerIds.indexOf(e.id);
    return t < 0 || (this._runners.splice(t, 1), this._runnerIds.splice(t, 1), e.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(e = !1) {
    return Ce.cancelFrame(this._nextFrame), this._nextFrame = null, e ? this._stepImmediate() : (this._paused || (this._nextFrame = Ce.frame(this._step)), this);
  }
  _stepFn(e = !1) {
    const t = this._timeSource();
    let i = t - this._lastSourceTime;
    e && (i = 0);
    const r = this._speed * i + (this._time - this._lastStepTime);
    this._lastSourceTime = t, e || (this._time += r, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
    for (let n = this._runners.length; n--; ) {
      const o = this._runners[n], l = o.runner;
      this._time - o.start <= 0 && l.reset();
    }
    let a = !1;
    for (let n = 0, o = this._runners.length; n < o; n++) {
      const l = this._runners[n], c = l.runner;
      let h = r;
      const d = this._time - l.start;
      if (d <= 0) {
        a = !0;
        continue;
      }
      d < h && (h = d), c.active() && (c.step(h).done ? l.persist !== !0 && c.duration() - c.time() + this._time + l.persist < this._time && (c.unschedule(), --n, --o) : a = !0);
    }
    return a && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = !0, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, !1), this._stepImmediate = this._stepFn.bind(this, !0);
  }
}
fe({ Element: { timeline: function(s) {
  return s == null ? (this._timeline = this._timeline || new vo(), this._timeline) : (this._timeline = s, this);
} } });
class tt extends Ei {
  constructor(e) {
    super(), this.id = tt.id++, e = typeof (e = e ?? kr) == "function" ? new Qi(e) : e, this._element = null, this._timeline = null, this.done = !1, this._queue = [], this._duration = typeof e == "number" && e, this._isDeclarative = e instanceof Qi, this._stepper = this._isDeclarative ? e : new fs(), this._history = {}, this.enabled = !0, this._time = 0, this._lastTime = 0, this._reseted = !0, this.transforms = new ae(), this.transformId = 1, this._haveReversed = !1, this._reverse = !1, this._loopsDone = 0, this._swing = !1, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(e, t, i) {
    let r = 1, a = !1, n = 0;
    return t = t ?? Ih, i = i || "last", typeof (e = e ?? kr) != "object" || e instanceof Js || (t = e.delay ?? t, i = e.when ?? i, a = e.swing || a, r = e.times ?? r, n = e.wait ?? n, e = e.duration ?? kr), { duration: e, delay: t, swing: a, times: r, wait: n, when: i };
  }
  active(e) {
    return e == null ? this.enabled : (this.enabled = e, this);
  }
  addTransform(e) {
    return this.transforms.lmultiplyO(e), this;
  }
  after(e) {
    return this.on("finished", e);
  }
  animate(e, t, i) {
    const r = tt.sanitise(e, t, i), a = new tt(r.duration);
    return this._timeline && a.timeline(this._timeline), this._element && a.element(this._element), a.loop(r).schedule(r.delay, r.when);
  }
  clearTransform() {
    return this.transforms = new ae(), this;
  }
  clearTransformsFromQueue() {
    this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter((e) => !e.isTransform));
  }
  delay(e) {
    return this.animate(0, e);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(e) {
    return this.queue(null, e);
  }
  ease(e) {
    return this._stepper = new fs(e), this;
  }
  element(e) {
    return e == null ? this._element : (this._element = e, e._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(e, t, i) {
    return typeof e == "object" && (t = e.swing, i = e.wait, e = e.times), this._times = e || 1 / 0, this._swing = t || !1, this._wait = i || 0, this._times === !0 && (this._times = 1 / 0), this;
  }
  loops(e) {
    const t = this._duration + this._wait;
    if (e == null) {
      const a = Math.floor(this._time / t), n = (this._time - a * t) / this._duration;
      return Math.min(a + n, this._times);
    }
    const i = e % 1, r = t * Math.floor(e) + this._duration * i;
    return this.time(r);
  }
  persist(e) {
    return e == null ? this._persist : (this._persist = e, this);
  }
  position(e) {
    const t = this._time, i = this._duration, r = this._wait, a = this._times, n = this._swing, o = this._reverse;
    let l;
    if (e == null) {
      const d = function(g) {
        const p = n * Math.floor(g % (2 * (r + i)) / (r + i)), f = p && !o || !p && o, x = Math.pow(-1, f) * (g % (r + i)) / i + f;
        return Math.max(Math.min(x, 1), 0);
      }, u = a * (r + i) - r;
      return l = t <= 0 ? Math.round(d(1e-5)) : t < u ? d(t) : Math.round(d(u - 1e-5)), l;
    }
    const c = Math.floor(this.loops()), h = n && c % 2 == 0;
    return l = c + (h && !o || o && h ? e : 1 - e), this.loops(l);
  }
  progress(e) {
    return e == null ? Math.min(1, this._time / this.duration()) : this.time(e * this.duration());
  }
  queue(e, t, i, r) {
    return this._queue.push({ initialiser: e || Wa, runner: t || Wa, retarget: i, isTransform: r, initialised: !1, finished: !1 }), this.timeline() && this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = !0), this;
  }
  reverse(e) {
    return this._reverse = e ?? !this._reverse, this;
  }
  schedule(e, t, i) {
    if (e instanceof vo || (i = t, t = e, e = this.timeline()), !e) throw Error("Runner cannot be scheduled without timeline");
    return e.schedule(this, t, i), this;
  }
  step(e) {
    if (!this.enabled) return this;
    e = e ?? 16, this._time += e;
    const t = this.position(), i = this._lastPosition !== t && this._time >= 0;
    this._lastPosition = t;
    const r = this.duration(), a = this._lastTime <= 0 && this._time > 0, n = this._lastTime < r && this._time >= r;
    this._lastTime = this._time, a && this.fire("start", this);
    const o = this._isDeclarative;
    this.done = !o && !n && this._time >= r, this._reseted = !1;
    let l = !1;
    return (i || o) && (this._initialise(i), this.transforms = new ae(), l = this._run(o ? e : t), this.fire("step", this)), this.done = this.done || l && o, n && this.fire("finished", this), this;
  }
  time(e) {
    if (e == null) return this._time;
    const t = e - this._time;
    return this.step(t), this;
  }
  timeline(e) {
    return e === void 0 ? this._timeline : (this._timeline = e, this);
  }
  unschedule() {
    const e = this.timeline();
    return e && e.unschedule(this), this;
  }
  _initialise(e) {
    if (e || this._isDeclarative) for (let t = 0, i = this._queue.length; t < i; ++t) {
      const r = this._queue[t], a = this._isDeclarative || !r.initialised && e;
      e = !r.finished, a && e && (r.initialiser.call(this), r.initialised = !0);
    }
  }
  _rememberMorpher(e, t) {
    if (this._history[e] = { morpher: t, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const i = this.timeline();
      i && i.play();
    }
  }
  _run(e) {
    let t = !0;
    for (let i = 0, r = this._queue.length; i < r; ++i) {
      const a = this._queue[i], n = a.runner.call(this, e);
      a.finished = a.finished || n === !0, t = t && a.finished;
    }
    return t;
  }
  _tryRetarget(e, t, i) {
    if (this._history[e]) {
      if (!this._history[e].caller.initialised) {
        const a = this._queue.indexOf(this._history[e].caller);
        return this._queue.splice(a, 1), !1;
      }
      this._history[e].caller.retarget ? this._history[e].caller.retarget.call(this, t, i) : this._history[e].morpher.to(t), this._history[e].caller.finished = !1;
      const r = this.timeline();
      return r && r.play(), !0;
    }
    return !1;
  }
}
tt.id = 0;
class er {
  constructor(e = new ae(), t = -1, i = !0) {
    this.transforms = e, this.id = t, this.done = i;
  }
  clearTransformsFromQueue() {
  }
}
oe([tt, er], { mergeWith(s) {
  return new er(s.transforms.lmultiply(this.transforms), s.id);
} });
const yo = (s, e) => s.lmultiplyO(e), wo = (s) => s.transforms;
function Vh() {
  const s = this._transformationRunners.runners.map(wo).reduce(yo, new ae());
  this.transform(s), this._transformationRunners.merge(), this._transformationRunners.length() === 1 && (this._frameId = null);
}
class Gh {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(e) {
    if (this.runners.includes(e)) return;
    const t = e.id + 1;
    return this.runners.push(e), this.ids.push(t), this;
  }
  clearBefore(e) {
    const t = this.ids.indexOf(e + 1) || 1;
    return this.ids.splice(0, t, 0), this.runners.splice(0, t, new er()).forEach((i) => i.clearTransformsFromQueue()), this;
  }
  edit(e, t) {
    const i = this.ids.indexOf(e + 1);
    return this.ids.splice(i, 1, e + 1), this.runners.splice(i, 1, t), this;
  }
  getByID(e) {
    return this.runners[this.ids.indexOf(e + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let e = null;
    for (let t = 0; t < this.runners.length; ++t) {
      const i = this.runners[t];
      if (e && i.done && e.done && (!i._timeline || !i._timeline._runnerIds.includes(i.id)) && (!e._timeline || !e._timeline._runnerIds.includes(e.id))) {
        this.remove(i.id);
        const r = i.mergeWith(e);
        this.edit(e.id, r), e = r, --t;
      } else e = i;
    }
    return this;
  }
  remove(e) {
    const t = this.ids.indexOf(e + 1);
    return this.ids.splice(t, 1), this.runners.splice(t, 1), this;
  }
}
fe({ Element: { animate(s, e, t) {
  const i = tt.sanitise(s, e, t), r = this.timeline();
  return new tt(i.duration).loop(i).element(this).timeline(r.play()).schedule(i.delay, i.when);
}, delay(s, e) {
  return this.animate(0, s, e);
}, _clearTransformRunnersBefore(s) {
  this._transformationRunners.clearBefore(s.id);
}, _currentTransform(s) {
  return this._transformationRunners.runners.filter((e) => e.id <= s.id).map(wo).reduce(yo, new ae());
}, _addRunner(s) {
  this._transformationRunners.add(s), Ce.cancelImmediate(this._frameId), this._frameId = Ce.immediate(Vh.bind(this));
}, _prepareRunner() {
  this._frameId == null && (this._transformationRunners = new Gh().add(new er(new ae(this))));
} } });
oe(tt, { attr(s, e) {
  return this.styleAttr("attr", s, e);
}, css(s, e) {
  return this.styleAttr("css", s, e);
}, styleAttr(s, e, t) {
  if (typeof e == "string") return this.styleAttr(s, { [e]: t });
  let i = e;
  if (this._tryRetarget(s, i)) return this;
  let r = new _t(this._stepper).to(i), a = Object.keys(i);
  return this.queue(function() {
    r = r.from(this.element()[s](a));
  }, function(n) {
    return this.element()[s](r.at(n).valueOf()), r.done();
  }, function(n) {
    const o = Object.keys(n), l = (c = a, o.filter((d) => !c.includes(d)));
    var c;
    if (l.length) {
      const d = this.element()[s](l), u = new Ci(r.from()).valueOf();
      Object.assign(u, d), r.from(u);
    }
    const h = new Ci(r.to()).valueOf();
    Object.assign(h, n), r.to(h), a = o, i = n;
  }), this._rememberMorpher(s, r), this;
}, zoom(s, e) {
  if (this._tryRetarget("zoom", s, e)) return this;
  let t = new _t(this._stepper).to(new ue(s));
  return this.queue(function() {
    t = t.from(this.element().zoom());
  }, function(i) {
    return this.element().zoom(t.at(i), e), t.done();
  }, function(i, r) {
    e = r, t.to(i);
  }), this._rememberMorpher("zoom", t), this;
}, transform(s, e, t) {
  if (e = s.relative || e, this._isDeclarative && !e && this._tryRetarget("transform", s)) return this;
  const i = ae.isMatrixLike(s);
  t = s.affine != null ? s.affine : t ?? !i;
  const r = new _t(this._stepper).type(t ? Ti : ae);
  let a, n, o, l, c;
  return this.queue(function() {
    n = n || this.element(), a = a || us(s, n), c = new ae(e ? void 0 : n), n._addRunner(this), e || n._clearTransformRunnersBefore(this);
  }, function(h) {
    e || this.clearTransform();
    const { x: d, y: u } = new ye(a).transform(n._currentTransform(this));
    let g = new ae({ ...s, origin: [d, u] }), p = this._isDeclarative && o ? o : c;
    if (t) {
      g = g.decompose(d, u), p = p.decompose(d, u);
      const x = g.rotate, m = p.rotate, b = [x - 360, x, x + 360], w = b.map((k) => Math.abs(k - m)), y = Math.min(...w), v = w.indexOf(y);
      g.rotate = b[v];
    }
    e && (i || (g.rotate = s.rotate || 0), this._isDeclarative && l && (p.rotate = l)), r.from(p), r.to(g);
    const f = r.at(h);
    return l = f.rotate, o = new ae(f), this.addTransform(o), n._addRunner(this), r.done();
  }, function(h) {
    (h.origin || "center").toString() !== (s.origin || "center").toString() && (a = us(h, n)), s = { ...h, origin: a };
  }, !0), this._isDeclarative && this._rememberMorpher("transform", r), this;
}, x(s) {
  return this._queueNumber("x", s);
}, y(s) {
  return this._queueNumber("y", s);
}, ax(s) {
  return this._queueNumber("ax", s);
}, ay(s) {
  return this._queueNumber("ay", s);
}, dx(s = 0) {
  return this._queueNumberDelta("x", s);
}, dy(s = 0) {
  return this._queueNumberDelta("y", s);
}, dmove(s, e) {
  return this.dx(s).dy(e);
}, _queueNumberDelta(s, e) {
  if (e = new ue(e), this._tryRetarget(s, e)) return this;
  const t = new _t(this._stepper).to(e);
  let i = null;
  return this.queue(function() {
    i = this.element()[s](), t.from(i), t.to(i + e);
  }, function(r) {
    return this.element()[s](t.at(r)), t.done();
  }, function(r) {
    t.to(i + new ue(r));
  }), this._rememberMorpher(s, t), this;
}, _queueObject(s, e) {
  if (this._tryRetarget(s, e)) return this;
  const t = new _t(this._stepper).to(e);
  return this.queue(function() {
    t.from(this.element()[s]());
  }, function(i) {
    return this.element()[s](t.at(i)), t.done();
  }), this._rememberMorpher(s, t), this;
}, _queueNumber(s, e) {
  return this._queueObject(s, new ue(e));
}, cx(s) {
  return this._queueNumber("cx", s);
}, cy(s) {
  return this._queueNumber("cy", s);
}, move(s, e) {
  return this.x(s).y(e);
}, amove(s, e) {
  return this.ax(s).ay(e);
}, center(s, e) {
  return this.cx(s).cy(e);
}, size(s, e) {
  let t;
  return s && e || (t = this._element.bbox()), s || (s = t.width / t.height * e), e || (e = t.height / t.width * s), this.width(s).height(e);
}, width(s) {
  return this._queueNumber("width", s);
}, height(s) {
  return this._queueNumber("height", s);
}, plot(s, e, t, i) {
  if (arguments.length === 4) return this.plot([s, e, t, i]);
  if (this._tryRetarget("plot", s)) return this;
  const r = new _t(this._stepper).type(this._element.MorphArray).to(s);
  return this.queue(function() {
    r.from(this._element.array());
  }, function(a) {
    return this._element.plot(r.at(a)), r.done();
  }), this._rememberMorpher("plot", r), this;
}, leading(s) {
  return this._queueNumber("leading", s);
}, viewbox(s, e, t, i) {
  return this._queueObject("viewbox", new Oe(s, e, t, i));
}, update(s) {
  return typeof s != "object" ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (s.opacity != null && this.attr("stop-opacity", s.opacity), s.color != null && this.attr("stop-color", s.color), s.offset != null && this.attr("offset", s.offset), this);
} }), oe(tt, { rx: qs, ry: Zs, from: po, to: xo }), be(tt, "Runner");
class ys extends qe {
  constructor(e, t = e) {
    super(Re("svg", e), t), this.namespace();
  }
  defs() {
    return this.isRoot() ? ot(this.node.querySelector("defs")) || this.put(new ar()) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof me.window.SVGElement) && this.node.parentNode.nodeName !== "#document-fragment";
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: Ws, version: "1.1" }).attr("xmlns:xlink", ai, vr) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr("xmlns:xlink", null, vr).attr("xmlns:svgjs", null, vr);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
}
fe({ Container: { nested: Me(function() {
  return this.put(new ys());
}) } }), be(ys, "Svg", !0);
let ws = class extends qe {
  constructor(s, e = s) {
    super(Re("symbol", s), e);
  }
};
fe({ Container: { symbol: Me(function() {
  return this.put(new ws());
}) } }), be(ws, "Symbol");
var ko = Object.freeze({ __proto__: null, amove: function(s, e) {
  return this.ax(s).ay(e);
}, ax: function(s) {
  return this.attr("x", s);
}, ay: function(s) {
  return this.attr("y", s);
}, build: function(s) {
  return this._build = !!s, this;
}, center: function(s, e, t = this.bbox()) {
  return this.cx(s, t).cy(e, t);
}, cx: function(s, e = this.bbox()) {
  return s == null ? e.cx : this.attr("x", this.attr("x") + s - e.cx);
}, cy: function(s, e = this.bbox()) {
  return s == null ? e.cy : this.attr("y", this.attr("y") + s - e.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(s, e, t = this.bbox()) {
  return this.x(s, t).y(e, t);
}, plain: function(s) {
  return this._build === !1 && this.clear(), this.node.appendChild(me.document.createTextNode(s)), this;
}, x: function(s, e = this.bbox()) {
  return s == null ? e.x : this.attr("x", this.attr("x") + s - e.x);
}, y: function(s, e = this.bbox()) {
  return s == null ? e.y : this.attr("y", this.attr("y") + s - e.y);
} });
class ut extends st {
  constructor(e, t = e) {
    super(Re("text", e), t), this.dom.leading = this.dom.leading ?? new ue(1.3), this._rebuild = !0, this._build = !1;
  }
  leading(e) {
    return e == null ? this.dom.leading : (this.dom.leading = new ue(e), this.rebuild());
  }
  rebuild(e) {
    if (typeof e == "boolean" && (this._rebuild = e), this._rebuild) {
      const t = this;
      let i = 0;
      const r = this.dom.leading;
      this.each(function(a) {
        if (gs(this.node)) return;
        const n = me.window.getComputedStyle(this.node).getPropertyValue("font-size"), o = r * new ue(n);
        this.dom.newLined && (this.attr("x", t.attr("x")), this.text() === `
` ? i += o : (this.attr("dy", a ? o + i : 0), i = 0));
      }), this.fire("rebuild");
    }
    return this;
  }
  setData(e) {
    return this.dom = e, this.dom.leading = new ue(e.leading || 1.3), this;
  }
  writeDataToDom() {
    return Qn(this, this.dom, { leading: 1.3 }), this;
  }
  text(e) {
    if (e === void 0) {
      const t = this.node.childNodes;
      let i = 0;
      e = "";
      for (let r = 0, a = t.length; r < a; ++r) t[r].nodeName === "textPath" || gs(t[r]) ? r === 0 && (i = r + 1) : (r !== i && t[r].nodeType !== 3 && ot(t[r]).dom.newLined === !0 && (e += `
`), e += t[r].textContent);
      return e;
    }
    if (this.clear().build(!0), typeof e == "function") e.call(this, this);
    else for (let t = 0, i = (e = (e + "").split(`
`)).length; t < i; t++) this.newLine(e[t]);
    return this.build(!1).rebuild();
  }
}
oe(ut, ko), fe({ Container: { text: Me(function(s = "") {
  return this.put(new ut()).text(s);
}), plain: Me(function(s = "") {
  return this.put(new ut()).plain(s);
}) } }), be(ut, "Text");
class qi extends st {
  constructor(e, t = e) {
    super(Re("tspan", e), t), this._build = !1;
  }
  dx(e) {
    return this.attr("dx", e);
  }
  dy(e) {
    return this.attr("dy", e);
  }
  newLine() {
    this.dom.newLined = !0;
    const e = this.parent();
    if (!(e instanceof ut)) return this;
    const t = e.index(this), i = me.window.getComputedStyle(this.node).getPropertyValue("font-size"), r = e.dom.leading * new ue(i);
    return this.dy(t ? r : 0).attr("x", e.x());
  }
  text(e) {
    return e == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof e == "function" ? (this.clear().build(!0), e.call(this, this), this.build(!1)) : this.plain(e), this);
  }
}
oe(qi, ko), fe({ Tspan: { tspan: Me(function(s = "") {
  const e = new qi();
  return this._build || this.clear(), this.put(e).text(s);
}) }, Text: { newLine: function(s = "") {
  return this.tspan(s).newLine();
} } }), be(qi, "Tspan");
class Ar extends st {
  constructor(e, t = e) {
    super(Re("circle", e), t);
  }
  radius(e) {
    return this.attr("r", e);
  }
  rx(e) {
    return this.attr("r", e);
  }
  ry(e) {
    return this.rx(e);
  }
  size(e) {
    return this.radius(new ue(e).divide(2));
  }
}
oe(Ar, { x: oo, y: lo, cx: co, cy: ho, width: uo, height: go }), fe({ Container: { circle: Me(function(s = 0) {
  return this.put(new Ar()).size(s).move(0, 0);
}) } }), be(Ar, "Circle");
class Mr extends qe {
  constructor(e, t = e) {
    super(Re("clipPath", e), t);
  }
  remove() {
    return this.targets().forEach(function(e) {
      e.unclip();
    }), super.remove();
  }
  targets() {
    return Xt("svg [clip-path*=" + this.id() + "]");
  }
}
fe({ Container: { clip: Me(function() {
  return this.defs().put(new Mr());
}) }, Element: { clipper() {
  return this.reference("clip-path");
}, clipWith(s) {
  const e = s instanceof Mr ? s : this.parent().clip().add(s);
  return this.attr("clip-path", "url(#" + e.id() + ")");
}, unclip() {
  return this.attr("clip-path", null);
} } }), be(Mr, "ClipPath");
class $a extends Xe {
  constructor(e, t = e) {
    super(Re("foreignObject", e), t);
  }
}
fe({ Container: { foreignObject: Me(function(s, e) {
  return this.put(new $a()).size(s, e);
}) } }), be($a, "ForeignObject");
var So = Object.freeze({ __proto__: null, dmove: function(s, e) {
  return this.children().forEach((t) => {
    let i;
    try {
      i = t.node instanceof Ii().SVGSVGElement ? new Oe(t.attr(["x", "y", "width", "height"])) : t.bbox();
    } catch {
      return;
    }
    const r = new ae(t), a = r.translate(s, e).transform(r.inverse()), n = new ye(i.x, i.y).transform(a);
    t.move(n.x, n.y);
  }), this;
}, dx: function(s) {
  return this.dmove(s, 0);
}, dy: function(s) {
  return this.dmove(0, s);
}, height: function(s, e = this.bbox()) {
  return s == null ? e.height : this.size(e.width, s, e);
}, move: function(s = 0, e = 0, t = this.bbox()) {
  const i = s - t.x, r = e - t.y;
  return this.dmove(i, r);
}, size: function(s, e, t = this.bbox()) {
  const i = si(this, s, e, t), r = i.width / t.width, a = i.height / t.height;
  return this.children().forEach((n) => {
    const o = new ye(t).transform(new ae(n).inverse());
    n.scale(r, a, o.x, o.y);
  }), this;
}, width: function(s, e = this.bbox()) {
  return s == null ? e.width : this.size(s, e.height, e);
}, x: function(s, e = this.bbox()) {
  return s == null ? e.x : this.move(s, e.y, e);
}, y: function(s, e = this.bbox()) {
  return s == null ? e.y : this.move(e.x, s, e);
} });
class Mt extends qe {
  constructor(e, t = e) {
    super(Re("g", e), t);
  }
}
oe(Mt, So), fe({ Container: { group: Me(function() {
  return this.put(new Mt());
}) } }), be(Mt, "G");
class Ni extends qe {
  constructor(e, t = e) {
    super(Re("a", e), t);
  }
  target(e) {
    return this.attr("target", e);
  }
  to(e) {
    return this.attr("href", e, ai);
  }
}
oe(Ni, So), fe({ Container: { link: Me(function(s) {
  return this.put(new Ni()).to(s);
}) }, Element: { unlink() {
  const s = this.linker();
  if (!s) return this;
  const e = s.parent();
  if (!e) return this.remove();
  const t = e.index(s);
  return e.add(this, t), s.remove(), this;
}, linkTo(s) {
  let e = this.linker();
  return e || (e = new Ni(), this.wrap(e)), typeof s == "function" ? s.call(e, e) : e.to(s), this;
}, linker() {
  const s = this.parent();
  return s && s.node.nodeName.toLowerCase() === "a" ? s : null;
} } }), be(Ni, "A");
class Rr extends qe {
  constructor(e, t = e) {
    super(Re("mask", e), t);
  }
  remove() {
    return this.targets().forEach(function(e) {
      e.unmask();
    }), super.remove();
  }
  targets() {
    return Xt("svg [mask*=" + this.id() + "]");
  }
}
fe({ Container: { mask: Me(function() {
  return this.defs().put(new Rr());
}) }, Element: { masker() {
  return this.reference("mask");
}, maskWith(s) {
  const e = s instanceof Rr ? s : this.parent().mask().add(s);
  return this.attr("mask", "url(#" + e.id() + ")");
}, unmask() {
  return this.attr("mask", null);
} } }), be(Rr, "Mask");
class Ua extends Xe {
  constructor(e, t = e) {
    super(Re("stop", e), t);
  }
  update(e) {
    return (typeof e == "number" || e instanceof ue) && (e = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), e.opacity != null && this.attr("stop-opacity", e.opacity), e.color != null && this.attr("stop-color", e.color), e.offset != null && this.attr("offset", new ue(e.offset)), this;
  }
}
fe({ Gradient: { stop: function(s, e, t) {
  return this.put(new Ua()).update(s, e, t);
} } }), be(Ua, "Stop");
class Pr extends Xe {
  constructor(e, t = e) {
    super(Re("style", e), t);
  }
  addText(e = "") {
    return this.node.textContent += e, this;
  }
  font(e, t, i = {}) {
    return this.rule("@font-face", { fontFamily: e, src: t, ...i });
  }
  rule(e, t) {
    return this.addText(function(i, r) {
      if (!i) return "";
      if (!r) return i;
      let a = i + "{";
      for (const n in r) a += n.replace(/([A-Z])/g, function(o, l) {
        return "-" + l.toLowerCase();
      }) + ":" + r[n] + ";";
      return a += "}", a;
    }(e, t));
  }
}
fe("Dom", { style(s, e) {
  return this.put(new Pr()).rule(s, e);
}, fontface(s, e, t) {
  return this.put(new Pr()).font(s, e, t);
} }), be(Pr, "Style");
class Lr extends ut {
  constructor(e, t = e) {
    super(Re("textPath", e), t);
  }
  array() {
    const e = this.track();
    return e ? e.array() : null;
  }
  plot(e) {
    const t = this.track();
    let i = null;
    return t && (i = t.plot(e)), e == null ? i : this;
  }
  track() {
    return this.reference("href");
  }
}
fe({ Container: { textPath: Me(function(s, e) {
  return s instanceof ut || (s = this.text(s)), s.path(e);
}) }, Text: { path: Me(function(s, e = !0) {
  const t = new Lr();
  let i;
  if (s instanceof qt || (s = this.defs().path(s)), t.attr("href", "#" + s, ai), e) for (; i = this.node.firstChild; ) t.node.appendChild(i);
  return this.put(t);
}), textPath() {
  return this.findOne("textPath");
} }, Path: { text: Me(function(s) {
  return s instanceof ut || (s = new ut().addTo(this.parent()).text(s)), s.path(this);
}), targets() {
  return Xt("svg textPath").filter((s) => (s.attr("href") || "").includes(this.id()));
} } }), Lr.prototype.MorphArray = dt, be(Lr, "TextPath");
class qa extends st {
  constructor(e, t = e) {
    super(Re("use", e), t);
  }
  use(e, t) {
    return this.attr("href", (t || "") + "#" + e, ai);
  }
}
fe({ Container: { use: Me(function(s, e) {
  return this.put(new qa()).use(s, e);
}) } }), be(qa, "Use");
const $h = Ue;
oe([ys, ws, Gi, Si, $i], Je("viewbox")), oe([zt, Nt, Ft, qt], Je("marker")), oe(ut, Je("Text")), oe(qt, Je("Path")), oe(ar, Je("Defs")), oe([ut, qi], Je("Tspan")), oe([Ui, Vi, mi, tt], Je("radius")), oe(Ei, Je("EventTarget")), oe(Rt, Je("Dom")), oe(Xe, Je("Element")), oe(st, Je("Shape")), oe([qe, fo], Je("Container")), oe(mi, Je("Gradient")), oe(tt, Je("Runner")), jt.extend([...new Set(Kn)]), function(s = []) {
  vs.push(...[].concat(s));
}([ue, Ae, Oe, ae, Yt, Pt, dt, ye]), oe(vs, { to(s) {
  return new _t().type(this.constructor).from(this.toArray()).to(s);
}, fromArray(s) {
  return this.init(s), this;
}, toConsumable() {
  return this.toArray();
}, morph(s, e, t, i, r) {
  return this.fromArray(s.map(function(a, n) {
    return i.step(a, e[n], t, r[n], r);
  }));
} });
class Ie extends Xe {
  constructor(e) {
    super(Re("filter", e), e), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = !0;
  }
  put(e, t) {
    return !(e = super.put(e, t)).attr("in") && this.$autoSetIn && e.attr("in", this.$source), e.attr("result") || e.attr("result", e.id()), e;
  }
  remove() {
    return this.targets().each("unfilter"), super.remove();
  }
  targets() {
    return Xt('svg [filter*="' + this.id() + '"]');
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
}
class Qs extends Xe {
  constructor(e, t) {
    super(e, t), this.result(this.id());
  }
  in(e) {
    if (e == null) {
      const t = this.attr("in");
      return this.parent() && this.parent().find(`[result="${t}"]`)[0] || t;
    }
    return this.attr("in", e);
  }
  result(e) {
    return this.attr("result", e);
  }
  toString() {
    return this.result();
  }
}
const nt = (s) => function(...e) {
  for (let t = s.length; t--; ) e[t] != null && this.attr(s[t], e[t]);
}, Uh = { blend: nt(["in", "in2", "mode"]), colorMatrix: nt(["type", "values"]), composite: nt(["in", "in2", "operator"]), convolveMatrix: function(s) {
  s = new Yt(s).toString(), this.attr({ order: Math.sqrt(s.split(" ").length), kernelMatrix: s });
}, diffuseLighting: nt(["surfaceScale", "lightingColor", "diffuseConstant", "kernelUnitLength"]), displacementMap: nt(["in", "in2", "scale", "xChannelSelector", "yChannelSelector"]), dropShadow: nt(["in", "dx", "dy", "stdDeviation"]), flood: nt(["flood-color", "flood-opacity"]), gaussianBlur: function(s = 0, e = s) {
  this.attr("stdDeviation", s + " " + e);
}, image: function(s) {
  this.attr("href", s, ai);
}, morphology: nt(["operator", "radius"]), offset: nt(["dx", "dy"]), specularLighting: nt(["surfaceScale", "lightingColor", "diffuseConstant", "specularExponent", "kernelUnitLength"]), tile: nt([]), turbulence: nt(["baseFrequency", "numOctaves", "seed", "stitchTiles", "type"]) };
["blend", "colorMatrix", "componentTransfer", "composite", "convolveMatrix", "diffuseLighting", "displacementMap", "dropShadow", "flood", "gaussianBlur", "image", "merge", "morphology", "offset", "specularLighting", "tile", "turbulence"].forEach((s) => {
  const e = ri(s), t = Uh[s];
  Ie[e + "Effect"] = class extends Qs {
    constructor(i) {
      super(Re("fe" + e, i), i);
    }
    update(i) {
      return t.apply(this, i), this;
    }
  }, Ie.prototype[s] = Me(function(i, ...r) {
    const a = new Ie[e + "Effect"]();
    return i == null ? this.put(a) : (typeof i == "function" ? i.call(a, a) : r.unshift(i), this.put(a).update(r));
  });
}), oe(Ie, { merge(s) {
  const e = this.put(new Ie.MergeEffect());
  return typeof s == "function" ? (s.call(e, e), e) : ((s instanceof Array ? s : [...arguments]).forEach((t) => {
    t instanceof Ie.MergeNode ? e.put(t) : e.mergeNode(t);
  }), e);
}, componentTransfer(s = {}) {
  const e = this.put(new Ie.ComponentTransferEffect());
  if (typeof s == "function") return s.call(e, e), e;
  s.r || s.g || s.b || s.a || (s = { r: s, g: s, b: s, a: s });
  for (const t in s) e.add(new Ie["Func" + t.toUpperCase()](s[t]));
  return e;
} });
["distantLight", "pointLight", "spotLight", "mergeNode", "FuncR", "FuncG", "FuncB", "FuncA"].forEach((s) => {
  const e = ri(s);
  Ie[e] = class extends Qs {
    constructor(t) {
      super(Re("fe" + e, t), t);
    }
  };
});
["funcR", "funcG", "funcB", "funcA"].forEach(function(s) {
  const e = Ie[ri(s)], t = Me(function() {
    return this.put(new e());
  });
  Ie.ComponentTransferEffect.prototype[s] = t;
});
["distantLight", "pointLight", "spotLight"].forEach((s) => {
  const e = Ie[ri(s)], t = Me(function() {
    return this.put(new e());
  });
  Ie.DiffuseLightingEffect.prototype[s] = t, Ie.SpecularLightingEffect.prototype[s] = t;
}), oe(Ie.MergeEffect, { mergeNode(s) {
  return this.put(new Ie.MergeNode()).attr("in", s);
} }), oe(ar, { filter: function(s) {
  const e = this.put(new Ie());
  return typeof s == "function" && s.call(e, e), e;
} }), oe(qe, { filter: function(s) {
  return this.defs().filter(s);
} }), oe(Xe, { filterWith: function(s) {
  const e = s instanceof Ie ? s : this.defs().filter(s);
  return this.attr("filter", e);
}, unfilter: function(s) {
  return this.attr("filter", null);
}, filterer() {
  return this.reference("filter");
} });
const qh = { blend: function(s, e) {
  return this.parent() && this.parent().blend(this, s, e);
}, colorMatrix: function(s, e) {
  return this.parent() && this.parent().colorMatrix(s, e).in(this);
}, componentTransfer: function(s) {
  return this.parent() && this.parent().componentTransfer(s).in(this);
}, composite: function(s, e) {
  return this.parent() && this.parent().composite(this, s, e);
}, convolveMatrix: function(s) {
  return this.parent() && this.parent().convolveMatrix(s).in(this);
}, diffuseLighting: function(s, e, t, i) {
  return this.parent() && this.parent().diffuseLighting(s, t, i).in(this);
}, displacementMap: function(s, e, t, i) {
  return this.parent() && this.parent().displacementMap(this, s, e, t, i);
}, dropShadow: function(s, e, t) {
  return this.parent() && this.parent().dropShadow(this, s, e, t).in(this);
}, flood: function(s, e) {
  return this.parent() && this.parent().flood(s, e);
}, gaussianBlur: function(s, e) {
  return this.parent() && this.parent().gaussianBlur(s, e).in(this);
}, image: function(s) {
  return this.parent() && this.parent().image(s);
}, merge: function(s) {
  return s = s instanceof Array ? s : [...s], this.parent() && this.parent().merge(this, ...s);
}, morphology: function(s, e) {
  return this.parent() && this.parent().morphology(s, e).in(this);
}, offset: function(s, e) {
  return this.parent() && this.parent().offset(s, e).in(this);
}, specularLighting: function(s, e, t, i, r) {
  return this.parent() && this.parent().specularLighting(s, t, i, r).in(this);
}, tile: function() {
  return this.parent() && this.parent().tile().in(this);
}, turbulence: function(s, e, t, i, r) {
  return this.parent() && this.parent().turbulence(s, e, t, i, r).in(this);
} };
oe(Qs, qh), oe(Ie.MergeEffect, { in: function(s) {
  return s instanceof Ie.MergeNode ? this.add(s, 0) : this.add(new Ie.MergeNode().in(s), 0), this;
} }), oe([Ie.CompositeEffect, Ie.BlendEffect, Ie.DisplacementMapEffect], { in2: function(s) {
  if (s == null) {
    const e = this.attr("in2");
    return this.parent() && this.parent().find(`[result="${e}"]`)[0] || e;
  }
  return this.attr("in2", s);
} }), Ie.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var Ye = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "getDefaultFilter", value: function(e, t) {
    var i = this.w;
    e.unfilter(!0), new Ie().size("120%", "180%", "-5%", "-40%"), i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t);
  } }, { key: "applyFilter", value: function(e, t, i) {
    var r, a = this, n = this.w;
    if (e.unfilter(!0), i !== "none") {
      var o, l, c = n.config.chart.dropShadow, h = i === "lighten" ? 2 : 0.3;
      e.filterWith(function(d) {
        d.colorMatrix({ type: "matrix", values: `
          `.concat(h, ` 0 0 0 0
          0 `).concat(h, ` 0 0 0
          0 0 `).concat(h, ` 0 0
          0 0 0 1 0
        `), in: "SourceGraphic", result: "brightness" }), c.enabled && a.addShadow(d, t, c, "brightness");
      }), !c.noUserSpaceOnUse && ((o = e.filterer()) === null || o === void 0 || (l = o.node) === null || l === void 0 || l.setAttribute("filterUnits", "userSpaceOnUse")), this._scaleFilterSize((r = e.filterer()) === null || r === void 0 ? void 0 : r.node);
    } else this.getDefaultFilter(e, t);
  } }, { key: "addShadow", value: function(e, t, i, r) {
    var a, n = this.w, o = i.blur, l = i.top, c = i.left, h = i.color, d = i.opacity;
    if (h = Array.isArray(h) ? h[t] : h, ((a = n.config.chart.dropShadow.enabledOnSeries) === null || a === void 0 ? void 0 : a.length) > 0 && n.config.chart.dropShadow.enabledOnSeries.indexOf(t) === -1) return e;
    e.offset({ in: r, dx: c, dy: l, result: "offset" }), e.gaussianBlur({ in: "offset", stdDeviation: o, result: "blur" }), e.flood({ "flood-color": h, "flood-opacity": d, result: "flood" }), e.composite({ in: "flood", in2: "blur", operator: "in", result: "shadow" }), e.merge(["shadow", r]);
  } }, { key: "dropShadow", value: function(e, t) {
    var i, r, a, n, o, l = this, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, h = this.w;
    return e.unfilter(!0), F.isMsEdge() && h.config.chart.type === "radialBar" || ((i = h.config.chart.dropShadow.enabledOnSeries) === null || i === void 0 ? void 0 : i.length) > 0 && ((a = h.config.chart.dropShadow.enabledOnSeries) === null || a === void 0 ? void 0 : a.indexOf(c)) === -1 ? e : (e.filterWith(function(d) {
      l.addShadow(d, c, t, "SourceGraphic");
    }), t.noUserSpaceOnUse || (n = e.filterer()) === null || n === void 0 || (o = n.node) === null || o === void 0 || o.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize((r = e.filterer()) === null || r === void 0 ? void 0 : r.node), e);
  } }, { key: "setSelectionFilter", value: function(e, t, i) {
    var r = this.w;
    if (r.globals.selectedDataPoints[t] !== void 0 && r.globals.selectedDataPoints[t].indexOf(i) > -1) {
      e.node.setAttribute("selected", !0);
      var a = r.config.states.active.filter;
      a !== "none" && this.applyFilter(e, t, a.type);
    }
  } }, { key: "_scaleFilterSize", value: function(e) {
    e && function(t) {
      for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
    }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
  } }]), s;
}(), $ = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "roundPathCorners", value: function(e, t) {
    function i(C, M, R) {
      var P = M.x - C.x, I = M.y - C.y, D = Math.sqrt(P * P + I * I);
      return r(C, M, Math.min(1, R / D));
    }
    function r(C, M, R) {
      return { x: C.x + (M.x - C.x) * R, y: C.y + (M.y - C.y) * R };
    }
    function a(C, M) {
      C.length > 2 && (C[C.length - 2] = M.x, C[C.length - 1] = M.y);
    }
    function n(C) {
      return { x: parseFloat(C[C.length - 2]), y: parseFloat(C[C.length - 1]) };
    }
    e.indexOf("NaN") > -1 && (e = "");
    var o = e.split(/[,\s]/).reduce(function(C, M) {
      var R = M.match(/^([a-zA-Z])(.+)/);
      return R ? (C.push(R[1]), C.push(R[2])) : C.push(M), C;
    }, []).reduce(function(C, M) {
      return parseFloat(M) == M && C.length ? C[C.length - 1].push(M) : C.push([M]), C;
    }, []), l = [];
    if (o.length > 1) {
      var c = n(o[0]), h = null;
      o[o.length - 1][0] == "Z" && o[0].length > 2 && (h = ["L", c.x, c.y], o[o.length - 1] = h), l.push(o[0]);
      for (var d = 1; d < o.length; d++) {
        var u = l[l.length - 1], g = o[d], p = g == h ? o[1] : o[d + 1];
        if (p && u && u.length > 2 && g[0] == "L" && p.length > 2 && p[0] == "L") {
          var f, x, m = n(u), b = n(g), w = n(p);
          f = i(b, m, t), x = i(b, w, t), a(g, f), g.origPoint = b, l.push(g);
          var y = r(f, b, 0.5), v = r(b, x, 0.5), k = ["C", y.x, y.y, v.x, v.y, x.x, x.y];
          k.origPoint = b, l.push(k);
        } else l.push(g);
      }
      if (h) {
        var S = n(l[l.length - 1]);
        l.push(["Z"]), a(l[0], S);
      }
    } else l = o;
    return l.reduce(function(C, M) {
      return C + M.join(" ") + " ";
    }, "");
  } }, { key: "drawLine", value: function(e, t, i, r) {
    var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
    return this.w.globals.dom.Paper.line().attr({ x1: e, y1: t, x2: i, y2: r, stroke: a, "stroke-dasharray": n, "stroke-width": o, "stroke-linecap": l });
  } }, { key: "drawRect", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, c = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, h = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, d = this.w.globals.dom.Paper.rect();
    return d.attr({ x: e, y: t, width: i > 0 ? i : 0, height: r > 0 ? r : 0, rx: a, ry: a, opacity: o, "stroke-width": l !== null ? l : 0, stroke: c !== null ? c : "none", "stroke-dasharray": h }), d.node.setAttribute("fill", n), d;
  } }, { key: "drawPolygon", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
    return this.w.globals.dom.Paper.polygon(e).attr({ fill: r, stroke: t, "stroke-width": i });
  } }, { key: "drawCircle", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    e < 0 && (e = 0);
    var i = this.w.globals.dom.Paper.circle(2 * e);
    return t !== null && i.attr(t), i;
  } }, { key: "drawPath", value: function(e) {
    var t = e.d, i = t === void 0 ? "" : t, r = e.stroke, a = r === void 0 ? "#a8a8a8" : r, n = e.strokeWidth, o = n === void 0 ? 1 : n, l = e.fill, c = e.fillOpacity, h = c === void 0 ? 1 : c, d = e.strokeOpacity, u = d === void 0 ? 1 : d, g = e.classes, p = e.strokeLinecap, f = p === void 0 ? null : p, x = e.strokeDashArray, m = x === void 0 ? 0 : x, b = this.w;
    return f === null && (f = b.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(b.globals.gridHeight)), b.globals.dom.Paper.path(i).attr({ fill: l, "fill-opacity": h, stroke: a, "stroke-opacity": u, "stroke-linecap": f, "stroke-width": o, "stroke-dasharray": m, class: g });
  } }, { key: "group", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = this.w.globals.dom.Paper.group();
    return e !== null && t.attr(e), t;
  } }, { key: "move", value: function(e, t) {
    var i = ["M", e, t].join(" ");
    return i;
  } }, { key: "line", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = null;
    return i === null ? r = [" L", e, t].join(" ") : i === "H" ? r = [" H", e].join(" ") : i === "V" && (r = [" V", t].join(" ")), r;
  } }, { key: "curve", value: function(e, t, i, r, a, n) {
    var o = ["C", e, t, i, r, a, n].join(" ");
    return o;
  } }, { key: "quadraticCurve", value: function(e, t, i, r) {
    return ["Q", e, t, i, r].join(" ");
  } }, { key: "arc", value: function(e, t, i, r, a, n, o) {
    var l = "A";
    arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (l = "a");
    var c = [l, e, t, i, r, a, n, o].join(" ");
    return c;
  } }, { key: "renderPaths", value: function(e) {
    var t, i = e.j, r = e.realIndex, a = e.pathFrom, n = e.pathTo, o = e.stroke, l = e.strokeWidth, c = e.strokeLinecap, h = e.fill, d = e.animationDelay, u = e.initialSpeed, g = e.dataChangeSpeed, p = e.className, f = e.chartType, x = e.shouldClipToGrid, m = x === void 0 || x, b = e.bindEventsOnPaths, w = b === void 0 || b, y = e.drawShadow, v = y === void 0 || y, k = this.w, S = new Ye(this.ctx), C = new ii(this.ctx), M = this.w.config.chart.animations.enabled, R = M && this.w.config.chart.animations.dynamicAnimation.enabled;
    if (a && a.startsWith("M 0 0") && n) {
      var P = n.match(/^M\s+[\d.-]+\s+[\d.-]+/);
      P && (a = a.replace(/^M\s+0\s+0/, P[0]));
    }
    var I = !!(M && !k.globals.resized || R && k.globals.dataChanged && k.globals.shouldAnimate);
    I ? t = a : (t = n, k.globals.animationEnded = !0);
    var D = k.config.stroke.dashArray, N = 0;
    N = Array.isArray(D) ? D[r] : k.config.stroke.dashArray;
    var z = this.drawPath({ d: t, stroke: o, strokeWidth: l, fill: h, fillOpacity: 1, classes: p, strokeLinecap: c, strokeDashArray: N });
    z.attr("index", r), m && (f === "bar" && !k.globals.isHorizontal || k.globals.comboCharts ? z.attr({ "clip-path": "url(#gridRectBarMask".concat(k.globals.cuid, ")") }) : z.attr({ "clip-path": "url(#gridRectMask".concat(k.globals.cuid, ")") })), k.config.chart.dropShadow.enabled && v && S.dropShadow(z, k.config.chart.dropShadow, r), w && (z.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z)), z.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z)), z.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z))), z.attr({ pathTo: n, pathFrom: a });
    var L = { el: z, j: i, realIndex: r, pathFrom: a, pathTo: n, fill: h, strokeWidth: l, delay: d };
    return !M || k.globals.resized || k.globals.dataChanged ? !k.globals.resized && k.globals.dataChanged || C.showDelayedElements() : C.animatePathsGradually(J(J({}, L), {}, { speed: u })), k.globals.dataChanged && R && I && C.animatePathsGradually(J(J({}, L), {}, { speed: g })), z;
  } }, { key: "drawPattern", value: function(e, t, i) {
    var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(t, i, function(n) {
      e === "horizontalLines" ? n.line(0, 0, i, 0).stroke({ color: r, width: a + 1 }) : e === "verticalLines" ? n.line(0, 0, 0, t).stroke({ color: r, width: a + 1 }) : e === "slantedLines" ? n.line(0, 0, t, i).stroke({ color: r, width: a }) : e === "squares" ? n.rect(t, i).fill("none").stroke({ color: r, width: a }) : e === "circles" && n.circle(t).fill("none").stroke({ color: r, width: a });
    });
  } }, { key: "drawGradient", value: function(e, t, i, r, a) {
    var n, o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, c = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : [], h = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, d = this.w;
    t.length < 9 && t.indexOf("#") === 0 && (t = F.hexToRgba(t, r)), i.length < 9 && i.indexOf("#") === 0 && (i = F.hexToRgba(i, a));
    var u = 0, g = 1, p = 1, f = null;
    l !== null && (u = l[0] !== void 0 ? l[0] / 100 : 0, g = l[1] !== void 0 ? l[1] / 100 : 1, p = l[2] !== void 0 ? l[2] / 100 : 1, f = l[3] !== void 0 ? l[3] / 100 : null);
    var x = !(d.config.chart.type !== "donut" && d.config.chart.type !== "pie" && d.config.chart.type !== "polarArea" && d.config.chart.type !== "bubble");
    if (n = c && c.length !== 0 ? d.globals.dom.Paper.gradient(x ? "radial" : "linear", function(w) {
      (Array.isArray(c[h]) ? c[h] : c).forEach(function(y) {
        w.stop(y.offset / 100, y.color, y.opacity);
      });
    }) : d.globals.dom.Paper.gradient(x ? "radial" : "linear", function(w) {
      w.stop(u, t, r), w.stop(g, i, a), w.stop(p, i, a), f !== null && w.stop(f, t, r);
    }), x) {
      var m = d.globals.gridWidth / 2, b = d.globals.gridHeight / 2;
      d.config.chart.type !== "bubble" ? n.attr({ gradientUnits: "userSpaceOnUse", cx: m, cy: b, r: o }) : n.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else e === "vertical" ? n.from(0, 0).to(0, 1) : e === "diagonal" ? n.from(0, 0).to(1, 1) : e === "horizontal" ? n.from(0, 1).to(1, 1) : e === "diagonal2" && n.from(1, 0).to(0, 1);
    return n;
  } }, { key: "getTextBasedOnMaxWidth", value: function(e) {
    var t = e.text, i = e.maxWidth, r = e.fontSize, a = e.fontFamily, n = this.getTextRects(t, r, a), o = n.width / t.length, l = Math.floor(i / o);
    return i < n.width ? t.slice(0, l - 3) + "..." : t;
  } }, { key: "drawText", value: function(e) {
    var t = this, i = e.x, r = e.y, a = e.text, n = e.textAnchor, o = e.fontSize, l = e.fontFamily, c = e.fontWeight, h = e.foreColor, d = e.opacity, u = e.maxWidth, g = e.cssClass, p = g === void 0 ? "" : g, f = e.isPlainText, x = f === void 0 || f, m = e.dominantBaseline, b = m === void 0 ? "auto" : m, w = this.w;
    a === void 0 && (a = "");
    var y = a;
    n || (n = "start"), h && h.length || (h = w.config.chart.foreColor), l = l || w.config.chart.fontFamily, c = c || "regular";
    var v, k = { maxWidth: u, fontSize: o = o || "11px", fontFamily: l };
    return Array.isArray(a) ? v = w.globals.dom.Paper.text(function(S) {
      for (var C = 0; C < a.length; C++) y = a[C], u && (y = t.getTextBasedOnMaxWidth(J({ text: a[C] }, k))), C === 0 ? S.tspan(y) : S.tspan(y).newLine();
    }) : (u && (y = this.getTextBasedOnMaxWidth(J({ text: a }, k))), v = x ? w.globals.dom.Paper.plain(a) : w.globals.dom.Paper.text(function(S) {
      return S.tspan(y);
    })), v.attr({ x: i, y: r, "text-anchor": n, "dominant-baseline": b, "font-size": o, "font-family": l, "font-weight": c, fill: h, class: "apexcharts-text " + p }), v.node.style.fontFamily = l, v.node.style.opacity = d, v;
  } }, { key: "getMarkerPath", value: function(e, t, i, r) {
    var a = "";
    switch (i) {
      case "cross":
        a = "M ".concat(e - (r /= 1.4), " ").concat(t - r, " L ").concat(e + r, " ").concat(t + r, "  M ").concat(e - r, " ").concat(t + r, " L ").concat(e + r, " ").concat(t - r);
        break;
      case "plus":
        a = "M ".concat(e - (r /= 1.12), " ").concat(t, " L ").concat(e + r, " ").concat(t, "  M ").concat(e, " ").concat(t - r, " L ").concat(e, " ").concat(t + r);
        break;
      case "star":
      case "sparkle":
        var n = 5;
        r *= 1.15, i === "sparkle" && (r /= 1.1, n = 4);
        for (var o = Math.PI / n, l = 0; l <= 2 * n; l++) {
          var c = l * o, h = l % 2 == 0 ? r : r / 2;
          a += (l === 0 ? "M" : "L") + (e + h * Math.sin(c)) + "," + (t - h * Math.cos(c));
        }
        a += "Z";
        break;
      case "triangle":
        a = "M ".concat(e, " ").concat(t - r, ` 
             L `).concat(e + r, " ").concat(t + r, ` 
             L `).concat(e - r, " ").concat(t + r, ` 
             Z`);
        break;
      case "square":
      case "rect":
        a = "M ".concat(e - (r /= 1.125), " ").concat(t - r, ` 
           L `).concat(e + r, " ").concat(t - r, ` 
           L `).concat(e + r, " ").concat(t + r, ` 
           L `).concat(e - r, " ").concat(t + r, ` 
           Z`);
        break;
      case "diamond":
        r *= 1.05, a = "M ".concat(e, " ").concat(t - r, ` 
             L `).concat(e + r, " ").concat(t, ` 
             L `).concat(e, " ").concat(t + r, ` 
             L `).concat(e - r, " ").concat(t, ` 
            Z`);
        break;
      case "line":
        a = "M ".concat(e - (r /= 1.1), " ").concat(t, ` 
           L `).concat(e + r, " ").concat(t);
        break;
      default:
        r *= 2, a = "M ".concat(e, ", ").concat(t, ` 
           m -`).concat(r / 2, `, 0 
           a `).concat(r / 2, ",").concat(r / 2, " 0 1,0 ").concat(r, `,0 
           a `).concat(r / 2, ",").concat(r / 2, " 0 1,0 -").concat(r, ",0");
    }
    return a;
  } }, { key: "drawMarkerShape", value: function(e, t, i, r, a) {
    var n = this.drawPath({ d: this.getMarkerPath(e, t, i, r, a), stroke: a.pointStrokeColor, strokeDashArray: a.pointStrokeDashArray, strokeWidth: a.pointStrokeWidth, fill: a.pointFillColor, fillOpacity: a.pointFillOpacity, strokeOpacity: a.pointStrokeOpacity });
    return n.attr({ cx: e, cy: t, shape: a.shape, class: a.class ? a.class : "" }), n;
  } }, { key: "drawMarker", value: function(e, t, i) {
    e = e || 0;
    var r = i.pSize || 0;
    return F.isNumber(t) || (r = 0, t = 0), this.drawMarkerShape(e, t, i == null ? void 0 : i.shape, r, J(J({}, i), i.shape === "line" || i.shape === "plus" || i.shape === "cross" ? { pointStrokeColor: i.pointFillColor, pointStrokeOpacity: i.pointFillOpacity } : {}));
  } }, { key: "pathMouseEnter", value: function(e, t) {
    var i = this.w, r = new Ye(this.ctx), a = parseInt(e.node.getAttribute("index"), 10), n = parseInt(e.node.getAttribute("j"), 10);
    if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }]), (i.config.states.active.filter.type === "none" || e.node.getAttribute("selected") !== "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
      var o = i.config.states.hover.filter;
      r.applyFilter(e, a, o.type);
    }
  } }, { key: "pathMouseLeave", value: function(e, t) {
    var i = this.w, r = new Ye(this.ctx), a = parseInt(e.node.getAttribute("index"), 10), n = parseInt(e.node.getAttribute("j"), 10);
    typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, { seriesIndex: a, dataPointIndex: n, w: i }]), i.config.states.active.filter.type !== "none" && e.node.getAttribute("selected") === "true" || i.config.states.hover.filter.type !== "none" && r.getDefaultFilter(e, a);
  } }, { key: "pathMouseDown", value: function(e, t) {
    var i = this.w, r = new Ye(this.ctx), a = parseInt(e.node.getAttribute("index"), 10), n = parseInt(e.node.getAttribute("j"), 10), o = "false";
    if (e.node.getAttribute("selected") === "true") {
      if (e.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[a].indexOf(n) > -1) {
        var l = i.globals.selectedDataPoints[a].indexOf(n);
        i.globals.selectedDataPoints[a].splice(l, 1);
      }
    } else {
      if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
        i.globals.selectedDataPoints = [];
        var c = i.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h = i.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), d = function(p) {
          Array.prototype.forEach.call(p, function(f) {
            f.node.setAttribute("selected", "false"), r.getDefaultFilter(f, a);
          });
        };
        d(c), d(h);
      }
      e.node.setAttribute("selected", "true"), o = "true", i.globals.selectedDataPoints[a] === void 0 && (i.globals.selectedDataPoints[a] = []), i.globals.selectedDataPoints[a].push(n);
    }
    if (o === "true") {
      var u = i.config.states.active.filter;
      if (u !== "none") r.applyFilter(e, a, u.type);
      else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
        var g = i.config.states.hover.filter;
        r.applyFilter(e, a, g.type);
      }
    } else i.config.states.active.filter.type !== "none" && (i.config.states.hover.filter.type === "none" || i.globals.isTouchDevice ? r.getDefaultFilter(e, a) : (g = i.config.states.hover.filter, r.applyFilter(e, a, g.type)));
    typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(t, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: n, w: i }), t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: a, dataPointIndex: n, w: i }]);
  } }, { key: "rotateAroundCenter", value: function(e) {
    var t = {};
    return e && typeof e.getBBox == "function" && (t = e.getBBox()), { x: t.x + t.width / 2, y: t.y + t.height / 2 };
  } }, { key: "getTextRects", value: function(e, t, i, r) {
    var a = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], n = this.w, o = this.drawText({ x: -200, y: -200, text: e, textAnchor: "start", fontSize: t, fontFamily: i, foreColor: "#fff", opacity: 0 });
    r && o.attr("transform", r), n.globals.dom.Paper.add(o);
    var l = o.bbox();
    return a || (l = o.node.getBoundingClientRect()), o.remove(), { width: l.width, height: l.height };
  } }, { key: "placeTextWithEllipsis", value: function(e, t, i) {
    if (typeof e.getComputedTextLength == "function" && (e.textContent = t, t.length > 0 && e.getComputedTextLength() >= i / 1.1)) {
      for (var r = t.length - 3; r > 0; r -= 3) if (e.getSubStringLength(0, r) <= i / 1.1) return void (e.textContent = t.substring(0, r) + "...");
      e.textContent = ".";
    }
  } }], [{ key: "setAttrs", value: function(e, t) {
    for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
  } }]), s;
}(), ze = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "getStackedSeriesTotals", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = this.w, i = [];
    if (t.globals.series.length === 0) return i;
    for (var r = 0; r < t.globals.series[t.globals.maxValsInArrayIndex].length; r++) {
      for (var a = 0, n = 0; n < t.globals.series.length; n++) t.globals.series[n][r] !== void 0 && e.indexOf(n) === -1 && (a += t.globals.series[n][r]);
      i.push(a);
    }
    return i;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return e === null ? this.w.config.series.reduce(function(t, i) {
      return t + i;
    }, 0) : this.w.globals.series[e].reduce(function(t, i) {
      return t + i;
    }, 0);
  } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
    var e = this, t = this.w, i = [];
    return t.globals.seriesGroups.forEach(function(r) {
      var a = [];
      t.config.series.forEach(function(o, l) {
        r.indexOf(t.globals.seriesNames[l]) > -1 && a.push(l);
      });
      var n = t.globals.series.map(function(o, l) {
        return a.indexOf(l) === -1 ? l : -1;
      }).filter(function(o) {
        return o !== -1;
      });
      i.push(e.getStackedSeriesTotals(n));
    }), i;
  } }, { key: "setSeriesYAxisMappings", value: function() {
    var e = this.w.globals, t = this.w.config, i = [], r = [], a = [], n = e.series.length > t.yaxis.length || t.yaxis.some(function(d) {
      return Array.isArray(d.seriesName);
    });
    t.series.forEach(function(d, u) {
      a.push(u), r.push(null);
    }), t.yaxis.forEach(function(d, u) {
      i[u] = [];
    });
    var o = [];
    t.yaxis.forEach(function(d, u) {
      var g = !1;
      if (d.seriesName) {
        var p = [];
        Array.isArray(d.seriesName) ? p = d.seriesName : p.push(d.seriesName), p.forEach(function(f) {
          t.series.forEach(function(x, m) {
            if (x.name === f) {
              var b = m;
              u === m || n ? !n || a.indexOf(m) > -1 ? i[u].push([u, m]) : console.warn("Series '" + x.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i[m].push([m, u]), b = u), g = !0, (b = a.indexOf(b)) !== -1 && a.splice(b, 1);
            }
          });
        });
      }
      g || o.push(u);
    }), i = i.map(function(d, u) {
      var g = [];
      return d.forEach(function(p) {
        r[p[1]] = p[0], g.push(p[1]);
      }), g;
    });
    for (var l = t.yaxis.length - 1, c = 0; c < o.length && (l = o[c], i[l] = [], a); c++) {
      var h = a[0];
      a.shift(), i[l].push(h), r[h] = l;
    }
    a.forEach(function(d) {
      i[l].push(d), r[d] = l;
    }), e.seriesYAxisMap = i.map(function(d) {
      return d;
    }), e.seriesYAxisReverseMap = r.map(function(d) {
      return d;
    }), e.seriesYAxisMap.forEach(function(d, u) {
      d.forEach(function(g) {
        t.series[g] && t.series[g].group === void 0 && (t.series[g].group = "apexcharts-axis-".concat(u.toString()));
      });
    });
  } }, { key: "isSeriesNull", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return (e === null ? this.w.config.series.filter(function(t) {
      return t !== null;
    }) : this.w.config.series[e].data.filter(function(t) {
      return t !== null;
    })).length === 0;
  } }, { key: "seriesHaveSameValues", value: function(e) {
    return this.w.globals.series[e].every(function(t, i, r) {
      return t === r[0];
    });
  } }, { key: "getCategoryLabels", value: function(e) {
    var t = this.w, i = e.slice();
    return t.config.xaxis.convertedCatToNumeric && (i = e.map(function(r, a) {
      return t.config.xaxis.labels.formatter(r - t.globals.minX + 1);
    })), i;
  } }, { key: "getLargestSeries", value: function() {
    var e = this.w;
    e.globals.maxValsInArrayIndex = e.globals.series.map(function(t) {
      return t.length;
    }).indexOf(Math.max.apply(Math, e.globals.series.map(function(t) {
      return t.length;
    })));
  } }, { key: "getLargestMarkerSize", value: function() {
    var e = this.w, t = 0;
    return e.globals.markers.size.forEach(function(i) {
      t = Math.max(t, i);
    }), e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach(function(i) {
      t = Math.max(t, i.size);
    }), t > 0 && (e.config.markers.hover.size > 0 ? t = e.config.markers.hover.size : t += e.config.markers.hover.sizeOffset), e.globals.markers.largestSize = t, t;
  } }, { key: "getSeriesTotals", value: function() {
    var e = this.w;
    e.globals.seriesTotals = e.globals.series.map(function(t, i) {
      var r = 0;
      if (Array.isArray(t)) for (var a = 0; a < t.length; a++) r += t[a];
      else r += t;
      return r;
    });
  } }, { key: "getSeriesTotalsXRange", value: function(e, t) {
    var i = this.w;
    return i.globals.series.map(function(r, a) {
      for (var n = 0, o = 0; o < r.length; o++) i.globals.seriesX[a][o] > e && i.globals.seriesX[a][o] < t && (n += r[o]);
      return n;
    });
  } }, { key: "getPercentSeries", value: function() {
    var e = this.w;
    e.globals.seriesPercent = e.globals.series.map(function(t, i) {
      var r = [];
      if (Array.isArray(t)) for (var a = 0; a < t.length; a++) {
        var n = e.globals.stackedSeriesTotals[a], o = 0;
        n && (o = 100 * t[a] / n), r.push(o);
      }
      else {
        var l = 100 * t / e.globals.seriesTotals.reduce(function(c, h) {
          return c + h;
        }, 0);
        r.push(l);
      }
      return r;
    });
  } }, { key: "getCalculatedRatios", value: function() {
    var e, t, i, r = this, a = this.w, n = a.globals, o = [], l = 0, c = [], h = 0.1, d = 0;
    if (n.yRange = [], n.isMultipleYAxis) for (var u = 0; u < n.minYArr.length; u++) n.yRange.push(Math.abs(n.minYArr[u] - n.maxYArr[u])), c.push(0);
    else n.yRange.push(Math.abs(n.minY - n.maxY));
    n.xRange = Math.abs(n.maxX - n.minX), n.zRange = Math.abs(n.maxZ - n.minZ);
    for (var g = 0; g < n.yRange.length; g++) o.push(n.yRange[g] / n.gridHeight);
    if (t = n.xRange / n.gridWidth, e = n.yRange / n.gridWidth, i = n.xRange / n.gridHeight, (l = n.zRange / n.gridHeight * 16) || (l = 1), n.minY !== Number.MIN_VALUE && Math.abs(n.minY) !== 0 && (n.hasNegs = !0), a.globals.seriesYAxisReverseMap.length > 0) {
      var p = function(x, m) {
        var b = a.config.yaxis[a.globals.seriesYAxisReverseMap[m]], w = x < 0 ? -1 : 1;
        return x = Math.abs(x), b.logarithmic && (x = r.getBaseLog(b.logBase, x)), -w * x / o[m];
      };
      if (n.isMultipleYAxis) {
        c = [];
        for (var f = 0; f < o.length; f++) c.push(p(n.minYArr[f], f));
      } else (c = []).push(p(n.minY, 0)), n.minY !== Number.MIN_VALUE && Math.abs(n.minY) !== 0 && (h = -n.minY / e, d = n.minX / t);
    } else (c = []).push(0), h = 0, d = 0;
    return { yRatio: o, invertedYRatio: e, zRatio: l, xRatio: t, invertedXRatio: i, baseLineInvertedY: h, baseLineY: c, baseLineX: d };
  } }, { key: "getLogSeries", value: function(e) {
    var t = this, i = this.w;
    return i.globals.seriesLog = e.map(function(r, a) {
      var n = i.globals.seriesYAxisReverseMap[a];
      return i.config.yaxis[n] && i.config.yaxis[n].logarithmic ? r.map(function(o) {
        return o === null ? null : t.getLogVal(i.config.yaxis[n].logBase, o, a);
      }) : r;
    }), i.globals.invalidLogScale ? e : i.globals.seriesLog;
  } }, { key: "getLogValAtSeriesIndex", value: function(e, t) {
    if (e === null) return null;
    var i = this.w, r = i.globals.seriesYAxisReverseMap[t];
    return i.config.yaxis[r] && i.config.yaxis[r].logarithmic ? this.getLogVal(i.config.yaxis[r].logBase, e, t) : e;
  } }, { key: "getBaseLog", value: function(e, t) {
    return Math.log(t) / Math.log(e);
  } }, { key: "getLogVal", value: function(e, t, i) {
    if (t <= 0) return 0;
    var r = this.w, a = r.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(e, r.globals.minYArr[i]), n = (r.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(e, r.globals.maxYArr[i])) - a;
    return t < 1 ? t / n : (this.getBaseLog(e, t) - a) / n;
  } }, { key: "getLogYRatios", value: function(e) {
    var t = this, i = this.w, r = this.w.globals;
    return r.yLogRatio = e.slice(), r.logYRange = r.yRange.map(function(a, n) {
      var o = i.globals.seriesYAxisReverseMap[n];
      if (i.config.yaxis[o] && t.w.config.yaxis[o].logarithmic) {
        var l, c = -Number.MAX_VALUE, h = Number.MIN_VALUE;
        return r.seriesLog.forEach(function(d, u) {
          d.forEach(function(g) {
            i.config.yaxis[u] && i.config.yaxis[u].logarithmic && (c = Math.max(g, c), h = Math.min(g, h));
          });
        }), l = Math.pow(r.yRange[n], Math.abs(h - c) / r.yRange[n]), r.yLogRatio[n] = l / r.gridHeight, l;
      }
    }), r.invalidLogScale ? e.slice() : r.yLogRatio;
  } }, { key: "drawSeriesByGroup", value: function(e, t, i, r) {
    var a = this.w, n = [];
    return e.series.length > 0 && t.forEach(function(o) {
      var l = [], c = [];
      e.i.forEach(function(h, d) {
        a.config.series[h].group === o && (l.push(e.series[d]), c.push(h));
      }), l.length > 0 && n.push(r.draw(l, i, c));
    }), n;
  } }], [{ key: "checkComboSeries", value: function(e, t) {
    var i = !1, r = 0, a = 0;
    return t === void 0 && (t = "line"), e.length && e[0].type !== void 0 && e.forEach(function(n) {
      n.type !== "bar" && n.type !== "column" && n.type !== "candlestick" && n.type !== "boxPlot" || r++, n.type !== void 0 && n.type !== t && a++;
    }), a > 0 && (i = !0), { comboBarCount: r, comboCharts: i };
  } }, { key: "extendArrayProps", value: function(e, t, i) {
    var r, a, n, o, l, c;
    return (r = t) !== null && r !== void 0 && r.yaxis && (t = e.extendYAxis(t, i)), (a = t) !== null && a !== void 0 && a.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)), (n = t) !== null && n !== void 0 && (o = n.annotations) !== null && o !== void 0 && o.xaxis && (t = e.extendXAxisAnnotations(t)), (l = t) !== null && l !== void 0 && (c = l.annotations) !== null && c !== void 0 && c.points && (t = e.extendPointAnnotations(t))), t;
  } }]), s;
}(), nr = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.annoCtx = e;
  }
  return ie(s, [{ key: "setOrientations", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.w;
    if (e.label.orientation === "vertical") {
      var r = t !== null ? t : 0, a = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(r, "']"));
      if (a !== null) {
        var n = a.getBoundingClientRect();
        a.setAttribute("x", parseFloat(a.getAttribute("x")) - n.height + 4);
        var o = e.label.position === "top" ? n.width : -n.width;
        a.setAttribute("y", parseFloat(a.getAttribute("y")) + o);
        var l = this.annoCtx.graphics.rotateAroundCenter(a), c = l.x, h = l.y;
        a.setAttribute("transform", "rotate(-90 ".concat(c, " ").concat(h, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(e, t) {
    var i = this.w;
    if (!e || !t.label.text || !String(t.label.text).trim()) return null;
    var r = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), a = e.getBoundingClientRect(), n = t.label.style.padding, o = n.left, l = n.right, c = n.top, h = n.bottom;
    if (t.label.orientation === "vertical") {
      var d = [o, l, c, h];
      c = d[0], h = d[1], o = d[2], l = d[3];
    }
    var u = a.left - r.left - o, g = a.top - r.top - c, p = this.annoCtx.graphics.drawRect(u - i.globals.barPadForNumericAxis, g, a.width + o + l, a.height + c + h, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0);
    return t.id && p.node.classList.add(t.id), p;
  } }, { key: "annotationsBackground", value: function() {
    var e = this, t = this.w, i = function(r, a, n) {
      var o = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(n, "-annotations .apexcharts-").concat(n, "-annotation-label[rel='").concat(a, "']"));
      if (o) {
        var l = o.parentNode, c = e.addBackgroundToAnno(o, r);
        c && (l.insertBefore(c.node, o), r.label.mouseEnter && c.node.addEventListener("mouseenter", r.label.mouseEnter.bind(e, r)), r.label.mouseLeave && c.node.addEventListener("mouseleave", r.label.mouseLeave.bind(e, r)), r.label.click && c.node.addEventListener("click", r.label.click.bind(e, r)));
      }
    };
    t.config.annotations.xaxis.forEach(function(r, a) {
      return i(r, a, "xaxis");
    }), t.config.annotations.yaxis.forEach(function(r, a) {
      return i(r, a, "yaxis");
    }), t.config.annotations.points.forEach(function(r, a) {
      return i(r, a, "point");
    });
  } }, { key: "getY1Y2", value: function(e, t) {
    var i, r = this.w, a = e === "y1" ? t.y : t.y2, n = !1;
    if (this.annoCtx.invertAxis) {
      var o = r.config.xaxis.convertedCatToNumeric ? r.globals.categoryLabels : r.globals.labels, l = o.indexOf(a), c = r.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(l + 1, ")"));
      i = c ? parseFloat(c.getAttribute("y")) : (r.globals.gridHeight / o.length - 1) * (l + 1) - r.globals.barHeight, t.seriesIndex !== void 0 && r.globals.barHeight && (i -= r.globals.barHeight / 2 * (r.globals.series.length - 1) - r.globals.barHeight * t.seriesIndex);
    } else {
      var h, d = r.globals.seriesYAxisMap[t.yAxisIndex][0], u = r.config.yaxis[t.yAxisIndex].logarithmic ? new ze(this.annoCtx.ctx).getLogVal(r.config.yaxis[t.yAxisIndex].logBase, a, d) / r.globals.yLogRatio[d] : (a - r.globals.minYArr[d]) / (r.globals.yRange[d] / r.globals.gridHeight);
      i = r.globals.gridHeight - Math.min(Math.max(u, 0), r.globals.gridHeight), n = u > r.globals.gridHeight || u < 0, !t.marker || t.y !== void 0 && t.y !== null || (i = 0), (h = r.config.yaxis[t.yAxisIndex]) !== null && h !== void 0 && h.reversed && (i = u);
    }
    return typeof a == "string" && a.includes("px") && (i = parseFloat(a)), { yP: i, clipped: n };
  } }, { key: "getX1X2", value: function(e, t) {
    var i = this.w, r = e === "x1" ? t.x : t.x2, a = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, n = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, o = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, l = !1, c = this.annoCtx.inversedReversedAxis ? (n - r) / (o / i.globals.gridWidth) : (r - a) / (o / i.globals.gridWidth);
    return i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || i.config.chart.sparkline.enabled || (c = this.getStringX(r)), typeof r == "string" && r.includes("px") && (c = parseFloat(r)), r == null && t.marker && (c = i.globals.gridWidth), t.seriesIndex !== void 0 && i.globals.barWidth && !this.annoCtx.invertAxis && (c -= i.globals.barWidth / 2 * (i.globals.series.length - 1) - i.globals.barWidth * t.seriesIndex), typeof c != "number" && (c = 0, l = !0), parseFloat(c.toFixed(10)) > parseFloat(i.globals.gridWidth.toFixed(10)) ? (c = i.globals.gridWidth, l = !0) : c < 0 && (c = 0, l = !0), { x: c, clipped: l };
  } }, { key: "getStringX", value: function(e) {
    var t = this.w, i = e;
    t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
    var r = t.globals.labels.map(function(n) {
      return Array.isArray(n) ? n.join(" ") : n;
    }).indexOf(e), a = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(r + 1, ")"));
    return a && (i = parseFloat(a.getAttribute("x"))), i;
  } }]), s;
}(), Zh = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new nr(this.annoCtx);
  }
  return ie(s, [{ key: "addXaxisAnnotation", value: function(e, t, i) {
    var r, a = this.w, n = this.helpers.getX1X2("x1", e), o = n.x, l = n.clipped, c = !0, h = e.label.text, d = e.strokeDashArray;
    if (F.isNumber(o)) {
      if (e.x2 === null || e.x2 === void 0) {
        if (!l) {
          var u = this.annoCtx.graphics.drawLine(o + e.offsetX, 0 + e.offsetY, o + e.offsetX, a.globals.gridHeight + e.offsetY, e.borderColor, d, e.borderWidth);
          t.appendChild(u.node), e.id && u.node.classList.add(e.id);
        }
      } else {
        var g = this.helpers.getX1X2("x2", e);
        if (r = g.x, c = g.clipped, r < o) {
          var p = o;
          o = r, r = p;
        }
        var f = this.annoCtx.graphics.drawRect(o + e.offsetX, 0 + e.offsetY, r - o, a.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, d);
        f.node.classList.add("apexcharts-annotation-rect"), f.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), t.appendChild(f.node), e.id && f.node.classList.add(e.id);
      }
      if (!l || !c) {
        var x = this.annoCtx.graphics.getTextRects(h, parseFloat(e.label.style.fontSize)), m = e.label.position === "top" ? 4 : e.label.position === "center" ? a.globals.gridHeight / 2 + (e.label.orientation === "vertical" ? x.width / 2 : 0) : a.globals.gridHeight, b = this.annoCtx.graphics.drawText({ x: o + e.label.offsetX, y: m + e.label.offsetY - (e.label.orientation === "vertical" ? e.label.position === "top" ? x.width / 2 - 12 : -x.width / 2 : 0), text: h, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
        b.attr({ rel: i }), t.appendChild(b.node), this.annoCtx.helpers.setOrientations(e, i);
      }
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return t.config.annotations.xaxis.map(function(r, a) {
      e.addXaxisAnnotation(r, i.node, a);
    }), i;
  } }]), s;
}(), je = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return ie(s, [{ key: "isValidDate", value: function(e) {
    return typeof e != "number" && !isNaN(this.parseDate(e));
  } }, { key: "getTimeStamp", value: function(e) {
    return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e;
  } }, { key: "getDate", value: function(e) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e);
  } }, { key: "parseDate", value: function(e) {
    var t = Date.parse(e);
    if (!isNaN(t)) return this.getTimeStamp(e);
    var i = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i = this.getTimeStamp(i);
  } }, { key: "parseDateWithTimezone", value: function(e) {
    return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  } }, { key: "formatDate", value: function(e, t) {
    var i = this.w.globals.locale, r = this.w.config.xaxis.labels.datetimeUTC, a = ["\0"].concat(De(i.months)), n = [""].concat(De(i.shortMonths)), o = [""].concat(De(i.days)), l = [""].concat(De(i.shortDays));
    function c(C, M) {
      var R = C + "";
      for (M = M || 2; R.length < M; ) R = "0" + R;
      return R;
    }
    var h = r ? e.getUTCFullYear() : e.getFullYear();
    t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + h)).replace(/(^|[^\\])yy/g, "$1" + h.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h);
    var d = (r ? e.getUTCMonth() : e.getMonth()) + 1;
    t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + a[0])).replace(/(^|[^\\])MMM/g, "$1" + n[0])).replace(/(^|[^\\])MM/g, "$1" + c(d))).replace(/(^|[^\\])M/g, "$1" + d);
    var u = r ? e.getUTCDate() : e.getDate();
    t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + o[0])).replace(/(^|[^\\])ddd/g, "$1" + l[0])).replace(/(^|[^\\])dd/g, "$1" + c(u))).replace(/(^|[^\\])d/g, "$1" + u);
    var g = r ? e.getUTCHours() : e.getHours(), p = g > 12 ? g - 12 : g === 0 ? 12 : g;
    t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + c(g))).replace(/(^|[^\\])H/g, "$1" + g)).replace(/(^|[^\\])hh+/g, "$1" + c(p))).replace(/(^|[^\\])h/g, "$1" + p);
    var f = r ? e.getUTCMinutes() : e.getMinutes();
    t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + c(f))).replace(/(^|[^\\])m/g, "$1" + f);
    var x = r ? e.getUTCSeconds() : e.getSeconds();
    t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + c(x))).replace(/(^|[^\\])s/g, "$1" + x);
    var m = r ? e.getUTCMilliseconds() : e.getMilliseconds();
    t = t.replace(/(^|[^\\])fff+/g, "$1" + c(m, 3)), m = Math.round(m / 10), t = t.replace(/(^|[^\\])ff/g, "$1" + c(m)), m = Math.round(m / 10);
    var b = g < 12 ? "AM" : "PM";
    t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + m)).replace(/(^|[^\\])TT+/g, "$1" + b)).replace(/(^|[^\\])T/g, "$1" + b.charAt(0));
    var w = b.toLowerCase();
    t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + w)).replace(/(^|[^\\])t/g, "$1" + w.charAt(0));
    var y = -e.getTimezoneOffset(), v = r || !y ? "Z" : y > 0 ? "+" : "-";
    if (!r) {
      var k = (y = Math.abs(y)) % 60;
      v += c(Math.floor(y / 60)) + ":" + c(k);
    }
    t = t.replace(/(^|[^\\])K/g, "$1" + v);
    var S = (r ? e.getUTCDay() : e.getDay()) + 1;
    return t = (t = (t = (t = (t = t.replace(new RegExp(o[0], "g"), o[S])).replace(new RegExp(l[0], "g"), l[S])).replace(new RegExp(a[0], "g"), a[d])).replace(new RegExp(n[0], "g"), n[d])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(e, t, i) {
    var r = this.w;
    r.config.xaxis.min !== void 0 && (e = r.config.xaxis.min), r.config.xaxis.max !== void 0 && (t = r.config.xaxis.max);
    var a = this.getDate(e), n = this.getDate(t), o = this.formatDate(a, "yyyy MM dd HH mm ss fff").split(" "), l = this.formatDate(n, "yyyy MM dd HH mm ss fff").split(" ");
    return { minMillisecond: parseInt(o[6], 10), maxMillisecond: parseInt(l[6], 10), minSecond: parseInt(o[5], 10), maxSecond: parseInt(l[5], 10), minMinute: parseInt(o[4], 10), maxMinute: parseInt(l[4], 10), minHour: parseInt(o[3], 10), maxHour: parseInt(l[3], 10), minDate: parseInt(o[2], 10), maxDate: parseInt(l[2], 10), minMonth: parseInt(o[1], 10) - 1, maxMonth: parseInt(l[1], 10) - 1, minYear: parseInt(o[0], 10), maxYear: parseInt(l[0], 10) };
  } }, { key: "isLeapYear", value: function(e) {
    return e % 4 == 0 && e % 100 != 0 || e % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(e, t, i) {
    return this.determineDaysOfMonths(e, t) - i;
  } }, { key: "determineDaysOfYear", value: function(e) {
    var t = 365;
    return this.isLeapYear(e) && (t = 366), t;
  } }, { key: "determineRemainingDaysOfYear", value: function(e, t, i) {
    var r = this.daysCntOfYear[t] + i;
    return t > 1 && this.isLeapYear() && r++, r;
  } }, { key: "determineDaysOfMonths", value: function(e, t) {
    var i = 30;
    switch (e = F.monthMod(e), !0) {
      case this.months30.indexOf(e) > -1:
        e === 2 && (i = this.isLeapYear(t) ? 29 : 28);
        break;
      case this.months31.indexOf(e) > -1:
      default:
        i = 31;
    }
    return i;
  } }]), s;
}(), _i = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM";
  }
  return ie(s, [{ key: "xLabelFormat", value: function(e, t, i, r) {
    var a = this.w;
    if (a.config.xaxis.type === "datetime" && a.config.xaxis.labels.formatter === void 0 && a.config.tooltip.x.formatter === void 0) {
      var n = new je(this.ctx);
      return n.formatDate(n.getDate(t), a.config.tooltip.x.format);
    }
    return e(t, i, r);
  } }, { key: "defaultGeneralFormatter", value: function(e) {
    return Array.isArray(e) ? e.map(function(t) {
      return t;
    }) : e;
  } }, { key: "defaultYFormatter", value: function(e, t, i) {
    var r = this.w;
    if (F.isNumber(e)) if (r.globals.yValueDecimal !== 0) e = e.toFixed(t.decimalsInFloat !== void 0 ? t.decimalsInFloat : r.globals.yValueDecimal);
    else {
      var a = e.toFixed(0);
      e = e == a ? a : e.toFixed(1);
    }
    return e;
  } }, { key: "setLabelFormatters", value: function() {
    var e = this, t = this.w;
    return t.globals.xaxisTooltipFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.globals.ttKeyFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.globals.ttZFormatter = function(i) {
      return i;
    }, t.globals.legendFormatter = function(i) {
      return e.defaultGeneralFormatter(i);
    }, t.config.xaxis.labels.formatter !== void 0 ? t.globals.xLabelFormatter = t.config.xaxis.labels.formatter : t.globals.xLabelFormatter = function(i) {
      if (F.isNumber(i)) {
        if (!t.config.xaxis.convertedCatToNumeric && t.config.xaxis.type === "numeric") {
          if (F.isNumber(t.config.xaxis.decimalsInFloat)) return i.toFixed(t.config.xaxis.decimalsInFloat);
          var r = t.globals.maxX - t.globals.minX;
          return r > 0 && r < 100 ? i.toFixed(1) : i.toFixed(0);
        }
        return t.globals.isBarHorizontal && t.globals.maxY - t.globals.minYArr < 4 ? i.toFixed(1) : i.toFixed(0);
      }
      return i;
    }, typeof t.config.tooltip.x.formatter == "function" ? t.globals.ttKeyFormatter = t.config.tooltip.x.formatter : t.globals.ttKeyFormatter = t.globals.xLabelFormatter, typeof t.config.xaxis.tooltip.formatter == "function" && (t.globals.xaxisTooltipFormatter = t.config.xaxis.tooltip.formatter), (Array.isArray(t.config.tooltip.y) || t.config.tooltip.y.formatter !== void 0) && (t.globals.ttVal = t.config.tooltip.y), t.config.tooltip.z.formatter !== void 0 && (t.globals.ttZFormatter = t.config.tooltip.z.formatter), t.config.legend.formatter !== void 0 && (t.globals.legendFormatter = t.config.legend.formatter), t.config.yaxis.forEach(function(i, r) {
      i.labels.formatter !== void 0 ? t.globals.yLabelFormatters[r] = i.labels.formatter : t.globals.yLabelFormatters[r] = function(a) {
        return t.globals.xyCharts ? Array.isArray(a) ? a.map(function(n) {
          return e.defaultYFormatter(n, i, r);
        }) : e.defaultYFormatter(a, i, r) : a;
      };
    }), t.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var e = this.w;
    if (e.config.chart.type === "heatmap") {
      e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
      var t = e.globals.seriesNames.reduce(function(i, r) {
        return i.length > r.length ? i : r;
      }, 0);
      e.globals.yAxisScale[0].niceMax = t, e.globals.yAxisScale[0].niceMin = t;
    }
  } }]), s;
}(), Lt = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "getLabel", value: function(e, t, i, r) {
    var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", o = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], l = this.w, c = e[r] === void 0 ? "" : e[r], h = c, d = l.globals.xLabelFormatter, u = l.config.xaxis.labels.formatter, g = !1, p = new _i(this.ctx), f = c;
    o && (h = p.xLabelFormat(d, c, f, { i: r, dateFormatter: new je(this.ctx).formatDate, w: l }), u !== void 0 && (h = u(c, e[r], { i: r, dateFormatter: new je(this.ctx).formatDate, w: l })));
    var x, m;
    t.length > 0 ? (x = t[r].unit, m = null, t.forEach(function(v) {
      v.unit === "month" ? m = "year" : v.unit === "day" ? m = "month" : v.unit === "hour" ? m = "day" : v.unit === "minute" && (m = "hour");
    }), g = m === x, i = t[r].position, h = t[r].value) : l.config.xaxis.type === "datetime" && u === void 0 && (h = ""), h === void 0 && (h = ""), h = Array.isArray(h) ? h : h.toString();
    var b = new $(this.ctx), w = {};
    w = l.globals.rotateXLabels && o ? b.getTextRects(h, parseInt(n, 10), null, "rotate(".concat(l.config.xaxis.labels.rotate, " 0 0)"), !1) : b.getTextRects(h, parseInt(n, 10));
    var y = !l.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(h) && (String(h) === "NaN" || a.indexOf(h) >= 0 && y) && (h = ""), { x: i, text: h, textRect: w, isBold: g };
  } }, { key: "checkLabelBasedOnTickamount", value: function(e, t, i) {
    var r = this.w, a = r.config.xaxis.tickAmount;
    return a === "dataPoints" && (a = Math.round(r.globals.gridWidth / 120)), a > i || e % Math.round(i / (a + 1)) == 0 || (t.text = ""), t;
  } }, { key: "checkForOverflowingLabels", value: function(e, t, i, r, a) {
    var n = this.w;
    if (e === 0 && n.globals.skipFirstTimelinelabel && (t.text = ""), e === i - 1 && n.globals.skipLastTimelinelabel && (t.text = ""), n.config.xaxis.labels.hideOverlappingLabels && r.length > 0) {
      var o = a[a.length - 1];
      t.x < o.textRect.width / (n.globals.rotateXLabels ? Math.abs(n.config.xaxis.labels.rotate) / 12 : 1.01) + o.x && (t.text = "");
    }
    return t;
  } }, { key: "checkForReversedLabels", value: function(e, t) {
    var i = this.w;
    return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(), t;
  } }, { key: "yAxisAllSeriesCollapsed", value: function(e) {
    var t = this.w.globals;
    return !t.seriesYAxisMap[e].some(function(i) {
      return t.collapsedSeriesIndices.indexOf(i) === -1;
    });
  } }, { key: "translateYAxisIndex", value: function(e) {
    var t = this.w, i = t.globals, r = t.config.yaxis;
    return i.series.length > r.length || r.some(function(a) {
      return Array.isArray(a.seriesName);
    }) ? e : i.seriesYAxisReverseMap[e];
  } }, { key: "isYAxisHidden", value: function(e) {
    var t = this.w, i = t.config.yaxis[e];
    if (!i.show || this.yAxisAllSeriesCollapsed(e)) return !0;
    if (!i.showForNullSeries) {
      var r = t.globals.seriesYAxisMap[e], a = new ze(this.ctx);
      return r.every(function(n) {
        return a.isSeriesNull(n);
      });
    }
    return !1;
  } }, { key: "getYAxisForeColor", value: function(e, t) {
    var i = this.w;
    return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, i.globals.yAxisScale[t].result.length, !1), e;
  } }, { key: "drawYAxisTicks", value: function(e, t, i, r, a, n, o) {
    var l = this.w, c = new $(this.ctx), h = l.globals.translateY + l.config.yaxis[a].labels.offsetY;
    if (l.globals.isBarHorizontal ? h = 0 : l.config.chart.type === "heatmap" && (h += n / 2), r.show && t > 0) {
      l.config.yaxis[a].opposite === !0 && (e += r.width);
      for (var d = t; d >= 0; d--) {
        var u = c.drawLine(e + i.offsetX - r.width + r.offsetX, h + r.offsetY, e + i.offsetX + r.offsetX, h + r.offsetY, r.color);
        o.add(u), h += n;
      }
    }
  } }]), s;
}(), Kh = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.annoCtx = e, this.helpers = new nr(this.annoCtx), this.axesUtils = new Lt(this.annoCtx);
  }
  return ie(s, [{ key: "addYaxisAnnotation", value: function(e, t, i) {
    var r, a = this.w, n = e.strokeDashArray, o = this.helpers.getY1Y2("y1", e), l = o.yP, c = o.clipped, h = !0, d = !1, u = e.label.text;
    if (e.y2 === null || e.y2 === void 0) {
      if (!c) {
        d = !0;
        var g = this.annoCtx.graphics.drawLine(0 + e.offsetX, l + e.offsetY, this._getYAxisAnnotationWidth(e), l + e.offsetY, e.borderColor, n, e.borderWidth);
        t.appendChild(g.node), e.id && g.node.classList.add(e.id);
      }
    } else {
      if (r = (o = this.helpers.getY1Y2("y2", e)).yP, h = o.clipped, r > l) {
        var p = l;
        l = r, r = p;
      }
      if (!c || !h) {
        d = !0;
        var f = this.annoCtx.graphics.drawRect(0 + e.offsetX, r + e.offsetY, this._getYAxisAnnotationWidth(e), l - r, 0, e.fillColor, e.opacity, 1, e.borderColor, n);
        f.node.classList.add("apexcharts-annotation-rect"), f.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), t.appendChild(f.node), e.id && f.node.classList.add(e.id);
      }
    }
    if (d) {
      var x = e.label.position === "right" ? a.globals.gridWidth : e.label.position === "center" ? a.globals.gridWidth / 2 : 0, m = this.annoCtx.graphics.drawText({ x: x + e.label.offsetX, y: (r ?? l) + e.label.offsetY - 3, text: u, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
      m.attr({ rel: i }), t.appendChild(m.node);
    }
  } }, { key: "_getYAxisAnnotationWidth", value: function(e) {
    var t = this.w;
    return t.globals.gridWidth, (e.width.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX;
  } }, { key: "drawYAxisAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return t.config.annotations.yaxis.forEach(function(r, a) {
      r.yAxisIndex = e.axesUtils.translateYAxisIndex(r.yAxisIndex), e.axesUtils.isYAxisHidden(r.yAxisIndex) && e.axesUtils.yAxisAllSeriesCollapsed(r.yAxisIndex) || e.addYaxisAnnotation(r, i.node, a);
    }), i;
  } }]), s;
}(), Jh = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.annoCtx = e, this.helpers = new nr(this.annoCtx);
  }
  return ie(s, [{ key: "addPointAnnotation", value: function(e, t, i) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(e.seriesIndex) > -1)) {
      var r = this.helpers.getX1X2("x1", e), a = r.x, n = r.clipped, o = (r = this.helpers.getY1Y2("y1", e)).yP, l = r.clipped;
      if (F.isNumber(a) && !l && !n) {
        var c = { pSize: e.marker.size, pointStrokeWidth: e.marker.strokeWidth, pointFillColor: e.marker.fillColor, pointStrokeColor: e.marker.strokeColor, shape: e.marker.shape, pRadius: e.marker.radius, class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id ? e.id : "") }, h = this.annoCtx.graphics.drawMarker(a + e.marker.offsetX, o + e.marker.offsetY, c);
        t.appendChild(h.node);
        var d = e.label.text ? e.label.text : "", u = this.annoCtx.graphics.drawText({ x: a + e.label.offsetX, y: o + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6, text: d, textAnchor: e.label.textAnchor, fontSize: e.label.style.fontSize, fontFamily: e.label.style.fontFamily, fontWeight: e.label.style.fontWeight, foreColor: e.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "") });
        if (u.attr({ rel: i }), t.appendChild(u.node), e.customSVG.SVG) {
          var g = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass });
          g.attr({ transform: "translate(".concat(a + e.customSVG.offsetX, ", ").concat(o + e.customSVG.offsetY, ")") }), g.node.innerHTML = e.customSVG.SVG, t.appendChild(g.node);
        }
        if (e.image.path) {
          var p = e.image.width ? e.image.width : 20, f = e.image.height ? e.image.height : 20;
          h = this.annoCtx.addImage({ x: a + e.image.offsetX - p / 2, y: o + e.image.offsetY - f / 2, width: p, height: f, path: e.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        e.mouseEnter && h.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)), e.mouseLeave && h.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e)), e.click && h.node.addEventListener("click", e.click.bind(this, e));
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var e = this, t = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
    return t.config.annotations.points.map(function(r, a) {
      e.addPointAnnotation(r, i.node, a);
    }), i;
  } }]), s;
}(), Co = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, Ot = function() {
  function s() {
    te(this, s), this.yAxis = { show: !0, showAlways: !1, showForNullSeries: !0, seriesName: void 0, opposite: !1, reversed: !1, logarithmic: !1, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: !1, max: void 0, min: void 0, floating: !1, decimalsInFloat: void 0, labels: { show: !0, showDuplicates: !1, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: !1, offsetX: 0 }, crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return ie(s, [{ key: "init", value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: !0, speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 } }, background: "", locales: [Co], defaultLocale: "en", dropShadow: { enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.7 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: !0, redrawOnWindowResize: !0, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: !1, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: !1 }, brush: { enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0 }, stacked: !1, stackOnlyBar: !0, stackType: "normal", toolbar: { show: !0, offsetX: 0, offsetY: 0, tools: { download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: !0, type: "x", autoScaleYaxis: !1, allowMouseWheelZoom: !0, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: !1, colors: { threshold: 0, colorAboveThreshold: void 0, colorBelowThreshold: void 0 } }, area: { fillTo: "origin" }, bar: { horizontal: !1, columnWidth: "70%", barHeight: "70%", distributed: !1, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: !0, rangeBarGroupRows: !1, hideZeroBarsWhenGrouped: !1, isDumbbell: !1, dumbbellColors: void 0, isFunnel: !1, isFunnel3d: !0, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: !0, orientation: "horizontal", total: { enabled: !1, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: !0, shadeIntensity: 0.5, reverseNegativeShade: !1, distributed: !1, useFillColorAsStroke: !1, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: !0, shadeIntensity: 0.5, distributed: !1, reverseNegativeShade: !1, useFillColorAsStroke: !1, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 }, seriesTitle: { show: !0, offsetY: 1, offsetX: 1, borderColor: "#000", borderWidth: 1, borderRadius: 2, style: { background: "rgba(0, 0, 0, 0.6)", color: "#fff", fontSize: "12px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: !1, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: !0, position: "front", dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: !0, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: !0, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(e) {
      return e;
    } }, value: { show: !0, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(e) {
      return e + "%";
    } }, total: { show: !1, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(e) {
      return e.globals.seriesTotals.reduce(function(t, i) {
        return t + i;
      }, 0) / e.globals.series.length + "%";
    } } }, barLabels: { enabled: !1, offsetX: 0, offsetY: 0, useSeriesColors: !0, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(e) {
      return e;
    }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: !0, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: !1, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(e) {
      return e;
    } }, value: { show: !0, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(e) {
      return e;
    } }, total: { show: !1, showAlways: !1, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(e) {
      return e.globals.seriesTotals.reduce(function(t, i) {
        return t + i;
      }, 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: !0, enabledOnSeries: void 0, formatter: function(e) {
      return e !== null ? e : "";
    }, textAnchor: "middle", distributed: !1, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: !0, foreColor: "#fff", backgroundColor: void 0, borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: !0, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: !1 } }, yaxis: { lines: { show: !0 } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: !0, showForSingleSeries: !1, showForNullSeries: !0, showForZeroSeries: !0, floating: !1, position: "bottom", horizontalAlign: "center", inverseOrder: !1, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: !0, clusterGroupedSeriesOrientation: "vertical", labels: { colors: void 0, useSeriesColors: !1 }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: !0 }, onItemHover: { highlightDataSeries: !0 } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: !0, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { hover: { filter: { type: "lighten" } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken" } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: !0, enabledOnSeries: void 0, shared: !0, hideEmptySeries: !1, followCursor: !1, intersect: !1, inverseOrder: !1, custom: void 0, fillSeriesColor: !1, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: !1 }, x: { show: !0, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(e) {
      return e ? e + ": " : "";
    } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: !0, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: !1, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: !0, rotate: -45, rotateAlways: !1, hideOverlappingLabels: !0, trim: !1, minHeight: void 0, maxHeight: 120, showDuplicates: !0, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: !0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: !1, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: !0, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), s;
}(), Qh = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.graphics = new $(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new nr(this), this.xAxisAnnotations = new Zh(this), this.yAxisAnnotations = new Kh(this), this.pointsAnnotations = new Jh(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return ie(s, [{ key: "drawAxesAnnotations", value: function() {
    var e = this.w;
    if (e.globals.axisCharts && e.globals.dataPoints) {
      for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), r = this.pointsAnnotations.drawPointAnnotations(), a = e.config.chart.animations.enabled, n = [t, i, r], o = [i.node, t.node, r.node], l = 0; l < 3; l++) e.globals.dom.elGraphical.add(n[l]), !a || e.globals.resized || e.globals.dataChanged || e.config.chart.type !== "scatter" && e.config.chart.type !== "bubble" && e.globals.dataPoints > 1 && o[l].classList.add("apexcharts-element-hidden"), e.globals.delayedElements.push({ el: o[l], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: "drawImageAnnos", value: function() {
    var e = this;
    this.w.config.annotations.images.map(function(t, i) {
      e.addImage(t, i);
    });
  } }, { key: "drawTextAnnos", value: function() {
    var e = this;
    this.w.config.annotations.texts.map(function(t, i) {
      e.addText(t, i);
    });
  } }, { key: "addXaxisAnnotation", value: function(e, t, i) {
    this.xAxisAnnotations.addXaxisAnnotation(e, t, i);
  } }, { key: "addYaxisAnnotation", value: function(e, t, i) {
    this.yAxisAnnotations.addYaxisAnnotation(e, t, i);
  } }, { key: "addPointAnnotation", value: function(e, t, i) {
    this.pointsAnnotations.addPointAnnotation(e, t, i);
  } }, { key: "addText", value: function(e, t) {
    var i = e.x, r = e.y, a = e.text, n = e.textAnchor, o = e.foreColor, l = e.fontSize, c = e.fontFamily, h = e.fontWeight, d = e.cssClass, u = e.backgroundColor, g = e.borderWidth, p = e.strokeDashArray, f = e.borderRadius, x = e.borderColor, m = e.appendTo, b = m === void 0 ? ".apexcharts-svg" : m, w = e.paddingLeft, y = w === void 0 ? 4 : w, v = e.paddingRight, k = v === void 0 ? 4 : v, S = e.paddingBottom, C = S === void 0 ? 2 : S, M = e.paddingTop, R = M === void 0 ? 2 : M, P = this.w, I = this.graphics.drawText({ x: i, y: r, text: a, textAnchor: n || "start", fontSize: l || "12px", fontWeight: h || "regular", fontFamily: c || P.config.chart.fontFamily, foreColor: o || P.config.chart.foreColor, cssClass: d }), D = P.globals.dom.baseEl.querySelector(b);
    D && D.appendChild(I.node);
    var N = I.bbox();
    if (a) {
      var z = this.graphics.drawRect(N.x - y, N.y - R, N.width + y + k, N.height + C + R, f, u || "transparent", 1, g, x, p);
      D.insertBefore(z.node, I.node);
    }
  } }, { key: "addImage", value: function(e, t) {
    var i = this.w, r = e.path, a = e.x, n = a === void 0 ? 0 : a, o = e.y, l = o === void 0 ? 0 : o, c = e.width, h = c === void 0 ? 20 : c, d = e.height, u = d === void 0 ? 20 : d, g = e.appendTo, p = g === void 0 ? ".apexcharts-svg" : g, f = i.globals.dom.Paper.image(r);
    f.size(h, u).move(n, l);
    var x = i.globals.dom.baseEl.querySelector(p);
    return x && x.appendChild(f.node), f;
  } }, { key: "addXaxisAnnotationExternal", value: function(e, t, i) {
    return this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
  } }, { key: "addYaxisAnnotationExternal", value: function(e, t, i) {
    return this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
  } }, { key: "addPointAnnotationExternal", value: function(e, t, i) {
    return this.invertAxis === void 0 && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: e, pushToMemory: t, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
  } }, { key: "addAnnotationExternal", value: function(e) {
    var t = e.params, i = e.pushToMemory, r = e.context, a = e.type, n = e.contextMethod, o = r, l = o.w, c = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations")), h = c.childNodes.length + 1, d = new Ot(), u = Object.assign({}, a === "xaxis" ? d.xAxisAnnotation : a === "yaxis" ? d.yAxisAnnotation : d.pointAnnotation), g = F.extend(u, t);
    switch (a) {
      case "xaxis":
        this.addXaxisAnnotation(g, c, h);
        break;
      case "yaxis":
        this.addYaxisAnnotation(g, c, h);
        break;
      case "point":
        this.addPointAnnotation(g, c, h);
    }
    var p = l.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(h, "']")), f = this.helpers.addBackgroundToAnno(p, g);
    return f && c.insertBefore(f.node, p), i && l.globals.memory.methodsToExec.push({ context: o, id: g.id ? g.id : F.randomId(), method: n, label: "addAnnotation", params: t }), r;
  } }, { key: "clearAnnotations", value: function(e) {
    for (var t = e.w, i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), r = t.globals.memory.methodsToExec.length - 1; r >= 0; r--) t.globals.memory.methodsToExec[r].label !== "addText" && t.globals.memory.methodsToExec[r].label !== "addAnnotation" || t.globals.memory.methodsToExec.splice(r, 1);
    i = F.listToArray(i), Array.prototype.forEach.call(i, function(a) {
      for (; a.firstChild; ) a.removeChild(a.firstChild);
    });
  } }, { key: "removeAnnotation", value: function(e, t) {
    var i = e.w, r = i.globals.dom.baseEl.querySelectorAll(".".concat(t));
    r && (i.globals.memory.methodsToExec.map(function(a, n) {
      a.id === t && i.globals.memory.methodsToExec.splice(n, 1);
    }), Object.keys(i.config.annotations).forEach(function(a) {
      var n = i.config.annotations[a];
      Array.isArray(n) && (i.config.annotations[a] = n.filter(function(o) {
        return o.id !== t;
      }));
    }), Array.prototype.forEach.call(r, function(a) {
      a.parentElement.removeChild(a);
    }));
  } }]), s;
}(), Ir = function(s) {
  var e, t = s.isTimeline, i = s.ctx, r = s.seriesIndex, a = s.dataPointIndex, n = s.y1, o = s.y2, l = s.w, c = l.globals.seriesRangeStart[r][a], h = l.globals.seriesRangeEnd[r][a], d = l.globals.labels[a], u = l.config.series[r].name ? l.config.series[r].name : "", g = l.globals.ttKeyFormatter, p = l.config.tooltip.y.title.formatter, f = { w: l, seriesIndex: r, dataPointIndex: a, start: c, end: h };
  typeof p == "function" && (u = p(u, f)), (e = l.config.series[r].data[a]) !== null && e !== void 0 && e.x && (d = l.config.series[r].data[a].x), t || l.config.xaxis.type === "datetime" && (d = new _i(i).xLabelFormat(l.globals.ttKeyFormatter, d, d, { i: void 0, dateFormatter: new je(i).formatDate, w: l })), typeof g == "function" && (d = g(d, f)), Number.isFinite(n) && Number.isFinite(o) && (c = n, h = o);
  var x = "", m = "", b = l.globals.colors[r];
  if (l.config.tooltip.x.formatter === void 0) if (l.config.xaxis.type === "datetime") {
    var w = new je(i);
    x = w.formatDate(w.getDate(c), l.config.tooltip.x.format), m = w.formatDate(w.getDate(h), l.config.tooltip.x.format);
  } else x = c, m = h;
  else x = l.config.tooltip.x.formatter(c), m = l.config.tooltip.x.formatter(h);
  return { start: c, end: h, startVal: x, endVal: m, ylabel: d, color: b, seriesName: u };
}, Er = function(s) {
  var e = s.color, t = s.seriesName, i = s.ylabel, r = s.start, a = s.end, n = s.seriesIndex, o = s.dataPointIndex, l = s.ctx.tooltip.tooltipLabels.getFormatters(n);
  r = l.yLbFormatter(r), a = l.yLbFormatter(a);
  var c = l.yLbFormatter(s.w.globals.series[n][o]), h = `<span class="value start-value">
  `.concat(r, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(a, `
  </span>`);
  return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (t || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (s.w.globals.comboCharts ? s.w.config.series[n].type === "rangeArea" || s.w.config.series[n].type === "rangeBar" ? h : "<span>".concat(c, "</span>") : h) + " </div></div>";
}, Ai = function() {
  function s(e) {
    te(this, s), this.opts = e;
  }
  return ie(s, [{ key: "hideYAxis", value: function() {
    this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
  } }, { key: "line", value: function() {
    return { dataLabels: { enabled: !1 }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(e) {
    return this.hideYAxis(), F.extend(e, { grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: !1 }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } }, chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 } });
  } }, { key: "slope", value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !0, formatter: function(e, t) {
      var i = t.w.config.series[t.seriesIndex].name;
      return e !== null ? i + ": " + e : "";
    }, background: { enabled: !1 }, offsetX: -5 }, grid: { xaxis: { lines: { show: !0 } }, yaxis: { lines: { show: !1 } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: !1 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, stroke: { width: 5, curve: "straight" } };
  } }, { key: "bar", value: function() {
    return { chart: { stacked: !1 }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } }, stroke: { width: 0, lineCap: "square" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { tooltip: { enabled: !1 }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: !1 }, stroke: { width: 0 } } } };
  } }, { key: "funnel", value: function() {
    return this.hideYAxis(), J(J({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: !1 } } }, plotOptions: { bar: { horizontal: !0, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: !1, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } } });
  } }, { key: "candlestick", value: function() {
    var e = this;
    return { stroke: { width: 1 }, fill: { opacity: 1 }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(t) {
      var i = t.seriesIndex, r = t.dataPointIndex, a = t.w;
      return e._getBoxTooltip(a, i, r, ["Open", "High", "", "Low", "Close"], "candlestick");
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "boxPlot", value: function() {
    var e = this;
    return { chart: { animations: { dynamicAnimation: { enabled: !1 } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(t) {
      var i = t.seriesIndex, r = t.dataPointIndex, a = t.w;
      return e._getBoxTooltip(a, i, r, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { chart: { animations: { animateGradually: !1 } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: !1, formatter: function(e, t) {
      t.ctx;
      var i = t.seriesIndex, r = t.dataPointIndex, a = t.w, n = function() {
        var o = a.globals.seriesRangeStart[i][r];
        return a.globals.seriesRangeEnd[i][r] - o;
      };
      return a.globals.comboCharts ? a.config.series[i].type === "rangeBar" || a.config.series[i].type === "rangeArea" ? n() : e : n();
    }, background: { enabled: !1 }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: !1, followCursor: !0, custom: function(e) {
      return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? function(t) {
        var i = Ir(J(J({}, t), {}, { isTimeline: !0 })), r = i.color, a = i.seriesName, n = i.ylabel, o = i.startVal, l = i.endVal;
        return Er(J(J({}, t), {}, { color: r, seriesName: a, ylabel: n, start: o, end: l }));
      }(e) : function(t) {
        var i = Ir(t), r = i.color, a = i.seriesName, n = i.ylabel, o = i.start, l = i.end;
        return Er(J(J({}, t), {}, { color: r, seriesName: a, ylabel: n, start: o, end: l }));
      }(e);
    } }, xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "dumbbell", value: function(e) {
    var t, i;
    return (t = e.plotOptions.bar) !== null && t !== void 0 && t.barHeight || (e.plotOptions.bar.barHeight = 2), (i = e.plotOptions.bar) !== null && i !== void 0 && i.columnWidth || (e.plotOptions.bar.columnWidth = 2), e;
  } }, { key: "area", value: function() {
    return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: !1 } };
  } }, { key: "rangeArea", value: function() {
    return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: !1, shared: !0, followCursor: !0, custom: function(e) {
      return function(t) {
        var i = Ir(t), r = i.color, a = i.seriesName, n = i.ylabel, o = i.start, l = i.end;
        return Er(J(J({}, t), {}, { color: r, seriesName: a, ylabel: n, start: o, end: l }));
      }(e);
    } } };
  } }, { key: "brush", value: function(e) {
    return F.extend(e, { chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } } });
  } }, { key: "stacked100", value: function(e) {
    e.dataLabels = e.dataLabels || {}, e.dataLabels.formatter = e.dataLabels.formatter || void 0;
    var t = e.dataLabels.formatter;
    return e.yaxis.forEach(function(i, r) {
      e.yaxis[r].min = 0, e.yaxis[r].max = 100;
    }), e.chart.type === "bar" && (e.dataLabels.formatter = t || function(i) {
      return typeof i == "number" && i ? i.toFixed(0) + "%" : i;
    }), e;
  } }, { key: "stackedBars", value: function() {
    var e = this.bar();
    return J(J({}, e), {}, { plotOptions: J(J({}, e.plotOptions), {}, { bar: J(J({}, e.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
  } }, { key: "convertCatToNumeric", value: function(e) {
    return e.xaxis.convertedCatToNumeric = !0, e;
  } }, { key: "convertCatToNumericXaxis", value: function(e, t, i) {
    e.xaxis.type = "numeric", e.xaxis.labels = e.xaxis.labels || {}, e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(n) {
      return F.isNumber(n) ? Math.floor(n) : n;
    };
    var r = e.xaxis.labels.formatter, a = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
    return i && i.length && (a = i.map(function(n) {
      return Array.isArray(n) ? n : String(n);
    })), a && a.length && (e.xaxis.labels.formatter = function(n) {
      return F.isNumber(n) ? r(a[Math.floor(n) - 1]) : r(n);
    }), e.xaxis.categories = [], e.labels = [], e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints", e;
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
  } }, { key: "treemap", value: function() {
    return { chart: { zoom: { enabled: !1 } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: !0, width: 2, colors: ["#fff"] }, legend: { show: !1 }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: !0, x: { show: !1 } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: !1 } }, plotOptions: { pie: { donut: { labels: { show: !1 } } } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "polarArea", value: function() {
    return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(e) {
      return e.toFixed(1) + "%";
    }, enabled: !1 }, stroke: { show: !0, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: !1, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(e) {
      return e;
    }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: !1, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: !1, position: "right" }, tooltip: { enabled: !1, fillSeriesColor: !0 }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "_getBoxTooltip", value: function(e, t, i, r, a) {
    var n = e.globals.seriesCandleO[t][i], o = e.globals.seriesCandleH[t][i], l = e.globals.seriesCandleM[t][i], c = e.globals.seriesCandleL[t][i], h = e.globals.seriesCandleC[t][i];
    return e.config.series[t].type && e.config.series[t].type !== a ? `<div class="apexcharts-custom-tooltip">
          `.concat(e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][i], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(r[0], ': <span class="value">') + n + "</span></div>" + "<div>".concat(r[1], ': <span class="value">') + o + "</span></div>" + (l ? "<div>".concat(r[2], ': <span class="value">') + l + "</span></div>" : "") + "<div>".concat(r[3], ': <span class="value">') + c + "</span></div>" + "<div>".concat(r[4], ': <span class="value">') + h + "</span></div></div>";
  } }]), s;
}(), Mi = function() {
  function s(e) {
    te(this, s), this.opts = e;
  }
  return ie(s, [{ key: "init", value: function(e) {
    var t = e.responsiveOverride, i = this.opts, r = new Ot(), a = new Ai(i);
    this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
    var n = r.init(), o = {};
    if (i && Kt(i) === "object") {
      var l, c, h, d, u, g, p, f, x, m, b = {};
      b = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) !== -1 ? a[i.chart.type]() : a.line(), (l = i.plotOptions) !== null && l !== void 0 && (c = l.bar) !== null && c !== void 0 && c.isFunnel && (b = a.funnel()), i.chart.stacked && i.chart.type === "bar" && (b = a.stackedBars()), (h = i.chart.brush) !== null && h !== void 0 && h.enabled && (b = a.brush(b)), (d = i.plotOptions) !== null && d !== void 0 && (u = d.line) !== null && u !== void 0 && u.isSlopeChart && (b = a.slope()), i.chart.stacked && i.chart.stackType === "100%" && (i = a.stacked100(i)), (g = i.plotOptions) !== null && g !== void 0 && (p = g.bar) !== null && p !== void 0 && p.isDumbbell && (i = a.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, t || (i.xaxis.convertedCatToNumeric = !1), ((f = (i = this.checkForCatToNumericXAxis(this.chartType, b, i)).chart.sparkline) !== null && f !== void 0 && f.enabled || (x = window.Apex.chart) !== null && x !== void 0 && (m = x.sparkline) !== null && m !== void 0 && m.enabled) && (b = a.sparkline(b)), o = F.extend(n, b);
    }
    var w = F.extend(o, window.Apex);
    return n = F.extend(w, i), n = this.handleUserInputErrors(n);
  } }, { key: "checkForCatToNumericXAxis", value: function(e, t, i) {
    var r, a, n = new Ai(i), o = (e === "bar" || e === "boxPlot") && ((r = i.plotOptions) === null || r === void 0 || (a = r.bar) === null || a === void 0 ? void 0 : a.horizontal), l = e === "pie" || e === "polarArea" || e === "donut" || e === "radar" || e === "radialBar" || e === "heatmap", c = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric", h = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement;
    return o || l || !c || h === "between" || (i = n.convertCatToNumeric(i)), i;
  } }, { key: "extendYAxis", value: function(e, t) {
    var i = new Ot();
    (e.yaxis === void 0 || !e.yaxis || Array.isArray(e.yaxis) && e.yaxis.length === 0) && (e.yaxis = {}), e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = F.extend(e.yaxis, window.Apex.yaxis)), e.yaxis.constructor !== Array ? e.yaxis = [F.extend(i.yAxis, e.yaxis)] : e.yaxis = F.extendArray(e.yaxis, i.yAxis);
    var r = !1;
    e.yaxis.forEach(function(n) {
      n.logarithmic && (r = !0);
    });
    var a = e.series;
    return t && !a && (a = t.config.series), r && a.length !== e.yaxis.length && a.length && (e.yaxis = a.map(function(n, o) {
      if (n.name || (a[o].name = "series-".concat(o + 1)), e.yaxis[o]) return e.yaxis[o].seriesName = a[o].name, e.yaxis[o];
      var l = F.extend(i.yAxis, e.yaxis[0]);
      return l.show = !1, l;
    })), r && a.length > 1 && a.length !== e.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), e;
  } }, { key: "extendAnnotations", value: function(e) {
    return e.annotations === void 0 && (e.annotations = {}, e.annotations.yaxis = [], e.annotations.xaxis = [], e.annotations.points = []), e = this.extendYAxisAnnotations(e), e = this.extendXAxisAnnotations(e), e = this.extendPointAnnotations(e);
  } }, { key: "extendYAxisAnnotations", value: function(e) {
    var t = new Ot();
    return e.annotations.yaxis = F.extendArray(e.annotations.yaxis !== void 0 ? e.annotations.yaxis : [], t.yAxisAnnotation), e;
  } }, { key: "extendXAxisAnnotations", value: function(e) {
    var t = new Ot();
    return e.annotations.xaxis = F.extendArray(e.annotations.xaxis !== void 0 ? e.annotations.xaxis : [], t.xAxisAnnotation), e;
  } }, { key: "extendPointAnnotations", value: function(e) {
    var t = new Ot();
    return e.annotations.points = F.extendArray(e.annotations.points !== void 0 ? e.annotations.points : [], t.pointAnnotation), e;
  } }, { key: "checkForDarkTheme", value: function(e) {
    e.theme && e.theme.mode === "dark" && (e.tooltip || (e.tooltip = {}), e.tooltip.theme !== "light" && (e.tooltip.theme = "dark"), e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"), e.theme.palette || (e.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(e) {
    var t = e;
    if (t.tooltip.shared && t.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if (t.chart.type === "bar" && t.plotOptions.bar.horizontal) {
      if (t.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      t.yaxis[0].reversed && (t.yaxis[0].opposite = !0), t.xaxis.tooltip.enabled = !1, t.yaxis[0].tooltip.enabled = !1, t.chart.zoom.enabled = !1;
    }
    return t.chart.type !== "bar" && t.chart.type !== "rangeBar" || t.tooltip.shared && t.xaxis.crosshairs.width === "barWidth" && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"), t.chart.type !== "candlestick" && t.chart.type !== "boxPlot" || t.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(t.chart.type, " chart is not supported.")), t.yaxis[0].reversed = !1), t;
  } }]), s;
}(), Ao = function() {
  function s() {
    te(this, s);
  }
  return ie(s, [{ key: "initGlobalVars", value: function(e) {
    e.series = [], e.seriesCandleO = [], e.seriesCandleH = [], e.seriesCandleM = [], e.seriesCandleL = [], e.seriesCandleC = [], e.seriesRangeStart = [], e.seriesRangeEnd = [], e.seriesRange = [], e.seriesPercent = [], e.seriesGoals = [], e.seriesX = [], e.seriesZ = [], e.seriesNames = [], e.seriesTotals = [], e.seriesLog = [], e.seriesColors = [], e.stackedSeriesTotals = [], e.seriesXvalues = [], e.seriesYvalues = [], e.labels = [], e.hasXaxisGroups = !1, e.groups = [], e.barGroups = [], e.lineGroups = [], e.areaGroups = [], e.hasSeriesGroups = !1, e.seriesGroups = [], e.categoryLabels = [], e.timescaleLabels = [], e.noLabelsProvided = !1, e.resizeTimer = null, e.selectionResizeTimer = null, e.lastWheelExecution = 0, e.delayedElements = [], e.pointsArray = [], e.dataLabelsRects = [], e.isXNumeric = !1, e.skipLastTimelinelabel = !1, e.skipFirstTimelinelabel = !1, e.isDataXYZ = !1, e.isMultiLineX = !1, e.isMultipleYAxis = !1, e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE, e.minYArr = [], e.maxYArr = [], e.maxX = -Number.MAX_VALUE, e.minX = Number.MAX_VALUE, e.initialMaxX = -Number.MAX_VALUE, e.initialMinX = Number.MAX_VALUE, e.maxDate = 0, e.minDate = Number.MAX_VALUE, e.minZ = Number.MAX_VALUE, e.maxZ = -Number.MAX_VALUE, e.minXDiff = Number.MAX_VALUE, e.yAxisScale = [], e.xAxisScale = null, e.xAxisTicksPositions = [], e.yLabelsCoords = [], e.yTitleCoords = [], e.barPadForNumericAxis = 0, e.padHorizontal = 0, e.xRange = 0, e.yRange = [], e.zRange = 0, e.dataPoints = 0, e.xTickAmount = 0, e.multiAxisTickAmount = 0;
  } }, { key: "globalVars", value: function(e) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: e.markers.size, largestSize: 0 }, animationEnded: !1, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: !1, isExecCalled: !1, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: !1, allSeriesCollapsed: !1, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: !1, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: !1, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: e.chart.toolbar.autoSelected === "zoom" && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled, panEnabled: e.chart.toolbar.autoSelected === "pan" && e.chart.toolbar.tools.pan, selectionEnabled: e.chart.toolbar.autoSelected === "selection" && e.chart.toolbar.tools.selection, yaxis: null, mousedown: !1, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: !1, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: !0, skipLastTimelinelabel: !1, skipFirstTimelinelabel: !1, delayedElements: [], axisCharts: !0, isDataXYZ: !1, isSlopeChart: e.plotOptions.line.isSlopeChart, resized: !1, resizeTimer: null, comboCharts: !1, dataChanged: !1, previousPaths: [], allSeriesHasEqualX: !0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: !1, zoomed: !1, gridWidth: 0, gridHeight: 0, rotateXLabels: !1, defaultLabels: !1, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: "init", value: function(e) {
    var t = this.globalVars(e);
    return this.initGlobalVars(t), t.initialConfig = F.extend({}, e), t.initialSeries = F.clone(e.series), t.lastXAxis = F.clone(t.initialConfig.xaxis), t.lastYAxis = F.clone(t.initialConfig.yaxis), t;
  } }]), s;
}(), ed = function() {
  function s(e) {
    te(this, s), this.opts = e;
  }
  return ie(s, [{ key: "init", value: function() {
    var e = new Mi(this.opts).init({ responsiveOverride: !1 });
    return { config: e, globals: new Ao().init(e) };
  } }]), s;
}(), gt = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return ie(s, [{ key: "clippedImgArea", value: function(e) {
    var t = this.w, i = t.config, r = parseInt(t.globals.gridWidth, 10), a = parseInt(t.globals.gridHeight, 10), n = r > a ? r : a, o = e.image, l = 0, c = 0;
    e.width === void 0 && e.height === void 0 ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (l = i.fill.image.width + 1, c = i.fill.image.height) : (l = n + 1, c = n) : (l = e.width, c = e.height);
    var h = document.createElementNS(t.globals.SVGNS, "pattern");
    $.setAttrs(h, { id: e.patternID, patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse", width: l + "px", height: c + "px" });
    var d = document.createElementNS(t.globals.SVGNS, "image");
    h.appendChild(d), d.setAttributeNS(window.SVG.xlink, "href", o), $.setAttrs(d, { x: 0, y: 0, preserveAspectRatio: "none", width: l + "px", height: c + "px" }), d.style.opacity = e.opacity, t.globals.dom.elDefs.node.appendChild(h);
  } }, { key: "getSeriesIndex", value: function(e) {
    var t = this.w, i = t.config.chart.type;
    return (i === "bar" || i === "rangeBar") && t.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = e.seriesNumber : this.seriesIndex = e.seriesNumber % t.globals.series.length, this.seriesIndex;
  } }, { key: "computeColorStops", value: function(e, t) {
    var i, r = this.w, a = null, n = null, o = fi(e);
    try {
      for (o.s(); !(i = o.n()).done; ) {
        var l = i.value;
        l >= t.threshold ? (a === null || l > a) && (a = l) : (n === null || l < n) && (n = l);
      }
    } catch (d) {
      o.e(d);
    } finally {
      o.f();
    }
    a === null && (a = t.threshold), n === null && (n = t.threshold);
    var c = a - t.threshold + (t.threshold - n);
    c === 0 && (c = 1);
    var h = 100 - (t.threshold - n) / c * 100;
    return [{ offset: h = Math.max(0, Math.min(h, 100)), color: t.colorAboveThreshold, opacity: r.config.fill.opacity }, { offset: 0, color: t.colorBelowThreshold, opacity: r.config.fill.opacity }];
  } }, { key: "fillPath", value: function(e) {
    var t, i, r, a = this.w;
    this.opts = e;
    var n, o, l, c = this.w.config;
    this.seriesIndex = this.getSeriesIndex(e);
    var h = c.plotOptions.line.colors.colorAboveThreshold && c.plotOptions.line.colors.colorBelowThreshold, d = this.getFillColors()[this.seriesIndex];
    a.globals.seriesColors[this.seriesIndex] !== void 0 && (d = a.globals.seriesColors[this.seriesIndex]), typeof d == "function" && (d = d({ seriesIndex: this.seriesIndex, dataPointIndex: e.dataPointIndex, value: e.value, w: a }));
    var u, g, p, f = e.fillType ? e.fillType : this.getFillType(this.seriesIndex), x = Array.isArray(c.fill.opacity) ? c.fill.opacity[this.seriesIndex] : c.fill.opacity, m = f === "gradient" || h;
    e.color && (d = e.color), (t = a.config.series[this.seriesIndex]) !== null && t !== void 0 && (i = t.data) !== null && i !== void 0 && (r = i[e.dataPointIndex]) !== null && r !== void 0 && r.fillColor && (d = (u = a.config.series[this.seriesIndex]) === null || u === void 0 || (g = u.data) === null || g === void 0 || (p = g[e.dataPointIndex]) === null || p === void 0 ? void 0 : p.fillColor), d || (d = "#fff", console.warn("undefined color - ApexCharts"));
    var b = d;
    if (d.indexOf("rgb") === -1 ? d.indexOf("#") === -1 ? b = d : d.length < 9 && (b = F.hexToRgba(d, x)) : d.indexOf("rgba") > -1 ? x = F.getOpacityFromRGBA(d) : b = F.hexToRgba(F.rgb2hex(d), x), e.opacity && (x = e.opacity), f === "pattern" && (o = this.handlePatternFill({ fillConfig: e.fillConfig, patternFill: o, fillColor: d, fillOpacity: x, defaultColor: b })), m) {
      var w = De(c.fill.gradient.colorStops) || [], y = c.fill.gradient.type;
      h && (w[this.seriesIndex] = this.computeColorStops(a.globals.series[this.seriesIndex], c.plotOptions.line.colors), y = "vertical"), l = this.handleGradientFill({ type: y, fillConfig: e.fillConfig, fillColor: d, fillOpacity: x, colorStops: w, i: this.seriesIndex });
    }
    if (f === "image") {
      var v = c.fill.image.src, k = e.patternID ? e.patternID : "", S = "pattern".concat(a.globals.cuid).concat(e.seriesNumber + 1).concat(k);
      this.patternIDs.indexOf(S) === -1 && (this.clippedImgArea({ opacity: x, image: Array.isArray(v) ? e.seriesNumber < v.length ? v[e.seriesNumber] : v[0] : v, width: e.width ? e.width : void 0, height: e.height ? e.height : void 0, patternUnits: e.patternUnits, patternID: S }), this.patternIDs.push(S)), n = "url(#".concat(S, ")");
    } else n = m ? l : f === "pattern" ? o : b;
    return e.solid && (n = b), n;
  } }, { key: "getFillType", value: function(e) {
    var t = this.w;
    return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var e = this.w, t = e.config, i = this.opts, r = [];
    return e.globals.comboCharts ? e.config.series[this.seriesIndex].type === "line" ? Array.isArray(e.globals.stroke.colors) ? r = e.globals.stroke.colors : r.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? r = e.globals.fill.colors : r.push(e.globals.fill.colors) : t.chart.type === "line" ? Array.isArray(e.globals.stroke.colors) ? r = e.globals.stroke.colors : r.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? r = e.globals.fill.colors : r.push(e.globals.fill.colors), i.fillColors !== void 0 && (r = [], Array.isArray(i.fillColors) ? r = i.fillColors.slice() : r.push(i.fillColors)), r;
  } }, { key: "handlePatternFill", value: function(e) {
    var t = e.fillConfig, i = e.patternFill, r = e.fillColor, a = e.fillOpacity, n = e.defaultColor, o = this.w.config.fill;
    t && (o = t);
    var l = this.opts, c = new $(this.ctx), h = Array.isArray(o.pattern.strokeWidth) ? o.pattern.strokeWidth[this.seriesIndex] : o.pattern.strokeWidth, d = r;
    return Array.isArray(o.pattern.style) ? i = o.pattern.style[l.seriesNumber] !== void 0 ? c.drawPattern(o.pattern.style[l.seriesNumber], o.pattern.width, o.pattern.height, d, h, a) : n : i = c.drawPattern(o.pattern.style, o.pattern.width, o.pattern.height, d, h, a), i;
  } }, { key: "handleGradientFill", value: function(e) {
    var t = e.type, i = e.fillColor, r = e.fillOpacity, a = e.fillConfig, n = e.colorStops, o = e.i, l = this.w.config.fill;
    a && (l = J(J({}, l), a));
    var c = this.opts, h = new $(this.ctx), d = new F();
    t = t || l.gradient.type;
    var u, g = i, p = l.gradient.opacityFrom === void 0 ? r : Array.isArray(l.gradient.opacityFrom) ? l.gradient.opacityFrom[o] : l.gradient.opacityFrom;
    g.indexOf("rgba") > -1 && (p = F.getOpacityFromRGBA(g));
    var f = l.gradient.opacityTo === void 0 ? r : Array.isArray(l.gradient.opacityTo) ? l.gradient.opacityTo[o] : l.gradient.opacityTo;
    if (l.gradient.gradientToColors === void 0 || l.gradient.gradientToColors.length === 0) u = l.gradient.shade === "dark" ? d.shadeColor(-1 * parseFloat(l.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? F.rgb2hex(i) : i) : d.shadeColor(parseFloat(l.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? F.rgb2hex(i) : i);
    else if (l.gradient.gradientToColors[c.seriesNumber]) {
      var x = l.gradient.gradientToColors[c.seriesNumber];
      u = x, x.indexOf("rgba") > -1 && (f = F.getOpacityFromRGBA(x));
    } else u = i;
    if (l.gradient.gradientFrom && (g = l.gradient.gradientFrom), l.gradient.gradientTo && (u = l.gradient.gradientTo), l.gradient.inverseColors) {
      var m = g;
      g = u, u = m;
    }
    return g.indexOf("rgb") > -1 && (g = F.rgb2hex(g)), u.indexOf("rgb") > -1 && (u = F.rgb2hex(u)), h.drawGradient(t, g, u, p, f, c.size, l.gradient.stops, n, o);
  } }]), s;
}(), ni = function() {
  function s(e, t) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "setGlobalMarkerSize", value: function() {
    var e = this.w;
    if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size], e.globals.markers.size.length > 0) {
      if (e.globals.markers.size.length < e.globals.series.length + 1) for (var t = 0; t <= e.globals.series.length; t++) e.globals.markers.size[t] === void 0 && e.globals.markers.size.push(e.globals.markers.size[0]);
    } else e.globals.markers.size = e.config.series.map(function(i) {
      return e.config.markers.size;
    });
  } }, { key: "plotChartMarkers", value: function(e) {
    var t = e.pointsPos, i = e.seriesIndex, r = e.j, a = e.pSize, n = e.alwaysDrawMarker, o = n !== void 0 && n, l = e.isVirtualPoint, c = l !== void 0 && l, h = this.w, d = i, u = t, g = null, p = new $(this.ctx), f = h.config.markers.discrete && h.config.markers.discrete.length;
    if (Array.isArray(u.x)) for (var x = 0; x < u.x.length; x++) {
      var m = void 0, b = r, w = !F.isNumber(u.y[x]);
      h.globals.markers.largestSize === 0 && h.globals.hasNullValues && h.globals.series[d][r + 1] !== null && !c && (w = !0), r === 1 && x === 0 && (b = 0), r === 1 && x === 1 && (b = 1);
      var y = "apexcharts-marker";
      if (h.config.chart.type !== "line" && h.config.chart.type !== "area" || h.globals.comboCharts || h.config.tooltip.intersect || (y += " no-pointer-events"), (Array.isArray(h.config.markers.size) ? h.globals.markers.size[i] > 0 : h.config.markers.size > 0) || o || f) {
        w || (y += " w".concat(F.randomId()));
        var v = this.getMarkerConfig({ cssClass: y, seriesIndex: i, dataPointIndex: b });
        h.config.series[d].data[b] && (h.config.series[d].data[b].fillColor && (v.pointFillColor = h.config.series[d].data[b].fillColor), h.config.series[d].data[b].strokeColor && (v.pointStrokeColor = h.config.series[d].data[b].strokeColor)), a !== void 0 && (v.pSize = a), (u.x[x] < -h.globals.markers.largestSize || u.x[x] > h.globals.gridWidth + h.globals.markers.largestSize || u.y[x] < -h.globals.markers.largestSize || u.y[x] > h.globals.gridHeight + h.globals.markers.largestSize) && (v.pSize = 0), !w && ((h.globals.markers.size[i] > 0 || o || f) && !g && (g = p.group({ class: o || f ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h.globals.cuid, ")")), (m = p.drawMarker(u.x[x], u.y[x], v)).attr("rel", b), m.attr("j", b), m.attr("index", i), m.node.setAttribute("default-marker-size", v.pSize), new Ye(this.ctx).setSelectionFilter(m, i, b), this.addEvents(m), g && g.add(m));
      } else h.globals.pointsArray[i] === void 0 && (h.globals.pointsArray[i] = []), h.globals.pointsArray[i].push([u.x[x], u.y[x]]);
    }
    return g;
  } }, { key: "getMarkerConfig", value: function(e) {
    var t = e.cssClass, i = e.seriesIndex, r = e.dataPointIndex, a = r === void 0 ? null : r, n = e.radius, o = n === void 0 ? null : n, l = e.size, c = l === void 0 ? null : l, h = e.strokeWidth, d = h === void 0 ? null : h, u = this.w, g = this.getMarkerStyle(i), p = c === null ? u.globals.markers.size[i] : c, f = u.config.markers;
    return a !== null && f.discrete.length && f.discrete.map(function(x) {
      x.seriesIndex === i && x.dataPointIndex === a && (g.pointStrokeColor = x.strokeColor, g.pointFillColor = x.fillColor, p = x.size, g.pointShape = x.shape);
    }), { pSize: o === null ? p : o, pRadius: o !== null ? o : f.radius, pointStrokeWidth: d !== null ? d : Array.isArray(f.strokeWidth) ? f.strokeWidth[i] : f.strokeWidth, pointStrokeColor: g.pointStrokeColor, pointFillColor: g.pointFillColor, shape: g.pointShape || (Array.isArray(f.shape) ? f.shape[i] : f.shape), class: t, pointStrokeOpacity: Array.isArray(f.strokeOpacity) ? f.strokeOpacity[i] : f.strokeOpacity, pointStrokeDashArray: Array.isArray(f.strokeDashArray) ? f.strokeDashArray[i] : f.strokeDashArray, pointFillOpacity: Array.isArray(f.fillOpacity) ? f.fillOpacity[i] : f.fillOpacity, seriesIndex: i };
  } }, { key: "addEvents", value: function(e) {
    var t = this.w, i = new $(this.ctx);
    e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e)), e.node.addEventListener("click", t.config.markers.onClick), e.node.addEventListener("dblclick", t.config.markers.onDblClick), e.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e), { passive: !0 });
  } }, { key: "getMarkerStyle", value: function(e) {
    var t = this.w, i = t.globals.markers.colors, r = t.config.markers.strokeColor || t.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(r) ? r[e] : r, pointFillColor: Array.isArray(i) ? i[e] : i };
  } }]), s;
}(), Mo = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return ie(s, [{ key: "draw", value: function(e, t, i) {
    var r = this.w, a = new $(this.ctx), n = i.realIndex, o = i.pointsPos, l = i.zRatio, c = i.elParent, h = a.group({ class: "apexcharts-series-markers apexcharts-series-".concat(r.config.chart.type) });
    if (h.attr("clip-path", "url(#gridRectMarkerMask".concat(r.globals.cuid, ")")), Array.isArray(o.x)) for (var d = 0; d < o.x.length; d++) {
      var u = t + 1, g = !0;
      t === 0 && d === 0 && (u = 0), t === 0 && d === 1 && (u = 1);
      var p = r.globals.markers.size[n];
      if (l !== 1 / 0) {
        var f = r.config.plotOptions.bubble;
        p = r.globals.seriesZ[n][u], f.zScaling && (p /= l), f.minBubbleRadius && p < f.minBubbleRadius && (p = f.minBubbleRadius), f.maxBubbleRadius && p > f.maxBubbleRadius && (p = f.maxBubbleRadius);
      }
      var x = o.x[d], m = o.y[d];
      if (p = p || 0, m !== null && r.globals.series[n][u] !== void 0 || (g = !1), g) {
        var b = this.drawPoint(x, m, p, n, u, t);
        h.add(b);
      }
      c.add(h);
    }
  } }, { key: "drawPoint", value: function(e, t, i, r, a, n) {
    var o = this.w, l = r, c = new ii(this.ctx), h = new Ye(this.ctx), d = new gt(this.ctx), u = new ni(this.ctx), g = new $(this.ctx), p = u.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l, dataPointIndex: a, radius: o.config.chart.type === "bubble" || o.globals.comboCharts && o.config.series[r] && o.config.series[r].type === "bubble" ? i : null }), f = d.fillPath({ seriesNumber: r, dataPointIndex: a, color: p.pointFillColor, patternUnits: "objectBoundingBox", value: o.globals.series[r][n] }), x = g.drawMarker(e, t, p);
    if (o.config.series[l].data[a] && o.config.series[l].data[a].fillColor && (f = o.config.series[l].data[a].fillColor), x.attr({ fill: f }), o.config.chart.dropShadow.enabled) {
      var m = o.config.chart.dropShadow;
      h.dropShadow(x, m, r);
    }
    if (!this.initialAnim || o.globals.dataChanged || o.globals.resized) o.globals.animationEnded = !0;
    else {
      var b = o.config.chart.animations.speed;
      c.animateMarker(x, b, o.globals.easing, function() {
        window.setTimeout(function() {
          c.animationCompleted(x);
        }, 100);
      });
    }
    return x.attr({ rel: a, j: a, index: r, "default-marker-size": p.pSize }), h.setSelectionFilter(x, r, a), u.addEvents(x), x.node.classList.add("apexcharts-marker"), x;
  } }, { key: "centerTextInBubble", value: function(e) {
    var t = this.w;
    return { y: e += parseInt(t.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), s;
}(), Jt = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "dataLabelsCorrection", value: function(e, t, i, r, a, n, o) {
    var l = this.w, c = !1, h = new $(this.ctx).getTextRects(i, o), d = h.width, u = h.height;
    t < 0 && (t = 0), t > l.globals.gridHeight + u && (t = l.globals.gridHeight + u / 2), l.globals.dataLabelsRects[r] === void 0 && (l.globals.dataLabelsRects[r] = []), l.globals.dataLabelsRects[r].push({ x: e, y: t, width: d, height: u });
    var g = l.globals.dataLabelsRects[r].length - 2, p = l.globals.lastDrawnDataLabelsIndexes[r] !== void 0 ? l.globals.lastDrawnDataLabelsIndexes[r][l.globals.lastDrawnDataLabelsIndexes[r].length - 1] : 0;
    if (l.globals.dataLabelsRects[r][g] !== void 0) {
      var f = l.globals.dataLabelsRects[r][p];
      (e > f.x + f.width || t > f.y + f.height || t + u < f.y || e + d < f.x) && (c = !0);
    }
    return (a === 0 || n) && (c = !0), { x: e, y: t, textRects: h, drawnextLabel: c };
  } }, { key: "drawDataLabel", value: function(e) {
    var t = this, i = e.type, r = e.pos, a = e.i, n = e.j, o = e.isRangeStart, l = e.strokeWidth, c = l === void 0 ? 2 : l, h = this.w, d = new $(this.ctx), u = h.config.dataLabels, g = 0, p = 0, f = n, x = null;
    if (h.globals.collapsedSeriesIndices.indexOf(a) !== -1 || !u.enabled || !Array.isArray(r.x)) return x;
    x = d.group({ class: "apexcharts-data-labels" });
    for (var m = 0; m < r.x.length; m++) if (g = r.x[m] + u.offsetX, p = r.y[m] + u.offsetY + c, !isNaN(g)) {
      n === 1 && m === 0 && (f = 0), n === 1 && m === 1 && (f = 1);
      var b = h.globals.series[a][f];
      i === "rangeArea" && (b = o ? h.globals.seriesRangeStart[a][f] : h.globals.seriesRangeEnd[a][f]);
      var w = "", y = function(k) {
        return h.config.dataLabels.formatter(k, { ctx: t.ctx, seriesIndex: a, dataPointIndex: f, w: h });
      };
      h.config.chart.type === "bubble" ? (w = y(b = h.globals.seriesZ[a][f]), p = r.y[m], p = new Mo(this.ctx).centerTextInBubble(p, a, f).y) : b !== void 0 && (w = y(b));
      var v = h.config.dataLabels.textAnchor;
      h.globals.isSlopeChart && (v = f === 0 ? "end" : f === h.config.series[a].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: g, y: p, text: w, i: a, j: f, parent: x, offsetCorrection: !0, dataLabelsConfig: h.config.dataLabels, textAnchor: v });
    }
    return x;
  } }, { key: "plotDataLabelsText", value: function(e) {
    var t = this.w, i = new $(this.ctx), r = e.x, a = e.y, n = e.i, o = e.j, l = e.text, c = e.textAnchor, h = e.fontSize, d = e.parent, u = e.dataLabelsConfig, g = e.color, p = e.alwaysDrawDataLabel, f = e.offsetCorrection, x = e.className, m = null;
    if (Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(n) < 0) return m;
    var b = { x: r, y: a, drawnextLabel: !0, textRects: null };
    f && (b = this.dataLabelsCorrection(r, a, l, n, o, p, parseInt(u.style.fontSize, 10))), t.globals.zoomed || (r = b.x, a = b.y), b.textRects && (r < -20 - b.textRects.width || r > t.globals.gridWidth + b.textRects.width + 30) && (l = "");
    var w = t.globals.dataLabels.style.colors[n];
    ((t.config.chart.type === "bar" || t.config.chart.type === "rangeBar") && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (w = t.globals.dataLabels.style.colors[o]), typeof w == "function" && (w = w({ series: t.globals.series, seriesIndex: n, dataPointIndex: o, w: t })), g && (w = g);
    var y = u.offsetX, v = u.offsetY;
    if (t.config.chart.type !== "bar" && t.config.chart.type !== "rangeBar" || (y = 0, v = 0), t.globals.isSlopeChart && (o !== 0 && (y = -2 * u.offsetX + 5), o !== 0 && o !== t.config.series[n].data.length - 1 && (y = 0)), b.drawnextLabel) {
      if ((m = i.drawText({ width: 100, height: parseInt(u.style.fontSize, 10), x: r + y, y: a + v, foreColor: w, textAnchor: c || u.textAnchor, text: l, fontSize: h || u.style.fontSize, fontFamily: u.style.fontFamily, fontWeight: u.style.fontWeight || "normal" })).attr({ class: x || "apexcharts-datalabel", cx: r, cy: a }), u.dropShadow.enabled) {
        var k = u.dropShadow;
        new Ye(this.ctx).dropShadow(m, k);
      }
      d.add(m), t.globals.lastDrawnDataLabelsIndexes[n] === void 0 && (t.globals.lastDrawnDataLabelsIndexes[n] = []), t.globals.lastDrawnDataLabelsIndexes[n].push(o);
    }
    return m;
  } }, { key: "addBackgroundToDataLabel", value: function(e, t) {
    var i = this.w, r = i.config.dataLabels.background, a = r.padding, n = r.padding / 2, o = t.width, l = t.height, c = new $(this.ctx).drawRect(t.x - a, t.y - n / 2, o + 2 * a, l + n, r.borderRadius, i.config.chart.background !== "transparent" && i.config.chart.background ? i.config.chart.background : "#fff", r.opacity, r.borderWidth, r.borderColor);
    return r.dropShadow.enabled && new Ye(this.ctx).dropShadow(c, r.dropShadow), c;
  } }, { key: "dataLabelsBackground", value: function() {
    var e = this.w;
    if (e.config.chart.type !== "bubble") for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t.length; i++) {
      var r = t[i], a = r.getBBox(), n = null;
      if (a.width && a.height && (n = this.addBackgroundToDataLabel(r, a)), n) {
        r.parentNode.insertBefore(n.node, r);
        var o = e.config.dataLabels.background.backgroundColor || r.getAttribute("fill");
        e.config.chart.animations.enabled && !e.globals.resized && !e.globals.dataChanged ? n.animate().attr({ fill: o }) : n.attr({ fill: o }), r.setAttribute("fill", e.config.dataLabels.background.foreColor);
      }
    }
  } }, { key: "bringForward", value: function() {
    for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), r = 0; r < t.length; r++) i && i.insertBefore(t[r], i.nextSibling);
  } }]), s;
}(), ct = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  return ie(s, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  } }, { key: "getSeriesByName", value: function(e) {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(F.escapeString(e), "']"));
  } }, { key: "isSeriesHidden", value: function(e) {
    var t = this.getSeriesByName(e), i = parseInt(t.getAttribute("data:realIndex"), 10);
    return { isHidden: t.classList.contains("apexcharts-series-collapsed"), realIndex: i };
  } }, { key: "addCollapsedClassToSeries", value: function(e, t) {
    var i = this.w;
    function r(a) {
      for (var n = 0; n < a.length; n++) a[n].index === t && e.node.classList.add("apexcharts-series-collapsed");
    }
    r(i.globals.collapsedSeries), r(i.globals.ancillaryCollapsedSeries);
  } }, { key: "toggleSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    return this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, t.isHidden), t.isHidden;
  } }, { key: "showSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !0);
  } }, { key: "hideSeries", value: function(e) {
    var t = this.isSeriesHidden(e);
    t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !1);
  } }, { key: "resetSeries", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], r = this.w, a = F.clone(r.globals.initialSeries);
    r.globals.previousPaths = [], i ? (r.globals.collapsedSeries = [], r.globals.ancillaryCollapsedSeries = [], r.globals.collapsedSeriesIndices = [], r.globals.ancillaryCollapsedSeriesIndices = []) : a = this.emptyCollapsedSeries(a), r.config.series = a, e && (t && (r.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(a, r.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: "emptyCollapsedSeries", value: function(e) {
    for (var t = this.w, i = 0; i < e.length; i++) t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = []);
    return e;
  } }, { key: "highlightSeries", value: function(e) {
    var t = this.w, i = this.getSeriesByName(e), r = parseInt(i == null ? void 0 : i.getAttribute("data:realIndex"), 10), a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), n = null, o = null, l = null;
    if (t.globals.axisCharts || t.config.chart.type === "radialBar") if (t.globals.axisCharts) {
      n = t.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(r, "']")), o = t.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(r, "']"));
      var c = t.globals.seriesYAxisReverseMap[r];
      l = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(c, "']"));
    } else n = t.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(r + 1, "']"));
    else n = t.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(r + 1, "'] path"));
    for (var h = 0; h < a.length; h++) a[h].classList.add(this.legendInactiveClass);
    if (n) t.globals.axisCharts || n.parentNode.classList.remove(this.legendInactiveClass), n.classList.remove(this.legendInactiveClass), o !== null && o.classList.remove(this.legendInactiveClass), l !== null && l.classList.remove(this.legendInactiveClass);
    else for (var d = 0; d < a.length; d++) a[d].classList.remove(this.legendInactiveClass);
  } }, { key: "toggleSeriesOnHover", value: function(e, t) {
    var i = this.w;
    t || (t = e.target);
    var r = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
    if (e.type === "mousemove") {
      var a = parseInt(t.getAttribute("rel"), 10) - 1;
      this.highlightSeries(i.globals.seriesNames[a]);
    } else if (e.type === "mouseout") for (var n = 0; n < r.length; n++) r[n].classList.remove(this.legendInactiveClass);
  } }, { key: "highlightRangeInSeries", value: function(e, t) {
    var i = this, r = this.w, a = r.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), n = function(c) {
      for (var h = 0; h < a.length; h++) a[h].classList[c](i.legendInactiveClass);
    };
    if (e.type === "mousemove") {
      var o = parseInt(t.getAttribute("rel"), 10) - 1;
      n("add");
      var l = r.config.plotOptions.heatmap.colorScale.ranges;
      (function(c, h) {
        for (var d = 0; d < a.length; d++) {
          var u = Number(a[d].getAttribute("val"));
          u >= c.from && (u < c.to || c.to === h && u === h) && a[d].classList.remove(i.legendInactiveClass);
        }
      })(l[o], l.reduce(function(c, h) {
        return Math.max(c, h.to);
      }, 0));
    } else e.type === "mouseout" && n("remove");
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = this.w, r = 0;
    if (i.config.series.length > 1) {
      for (var a = i.config.series.map(function(o, l) {
        return o.data && o.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(l) === -1 && (!i.globals.comboCharts || t.length === 0 || t.length && t.indexOf(i.config.series[l].type) > -1) ? l : -1;
      }), n = e === "asc" ? 0 : a.length - 1; e === "asc" ? n < a.length : n >= 0; e === "asc" ? n++ : n--) if (a[n] !== -1) {
        r = a[n];
        break;
      }
    }
    return r;
  } }, { key: "getBarSeriesIndices", value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map(function(e, t) {
      return e.type === "bar" || e.type === "column" ? t : -1;
    }).filter(function(e) {
      return e !== -1;
    }) : this.w.config.series.map(function(e, t) {
      return t;
    });
  } }, { key: "getPreviousPaths", value: function() {
    var e = this.w;
    function t(n, o, l) {
      for (var c = n[o].childNodes, h = { type: l, paths: [], realIndex: n[o].getAttribute("data:realIndex") }, d = 0; d < c.length; d++) if (c[d].hasAttribute("pathTo")) {
        var u = c[d].getAttribute("pathTo");
        h.paths.push({ d: u });
      }
      e.globals.previousPaths.push(h);
    }
    e.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(n) {
      for (var o, l = (o = n, e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(o, "-series .apexcharts-series"))), c = 0; c < l.length; c++) t(l, c, n);
    });
    var i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series"));
    if (i.length > 0) for (var r = function(n) {
      for (var o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(n, "'] rect")), l = [], c = function(d) {
        var u = function(p) {
          return o[d].getAttribute(p);
        }, g = { x: parseFloat(u("x")), y: parseFloat(u("y")), width: parseFloat(u("width")), height: parseFloat(u("height")) };
        l.push({ rect: g, color: o[d].getAttribute("color") });
      }, h = 0; h < o.length; h++) c(h);
      e.globals.previousPaths.push(l);
    }, a = 0; a < i.length; a++) r(a);
    e.globals.axisCharts || (e.globals.previousPaths = e.globals.series);
  } }, { key: "clearPreviousPaths", value: function() {
    var e = this.w;
    e.globals.previousPaths = [], e.globals.allSeriesCollapsed = !1;
  } }, { key: "handleNoData", value: function() {
    var e = this.w, t = e.config.noData, i = new $(this.ctx), r = e.globals.svgWidth / 2, a = e.globals.svgHeight / 2, n = "middle";
    if (e.globals.noData = !0, e.globals.animationEnded = !0, t.align === "left" ? (r = 10, n = "start") : t.align === "right" && (r = e.globals.svgWidth - 10, n = "end"), t.verticalAlign === "top" ? a = 50 : t.verticalAlign === "bottom" && (a = e.globals.svgHeight - 50), r += t.offsetX, a = a + parseInt(t.style.fontSize, 10) + 2 + t.offsetY, t.text !== void 0 && t.text !== "") {
      var o = i.drawText({ x: r, y: a, text: t.text, textAnchor: n, fontSize: t.style.fontSize, fontFamily: t.style.fontFamily, foreColor: t.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      e.globals.dom.Paper.add(o);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(e) {
    for (var t = this.w, i = 0; i < e.length; i++) if (e[i].length === 0) for (var r = 0; r < e[t.globals.maxValsInArrayIndex].length; r++) e[i].push(0);
    return e;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var e = !0, t = this.w, i = this.filteredSeriesX(), r = 0; r < i.length - 1; r++) if (i[r][0] !== i[r + 1][0]) {
      e = !1;
      break;
    }
    return t.globals.allSeriesHasEqualX = e, e;
  } }, { key: "filteredSeriesX", value: function() {
    var e = this.w.globals.seriesX.map(function(t) {
      return t.length > 0 ? t : [];
    });
    return e;
  } }]), s;
}(), ea = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new ze(this.ctx);
  }
  return ie(s, [{ key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var e = this.w.config.series.slice(), t = new ct(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), e[this.activeSeriesIndex].data !== void 0 && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].x !== void 0 && e[this.activeSeriesIndex].data[0] !== null) return !0;
  } }, { key: "isFormat2DArray", value: function() {
    var e = this.w.config.series.slice(), t = new ct(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), e[this.activeSeriesIndex].data !== void 0 && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== void 0 && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].constructor === Array) return !0;
  } }, { key: "handleFormat2DArray", value: function(e, t) {
    for (var i = this.w.config, r = this.w.globals, a = i.chart.type === "boxPlot" || i.series[t].type === "boxPlot", n = 0; n < e[t].data.length; n++) if (e[t].data[n][1] !== void 0 && (Array.isArray(e[t].data[n][1]) && e[t].data[n][1].length === 4 && !a ? this.twoDSeries.push(F.parseNumber(e[t].data[n][1][3])) : e[t].data[n].length >= 5 ? this.twoDSeries.push(F.parseNumber(e[t].data[n][4])) : this.twoDSeries.push(F.parseNumber(e[t].data[n][1])), r.dataFormatXNumeric = !0), i.xaxis.type === "datetime") {
      var o = new Date(e[t].data[n][0]);
      o = new Date(o).getTime(), this.twoDSeriesX.push(o);
    } else this.twoDSeriesX.push(e[t].data[n][0]);
    for (var l = 0; l < e[t].data.length; l++) e[t].data[l][2] !== void 0 && (this.threeDSeries.push(e[t].data[l][2]), r.isDataXYZ = !0);
  } }, { key: "handleFormatXY", value: function(e, t) {
    var i = this.w.config, r = this.w.globals, a = new je(this.ctx), n = t;
    r.collapsedSeriesIndices.indexOf(t) > -1 && (n = this.activeSeriesIndex);
    for (var o = 0; o < e[t].data.length; o++) e[t].data[o].y !== void 0 && (Array.isArray(e[t].data[o].y) ? this.twoDSeries.push(F.parseNumber(e[t].data[o].y[e[t].data[o].y.length - 1])) : this.twoDSeries.push(F.parseNumber(e[t].data[o].y))), e[t].data[o].goals !== void 0 && Array.isArray(e[t].data[o].goals) ? (this.seriesGoals[t] === void 0 && (this.seriesGoals[t] = []), this.seriesGoals[t].push(e[t].data[o].goals)) : (this.seriesGoals[t] === void 0 && (this.seriesGoals[t] = []), this.seriesGoals[t].push(null));
    for (var l = 0; l < e[n].data.length; l++) {
      var c = typeof e[n].data[l].x == "string", h = Array.isArray(e[n].data[l].x), d = !h && !!a.isValidDate(e[n].data[l].x);
      if (c || d) if (c || i.xaxis.convertedCatToNumeric) {
        var u = r.isBarHorizontal && r.isRangeData;
        i.xaxis.type !== "datetime" || u ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[n].data[l].x), isNaN(e[n].data[l].x) || this.w.config.xaxis.type === "category" || typeof e[n].data[l].x == "string" || (r.isXNumeric = !0)) : this.twoDSeriesX.push(a.parseDate(e[n].data[l].x));
      } else i.xaxis.type === "datetime" ? this.twoDSeriesX.push(a.parseDate(e[n].data[l].x.toString())) : (r.dataFormatXNumeric = !0, r.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(e[n].data[l].x)));
      else h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[n].data[l].x)) : (r.isXNumeric = !0, r.dataFormatXNumeric = !0, this.twoDSeriesX.push(e[n].data[l].x));
    }
    if (e[t].data[0] && e[t].data[0].z !== void 0) {
      for (var g = 0; g < e[t].data.length; g++) this.threeDSeries.push(e[t].data[g].z);
      r.isDataXYZ = !0;
    }
  } }, { key: "handleRangeData", value: function(e, t) {
    var i = this.w.globals, r = {};
    return this.isFormat2DArray() ? r = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (r = this.handleRangeDataFormat("xy", e, t)), i.seriesRangeStart[t] = r.start === void 0 ? [] : r.start, i.seriesRangeEnd[t] = r.end === void 0 ? [] : r.end, i.seriesRange[t] = r.rangeUniques, i.seriesRange.forEach(function(a, n) {
      a && a.forEach(function(o, l) {
        o.y.forEach(function(c, h) {
          for (var d = 0; d < o.y.length; d++) if (h !== d) {
            var u = c.y1, g = c.y2, p = o.y[d].y1;
            u <= o.y[d].y2 && p <= g && (o.overlaps.indexOf(c.rangeName) < 0 && o.overlaps.push(c.rangeName), o.overlaps.indexOf(o.y[d].rangeName) < 0 && o.overlaps.push(o.y[d].rangeName));
          }
        });
      });
    }), r;
  } }, { key: "handleCandleStickBoxData", value: function(e, t) {
    var i = this.w.globals, r = {};
    return this.isFormat2DArray() ? r = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (r = this.handleCandleStickBoxDataFormat("xy", e, t)), i.seriesCandleO[t] = r.o, i.seriesCandleH[t] = r.h, i.seriesCandleM[t] = r.m, i.seriesCandleL[t] = r.l, i.seriesCandleC[t] = r.c, r;
  } }, { key: "handleRangeDataFormat", value: function(e, t, i) {
    var r = [], a = [], n = t[i].data.filter(function(h, d, u) {
      return d === u.findIndex(function(g) {
        return g.x === h.x;
      });
    }).map(function(h, d) {
      return { x: h.x, overlaps: [], y: [] };
    });
    if (e === "array") for (var o = 0; o < t[i].data.length; o++) Array.isArray(t[i].data[o]) ? (r.push(t[i].data[o][1][0]), a.push(t[i].data[o][1][1])) : (r.push(t[i].data[o]), a.push(t[i].data[o]));
    else if (e === "xy") for (var l = function(h) {
      var d = Array.isArray(t[i].data[h].y), u = F.randomId(), g = t[i].data[h].x, p = { y1: d ? t[i].data[h].y[0] : t[i].data[h].y, y2: d ? t[i].data[h].y[1] : t[i].data[h].y, rangeName: u };
      t[i].data[h].rangeName = u;
      var f = n.findIndex(function(x) {
        return x.x === g;
      });
      n[f].y.push(p), r.push(p.y1), a.push(p.y2);
    }, c = 0; c < t[i].data.length; c++) l(c);
    return { start: r, end: a, rangeUniques: n };
  } }, { key: "handleCandleStickBoxDataFormat", value: function(e, t, i) {
    var r = this.w, a = r.config.chart.type === "boxPlot" || r.config.series[i].type === "boxPlot", n = [], o = [], l = [], c = [], h = [];
    if (e === "array") if (a && t[i].data[0].length === 6 || !a && t[i].data[0].length === 5) for (var d = 0; d < t[i].data.length; d++) n.push(t[i].data[d][1]), o.push(t[i].data[d][2]), a ? (l.push(t[i].data[d][3]), c.push(t[i].data[d][4]), h.push(t[i].data[d][5])) : (c.push(t[i].data[d][3]), h.push(t[i].data[d][4]));
    else for (var u = 0; u < t[i].data.length; u++) Array.isArray(t[i].data[u][1]) && (n.push(t[i].data[u][1][0]), o.push(t[i].data[u][1][1]), a ? (l.push(t[i].data[u][1][2]), c.push(t[i].data[u][1][3]), h.push(t[i].data[u][1][4])) : (c.push(t[i].data[u][1][2]), h.push(t[i].data[u][1][3])));
    else if (e === "xy") for (var g = 0; g < t[i].data.length; g++) Array.isArray(t[i].data[g].y) && (n.push(t[i].data[g].y[0]), o.push(t[i].data[g].y[1]), a ? (l.push(t[i].data[g].y[2]), c.push(t[i].data[g].y[3]), h.push(t[i].data[g].y[4])) : (c.push(t[i].data[g].y[2]), h.push(t[i].data[g].y[3])));
    return { o: n, h: o, m: l, l: c, c: h };
  } }, { key: "parseDataAxisCharts", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, r = this.w.config, a = this.w.globals, n = new je(i), o = r.labels.length > 0 ? r.labels.slice() : r.xaxis.categories.slice();
    a.isRangeBar = r.chart.type === "rangeBar" && a.isBarHorizontal, a.hasXaxisGroups = r.xaxis.type === "category" && r.xaxis.group.groups.length > 0, a.hasXaxisGroups && (a.groups = r.xaxis.group.groups), e.forEach(function(g, p) {
      g.name !== void 0 ? a.seriesNames.push(g.name) : a.seriesNames.push("series-" + parseInt(p + 1, 10));
    }), this.coreUtils.setSeriesYAxisMappings();
    var l = [], c = De(new Set(r.series.map(function(g) {
      return g.group;
    })));
    r.series.forEach(function(g, p) {
      var f = c.indexOf(g.group);
      l[f] || (l[f] = []), l[f].push(a.seriesNames[p]);
    }), a.seriesGroups = l;
    for (var h = function() {
      for (var g = 0; g < o.length; g++) if (typeof o[g] == "string") {
        if (!n.isValidDate(o[g])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
        t.twoDSeriesX.push(n.parseDate(o[g]));
      } else t.twoDSeriesX.push(o[g]);
    }, d = 0; d < e.length; d++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], e[d].data === void 0) return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if (r.chart.type !== "rangeBar" && r.chart.type !== "rangeArea" && e[d].type !== "rangeBar" && e[d].type !== "rangeArea" || (a.isRangeData = !0, this.handleRangeData(e, d)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(e, d) : this.isFormatXY() && this.handleFormatXY(e, d), r.chart.type !== "candlestick" && e[d].type !== "candlestick" && r.chart.type !== "boxPlot" && e[d].type !== "boxPlot" || this.handleCandleStickBoxData(e, d), a.series.push(this.twoDSeries), a.labels.push(this.twoDSeriesX), a.seriesX.push(this.twoDSeriesX), a.seriesGoals = this.seriesGoals, d !== this.activeSeriesIndex || this.fallbackToCategory || (a.isXNumeric = !0);
      else {
        r.xaxis.type === "datetime" ? (a.isXNumeric = !0, h(), a.seriesX.push(this.twoDSeriesX)) : r.xaxis.type === "numeric" && (a.isXNumeric = !0, o.length > 0 && (this.twoDSeriesX = o, a.seriesX.push(this.twoDSeriesX))), a.labels.push(this.twoDSeriesX);
        var u = e[d].data.map(function(g) {
          return F.parseNumber(g);
        });
        a.series.push(u);
      }
      a.seriesZ.push(this.threeDSeries), e[d].color !== void 0 ? a.seriesColors.push(e[d].color) : a.seriesColors.push(void 0);
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(e) {
    var t = this.w.globals, i = this.w.config;
    t.series = e.slice(), t.seriesNames = i.labels.slice();
    for (var r = 0; r < t.series.length; r++) t.seriesNames[r] === void 0 && t.seriesNames.push("series-" + (r + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(e) {
    var t = this.w.config, i = this.w.globals;
    t.xaxis.categories.length > 0 ? i.labels = t.xaxis.categories : t.labels.length > 0 ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(r) {
      r.forEach(function(a) {
        i.labels.indexOf(a.x) < 0 && a.x && i.labels.push(a.x);
      });
    }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), t.xaxis.convertedCatToNumeric && (new Ai(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]), this._generateExternalLabels(e))) : this._generateExternalLabels(e);
  } }, { key: "_generateExternalLabels", value: function(e) {
    var t = this.w.globals, i = this.w.config, r = [];
    if (t.axisCharts) {
      if (t.series.length > 0) if (this.isFormatXY()) for (var a = i.series.map(function(d, u) {
        return d.data.filter(function(g, p, f) {
          return f.findIndex(function(x) {
            return x.x === g.x;
          }) === p;
        });
      }), n = a.reduce(function(d, u, g, p) {
        return p[d].length > u.length ? d : g;
      }, 0), o = 0; o < a[n].length; o++) r.push(o + 1);
      else for (var l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) r.push(l + 1);
      t.seriesX = [];
      for (var c = 0; c < e.length; c++) t.seriesX.push(r);
      this.w.globals.isBarHorizontal || (t.isXNumeric = !0);
    }
    if (r.length === 0) {
      r = t.axisCharts ? [] : t.series.map(function(d, u) {
        return u + 1;
      });
      for (var h = 0; h < e.length; h++) t.seriesX.push(r);
    }
    t.labels = r, i.xaxis.convertedCatToNumeric && (t.categoryLabels = r.map(function(d) {
      return i.xaxis.labels.formatter(d);
    })), t.noLabelsProvided = !0;
  } }, { key: "parseData", value: function(e) {
    var t = this.w, i = t.config, r = t.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), r.axisCharts ? (this.parseDataAxisCharts(e), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e), i.chart.stacked) {
      var a = new ct(this.ctx);
      r.series = a.setNullSeriesToZeroValues(r.series);
    }
    this.coreUtils.getSeriesTotals(), r.axisCharts && (r.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), r.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), r.dataFormatXNumeric || r.isXNumeric && (i.xaxis.type !== "numeric" || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(e);
    for (var n = this.coreUtils.getCategoryLabels(r.labels), o = 0; o < n.length; o++) if (Array.isArray(n[o])) {
      r.isMultiLineX = !0;
      break;
    }
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var e = this.w, t = [];
    e.globals.seriesYAxisMap.forEach(function(i, r) {
      var a = 0;
      i.forEach(function(n) {
        e.globals.collapsedSeriesIndices.indexOf(n) !== -1 && a++;
      }), a > 0 && a == i.length && t.push(r);
    }), e.globals.ignoreYAxisIndexes = t.map(function(i) {
      return i;
    });
  } }]), s;
}(), bi = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "svgStringToNode", value: function(e) {
    return new DOMParser().parseFromString(e, "image/svg+xml").documentElement;
  } }, { key: "scaleSvgNode", value: function(e, t) {
    var i = parseFloat(e.getAttributeNS(null, "width")), r = parseFloat(e.getAttributeNS(null, "height"));
    e.setAttributeNS(null, "width", i * t), e.setAttributeNS(null, "height", r * t), e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + r);
  } }, { key: "getSvgString", value: function(e) {
    var t = this;
    return new Promise(function(i) {
      var r = t.w, a = e || r.config.chart.toolbar.export.scale || r.config.chart.toolbar.export.width / r.globals.svgWidth;
      a || (a = 1);
      var n = r.globals.svgWidth * a, o = r.globals.svgHeight * a, l = r.globals.dom.elWrap.cloneNode(!0);
      l.style.width = n + "px", l.style.height = o + "px";
      var c = new XMLSerializer().serializeToString(l), h = `
        <svg xmlns="http://www.w3.org/2000/svg"
          version="1.1"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          class="apexcharts-svg"
          xmlns:data="ApexChartsNS"
          transform="translate(0, 0)"
          width="`.concat(r.globals.svgWidth, 'px" height="').concat(r.globals.svgHeight, `px">
          <foreignObject width="100%" height="100%">
            <div xmlns="http://www.w3.org/1999/xhtml" style="width:`).concat(n, "px; height:").concat(o, `px;">
            <style type="text/css">
              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {
                display: none;
              }
            </style>
              `).concat(c, `
            </div>
          </foreignObject>
        </svg>
      `), d = t.svgStringToNode(h);
      a !== 1 && t.scaleSvgNode(d, a), t.convertImagesToBase64(d).then(function() {
        h = new XMLSerializer().serializeToString(d), i(h.replace(/&nbsp;/g, "&#160;"));
      });
    });
  } }, { key: "convertImagesToBase64", value: function(e) {
    var t = this, i = e.getElementsByTagName("image"), r = Array.from(i).map(function(a) {
      var n = a.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      return n && !n.startsWith("data:") ? t.getBase64FromUrl(n).then(function(o) {
        a.setAttributeNS("http://www.w3.org/1999/xlink", "href", o);
      }).catch(function(o) {
        console.error("Error converting image to base64:", o);
      }) : Promise.resolve();
    });
    return Promise.all(r);
  } }, { key: "getBase64FromUrl", value: function(e) {
    return new Promise(function(t, i) {
      var r = new Image();
      r.crossOrigin = "Anonymous", r.onload = function() {
        var a = document.createElement("canvas");
        a.width = r.width, a.height = r.height, a.getContext("2d").drawImage(r, 0, 0), t(a.toDataURL());
      }, r.onerror = i, r.src = e;
    });
  } }, { key: "svgUrl", value: function() {
    var e = this;
    return new Promise(function(t) {
      e.getSvgString().then(function(i) {
        var r = new Blob([i], { type: "image/svg+xml;charset=utf-8" });
        t(URL.createObjectURL(r));
      });
    });
  } }, { key: "dataURI", value: function(e) {
    var t = this;
    return new Promise(function(i) {
      var r = t.w, a = e ? e.scale || e.width / r.globals.svgWidth : 1, n = document.createElement("canvas");
      n.width = r.globals.svgWidth * a, n.height = parseInt(r.globals.dom.elWrap.style.height, 10) * a;
      var o = r.config.chart.background !== "transparent" && r.config.chart.background ? r.config.chart.background : "#fff", l = n.getContext("2d");
      l.fillStyle = o, l.fillRect(0, 0, n.width * a, n.height * a), t.getSvgString(a).then(function(c) {
        var h = "data:image/svg+xml," + encodeURIComponent(c), d = new Image();
        d.crossOrigin = "anonymous", d.onload = function() {
          if (l.drawImage(d, 0, 0), n.msToBlob) {
            var u = n.msToBlob();
            i({ blob: u });
          } else {
            var g = n.toDataURL("image/png");
            i({ imgURI: g });
          }
        }, d.src = h;
      });
    });
  } }, { key: "exportToSVG", value: function() {
    var e = this;
    this.svgUrl().then(function(t) {
      e.triggerDownload(t, e.w.config.chart.toolbar.export.svg.filename, ".svg");
    });
  } }, { key: "exportToPng", value: function() {
    var e = this, t = this.w.config.chart.toolbar.export.scale, i = this.w.config.chart.toolbar.export.width, r = t ? { scale: t } : i ? { width: i } : void 0;
    this.dataURI(r).then(function(a) {
      var n = a.imgURI, o = a.blob;
      o ? navigator.msSaveOrOpenBlob(o, e.w.globals.chartID + ".png") : e.triggerDownload(n, e.w.config.chart.toolbar.export.png.filename, ".png");
    });
  } }, { key: "exportToCSV", value: function(e) {
    var t = this, i = e.series, r = e.fileName, a = e.columnDelimiter, n = a === void 0 ? "," : a, o = e.lineDelimiter, l = o === void 0 ? `
` : o, c = this.w;
    i || (i = c.config.series);
    var h = [], d = [], u = "", g = c.globals.series.map(function(v, k) {
      return c.globals.collapsedSeriesIndices.indexOf(k) === -1 ? v : [];
    }), p = function(v) {
      return typeof c.config.chart.toolbar.export.csv.categoryFormatter == "function" ? c.config.chart.toolbar.export.csv.categoryFormatter(v) : c.config.xaxis.type === "datetime" && String(v).length >= 10 ? new Date(v).toDateString() : F.isNumber(v) ? v : v.split(n).join("");
    }, f = function(v) {
      return typeof c.config.chart.toolbar.export.csv.valueFormatter == "function" ? c.config.chart.toolbar.export.csv.valueFormatter(v) : v;
    }, x = Math.max.apply(Math, De(i.map(function(v) {
      return v.data ? v.data.length : 0;
    }))), m = new ea(this.ctx), b = new Lt(this.ctx), w = function(v) {
      var k = "";
      if (c.globals.axisCharts) {
        if (c.config.xaxis.type === "category" || c.config.xaxis.convertedCatToNumeric) if (c.globals.isBarHorizontal) {
          var S = c.globals.yLabelFormatters[0], C = new ct(t.ctx).getActiveConfigSeriesIndex();
          k = S(c.globals.labels[v], { seriesIndex: C, dataPointIndex: v, w: c });
        } else k = b.getLabel(c.globals.labels, c.globals.timescaleLabels, 0, v).text;
        c.config.xaxis.type === "datetime" && (c.config.xaxis.categories.length ? k = c.config.xaxis.categories[v] : c.config.labels.length && (k = c.config.labels[v]));
      } else k = c.config.labels[v];
      return k === null ? "nullvalue" : (Array.isArray(k) && (k = k.join(" ")), F.isNumber(k) ? k : k.split(n).join(""));
    }, y = function(v, k) {
      if (h.length && k === 0 && d.push(h.join(n)), v.data) {
        v.data = v.data.length && v.data || De(Array(x)).map(function() {
          return "";
        });
        for (var S = 0; S < v.data.length; S++) {
          h = [];
          var C = w(S);
          if (C !== "nullvalue") {
            if (C || (m.isFormatXY() ? C = i[k].data[S].x : m.isFormat2DArray() && (C = i[k].data[S] ? i[k].data[S][0] : "")), k === 0) {
              h.push(p(C));
              for (var M = 0; M < c.globals.series.length; M++) {
                var R, P = m.isFormatXY() ? (R = i[M].data[S]) === null || R === void 0 ? void 0 : R.y : g[M][S];
                h.push(f(P));
              }
            }
            (c.config.chart.type === "candlestick" || v.type && v.type === "candlestick") && (h.pop(), h.push(c.globals.seriesCandleO[k][S]), h.push(c.globals.seriesCandleH[k][S]), h.push(c.globals.seriesCandleL[k][S]), h.push(c.globals.seriesCandleC[k][S])), (c.config.chart.type === "boxPlot" || v.type && v.type === "boxPlot") && (h.pop(), h.push(c.globals.seriesCandleO[k][S]), h.push(c.globals.seriesCandleH[k][S]), h.push(c.globals.seriesCandleM[k][S]), h.push(c.globals.seriesCandleL[k][S]), h.push(c.globals.seriesCandleC[k][S])), c.config.chart.type === "rangeBar" && (h.pop(), h.push(c.globals.seriesRangeStart[k][S]), h.push(c.globals.seriesRangeEnd[k][S])), h.length && d.push(h.join(n));
          }
        }
      }
    };
    h.push(c.config.chart.toolbar.export.csv.headerCategory), c.config.chart.type === "boxPlot" ? (h.push("minimum"), h.push("q1"), h.push("median"), h.push("q3"), h.push("maximum")) : c.config.chart.type === "candlestick" ? (h.push("open"), h.push("high"), h.push("low"), h.push("close")) : c.config.chart.type === "rangeBar" ? (h.push("minimum"), h.push("maximum")) : i.map(function(v, k) {
      var S = (v.name ? v.name : "series-".concat(k)) + "";
      c.globals.axisCharts && h.push(S.split(n).join("") ? S.split(n).join("") : "series-".concat(k));
    }), c.globals.axisCharts || (h.push(c.config.chart.toolbar.export.csv.headerValue), d.push(h.join(n))), c.globals.allSeriesHasEqualX || !c.globals.axisCharts || c.config.xaxis.categories.length || c.config.labels.length ? i.map(function(v, k) {
      c.globals.axisCharts ? y(v, k) : ((h = []).push(p(c.globals.labels[k])), h.push(f(g[k])), d.push(h.join(n)));
    }) : function() {
      var v = /* @__PURE__ */ new Set(), k = {};
      i.forEach(function(S, C) {
        S == null || S.data.forEach(function(M) {
          var R, P;
          if (m.isFormatXY()) R = M.x, P = M.y;
          else {
            if (!m.isFormat2DArray()) return;
            R = M[0], P = M[1];
          }
          k[R] || (k[R] = Array(i.length).fill("")), k[R][C] = f(P), v.add(R);
        });
      }), h.length && d.push(h.join(n)), Array.from(v).sort().forEach(function(S) {
        d.push([p(S), k[S].join(n)]);
      });
    }(), u += d.join(l), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + u), r || c.config.chart.toolbar.export.csv.filename, ".csv");
  } }, { key: "triggerDownload", value: function(e, t, i) {
    var r = document.createElement("a");
    r.href = e, r.download = (t || this.w.globals.chartID) + i, document.body.appendChild(r), r.click(), document.body.removeChild(r);
  } }]), s;
}(), Ri = function() {
  function s(e, t) {
    te(this, s), this.ctx = e, this.elgrid = t, this.w = e.w;
    var i = this.w;
    this.axesUtils = new Lt(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
  }
  return ie(s, [{ key: "drawXaxis", value: function() {
    var e = this.w, t = new $(this.ctx), i = t.group({ class: "apexcharts-xaxis", transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")") }), r = t.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")") });
    i.add(r);
    for (var a = [], n = 0; n < this.xaxisLabels.length; n++) a.push(this.xaxisLabels[n]);
    if (this.drawXAxisLabelAndGroup(!0, t, r, a, e.globals.isXNumeric, function(p, f) {
      return f;
    }), e.globals.hasXaxisGroups) {
      var o = e.globals.groups;
      a = [];
      for (var l = 0; l < o.length; l++) a.push(o[l].title);
      var c = {};
      e.config.xaxis.group.style && (c.xaxisFontSize = e.config.xaxis.group.style.fontSize, c.xaxisFontFamily = e.config.xaxis.group.style.fontFamily, c.xaxisForeColors = e.config.xaxis.group.style.colors, c.fontWeight = e.config.xaxis.group.style.fontWeight, c.cssClass = e.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, t, r, a, !1, function(p, f) {
        return o[p].cols * f;
      }, c);
    }
    if (e.config.xaxis.title.text !== void 0) {
      var h = t.group({ class: "apexcharts-xaxis-title" }), d = t.drawText({ x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (e.config.xaxis.position === "bottom" ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY, text: e.config.xaxis.title.text, textAnchor: "middle", fontSize: e.config.xaxis.title.style.fontSize, fontFamily: e.config.xaxis.title.style.fontFamily, fontWeight: e.config.xaxis.title.style.fontWeight, foreColor: e.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass });
      h.add(d), i.add(h);
    }
    if (e.config.xaxis.axisBorder.show) {
      var u = e.globals.barPadForNumericAxis, g = t.drawLine(e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - u, this.offY, this.xaxisBorderWidth + u, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(g) : i.add(g);
    }
    return i;
  } }, { key: "drawXAxisLabelAndGroup", value: function(e, t, i, r, a, n) {
    var o, l = this, c = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, h = [], d = [], u = this.w, g = c.xaxisFontSize || this.xaxisFontSize, p = c.xaxisFontFamily || this.xaxisFontFamily, f = c.xaxisForeColors || this.xaxisForeColors, x = c.fontWeight || u.config.xaxis.labels.style.fontWeight, m = c.cssClass || u.config.xaxis.labels.style.cssClass, b = u.globals.padHorizontal, w = r.length, y = u.config.xaxis.type === "category" ? u.globals.dataPoints : w;
    if (y === 0 && w > y && (y = w), a) {
      var v = Math.max(Number(u.config.xaxis.tickAmount) || 1, y > 1 ? y - 1 : y);
      o = u.globals.gridWidth / Math.min(v, w - 1), b = b + n(0, o) / 2 + u.config.xaxis.labels.offsetX;
    } else o = u.globals.gridWidth / y, b = b + n(0, o) + u.config.xaxis.labels.offsetX;
    for (var k = function(C) {
      var M = b - n(C, o) / 2 + u.config.xaxis.labels.offsetX;
      C === 0 && w === 1 && o / 2 === b && y === 1 && (M = u.globals.gridWidth / 2);
      var R = l.axesUtils.getLabel(r, u.globals.timescaleLabels, M, C, h, g, e), P = 28;
      if (u.globals.rotateXLabels && e && (P = 22), u.config.xaxis.title.text && u.config.xaxis.position === "top" && (P += parseFloat(u.config.xaxis.title.style.fontSize) + 2), e || (P = P + parseFloat(g) + (u.globals.xAxisLabelsHeight - u.globals.xAxisGroupLabelsHeight) + (u.globals.rotateXLabels ? 10 : 0)), R = u.config.xaxis.tickAmount !== void 0 && u.config.xaxis.tickAmount !== "dataPoints" && u.config.xaxis.type !== "datetime" ? l.axesUtils.checkLabelBasedOnTickamount(C, R, w) : l.axesUtils.checkForOverflowingLabels(C, R, w, h, d), u.config.xaxis.labels.show) {
        var I = t.drawText({ x: R.x, y: l.offY + u.config.xaxis.labels.offsetY + P - (u.config.xaxis.position === "top" ? u.globals.xAxisHeight + u.config.xaxis.axisTicks.height - 2 : 0), text: R.text, textAnchor: "middle", fontWeight: R.isBold ? 600 : x, fontSize: g, fontFamily: p, foreColor: Array.isArray(f) ? e && u.config.xaxis.convertedCatToNumeric ? f[u.globals.minX + C - 1] : f[C] : f, isPlainText: !1, cssClass: (e ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + m });
        if (i.add(I), I.on("click", function(N) {
          if (typeof u.config.chart.events.xAxisLabelClick == "function") {
            var z = Object.assign({}, u, { labelIndex: C });
            u.config.chart.events.xAxisLabelClick(N, l.ctx, z);
          }
        }), e) {
          var D = document.createElementNS(u.globals.SVGNS, "title");
          D.textContent = Array.isArray(R.text) ? R.text.join(" ") : R.text, I.node.appendChild(D), R.text !== "" && (h.push(R.text), d.push(R));
        }
      }
      C < w - 1 && (b += n(C + 1, o));
    }, S = 0; S <= w - 1; S++) k(S);
  } }, { key: "drawXaxisInversed", value: function(e) {
    var t, i, r = this, a = this.w, n = new $(this.ctx), o = a.config.yaxis[0].opposite ? a.globals.translateYAxisX[e] : 0, l = n.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: e }), c = n.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o + ", 0)" });
    l.add(c);
    var h = [];
    if (a.config.yaxis[e].show) for (var d = 0; d < this.xaxisLabels.length; d++) h.push(this.xaxisLabels[d]);
    t = a.globals.gridHeight / h.length, i = -t / 2.2;
    var u = a.globals.yLabelFormatters[0], g = a.config.yaxis[0].labels;
    if (g.show) for (var p = function(v) {
      var k = h[v] === void 0 ? "" : h[v];
      k = u(k, { seriesIndex: e, dataPointIndex: v, w: a });
      var S = r.axesUtils.getYAxisForeColor(g.style.colors, e), C = 0;
      Array.isArray(k) && (C = k.length / 2 * parseInt(g.style.fontSize, 10));
      var M = g.offsetX - 15, R = "end";
      r.yaxis.opposite && (R = "start"), a.config.yaxis[0].labels.align === "left" ? (M = g.offsetX, R = "start") : a.config.yaxis[0].labels.align === "center" ? (M = g.offsetX, R = "middle") : a.config.yaxis[0].labels.align === "right" && (R = "end");
      var P = n.drawText({ x: M, y: i + t + g.offsetY - C, text: k, textAnchor: R, foreColor: Array.isArray(S) ? S[v] : S, fontSize: g.style.fontSize, fontFamily: g.style.fontFamily, fontWeight: g.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + g.style.cssClass, maxWidth: g.maxWidth });
      c.add(P), P.on("click", function(N) {
        if (typeof a.config.chart.events.xAxisLabelClick == "function") {
          var z = Object.assign({}, a, { labelIndex: v });
          a.config.chart.events.xAxisLabelClick(N, r.ctx, z);
        }
      });
      var I = document.createElementNS(a.globals.SVGNS, "title");
      if (I.textContent = Array.isArray(k) ? k.join(" ") : k, P.node.appendChild(I), a.config.yaxis[e].labels.rotate !== 0) {
        var D = n.rotateAroundCenter(P.node);
        P.node.setAttribute("transform", "rotate(".concat(a.config.yaxis[e].labels.rotate, " 0 ").concat(D.y, ")"));
      }
      i += t;
    }, f = 0; f <= h.length - 1; f++) p(f);
    if (a.config.yaxis[0].title.text !== void 0) {
      var x = n.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o + ", 0)" }), m = n.drawText({ x: a.config.yaxis[0].title.offsetX, y: a.globals.gridHeight / 2 + a.config.yaxis[0].title.offsetY, text: a.config.yaxis[0].title.text, textAnchor: "middle", foreColor: a.config.yaxis[0].title.style.color, fontSize: a.config.yaxis[0].title.style.fontSize, fontWeight: a.config.yaxis[0].title.style.fontWeight, fontFamily: a.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[0].title.style.cssClass });
      x.add(m), l.add(x);
    }
    var b = 0;
    this.isCategoryBarHorizontal && a.config.yaxis[0].opposite && (b = a.globals.gridWidth);
    var w = a.config.xaxis.axisBorder;
    if (w.show) {
      var y = n.drawLine(a.globals.padHorizontal + w.offsetX + b, 1 + w.offsetY, a.globals.padHorizontal + w.offsetX + b, a.globals.gridHeight + w.offsetY, w.color, 0);
      this.elgrid && this.elgrid.elGridBorders && a.config.grid.show ? this.elgrid.elGridBorders.add(y) : l.add(y);
    }
    return a.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b, h.length, a.config.yaxis[0].axisBorder, a.config.yaxis[0].axisTicks, 0, t, l), l;
  } }, { key: "drawXaxisTicks", value: function(e, t, i) {
    var r = this.w, a = e;
    if (!(e < 0 || e - 2 > r.globals.gridWidth)) {
      var n = this.offY + r.config.xaxis.axisTicks.offsetY;
      if (t = t + n + r.config.xaxis.axisTicks.height, r.config.xaxis.position === "top" && (t = n - r.config.xaxis.axisTicks.height), r.config.xaxis.axisTicks.show) {
        var o = new $(this.ctx).drawLine(e + r.config.xaxis.axisTicks.offsetX, n + r.config.xaxis.offsetY, a + r.config.xaxis.axisTicks.offsetX, t + r.config.xaxis.offsetY, r.config.xaxis.axisTicks.color);
        i.add(o), o.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var e = this.w, t = [], i = this.xaxisLabels.length, r = e.globals.padHorizontal;
    if (e.globals.timescaleLabels.length > 0) for (var a = 0; a < i; a++) r = this.xaxisLabels[a].position, t.push(r);
    else for (var n = i, o = 0; o < n; o++) {
      var l = n;
      e.globals.isXNumeric && e.config.chart.type !== "bar" && (l -= 1), r += e.globals.gridWidth / l, t.push(r);
    }
    return t;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var e = this.w, t = new $(this.ctx), i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
    if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways) for (var o = 0; o < r.length; o++) {
      var l = t.rotateAroundCenter(r[o]);
      l.y = l.y - 1, l.x = l.x + 1, r[o].setAttribute("transform", "rotate(".concat(e.config.xaxis.labels.rotate, " ").concat(l.x, " ").concat(l.y, ")")), r[o].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
      var c = r[o].childNodes;
      e.config.xaxis.labels.trim && Array.prototype.forEach.call(c, function(g) {
        t.placeTextWithEllipsis(g, g.textContent, e.globals.xAxisLabelsHeight - (e.config.legend.position === "bottom" ? 20 : 10));
      });
    }
    else (function() {
      for (var g = e.globals.gridWidth / (e.globals.labels.length + 1), p = 0; p < r.length; p++) {
        var f = r[p].childNodes;
        e.config.xaxis.labels.trim && e.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(f, function(x) {
          t.placeTextWithEllipsis(x, x.textContent, g);
        });
      }
    })();
    if (a.length > 0) {
      var h = a[a.length - 1].getBBox(), d = a[0].getBBox();
      h.x < -20 && a[a.length - 1].parentNode.removeChild(a[a.length - 1]), d.x + d.width > e.globals.gridWidth && !e.globals.isBarHorizontal && a[0].parentNode.removeChild(a[0]);
      for (var u = 0; u < n.length; u++) t.placeTextWithEllipsis(n[u], n[u].textContent, e.config.yaxis[0].labels.maxWidth - (e.config.yaxis[0].title.text ? 2 * parseFloat(e.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), s;
}(), Ro = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.xaxisLabels = t.globals.labels.slice(), this.axesUtils = new Lt(e), this.isRangeBar = t.globals.seriesRange.length && t.globals.isBarHorizontal, t.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t.globals.timescaleLabels.slice());
  }
  return ie(s, [{ key: "drawGridArea", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = this.w, i = new $(this.ctx);
    e || (e = i.group({ class: "apexcharts-grid" }));
    var r = i.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent"), a = i.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
    return e.add(a), e.add(r), e;
  } }, { key: "drawGrid", value: function() {
    if (this.w.globals.axisCharts) {
      var e = this.renderGrid();
      return this.drawGridArea(e.el), e;
    }
    return null;
  } }, { key: "createGridMask", value: function() {
    var e = this.w, t = e.globals, i = new $(this.ctx), r = Array.isArray(e.config.stroke.width) ? Math.max.apply(Math, De(e.config.stroke.width)) : e.config.stroke.width, a = function(h) {
      var d = document.createElementNS(t.SVGNS, "clipPath");
      return d.setAttribute("id", h), d;
    };
    t.dom.elGridRectMask = a("gridRectMask".concat(t.cuid)), t.dom.elGridRectBarMask = a("gridRectBarMask".concat(t.cuid)), t.dom.elGridRectMarkerMask = a("gridRectMarkerMask".concat(t.cuid)), t.dom.elForecastMask = a("forecastMask".concat(t.cuid)), t.dom.elNonForecastMask = a("nonForecastMask".concat(t.cuid));
    var n = 0, o = 0;
    (["bar", "rangeBar", "candlestick", "boxPlot"].includes(e.config.chart.type) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (n = Math.max(e.config.grid.padding.left, t.barPadForNumericAxis), o = Math.max(e.config.grid.padding.right, t.barPadForNumericAxis)), t.dom.elGridRect = i.drawRect(-r / 2 - 2, -r / 2 - 2, t.gridWidth + r + 4, t.gridHeight + r + 4, 0, "#fff"), t.dom.elGridRectBar = i.drawRect(-r / 2 - n - 2, -r / 2 - 2, t.gridWidth + r + o + n + 4, t.gridHeight + r + 4, 0, "#fff");
    var l = e.globals.markers.largestSize;
    t.dom.elGridRectMarker = i.drawRect(-l, -l, t.gridWidth + 2 * l, t.gridHeight + 2 * l, 0, "#fff"), t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node), t.dom.elGridRectBarMask.appendChild(t.dom.elGridRectBar.node), t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
    var c = t.dom.baseEl.querySelector("defs");
    c.appendChild(t.dom.elGridRectMask), c.appendChild(t.dom.elGridRectBarMask), c.appendChild(t.dom.elGridRectMarkerMask), c.appendChild(t.dom.elForecastMask), c.appendChild(t.dom.elNonForecastMask);
  } }, { key: "_drawGridLines", value: function(e) {
    var t = e.i, i = e.x1, r = e.y1, a = e.x2, n = e.y2, o = e.xCount, l = e.parent, c = this.w;
    if (!(t === 0 && c.globals.skipFirstTimelinelabel || t === o - 1 && c.globals.skipLastTimelinelabel && !c.config.xaxis.labels.formatter || c.config.chart.type === "radar")) {
      c.config.grid.xaxis.lines.show && this._drawGridLine({ i: t, x1: i, y1: r, x2: a, y2: n, xCount: o, parent: l });
      var h = 0;
      if (c.globals.hasXaxisGroups && c.config.xaxis.tickPlacement === "between") {
        var d = c.globals.groups;
        if (d) {
          for (var u = 0, g = 0; u < t && g < d.length; g++) u += d[g].cols;
          u === t && (h = 0.6 * c.globals.xAxisLabelsHeight);
        }
      }
      new Ri(this.ctx).drawXaxisTicks(i, h, c.globals.dom.elGraphical);
    }
  } }, { key: "_drawGridLine", value: function(e) {
    var t = e.i, i = e.x1, r = e.y1, a = e.x2, n = e.y2, o = e.xCount, l = e.parent, c = this.w, h = l.node.classList.contains("apexcharts-gridlines-horizontal"), d = c.globals.barPadForNumericAxis, u = r === 0 && n === 0 || i === 0 && a === 0 || r === c.globals.gridHeight && n === c.globals.gridHeight || c.globals.isBarHorizontal && (t === 0 || t === o - 1), g = new $(this).drawLine(i - (h ? d : 0), r, a + (h ? d : 0), n, c.config.grid.borderColor, c.config.grid.strokeDashArray);
    g.node.classList.add("apexcharts-gridline"), u && c.config.grid.show ? this.elGridBorders.add(g) : l.add(g);
  } }, { key: "_drawGridBandRect", value: function(e) {
    var t = e.c, i = e.x1, r = e.y1, a = e.x2, n = e.y2, o = e.type, l = this.w, c = new $(this.ctx), h = l.globals.barPadForNumericAxis, d = l.config.grid[o].colors[t], u = c.drawRect(i - (o === "row" ? h : 0), r, a + (o === "row" ? 2 * h : 0), n, 0, d, l.config.grid[o].opacity);
    this.elg.add(u), u.attr("clip-path", "url(#gridRectMask".concat(l.globals.cuid, ")")), u.node.classList.add("apexcharts-grid-".concat(o));
  } }, { key: "_drawXYLines", value: function(e) {
    var t = this, i = e.xCount, r = e.tickAmount, a = this.w;
    if (a.config.grid.xaxis.lines.show || a.config.xaxis.axisTicks.show) {
      var n, o = a.globals.padHorizontal, l = a.globals.gridHeight;
      a.globals.timescaleLabels.length ? function(p) {
        for (var f = p.xC, x = p.x1, m = p.y1, b = p.x2, w = p.y2, y = 0; y < f; y++) x = t.xaxisLabels[y].position, b = t.xaxisLabels[y].position, t._drawGridLines({ i: y, x1: x, y1: m, x2: b, y2: w, xCount: i, parent: t.elgridLinesV });
      }({ xC: i, x1: o, y1: 0, x2: n, y2: l }) : (a.globals.isXNumeric && (i = a.globals.xAxisScale.result.length), function(p) {
        for (var f = p.xC, x = p.x1, m = p.y1, b = p.x2, w = p.y2, y = 0; y < f + (a.globals.isXNumeric ? 0 : 1); y++) y === 0 && f === 1 && a.globals.dataPoints === 1 && (b = x = a.globals.gridWidth / 2), t._drawGridLines({ i: y, x1: x, y1: m, x2: b, y2: w, xCount: i, parent: t.elgridLinesV }), b = x += a.globals.gridWidth / (a.globals.isXNumeric ? f - 1 : f);
      }({ xC: i, x1: o, y1: 0, x2: n, y2: l }));
    }
    if (a.config.grid.yaxis.lines.show) {
      var c = 0, h = 0, d = a.globals.gridWidth, u = r + 1;
      this.isRangeBar && (u = a.globals.labels.length);
      for (var g = 0; g < u + (this.isRangeBar ? 1 : 0); g++) this._drawGridLine({ i: g, xCount: u + (this.isRangeBar ? 1 : 0), x1: 0, y1: c, x2: d, y2: h, parent: this.elgridLinesH }), h = c += a.globals.gridHeight / (this.isRangeBar ? u : r);
    }
  } }, { key: "_drawInvertedXYLines", value: function(e) {
    var t = e.xCount, i = this.w;
    if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) for (var r, a = i.globals.padHorizontal, n = i.globals.gridHeight, o = 0; o < t + 1; o++)
      i.config.grid.xaxis.lines.show && this._drawGridLine({ i: o, xCount: t + 1, x1: a, y1: 0, x2: r, y2: n, parent: this.elgridLinesV }), new Ri(this.ctx).drawXaxisTicks(a, 0, i.globals.dom.elGraphical), r = a += i.globals.gridWidth / t;
    if (i.config.grid.yaxis.lines.show) for (var l = 0, c = 0, h = i.globals.gridWidth, d = 0; d < i.globals.dataPoints + 1; d++) this._drawGridLine({ i: d, xCount: i.globals.dataPoints + 1, x1: 0, y1: l, x2: h, y2: c, parent: this.elgridLinesH }), c = l += i.globals.gridHeight / i.globals.dataPoints;
  } }, { key: "renderGrid", value: function() {
    var e = this.w, t = e.globals, i = new $(this.ctx);
    this.elg = i.group({ class: "apexcharts-grid" }), this.elgridLinesH = i.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), e.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var r = 0; r < t.seriesYAxisMap.length && t.ignoreYAxisIndexes.includes(r); ) r++;
    r === t.seriesYAxisMap.length && (r = 0);
    var a, n = t.yAxisScale[r].result.length - 1;
    if (!t.isBarHorizontal || this.isRangeBar) {
      var o, l, c;
      a = this.xaxisLabels.length, this.isRangeBar && (n = t.labels.length, e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (a = e.config.xaxis.tickAmount), ((o = t.yAxisScale) === null || o === void 0 || (l = o[r]) === null || l === void 0 || (c = l.result) === null || c === void 0 ? void 0 : c.length) > 0 && e.config.xaxis.type !== "datetime" && (a = t.yAxisScale[r].result.length - 1)), this._drawXYLines({ xCount: a, tickAmount: n });
    } else a = n, n = t.xTickAmount, this._drawInvertedXYLines({ xCount: a, tickAmount: n });
    return this.drawGridBands(a, n), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.gridWidth / a };
  } }, { key: "drawGridBands", value: function(e, t) {
    var i, r, a = this, n = this.w;
    if (((i = n.config.grid.row.colors) === null || i === void 0 ? void 0 : i.length) > 0 && function(p, f, x, m, b, w) {
      for (var y = 0, v = 0; y < f; y++, v++) v >= n.config.grid[p].colors.length && (v = 0), a._drawGridBandRect({ c: v, x1: x, y1: m, x2: b, y2: w, type: p }), m += n.globals.gridHeight / t;
    }("row", t, 0, 0, n.globals.gridWidth, n.globals.gridHeight / t), ((r = n.config.grid.column.colors) === null || r === void 0 ? void 0 : r.length) > 0) {
      var o = n.globals.isBarHorizontal || n.config.xaxis.tickPlacement !== "on" || n.config.xaxis.type !== "category" && !n.config.xaxis.convertedCatToNumeric ? e : e - 1;
      n.globals.isXNumeric && (o = n.globals.xAxisScale.result.length - 1);
      for (var l = n.globals.padHorizontal, c = n.globals.padHorizontal + n.globals.gridWidth / o, h = n.globals.gridHeight, d = 0, u = 0; d < e; d++, u++) {
        var g;
        u >= n.config.grid.column.colors.length && (u = 0), n.config.xaxis.type === "datetime" && (l = this.xaxisLabels[d].position, c = (((g = this.xaxisLabels[d + 1]) === null || g === void 0 ? void 0 : g.position) || n.globals.gridWidth) - this.xaxisLabels[d].position), this._drawGridBandRect({ c: u, x1: l, y1: 0, x2: c, y2: h, type: "column" }), l += n.globals.gridWidth / o;
      }
    }
  } }]), s;
}(), Po = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.coreUtils = new ze(this.ctx);
  }
  return ie(s, [{ key: "niceScale", value: function(e, t) {
    var i, r, a, n, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, l = 1e-11, c = this.w, h = c.globals;
    h.isBarHorizontal ? (i = c.config.xaxis, r = Math.max((h.svgWidth - 100) / 25, 2)) : (i = c.config.yaxis[o], r = Math.max((h.svgHeight - 100) / 15, 2)), F.isNumber(r) || (r = 10), a = i.min !== void 0 && i.min !== null, n = i.max !== void 0 && i.min !== null;
    var d = i.stepSize !== void 0 && i.stepSize !== null, u = i.tickAmount !== void 0 && i.tickAmount !== null, g = u ? i.tickAmount : h.niceScaleDefaultTicks[Math.min(Math.round(r / 2), h.niceScaleDefaultTicks.length - 1)];
    if (h.isMultipleYAxis && !u && h.multiAxisTickAmount > 0 && (g = h.multiAxisTickAmount, u = !0), g = g === "dataPoints" ? h.dataPoints - 1 : Math.abs(Math.round(g)), (e === Number.MIN_VALUE && t === 0 || !F.isNumber(e) && !F.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE) && (e = F.isNumber(i.min) ? i.min : 0, t = F.isNumber(i.max) ? i.max : e + g, h.allSeriesCollapsed = !1), e > t) {
      console.warn("axis.min cannot be greater than axis.max: swapping min and max");
      var p = t;
      t = e, e = p;
    } else e === t && (e = e === 0 ? 0 : e - 1, t = t === 0 ? 2 : t + 1);
    var f = [];
    g < 1 && (g = 1);
    var x = g, m = Math.abs(t - e);
    !a && e > 0 && e / m < 0.15 && (e = 0, a = !0), !n && t < 0 && -t / m < 0.15 && (t = 0, n = !0);
    var b = (m = Math.abs(t - e)) / x, w = b, y = Math.floor(Math.log10(w)), v = Math.pow(10, y), k = Math.ceil(w / v);
    if (b = w = (k = h.niceScaleAllowedMagMsd[h.yValueDecimal === 0 ? 0 : 1][k]) * v, h.isBarHorizontal && i.stepSize && i.type !== "datetime" ? (b = i.stepSize, d = !0) : d && (b = i.stepSize), d && i.forceNiceScale) {
      var S = Math.floor(Math.log10(b));
      b *= Math.pow(10, y - S);
    }
    if (a && n) {
      var C = m / x;
      if (u) if (d) if (F.mod(m, b) != 0) {
        var M = F.getGCD(b, C);
        b = C / M < 10 ? M : C;
      } else F.mod(b, C) == 0 ? b = C : (C = b, u = !1);
      else b = C;
      else if (d) F.mod(m, b) == 0 ? C = b : b = C;
      else if (F.mod(m, b) == 0) C = b;
      else {
        C = m / (x = Math.ceil(m / b));
        var R = F.getGCD(m, b);
        m / R < r && (C = R), b = C;
      }
      x = Math.round(m / b);
    } else {
      if (a || n) {
        if (n) if (u) e = t - b * x;
        else {
          var P = e;
          e = b * Math.floor(e / b), Math.abs(t - e) / F.getGCD(m, b) > r && (e = t - b * g, e += b * Math.floor((P - e) / b));
        }
        else if (a) if (u) t = e + b * x;
        else {
          var I = t;
          t = b * Math.ceil(t / b), Math.abs(t - e) / F.getGCD(m, b) > r && (t = e + b * g, t += b * Math.ceil((I - t) / b));
        }
      } else if (h.isMultipleYAxis && u) {
        var D = b * Math.floor(e / b), N = D + b * x;
        N < t && (b *= 2), N = t, t = (e = D) + b * x, m = Math.abs(t - e), e > 0 && e < Math.abs(N - t) && (e = 0, t = b * x), t < 0 && -t < Math.abs(D - e) && (t = 0, e = -b * x);
      } else e = b * Math.floor(e / b), t = b * Math.ceil(t / b);
      m = Math.abs(t - e), b = F.getGCD(m, b), x = Math.round(m / b);
    }
    if (u || a || n || (x = Math.ceil((m - l) / (b + l))) > 16 && F.getPrimeFactors(x).length < 2 && x++, !u && i.forceNiceScale && h.yValueDecimal === 0 && x > m && (x = m, b = Math.round(m / x)), x > r && (!u && !d || i.forceNiceScale)) {
      var z = F.getPrimeFactors(x), L = z.length - 1, T = x;
      e: for (var H = 0; H < L; H++) for (var B = 0; B <= L - H; B++) {
        for (var _ = Math.min(B + H, L), O = T, Y = 1, X = B; X <= _; X++) Y *= z[X];
        if ((O /= Y) < r) {
          T = O;
          break e;
        }
      }
      b = T === x ? m : m / T, x = Math.round(m / b);
    }
    h.isMultipleYAxis && h.multiAxisTickAmount == 0 && h.ignoreYAxisIndexes.indexOf(o) < 0 && (h.multiAxisTickAmount = x);
    var V = e - b, W = b * l;
    do
      V += b, f.push(F.stripNumber(V, 7));
    while (t - V > W);
    return { result: f, niceMin: f[0], niceMax: f[f.length - 1] };
  } }, { key: "linearScale", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0, n = Math.abs(t - e), o = [];
    if (e === t) return { result: o = [e], niceMin: o[0], niceMax: o[o.length - 1] };
    (i = this._adjustTicksForSmallRange(i, r, n)) === "dataPoints" && (i = this.w.globals.dataPoints - 1), a || (a = n / i), a = Math.round(100 * (a + Number.EPSILON)) / 100, i === Number.MAX_VALUE && (i = 5, a = 1);
    for (var l = e; i >= 0; ) o.push(l), l = F.preciseAddition(l, a), i -= 1;
    return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
  } }, { key: "logarithmicScaleNice", value: function(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    for (var r = [], a = Math.ceil(Math.log(t) / Math.log(i) + 1), n = Math.floor(Math.log(e) / Math.log(i)); n < a; n++) r.push(Math.pow(i, n));
    return { result: r, niceMin: r[0], niceMax: r[r.length - 1] };
  } }, { key: "logarithmicScale", value: function(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    for (var r = [], a = Math.log(t) / Math.log(i), n = Math.log(e) / Math.log(i), o = a - n, l = Math.round(o), c = o / l, h = 0, d = n; h < l; h++, d += c) r.push(Math.pow(i, d));
    return r.push(Math.pow(i, a)), { result: r, niceMin: e, niceMax: t };
  } }, { key: "_adjustTicksForSmallRange", value: function(e, t, i) {
    var r = e;
    if (t !== void 0 && this.w.config.yaxis[t].labels.formatter && this.w.config.yaxis[t].tickAmount === void 0) {
      var a = Number(this.w.config.yaxis[t].labels.formatter(1));
      F.isNumber(a) && this.w.globals.yValueDecimal === 0 && (r = Math.ceil(i));
    }
    return r < e ? r : e;
  } }, { key: "setYScaleForIndex", value: function(e, t, i) {
    var r = this.w.globals, a = this.w.config, n = r.isBarHorizontal ? a.xaxis : a.yaxis[e];
    r.yAxisScale[e] === void 0 && (r.yAxisScale[e] = []);
    var o = Math.abs(i - t);
    n.logarithmic && o <= 5 && (r.invalidLogScale = !0), n.logarithmic && o > 5 ? (r.allSeriesCollapsed = !1, r.yAxisScale[e] = n.forceNiceScale ? this.logarithmicScaleNice(t, i, n.logBase) : this.logarithmicScale(t, i, n.logBase)) : i !== -Number.MAX_VALUE && F.isNumber(i) && t !== Number.MAX_VALUE && F.isNumber(t) ? (r.allSeriesCollapsed = !1, r.yAxisScale[e] = this.niceScale(t, i, e)) : r.yAxisScale[e] = this.niceScale(Number.MIN_VALUE, 0, e);
  } }, { key: "setXScale", value: function(e, t) {
    var i = this.w, r = i.globals;
    if (t !== -Number.MAX_VALUE && F.isNumber(t)) {
      var a = r.xTickAmount;
      r.xAxisScale = this.linearScale(e, t, a, 0, i.config.xaxis.stepSize);
    } else r.xAxisScale = this.linearScale(0, 10, 10);
    return r.xAxisScale;
  } }, { key: "scaleMultipleYAxes", value: function() {
    var e = this, t = this.w.config, i = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var r = i.seriesYAxisMap, a = i.minYArr, n = i.maxYArr;
    i.allSeriesCollapsed = !0, i.barGroups = [], r.forEach(function(o, l) {
      var c = [];
      o.forEach(function(h) {
        var d, u = (d = t.series[h]) === null || d === void 0 ? void 0 : d.group;
        c.indexOf(u) < 0 && c.push(u);
      }), o.length > 0 ? function() {
        var h, d, u = Number.MAX_VALUE, g = -Number.MAX_VALUE, p = u, f = g;
        if (t.chart.stacked) (function() {
          var b = new Array(i.dataPoints).fill(0), w = [], y = [], v = [];
          c.forEach(function() {
            w.push(b.map(function() {
              return Number.MIN_VALUE;
            })), y.push(b.map(function() {
              return Number.MIN_VALUE;
            })), v.push(b.map(function() {
              return Number.MIN_VALUE;
            }));
          });
          for (var k = function(C) {
            !h && t.series[o[C]].type && (h = t.series[o[C]].type);
            var M = o[C];
            d = t.series[M].group ? t.series[M].group : "axis-".concat(l), !(i.collapsedSeriesIndices.indexOf(M) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(M) < 0) || (i.allSeriesCollapsed = !1, c.forEach(function(R, P) {
              if (t.series[M].group === R) for (var I = 0; I < i.series[M].length; I++) {
                var D = i.series[M][I];
                D >= 0 ? y[P][I] += D : v[P][I] += D, w[P][I] += D, p = Math.min(p, D), f = Math.max(f, D);
              }
            })), h !== "bar" && h !== "column" || i.barGroups.push(d);
          }, S = 0; S < o.length; S++) k(S);
          h || (h = t.chart.type), h === "bar" || h === "column" ? c.forEach(function(C, M) {
            u = Math.min(u, Math.min.apply(null, v[M])), g = Math.max(g, Math.max.apply(null, y[M]));
          }) : (c.forEach(function(C, M) {
            p = Math.min(p, Math.min.apply(null, w[M])), f = Math.max(f, Math.max.apply(null, w[M]));
          }), u = p, g = f), u === Number.MIN_VALUE && g === Number.MIN_VALUE && (g = -Number.MAX_VALUE);
        })();
        else for (var x = 0; x < o.length; x++) {
          var m = o[x];
          u = Math.min(u, a[m]), g = Math.max(g, n[m]), !(i.collapsedSeriesIndices.indexOf(m) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(m) < 0) || (i.allSeriesCollapsed = !1);
        }
        t.yaxis[l].min !== void 0 && (u = typeof t.yaxis[l].min == "function" ? t.yaxis[l].min(u) : t.yaxis[l].min), t.yaxis[l].max !== void 0 && (g = typeof t.yaxis[l].max == "function" ? t.yaxis[l].max(g) : t.yaxis[l].max), i.barGroups = i.barGroups.filter(function(b, w, y) {
          return y.indexOf(b) === w;
        }), e.setYScaleForIndex(l, u, g), o.forEach(function(b) {
          a[b] = i.yAxisScale[l].niceMin, n[b] = i.yAxisScale[l].niceMax;
        });
      }() : e.setYScaleForIndex(l, 0, -Number.MAX_VALUE);
    });
  } }]), s;
}(), ks = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.scales = new Po(e);
  }
  return ie(s, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, a = this.w.config, n = this.w.globals, o = -Number.MAX_VALUE, l = Number.MIN_VALUE;
    r === null && (r = e + 1);
    var c = n.series, h = c, d = c;
    a.chart.type === "candlestick" ? (h = n.seriesCandleL, d = n.seriesCandleH) : a.chart.type === "boxPlot" ? (h = n.seriesCandleO, d = n.seriesCandleC) : n.isRangeData && (h = n.seriesRangeStart, d = n.seriesRangeEnd);
    var u = !1;
    if (n.seriesX.length >= r) {
      var g, p = (g = n.brushSource) === null || g === void 0 ? void 0 : g.w.config.chart.brush;
      (a.chart.zoom.enabled && a.chart.zoom.autoScaleYaxis || p != null && p.enabled && p != null && p.autoScaleYaxis) && (u = !0);
    }
    for (var f = e; f < r; f++) {
      n.dataPoints = Math.max(n.dataPoints, c[f].length);
      var x = a.series[f].type;
      n.categoryLabels.length && (n.dataPoints = n.categoryLabels.filter(function(M) {
        return M !== void 0;
      }).length), n.labels.length && a.xaxis.type !== "datetime" && n.series.reduce(function(M, R) {
        return M + R.length;
      }, 0) !== 0 && (n.dataPoints = Math.max(n.dataPoints, n.labels.length));
      var m = 0, b = c[f].length - 1;
      if (u) {
        if (a.xaxis.min) for (; m < b && n.seriesX[f][m] < a.xaxis.min; m++) ;
        if (a.xaxis.max) for (; b > m && n.seriesX[f][b] > a.xaxis.max; b--) ;
      }
      for (var w = m; w <= b && w < n.series[f].length; w++) {
        var y = c[f][w];
        if (y !== null && F.isNumber(y)) {
          var v, k, S, C;
          switch (((v = d[f]) === null || v === void 0 ? void 0 : v[w]) !== void 0 && (o = Math.max(o, d[f][w]), t = Math.min(t, d[f][w])), ((k = h[f]) === null || k === void 0 ? void 0 : k[w]) !== void 0 && (t = Math.min(t, h[f][w]), i = Math.max(i, h[f][w])), x) {
            case "candlestick":
              n.seriesCandleC[f][w] !== void 0 && (o = Math.max(o, n.seriesCandleH[f][w]), t = Math.min(t, n.seriesCandleL[f][w]));
              break;
            case "boxPlot":
              n.seriesCandleC[f][w] !== void 0 && (o = Math.max(o, n.seriesCandleC[f][w]), t = Math.min(t, n.seriesCandleO[f][w]));
          }
          x && x !== "candlestick" && x !== "boxPlot" && x !== "rangeArea" && x !== "rangeBar" && (o = Math.max(o, n.series[f][w]), t = Math.min(t, n.series[f][w])), n.seriesGoals[f] && n.seriesGoals[f][w] && Array.isArray(n.seriesGoals[f][w]) && n.seriesGoals[f][w].forEach(function(M) {
            o = Math.max(o, M.value), t = Math.min(t, M.value);
          }), i = o, y = F.noExponents(y), F.isFloat(y) && (n.yValueDecimal = Math.max(n.yValueDecimal, y.toString().split(".")[1].length)), l > ((S = h[f]) === null || S === void 0 ? void 0 : S[w]) && ((C = h[f]) === null || C === void 0 ? void 0 : C[w]) < 0 && (l = h[f][w]);
        } else n.hasNullValues = !0;
      }
      x !== "bar" && x !== "column" || (l < 0 && o < 0 && (o = 0, i = Math.max(i, 0)), l === Number.MIN_VALUE && (l = 0, t = Math.min(t, 0)));
    }
    return a.chart.type === "rangeBar" && n.seriesRangeStart.length && n.isBarHorizontal && (l = t), a.chart.type === "bar" && (l < 0 && o < 0 && (o = 0), l === Number.MIN_VALUE && (l = 0)), { minY: l, maxY: o, lowestY: t, highestY: i };
  } }, { key: "setYRange", value: function() {
    var e = this.w.globals, t = this.w.config;
    e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE;
    var i, r = Number.MAX_VALUE;
    if (e.isMultipleYAxis) {
      r = Number.MAX_VALUE;
      for (var a = 0; a < e.series.length; a++) i = this.getMinYMaxY(a), e.minYArr[a] = i.lowestY, e.maxYArr[a] = i.highestY, r = Math.min(r, i.lowestY);
    }
    return i = this.getMinYMaxY(0, r, null, e.series.length), t.chart.type === "bar" ? (e.minY = i.minY, e.maxY = i.maxY) : (e.minY = i.lowestY, e.maxY = i.highestY), r = i.lowestY, t.chart.stacked && this._setStackedMinMax(), t.chart.type === "line" || t.chart.type === "area" || t.chart.type === "scatter" || t.chart.type === "candlestick" || t.chart.type === "boxPlot" || t.chart.type === "rangeBar" && !e.isBarHorizontal ? e.minY === Number.MIN_VALUE && r !== -Number.MAX_VALUE && r !== e.maxY && (e.minY = r) : e.minY = e.minY !== Number.MIN_VALUE ? Math.min(i.minY, e.minY) : i.minY, t.yaxis.forEach(function(n, o) {
      n.max !== void 0 && (typeof n.max == "number" ? e.maxYArr[o] = n.max : typeof n.max == "function" && (e.maxYArr[o] = n.max(e.isMultipleYAxis ? e.maxYArr[o] : e.maxY)), e.maxY = e.maxYArr[o]), n.min !== void 0 && (typeof n.min == "number" ? e.minYArr[o] = n.min : typeof n.min == "function" && (e.minYArr[o] = n.min(e.isMultipleYAxis ? e.minYArr[o] === Number.MIN_VALUE ? 0 : e.minYArr[o] : e.minY)), e.minY = e.minYArr[o]);
    }), e.isBarHorizontal && ["min", "max"].forEach(function(n) {
      t.xaxis[n] !== void 0 && typeof t.xaxis[n] == "number" && (n === "min" ? e.minY = t.xaxis[n] : e.maxY = t.xaxis[n]);
    }), e.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), e.minY = r) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY), e.minY = e.yAxisScale[0].niceMin, e.maxY = e.yAxisScale[0].niceMax, e.minYArr[0] = e.minY, e.maxYArr[0] = e.maxY), e.barGroups = [], e.lineGroups = [], e.areaGroups = [], t.series.forEach(function(n) {
      switch (n.type || t.chart.type) {
        case "bar":
        case "column":
          e.barGroups.push(n.group);
          break;
        case "line":
          e.lineGroups.push(n.group);
          break;
        case "area":
          e.areaGroups.push(n.group);
      }
    }), e.barGroups = e.barGroups.filter(function(n, o, l) {
      return l.indexOf(n) === o;
    }), e.lineGroups = e.lineGroups.filter(function(n, o, l) {
      return l.indexOf(n) === o;
    }), e.areaGroups = e.areaGroups.filter(function(n, o, l) {
      return l.indexOf(n) === o;
    }), { minY: e.minY, maxY: e.maxY, minYArr: e.minYArr, maxYArr: e.maxYArr, yAxisScale: e.yAxisScale };
  } }, { key: "setXRange", value: function() {
    var e = this.w.globals, t = this.w.config, i = t.xaxis.type === "numeric" || t.xaxis.type === "datetime" || t.xaxis.type === "category" && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
    if (e.isXNumeric && function() {
      for (var l = 0; l < e.series.length; l++) if (e.labels[l]) for (var c = 0; c < e.labels[l].length; c++) e.labels[l][c] !== null && F.isNumber(e.labels[l][c]) && (e.maxX = Math.max(e.maxX, e.labels[l][c]), e.initialMaxX = Math.max(e.maxX, e.labels[l][c]), e.minX = Math.min(e.minX, e.labels[l][c]), e.initialMinX = Math.min(e.minX, e.labels[l][c]));
    }(), e.noLabelsProvided && t.xaxis.categories.length === 0 && (e.maxX = e.labels[e.labels.length - 1], e.initialMaxX = e.labels[e.labels.length - 1], e.minX = 1, e.initialMinX = 1), e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
      var r = 10;
      if (t.xaxis.tickAmount === void 0) r = Math.round(e.svgWidth / 150), t.xaxis.type === "numeric" && e.dataPoints < 30 && (r = e.dataPoints - 1), r > e.dataPoints && e.dataPoints !== 0 && (r = e.dataPoints - 1);
      else if (t.xaxis.tickAmount === "dataPoints") {
        if (e.series.length > 1 && (r = e.series[e.maxValsInArrayIndex].length - 1), e.isXNumeric) {
          var a = Math.round(e.maxX - e.minX);
          a < 30 && (r = a - 1);
        }
      } else r = t.xaxis.tickAmount;
      if (e.xTickAmount = r, t.xaxis.max !== void 0 && typeof t.xaxis.max == "number" && (e.maxX = t.xaxis.max), t.xaxis.min !== void 0 && typeof t.xaxis.min == "number" && (e.minX = t.xaxis.min), t.xaxis.range !== void 0 && (e.minX = e.maxX - t.xaxis.range), e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE) if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
        for (var n = [], o = e.minX - 1; o < e.maxX; o++) n.push(o + 1);
        e.xAxisScale = { result: n, niceMin: n[0], niceMax: n[n.length - 1] };
      } else e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
      else e.xAxisScale = this.scales.linearScale(0, r, r, 0, t.xaxis.stepSize), e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, r - 1, 0, t.xaxis.stepSize), e.seriesX = e.labels.slice());
      i && (e.labels = e.xAxisScale.result.slice());
    }
    return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: e.minX, maxX: e.maxX };
  } }, { key: "setZRange", value: function() {
    var e = this.w.globals;
    if (e.isDataXYZ) {
      for (var t = 0; t < e.series.length; t++) if (e.seriesZ[t] !== void 0) for (var i = 0; i < e.seriesZ[t].length; i++) e.seriesZ[t][i] !== null && F.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]), e.minZ = Math.min(e.minZ, e.seriesZ[t][i]));
    }
  } }, { key: "_handleSingleDataPoint", value: function() {
    var e = this.w.globals, t = this.w.config;
    if (e.minX === e.maxX) {
      var i = new je(this.ctx);
      if (t.xaxis.type === "datetime") {
        var r = i.getDate(e.minX);
        t.xaxis.labels.datetimeUTC ? r.setUTCDate(r.getUTCDate() - 2) : r.setDate(r.getDate() - 2), e.minX = new Date(r).getTime();
        var a = i.getDate(e.maxX);
        t.xaxis.labels.datetimeUTC ? a.setUTCDate(a.getUTCDate() + 2) : a.setDate(a.getDate() + 2), e.maxX = new Date(a).getTime();
      } else (t.xaxis.type === "numeric" || t.xaxis.type === "category" && !e.noLabelsProvided) && (e.minX = e.minX - 2, e.initialMinX = e.minX, e.maxX = e.maxX + 2, e.initialMaxX = e.maxX);
    }
  } }, { key: "_getMinXDiff", value: function() {
    var e = this.w.globals;
    e.isXNumeric && e.seriesX.forEach(function(t, i) {
      if (t.length) {
        t.length === 1 && t.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]);
        var r = t.slice();
        r.sort(function(a, n) {
          return a - n;
        }), r.forEach(function(a, n) {
          if (n > 0) {
            var o = a - r[n - 1];
            o > 0 && (e.minXDiff = Math.min(o, e.minXDiff));
          }
        }), e.dataPoints !== 1 && e.minXDiff !== Number.MAX_VALUE || (e.minXDiff = 0.5);
      }
    });
  } }, { key: "_setStackedMinMax", value: function() {
    var e = this, t = this.w.globals;
    if (t.series.length) {
      var i = t.seriesGroups;
      i.length || (i = [this.w.globals.seriesNames.map(function(n) {
        return n;
      })]);
      var r = {}, a = {};
      i.forEach(function(n) {
        r[n] = [], a[n] = [], e.w.config.series.map(function(o, l) {
          return n.indexOf(t.seriesNames[l]) > -1 ? l : null;
        }).filter(function(o) {
          return o !== null;
        }).forEach(function(o) {
          for (var l = 0; l < t.series[t.maxValsInArrayIndex].length; l++) {
            var c, h, d, u;
            r[n][l] === void 0 && (r[n][l] = 0, a[n][l] = 0), (e.w.config.chart.stacked && !t.comboCharts || e.w.config.chart.stacked && t.comboCharts && (!e.w.config.chart.stackOnlyBar || ((c = e.w.config.series) === null || c === void 0 || (h = c[o]) === null || h === void 0 ? void 0 : h.type) === "bar" || ((d = e.w.config.series) === null || d === void 0 || (u = d[o]) === null || u === void 0 ? void 0 : u.type) === "column")) && t.series[o][l] !== null && F.isNumber(t.series[o][l]) && (t.series[o][l] > 0 ? r[n][l] += parseFloat(t.series[o][l]) + 1e-4 : a[n][l] += parseFloat(t.series[o][l]));
          }
        });
      }), Object.entries(r).forEach(function(n) {
        var o = qn(n, 1)[0];
        r[o].forEach(function(l, c) {
          t.maxY = Math.max(t.maxY, r[o][c]), t.minY = Math.min(t.minY, a[o][c]);
        });
      });
    }
  } }]), s;
}(), ta = function() {
  function s(e, t) {
    te(this, s), this.ctx = e, this.elgrid = t, this.w = e.w;
    var i = this.w;
    this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = i.config.xaxis.position === "bottom" ? i.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Lt(e);
  }
  return ie(s, [{ key: "drawYaxis", value: function(e) {
    var t = this.w, i = new $(this.ctx), r = t.config.yaxis[e].labels.style, a = r.fontSize, n = r.fontFamily, o = r.fontWeight, l = i.group({ class: "apexcharts-yaxis", rel: e, transform: "translate(".concat(t.globals.translateYAxisX[e], ", 0)") });
    if (this.axesUtils.isYAxisHidden(e)) return l;
    var c = i.group({ class: "apexcharts-yaxis-texts-g" });
    l.add(c);
    var h = t.globals.yAxisScale[e].result.length - 1, d = t.globals.gridHeight / h, u = t.globals.yLabelFormatters[e], g = this.axesUtils.checkForReversedLabels(e, t.globals.yAxisScale[e].result.slice());
    if (t.config.yaxis[e].labels.show) {
      var p = t.globals.translateY + t.config.yaxis[e].labels.offsetY;
      t.globals.isBarHorizontal ? p = 0 : t.config.chart.type === "heatmap" && (p -= d / 2), p += parseInt(a, 10) / 3;
      for (var f = h; f >= 0; f--) {
        var x = u(g[f], f, t), m = t.config.yaxis[e].labels.padding;
        t.config.yaxis[e].opposite && t.config.yaxis.length !== 0 && (m *= -1);
        var b = this.getTextAnchor(t.config.yaxis[e].labels.align, t.config.yaxis[e].opposite), w = this.axesUtils.getYAxisForeColor(r.colors, e), y = Array.isArray(w) ? w[f] : w, v = F.listToArray(t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-label tspan"))).map(function(S) {
          return S.textContent;
        }), k = i.drawText({ x: m, y: p, text: v.includes(x) && !t.config.yaxis[e].labels.showDuplicates ? "" : x, textAnchor: b, fontSize: a, fontFamily: n, fontWeight: o, maxWidth: t.config.yaxis[e].labels.maxWidth, foreColor: y, isPlainText: !1, cssClass: "apexcharts-yaxis-label ".concat(r.cssClass) });
        c.add(k), this.addTooltip(k, x), t.config.yaxis[e].labels.rotate !== 0 && this.rotateLabel(i, k, firstLabel, t.config.yaxis[e].labels.rotate), p += d;
      }
    }
    return this.addYAxisTitle(i, l, e), this.addAxisBorder(i, l, e, h, d), l;
  } }, { key: "getTextAnchor", value: function(e, t) {
    return e === "left" ? "start" : e === "center" ? "middle" : e === "right" ? "end" : t ? "start" : "end";
  } }, { key: "addTooltip", value: function(e, t) {
    var i = document.createElementNS(this.w.globals.SVGNS, "title");
    i.textContent = Array.isArray(t) ? t.join(" ") : t, e.node.appendChild(i);
  } }, { key: "rotateLabel", value: function(e, t, i, r) {
    var a = e.rotateAroundCenter(i.node), n = e.rotateAroundCenter(t.node);
    t.node.setAttribute("transform", "rotate(".concat(r, " ").concat(a.x, " ").concat(n.y, ")"));
  } }, { key: "addYAxisTitle", value: function(e, t, i) {
    var r = this.w;
    if (r.config.yaxis[i].title.text !== void 0) {
      var a = e.group({ class: "apexcharts-yaxis-title" }), n = r.config.yaxis[i].opposite ? r.globals.translateYAxisX[i] : 0, o = e.drawText({ x: n, y: r.globals.gridHeight / 2 + r.globals.translateY + r.config.yaxis[i].title.offsetY, text: r.config.yaxis[i].title.text, textAnchor: "end", foreColor: r.config.yaxis[i].title.style.color, fontSize: r.config.yaxis[i].title.style.fontSize, fontWeight: r.config.yaxis[i].title.style.fontWeight, fontFamily: r.config.yaxis[i].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(r.config.yaxis[i].title.style.cssClass) });
      a.add(o), t.add(a);
    }
  } }, { key: "addAxisBorder", value: function(e, t, i, r, a) {
    var n = this.w, o = n.config.yaxis[i].axisBorder, l = 31 + o.offsetX;
    if (n.config.yaxis[i].opposite && (l = -31 - o.offsetX), o.show) {
      var c = e.drawLine(l, n.globals.translateY + o.offsetY - 2, l, n.globals.gridHeight + n.globals.translateY + o.offsetY + 2, o.color, 0, o.width);
      t.add(c);
    }
    n.config.yaxis[i].axisTicks.show && this.axesUtils.drawYAxisTicks(l, r, o, n.config.yaxis[i].axisTicks, i, a, t);
  } }, { key: "drawYaxisInversed", value: function(e) {
    var t = this.w, i = new $(this.ctx), r = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), a = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")") });
    r.add(a);
    var n = t.globals.yAxisScale[e].result.length - 1, o = t.globals.gridWidth / n + 0.1, l = o + t.config.xaxis.labels.offsetX, c = t.globals.xLabelFormatter, h = this.axesUtils.checkForReversedLabels(e, t.globals.yAxisScale[e].result.slice()), d = t.globals.timescaleLabels;
    if (d.length > 0 && (this.xaxisLabels = d.slice(), n = (h = d.slice()).length), t.config.xaxis.labels.show) for (var u = d.length ? 0 : n; d.length ? u < d.length : u >= 0; d.length ? u++ : u--) {
      var g = c(h[u], u, t), p = t.globals.gridWidth + t.globals.padHorizontal - (l - o + t.config.xaxis.labels.offsetX);
      if (d.length) {
        var f = this.axesUtils.getLabel(h, d, p, u, this.drawnLabels, this.xaxisFontSize);
        p = f.x, g = f.text, this.drawnLabels.push(f.text), u === 0 && t.globals.skipFirstTimelinelabel && (g = ""), u === h.length - 1 && t.globals.skipLastTimelinelabel && (g = "");
      }
      var x = i.drawText({ x: p, y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - (t.config.xaxis.position === "top" ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0), text: g, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: t.config.xaxis.labels.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-xaxis-label ".concat(t.config.xaxis.labels.style.cssClass) });
      a.add(x), x.tspan(g), this.addTooltip(x, g), l += o;
    }
    return this.inversedYAxisTitleText(r), this.inversedYAxisBorder(r), r;
  } }, { key: "inversedYAxisBorder", value: function(e) {
    var t = this.w, i = new $(this.ctx), r = t.config.xaxis.axisBorder;
    if (r.show) {
      var a = 0;
      t.config.chart.type === "bar" && t.globals.isXNumeric && (a -= 15);
      var n = i.drawLine(t.globals.padHorizontal + a + r.offsetX, this.xAxisoffX, t.globals.gridWidth, this.xAxisoffX, r.color, 0, r.height);
      this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(n) : e.add(n);
    }
  } }, { key: "inversedYAxisTitleText", value: function(e) {
    var t = this.w, i = new $(this.ctx);
    if (t.config.xaxis.title.text !== void 0) {
      var r = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), a = i.drawText({ x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20, text: t.config.xaxis.title.text, textAnchor: "middle", fontSize: t.config.xaxis.title.style.fontSize, fontFamily: t.config.xaxis.title.style.fontFamily, fontWeight: t.config.xaxis.title.style.fontWeight, foreColor: t.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(t.config.xaxis.title.style.cssClass) });
      r.add(a), e.add(r);
    }
  } }, { key: "yAxisTitleRotate", value: function(e, t) {
    var i = this.w, r = new $(this.ctx), a = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g")), n = a ? a.getBoundingClientRect() : { width: 0, height: 0 }, o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text")), l = o ? o.getBoundingClientRect() : { width: 0, height: 0 };
    if (o) {
      var c = this.xPaddingForYAxisTitle(e, n, l, t);
      o.setAttribute("x", c.xPos - (t ? 10 : 0));
      var h = r.rotateAroundCenter(o);
      o.setAttribute("transform", "rotate(".concat(t ? -1 * i.config.yaxis[e].title.rotate : i.config.yaxis[e].title.rotate, " ").concat(h.x, " ").concat(h.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(e, t, i, r) {
    var a = this.w, n = 0, o = 10;
    return a.config.yaxis[e].title.text === void 0 || e < 0 ? { xPos: n, padd: 0 } : (r ? n = t.width + a.config.yaxis[e].title.offsetX + i.width / 2 + o / 2 : (n = -1 * t.width + a.config.yaxis[e].title.offsetX + o / 2 + i.width / 2, a.globals.isBarHorizontal && (o = 25, n = -1 * t.width - a.config.yaxis[e].title.offsetX - o)), { xPos: n, padd: o });
  } }, { key: "setYAxisXPosition", value: function(e, t) {
    var i = this.w, r = 0, a = 0, n = 18, o = 1;
    i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.forEach(function(l, c) {
      var h = i.globals.ignoreYAxisIndexes.includes(c) || !l.show || l.floating || e[c].width === 0, d = e[c].width + t[c].width;
      l.opposite ? i.globals.isBarHorizontal ? (a = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[c] = a - l.labels.offsetX) : (a = i.globals.gridWidth + i.globals.translateX + o, h || (o += d + 20), i.globals.translateYAxisX[c] = a - l.labels.offsetX + 20) : (r = i.globals.translateX - n, h || (n += d + 20), i.globals.translateYAxisX[c] = r + l.labels.offsetX);
    });
  } }, { key: "setYAxisTextAlignments", value: function() {
    var e = this.w;
    F.listToArray(e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach(function(t, i) {
      var r = e.config.yaxis[i];
      if (r && !r.floating && r.labels.align !== void 0) {
        var a = e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")), n = F.listToArray(e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"))), o = a.getBoundingClientRect();
        n.forEach(function(l) {
          l.setAttribute("text-anchor", r.labels.align);
        }), r.labels.align !== "left" || r.opposite ? r.labels.align === "center" ? a.setAttribute("transform", "translate(".concat(o.width / 2 * (r.opposite ? 1 : -1), ", 0)")) : r.labels.align === "right" && r.opposite && a.setAttribute("transform", "translate(".concat(o.width, ", 0)")) : a.setAttribute("transform", "translate(-".concat(o.width, ", 0)"));
      }
    });
  } }]), s;
}(), td = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.documentEvent = F.bind(this.documentEvent, this);
  }
  return ie(s, [{ key: "addEventListener", value: function(e, t) {
    var i = this.w;
    i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t];
  } }, { key: "removeEventListener", value: function(e, t) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(e)) {
      var r = i.globals.events[e].indexOf(t);
      r !== -1 && i.globals.events[e].splice(r, 1);
    }
  } }, { key: "fireEvent", value: function(e, t) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(e)) {
      t && t.length || (t = []);
      for (var r = i.globals.events[e], a = r.length, n = 0; n < a; n++) r[n].apply(null, t);
    }
  } }, { key: "setupEventHandlers", value: function() {
    var e = this, t = this.w, i = this.ctx, r = t.globals.dom.baseEl.querySelector(t.globals.chartClass);
    this.ctx.eventList.forEach(function(a) {
      r.addEventListener(a, function(n) {
        var o = n.target.getAttribute("i") === null && t.globals.capturedSeriesIndex !== -1 ? t.globals.capturedSeriesIndex : n.target.getAttribute("i"), l = n.target.getAttribute("j") === null && t.globals.capturedDataPointIndex !== -1 ? t.globals.capturedDataPointIndex : n.target.getAttribute("j"), c = Object.assign({}, t, { seriesIndex: t.globals.axisCharts ? o : 0, dataPointIndex: l });
        n.type === "mousemove" || n.type === "touchmove" ? typeof t.config.chart.events.mouseMove == "function" && t.config.chart.events.mouseMove(n, i, c) : n.type === "mouseleave" || n.type === "touchleave" ? typeof t.config.chart.events.mouseLeave == "function" && t.config.chart.events.mouseLeave(n, i, c) : (n.type === "mouseup" && n.which === 1 || n.type === "touchend") && (typeof t.config.chart.events.click == "function" && t.config.chart.events.click(n, i, c), i.ctx.events.fireEvent("click", [n, i, c]));
      }, { capture: !1, passive: !0 });
    }), this.ctx.eventList.forEach(function(a) {
      t.globals.dom.baseEl.addEventListener(a, e.documentEvent, { passive: !0 });
    }), this.ctx.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(e) {
    var t = this.w, i = e.target.className;
    if (e.type === "click") {
      var r = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
      r && r.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && r.classList.remove("apexcharts-menu-open");
    }
    t.globals.clientX = e.type === "touchmove" ? e.touches[0].clientX : e.clientX, t.globals.clientY = e.type === "touchmove" ? e.touches[0].clientY : e.clientY;
  } }]), s;
}(), id = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "setCurrentLocaleValues", value: function(e) {
    var t = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i = t.filter(function(a) {
      return a.name === e;
    })[0];
    if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var r = F.extend(Co, i);
    this.w.globals.locale = r.options;
  } }]), s;
}(), rd = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "drawAxis", value: function(e, t) {
    var i, r, a = this, n = this.w.globals, o = this.w.config, l = new Ri(this.ctx, t), c = new ta(this.ctx, t);
    n.axisCharts && e !== "radar" && (n.isBarHorizontal ? (r = c.drawYaxisInversed(0), i = l.drawXaxisInversed(0), n.dom.elGraphical.add(i), n.dom.elGraphical.add(r)) : (i = l.drawXaxis(), n.dom.elGraphical.add(i), o.yaxis.map(function(h, d) {
      if (n.ignoreYAxisIndexes.indexOf(d) === -1 && (r = c.drawYaxis(d), n.dom.Paper.add(r), a.w.config.grid.position === "back")) {
        var u = n.dom.Paper.children()[1];
        u.remove(), n.dom.Paper.add(u);
      }
    })));
  } }]), s;
}(), Ss = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "drawXCrosshairs", value: function() {
    var e = this.w, t = new $(this.ctx), i = new Ye(this.ctx), r = e.config.xaxis.crosshairs.fill.gradient, a = e.config.xaxis.crosshairs.dropShadow, n = e.config.xaxis.crosshairs.fill.type, o = r.colorFrom, l = r.colorTo, c = r.opacityFrom, h = r.opacityTo, d = r.stops, u = a.enabled, g = a.left, p = a.top, f = a.blur, x = a.color, m = a.opacity, b = e.config.xaxis.crosshairs.fill.color;
    if (e.config.xaxis.crosshairs.show) {
      n === "gradient" && (b = t.drawGradient("vertical", o, l, c, h, null, d, null));
      var w = t.drawRect();
      e.config.xaxis.crosshairs.width === 1 && (w = t.drawLine());
      var y = e.globals.gridHeight;
      (!F.isNumber(y) || y < 0) && (y = 0);
      var v = e.config.xaxis.crosshairs.width;
      (!F.isNumber(v) || v < 0) && (v = 0), w.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: y, width: v, height: y, fill: b, filter: "none", "fill-opacity": e.config.xaxis.crosshairs.opacity, stroke: e.config.xaxis.crosshairs.stroke.color, "stroke-width": e.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray }), u && (w = i.dropShadow(w, { left: g, top: p, blur: f, color: x, opacity: m })), e.globals.dom.elGraphical.add(w);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var e = this.w, t = new $(this.ctx), i = e.config.yaxis[0].crosshairs, r = e.globals.barPadForNumericAxis;
    if (e.config.yaxis[0].crosshairs.show) {
      var a = t.drawLine(-r, 0, e.globals.gridWidth + r, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
      a.attr({ class: "apexcharts-ycrosshairs" }), e.globals.dom.elGraphical.add(a);
    }
    var n = t.drawLine(-r, 0, e.globals.gridWidth + r, 0, i.stroke.color, 0, 0);
    n.attr({ class: "apexcharts-ycrosshairs-hidden" }), e.globals.dom.elGraphical.add(n);
  } }]), s;
}(), sd = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "checkResponsiveConfig", value: function(e) {
    var t = this, i = this.w, r = i.config;
    if (r.responsive.length !== 0) {
      var a = r.responsive.slice();
      a.sort(function(c, h) {
        return c.breakpoint > h.breakpoint ? 1 : h.breakpoint > c.breakpoint ? -1 : 0;
      }).reverse();
      var n = new Mi({}), o = function() {
        var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = a[0].breakpoint, d = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (d > h) {
          var u = F.clone(i.globals.initialConfig);
          u.series = F.clone(i.config.series);
          var g = ze.extendArrayProps(n, u, i);
          c = F.extend(g, c), c = F.extend(i.config, c), t.overrideResponsiveOptions(c);
        } else for (var p = 0; p < a.length; p++) d < a[p].breakpoint && (c = ze.extendArrayProps(n, a[p].options, i), c = F.extend(i.config, c), t.overrideResponsiveOptions(c));
      };
      if (e) {
        var l = ze.extendArrayProps(n, e, i);
        l = F.extend(i.config, l), o(l = F.extend(l, e));
      } else o({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(e) {
    var t = new Mi(e).init({ responsiveOverride: !0 });
    this.w.config = t;
  } }]), s;
}(), ad = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.colors = [], this.isColorFn = !1, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return ie(s, [{ key: "checkHeatmapDistributed", value: function() {
    var e = this.w.config, t = e.chart, i = e.plotOptions;
    return t.type === "treemap" && i.treemap && i.treemap.distributed || t.type === "heatmap" && i.heatmap && i.heatmap.distributed;
  } }, { key: "checkBarDistributed", value: function() {
    var e = this.w.config, t = e.chart, i = e.plotOptions;
    return i.bar && i.bar.distributed && (t.type === "bar" || t.type === "rangeBar");
  } }, { key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var e = this.w, t = new F();
    e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode || "light"));
    var i = De(e.config.colors || e.config.fill.colors || []);
    e.globals.colors = this.getColors(i), this.applySeriesColors(e.globals.seriesColors, e.globals.colors), e.config.theme.monochrome.enabled && (e.globals.colors = this.getMonochromeColors(e.config.theme.monochrome, e.globals.series, t));
    var r = e.globals.colors.slice();
    this.pushExtraColors(e.globals.colors), this.applyColorTypes(["fill", "stroke"], r), this.applyDataLabelsColors(r), this.applyRadarPolygonsColors(), this.applyMarkersColors(r);
  } }, { key: "getColors", value: function(e) {
    var t = this, i = this.w;
    return e && e.length !== 0 ? Array.isArray(e) && e.length > 0 && typeof e[0] == "function" ? (this.isColorFn = !0, i.config.series.map(function(r, a) {
      var n = e[a] || e[0];
      return typeof n == "function" ? n({ value: i.globals.axisCharts ? i.globals.series[a][0] || 0 : i.globals.series[a], seriesIndex: a, dataPointIndex: a, w: t.w }) : n;
    })) : e : this.predefined();
  } }, { key: "applySeriesColors", value: function(e, t) {
    e.forEach(function(i, r) {
      i && (t[r] = i);
    });
  } }, { key: "getMonochromeColors", value: function(e, t, i) {
    var r = e.color, a = e.shadeIntensity, n = e.shadeTo, o = this.isBarDistributed || this.isHeatmapDistributed ? t[0].length * t.length : t.length, l = 1 / (o / a), c = 0;
    return Array.from({ length: o }, function() {
      var h = n === "dark" ? i.shadeColor(-1 * c, r) : i.shadeColor(c, r);
      return c += l, h;
    });
  } }, { key: "applyColorTypes", value: function(e, t) {
    var i = this, r = this.w;
    e.forEach(function(a) {
      r.globals[a].colors = r.config[a].colors === void 0 ? i.isColorFn ? r.config.colors : t : r.config[a].colors.slice(), i.pushExtraColors(r.globals[a].colors);
    });
  } }, { key: "applyDataLabelsColors", value: function(e) {
    var t = this.w;
    t.globals.dataLabels.style.colors = t.config.dataLabels.style.colors === void 0 ? e : t.config.dataLabels.style.colors.slice(), this.pushExtraColors(t.globals.dataLabels.style.colors, 50);
  } }, { key: "applyRadarPolygonsColors", value: function() {
    var e = this.w;
    e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors === void 0 ? [e.config.theme.mode === "dark" ? "#343A3F" : "none"] : e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20);
  } }, { key: "applyMarkersColors", value: function(e) {
    var t = this.w;
    t.globals.markers.colors = t.config.markers.colors === void 0 ? e : t.config.markers.colors.slice(), this.pushExtraColors(t.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = this.w, a = t || r.globals.series.length;
    if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || r.config.chart.type === "heatmap" && r.config.plotOptions.heatmap && r.config.plotOptions.heatmap.colorScale.inverse), i && r.globals.series.length && (a = r.globals.series[r.globals.maxValsInArrayIndex].length * r.globals.series.length), e.length < a) for (var n = a - e.length, o = 0; o < n; o++) e.push(e[o]);
  } }, { key: "updateThemeOptions", value: function(e) {
    e.chart = e.chart || {}, e.tooltip = e.tooltip || {};
    var t = e.theme.mode, i = t === "dark" ? "palette4" : t === "light" ? "palette1" : e.theme.palette || "palette1", r = t === "dark" ? "#f6f7f8" : t === "light" ? "#373d3f" : e.chart.foreColor || "#373d3f";
    return e.tooltip.theme = t || "light", e.chart.foreColor = r, e.theme.palette = i, e;
  } }, { key: "predefined", value: function() {
    var e = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
    return e[this.w.config.theme.palette] || e.default;
  } }]), s;
}(), nd = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(e) {
    var t = this.w, i = e === "title" ? t.config.title : t.config.subtitle, r = t.globals.svgWidth / 2, a = i.offsetY, n = "middle";
    if (i.align === "left" ? (r = 10, n = "start") : i.align === "right" && (r = t.globals.svgWidth - 10, n = "end"), r += i.offsetX, a = a + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
      var o = new $(this.ctx).drawText({ x: r, y: a, text: i.text, textAnchor: n, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
      o.node.setAttribute("class", "apexcharts-".concat(e, "-text")), t.globals.dom.Paper.add(o);
    }
  } }]), s;
}(), od = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.dCtx = e;
  }
  return ie(s, [{ key: "getTitleSubtitleCoords", value: function(e) {
    var t = this.w, i = 0, r = 0, a = e === "title" ? t.config.title.floating : t.config.subtitle.floating, n = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
    if (n !== null && !a) {
      var o = n.getBoundingClientRect();
      i = o.width, r = t.globals.axisCharts ? o.height + 5 : o.height;
    }
    return { width: i, height: r };
  } }, { key: "getLegendsRect", value: function() {
    var e = this.w, t = e.globals.dom.elLegendWrap;
    e.config.legend.height || e.config.legend.position !== "top" && e.config.legend.position !== "bottom" || (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
    var i = Object.assign({}, F.getBoundingClientRect(t));
    return t !== null && !e.config.legend.floating && e.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, e.config.legend.position !== "left" && e.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: "getDatalabelsRect", value: function() {
    var e = this, t = this.w, i = [];
    t.config.series.forEach(function(l, c) {
      l.data.forEach(function(h, d) {
        var u;
        u = t.globals.series[c][d], r = t.config.dataLabels.formatter(u, { ctx: e.dCtx.ctx, seriesIndex: c, dataPointIndex: d, w: t }), i.push(r);
      });
    });
    var r = F.getLargestStringFromArr(i), a = new $(this.dCtx.ctx), n = t.config.dataLabels.style, o = a.getTextRects(r, parseInt(n.fontSize), n.fontFamily);
    return { width: 1.05 * o.width, height: o.height };
  } }, { key: "getLargestStringFromMultiArr", value: function(e, t) {
    var i = e;
    if (this.w.globals.isMultiLineX) {
      var r = t.map(function(n, o) {
        return Array.isArray(n) ? n.length : 1;
      }), a = Math.max.apply(Math, De(r));
      i = t[r.indexOf(a)];
    }
    return i;
  } }]), s;
}(), ld = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.dCtx = e;
  }
  return ie(s, [{ key: "getxAxisLabelsCoords", value: function() {
    var e, t = this.w, i = t.globals.labels.slice();
    if (t.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = t.globals.categoryLabels), t.globals.timescaleLabels.length > 0) {
      var r = this.getxAxisTimeScaleLabelsCoords();
      e = { width: r.width, height: r.height }, t.globals.rotateXLabels = !1;
    } else {
      this.dCtx.lgWidthForSideLegends = t.config.legend.position !== "left" && t.config.legend.position !== "right" || t.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var a = t.globals.xLabelFormatter, n = F.getLargestStringFromArr(i), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, i);
      t.globals.isBarHorizontal && (o = n = t.globals.yAxisScale[0].result.reduce(function(p, f) {
        return p.length > f.length ? p : f;
      }, 0));
      var l = new _i(this.dCtx.ctx), c = n;
      n = l.xLabelFormat(a, n, c, { i: void 0, dateFormatter: new je(this.dCtx.ctx).formatDate, w: t }), o = l.xLabelFormat(a, o, c, { i: void 0, dateFormatter: new je(this.dCtx.ctx).formatDate, w: t }), (t.config.xaxis.convertedCatToNumeric && n === void 0 || String(n).trim() === "") && (o = n = "1");
      var h = new $(this.dCtx.ctx), d = h.getTextRects(n, t.config.xaxis.labels.style.fontSize), u = d;
      if (n !== o && (u = h.getTextRects(o, t.config.xaxis.labels.style.fontSize)), (e = { width: d.width >= u.width ? d.width : u.width, height: d.height >= u.height ? d.height : u.height }).width * i.length > t.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && t.config.xaxis.labels.rotate !== 0 || t.config.xaxis.labels.rotateAlways) {
        if (!t.globals.isBarHorizontal) {
          t.globals.rotateXLabels = !0;
          var g = function(p) {
            return h.getTextRects(p, t.config.xaxis.labels.style.fontSize, t.config.xaxis.labels.style.fontFamily, "rotate(".concat(t.config.xaxis.labels.rotate, " 0 0)"), !1);
          };
          d = g(n), n !== o && (u = g(o)), e.height = (d.height > u.height ? d.height : u.height) / 1.5, e.width = d.width > u.width ? d.width : u.width;
        }
      } else t.globals.rotateXLabels = !1;
    }
    return t.config.xaxis.labels.show || (e = { width: 0, height: 0 }), { width: e.width, height: e.height };
  } }, { key: "getxAxisGroupLabelsCoords", value: function() {
    var e, t = this.w;
    if (!t.globals.hasXaxisGroups) return { width: 0, height: 0 };
    var i, r = ((e = t.config.xaxis.group.style) === null || e === void 0 ? void 0 : e.fontSize) || t.config.xaxis.labels.style.fontSize, a = t.globals.groups.map(function(d) {
      return d.title;
    }), n = F.getLargestStringFromArr(a), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, a), l = new $(this.dCtx.ctx), c = l.getTextRects(n, r), h = c;
    return n !== o && (h = l.getTextRects(o, r)), i = { width: c.width >= h.width ? c.width : h.width, height: c.height >= h.height ? c.height : h.height }, t.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
  } }, { key: "getxAxisTitleCoords", value: function() {
    var e = this.w, t = 0, i = 0;
    if (e.config.xaxis.title.text !== void 0) {
      var r = new $(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize);
      t = r.width, i = r.height;
    }
    return { width: t, height: i };
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var e, t = this.w;
    this.dCtx.timescaleLabels = t.globals.timescaleLabels.slice();
    var i = this.dCtx.timescaleLabels.map(function(a) {
      return a.value;
    }), r = i.reduce(function(a, n) {
      return a === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : a.length > n.length ? a : n;
    }, 0);
    return 1.05 * (e = new $(this.dCtx.ctx).getTextRects(r, t.config.xaxis.labels.style.fontSize)).width * i.length > t.globals.gridWidth && t.config.xaxis.labels.rotate !== 0 && (t.globals.overlappingXLabels = !0), e;
  } }, { key: "additionalPaddingXLabels", value: function(e) {
    var t = this, i = this.w, r = i.globals, a = i.config, n = a.xaxis.type, o = e.width;
    r.skipLastTimelinelabel = !1, r.skipFirstTimelinelabel = !1;
    var l = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, c = function(h, d) {
      a.yaxis.length > 1 && function(u) {
        return r.collapsedSeriesIndices.indexOf(u) !== -1;
      }(d) || function(u) {
        if (t.dCtx.timescaleLabels && t.dCtx.timescaleLabels.length) {
          var g = t.dCtx.timescaleLabels[0], p = t.dCtx.timescaleLabels[t.dCtx.timescaleLabels.length - 1].position + o / 1.75 - t.dCtx.yAxisWidthRight, f = g.position - o / 1.75 + t.dCtx.yAxisWidthLeft, x = i.config.legend.position === "right" && t.dCtx.lgRect.width > 0 ? t.dCtx.lgRect.width : 0;
          p > r.svgWidth - r.translateX - x && (r.skipLastTimelinelabel = !0), f < -(u.show && !u.floating || a.chart.type !== "bar" && a.chart.type !== "candlestick" && a.chart.type !== "rangeBar" && a.chart.type !== "boxPlot" ? 10 : o / 1.75) && (r.skipFirstTimelinelabel = !0);
        } else n === "datetime" ? t.dCtx.gridPad.right < o && !r.rotateXLabels && (r.skipLastTimelinelabel = !0) : n !== "datetime" && t.dCtx.gridPad.right < o / 2 - t.dCtx.yAxisWidthRight && !r.rotateXLabels && !i.config.xaxis.labels.trim && (t.dCtx.xPadRight = o / 2 + 1);
      }(h);
    };
    a.yaxis.forEach(function(h, d) {
      l ? (t.dCtx.gridPad.left < o && (t.dCtx.xPadLeft = o / 2 + 1), t.dCtx.xPadRight = o / 2 + 1) : c(h, d);
    });
  } }]), s;
}(), cd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.dCtx = e;
  }
  return ie(s, [{ key: "getyAxisLabelsCoords", value: function() {
    var e = this, t = this.w, i = [], r = 10, a = new Lt(this.dCtx.ctx);
    return t.config.yaxis.map(function(n, o) {
      var l = { seriesIndex: o, dataPointIndex: -1, w: t }, c = t.globals.yAxisScale[o], h = 0;
      if (!a.isYAxisHidden(o) && n.labels.show && n.labels.minWidth !== void 0 && (h = n.labels.minWidth), !a.isYAxisHidden(o) && n.labels.show && c.result.length) {
        var d = t.globals.yLabelFormatters[o], u = c.niceMin === Number.MIN_VALUE ? 0 : c.niceMin, g = c.result.reduce(function(y, v) {
          var k, S;
          return ((k = String(d(y, l))) === null || k === void 0 ? void 0 : k.length) > ((S = String(d(v, l))) === null || S === void 0 ? void 0 : S.length) ? y : v;
        }, u), p = g = d(g, l);
        if (g !== void 0 && g.length !== 0 || (g = c.niceMax), t.globals.isBarHorizontal) {
          r = 0;
          var f = t.globals.labels.slice();
          g = F.getLargestStringFromArr(f), g = d(g, { seriesIndex: o, dataPointIndex: -1, w: t }), p = e.dCtx.dimHelpers.getLargestStringFromMultiArr(g, f);
        }
        var x = new $(e.dCtx.ctx), m = "rotate(".concat(n.labels.rotate, " 0 0)"), b = x.getTextRects(g, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1), w = b;
        g !== p && (w = x.getTextRects(p, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1)), i.push({ width: (h > w.width || h > b.width ? h : w.width > b.width ? w.width : b.width) + r, height: w.height > b.height ? w.height : b.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getyAxisTitleCoords", value: function() {
    var e = this, t = this.w, i = [];
    return t.config.yaxis.map(function(r, a) {
      if (r.show && r.title.text !== void 0) {
        var n = new $(e.dCtx.ctx), o = "rotate(".concat(r.title.rotate, " 0 0)"), l = n.getTextRects(r.title.text, r.title.style.fontSize, r.title.style.fontFamily, o, !1);
        i.push({ width: l.width, height: l.height });
      } else i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var e = this.w, t = 0, i = 0, r = 0, a = e.globals.yAxisScale.length > 1 ? 10 : 0, n = new Lt(this.dCtx.ctx), o = function(l, c) {
      var h = e.config.yaxis[c].floating, d = 0;
      l.width > 0 && !h ? (d = l.width + a, function(u) {
        return e.globals.ignoreYAxisIndexes.indexOf(u) > -1;
      }(c) && (d = d - l.width - a)) : d = h || n.isYAxisHidden(c) ? 0 : 5, e.config.yaxis[c].opposite ? r += d : i += d, t += d;
    };
    return e.globals.yLabelsCoords.map(function(l, c) {
      o(l, c);
    }), e.globals.yTitleCoords.map(function(l, c) {
      o(l, c);
    }), e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = r, t;
  } }]), s;
}(), hd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.dCtx = e;
  }
  return ie(s, [{ key: "gridPadForColumnsInNumericAxis", value: function(e) {
    var t = this.w, i = t.config, r = t.globals;
    if (r.noData || r.collapsedSeries.length + r.ancillaryCollapsedSeries.length === i.series.length) return 0;
    var a = function(g) {
      return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(g);
    }, n = i.chart.type, o = 0, l = a(n) ? i.series.length : 1;
    r.comboBarCount > 0 && (l = r.comboBarCount), r.collapsedSeries.forEach(function(g) {
      a(g.type) && (l -= 1);
    }), i.chart.stacked && (l = 1);
    var c = a(n) || r.comboBarCount > 0, h = Math.abs(r.initialMaxX - r.initialMinX);
    if (c && r.isXNumeric && !r.isBarHorizontal && l > 0 && h !== 0) {
      h <= 3 && (h = r.dataPoints);
      var d = h / e, u = r.minXDiff && r.minXDiff / d > 0 ? r.minXDiff / d : 0;
      u > e / 2 && (u /= 2), (o = u * parseInt(i.plotOptions.bar.columnWidth, 10) / 100) < 1 && (o = 1), r.barPadForNumericAxis = o;
    }
    return o;
  } }, { key: "gridPadFortitleSubtitle", value: function() {
    var e = this, t = this.w, i = t.globals, r = this.dCtx.isSparkline || !i.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach(function(o) {
      t.config[o].text !== void 0 ? r += t.config[o].margin : r += e.dCtx.isSparkline || !i.axisCharts ? 0 : 5;
    }), !t.config.legend.show || t.config.legend.position !== "bottom" || t.config.legend.floating || i.axisCharts || (r += 10);
    var a = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), n = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    i.gridHeight -= a.height + n.height + r, i.translateY += a.height + n.height + r;
  } }, { key: "setGridXPosForDualYAxis", value: function(e, t) {
    var i = this.w, r = new Lt(this.dCtx.ctx);
    i.config.yaxis.forEach(function(a, n) {
      i.globals.ignoreYAxisIndexes.indexOf(n) !== -1 || a.floating || r.isYAxisHidden(n) || (a.opposite && (i.globals.translateX -= t[n].width + e[n].width + parseInt(a.labels.style.fontSize, 10) / 1.2 + 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
    });
  } }]), s;
}(), tr = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new od(this), this.dimYAxis = new cd(this), this.dimXAxis = new ld(this), this.dimGrid = new hd(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return ie(s, [{ key: "plotCoords", value: function() {
    var e = this, t = this.w, i = t.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var r = Array.isArray(t.config.stroke.width) ? Math.max.apply(Math, De(t.config.stroke.width)) : t.config.stroke.width;
    this.isSparkline && ((t.config.markers.discrete.length > 0 || t.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(n) {
      var o = qn(n, 2), l = o[0], c = o[1];
      e.gridPad[l] = Math.max(c, e.w.globals.markers.largestSize / 1.5);
    }), this.gridPad.top = Math.max(r / 2, this.gridPad.top), this.gridPad.bottom = Math.max(r / 2, this.gridPad.bottom)), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var a = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
    i.gridWidth = i.gridWidth - 2 * a, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (a > 0 ? a : 0), i.translateY = i.translateY + this.gridPad.top;
  } }, { key: "setDimensionsForAxisCharts", value: function() {
    var e = this, t = this.w, i = t.globals, r = this.dimYAxis.getyAxisLabelsCoords(), a = this.dimYAxis.getyAxisTitleCoords();
    i.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), t.globals.yLabelsCoords = [], t.globals.yTitleCoords = [], t.config.yaxis.map(function(g, p) {
      t.globals.yLabelsCoords.push({ width: r[p].width, index: p }), t.globals.yTitleCoords.push({ width: a[p].width, index: p });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var n = this.dimXAxis.getxAxisLabelsCoords(), o = this.dimXAxis.getxAxisGroupLabelsCoords(), l = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(n, l, o), i.translateXAxisY = t.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = t.globals.rotateXLabels && t.globals.isXNumeric && t.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, t.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(t.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + t.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + t.config.xaxis.labels.offsetX;
    var c = this.yAxisWidth, h = this.xAxisHeight;
    i.xAxisLabelsHeight = this.xAxisHeight - l.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - n.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
    var d = 10;
    (t.config.chart.type === "radar" || this.isSparkline) && (c = 0, h = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || t.config.chart.type === "treemap") && (c = 0, h = 0, d = 0), this.isSparkline || t.config.chart.type === "treemap" || this.dimXAxis.additionalPaddingXLabels(n);
    var u = function() {
      i.translateX = c + e.datalabelsCoords.width, i.gridHeight = i.svgHeight - e.lgRect.height - h - (e.isSparkline || t.config.chart.type === "treemap" ? 0 : t.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - c - 2 * e.datalabelsCoords.width;
    };
    switch (t.config.xaxis.position === "top" && (d = i.xAxisHeight - t.config.xaxis.axisTicks.height - 5), t.config.legend.position) {
      case "bottom":
        i.translateY = d, u();
        break;
      case "top":
        i.translateY = this.lgRect.height + d, u();
        break;
      case "left":
        i.translateY = d, i.translateX = this.lgRect.width + c + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h - 12, i.gridWidth = i.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width;
        break;
      case "right":
        i.translateY = d, i.translateX = c + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h - 12, i.gridWidth = i.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(a, r), new ta(this.ctx).setYAxisXPosition(r, a);
  } }, { key: "setDimensionsForNonAxisCharts", value: function() {
    var e = this.w, t = e.globals, i = e.config, r = 0;
    e.config.legend.show && !e.config.legend.floating && (r = 20);
    var a = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar", n = i.plotOptions[a].offsetY, o = i.plotOptions[a].offsetX;
    if (!i.legend.show || i.legend.floating) {
      t.gridHeight = t.svgHeight;
      var l = t.dom.elWrap.getBoundingClientRect().width;
      return t.gridWidth = Math.min(l, t.gridHeight), t.translateY = n, void (t.translateX = o + (t.svgWidth - t.gridWidth) / 2);
    }
    switch (i.legend.position) {
      case "bottom":
        t.gridHeight = t.svgHeight - this.lgRect.height, t.gridWidth = t.svgWidth, t.translateY = n - 10, t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "top":
        t.gridHeight = t.svgHeight - this.lgRect.height, t.gridWidth = t.svgWidth, t.translateY = this.lgRect.height + n + 10, t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "left":
        t.gridWidth = t.svgWidth - this.lgRect.width - r, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = n, t.translateX = o + this.lgRect.width + r;
        break;
      case "right":
        t.gridWidth = t.svgWidth - this.lgRect.width - r - 5, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = n, t.translateX = o + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "conditionalChecksForAxisCoords", value: function(e, t, i) {
    var r = this.w, a = r.globals.hasXaxisGroups ? 2 : 1, n = i.height + e.height + t.height, o = r.globals.isMultiLineX ? 1.2 : r.globals.LINE_HEIGHT_RATIO, l = r.globals.rotateXLabels ? 22 : 10, c = r.globals.rotateXLabels && r.config.legend.position === "bottom" ? 10 : 0;
    this.xAxisHeight = n * o + a * l + c, this.xAxisWidth = e.width, this.xAxisHeight - t.height > r.config.xaxis.labels.maxHeight && (this.xAxisHeight = r.config.xaxis.labels.maxHeight), r.config.xaxis.labels.minHeight && this.xAxisHeight < r.config.xaxis.labels.minHeight && (this.xAxisHeight = r.config.xaxis.labels.minHeight), r.config.xaxis.floating && (this.xAxisHeight = 0);
    var h = 0, d = 0;
    r.config.yaxis.forEach(function(u) {
      h += u.labels.minWidth, d += u.labels.maxWidth;
    }), this.yAxisWidth < h && (this.yAxisWidth = h), this.yAxisWidth > d && (this.yAxisWidth = d);
  } }]), s;
}(), dd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.lgCtx = e;
  }
  return ie(s, [{ key: "getLegendStyles", value: function() {
    var e, t, i, r = document.createElement("style");
    r.setAttribute("type", "text/css");
    var a = ((e = this.lgCtx.ctx) === null || e === void 0 || (t = e.opts) === null || t === void 0 || (i = t.chart) === null || i === void 0 ? void 0 : i.nonce) || this.w.config.chart.nonce;
    a && r.setAttribute("nonce", a);
    var n = document.createTextNode(`
      .apexcharts-flip-y {
        transform: scaleY(-1) translateY(-100%);
        transform-origin: top;
        transform-box: fill-box;
      }
      .apexcharts-flip-x {
        transform: scaleX(-1);
        transform-origin: center;
        transform-box: fill-box;
      }
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apexcharts-legend-group-horizontal {
        flex-direction: column;
      }
      .apexcharts-legend-group {
        display: flex;
      }
      .apexcharts-legend-group-vertical {
        flex-direction: column-reverse;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
        align-items: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
        align-items: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
        align-items: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 1px;
      }

      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }

    `);
    return r.appendChild(n), r;
  } }, { key: "getLegendDimensions", value: function() {
    var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), t = e.width;
    return { clwh: e.height, clww: t };
  } }, { key: "appendToForeignObject", value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: "toggleDataSeries", value: function(e, t) {
    var i = this, r = this.w;
    if (r.globals.axisCharts || r.config.chart.type === "radialBar") {
      r.globals.resized = !0;
      var a = null, n = null;
      r.globals.risingSeries = [], r.globals.axisCharts ? (a = r.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")), n = parseInt(a.getAttribute("data:realIndex"), 10)) : (a = r.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")), n = parseInt(a.getAttribute("rel"), 10) - 1), t ? [{ cs: r.globals.collapsedSeries, csi: r.globals.collapsedSeriesIndices }, { cs: r.globals.ancillaryCollapsedSeries, csi: r.globals.ancillaryCollapsedSeriesIndices }].forEach(function(h) {
        i.riseCollapsedSeries(h.cs, h.csi, n);
      }) : this.hideSeries({ seriesEl: a, realIndex: n });
    } else {
      var o = r.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(e + 1, "'] path")), l = r.config.chart.type;
      if (l === "pie" || l === "polarArea" || l === "donut") {
        var c = r.config.plotOptions.pie.donut.labels;
        new $(this.lgCtx.ctx).pathMouseDown(o, null), this.lgCtx.ctx.pie.printDataLabelsInner(o.node, c);
      }
      o.fire("click");
    }
  } }, { key: "getSeriesAfterCollapsing", value: function(e) {
    var t = e.realIndex, i = this.w, r = i.globals, a = F.clone(i.config.series);
    if (r.axisCharts) {
      var n = i.config.yaxis[r.seriesYAxisReverseMap[t]], o = { index: t, data: a[t].data.slice(), type: a[t].type || i.config.chart.type };
      if (n && n.show && n.showAlways) r.ancillaryCollapsedSeriesIndices.indexOf(t) < 0 && (r.ancillaryCollapsedSeries.push(o), r.ancillaryCollapsedSeriesIndices.push(t));
      else if (r.collapsedSeriesIndices.indexOf(t) < 0) {
        r.collapsedSeries.push(o), r.collapsedSeriesIndices.push(t);
        var l = r.risingSeries.indexOf(t);
        r.risingSeries.splice(l, 1);
      }
    } else r.collapsedSeries.push({ index: t, data: a[t] }), r.collapsedSeriesIndices.push(t);
    return r.allSeriesCollapsed = r.collapsedSeries.length + r.ancillaryCollapsedSeries.length === i.config.series.length, this._getSeriesBasedOnCollapsedState(a);
  } }, { key: "hideSeries", value: function(e) {
    for (var t = e.seriesEl, i = e.realIndex, r = this.w, a = this.getSeriesAfterCollapsing({ realIndex: i }), n = t.childNodes, o = 0; o < n.length; o++) n[o].classList.contains("apexcharts-series-markers-wrap") && (n[o].classList.contains("apexcharts-hide") ? n[o].classList.remove("apexcharts-hide") : n[o].classList.add("apexcharts-hide"));
    this.lgCtx.ctx.updateHelpers._updateSeries(a, r.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "riseCollapsedSeries", value: function(e, t, i) {
    var r = this.w, a = F.clone(r.config.series);
    if (e.length > 0) {
      for (var n = 0; n < e.length; n++) e[n].index === i && (r.globals.axisCharts ? a[i].data = e[n].data.slice() : a[i] = e[n].data, typeof a[i] != "number" && (a[i].hidden = !1), e.splice(n, 1), t.splice(n, 1), r.globals.risingSeries.push(i));
      a = this._getSeriesBasedOnCollapsedState(a), this.lgCtx.ctx.updateHelpers._updateSeries(a, r.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: "_getSeriesBasedOnCollapsedState", value: function(e) {
    var t = this.w, i = 0;
    return t.globals.axisCharts ? e.forEach(function(r, a) {
      t.globals.collapsedSeriesIndices.indexOf(a) < 0 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(a) < 0 || (e[a].data = [], i++);
    }) : e.forEach(function(r, a) {
      !t.globals.collapsedSeriesIndices.indexOf(a) < 0 && (e[a] = 0, i++);
    }), t.globals.allSeriesCollapsed = i === e.length, e;
  } }]), s;
}(), Lo = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new dd(this);
  }
  return ie(s, [{ key: "init", value: function() {
    var e = this.w, t = e.globals, i = e.config, r = i.legend.showForSingleSeries && t.series.length === 1 || this.isBarsDistributed || t.series.length > 1;
    if (this.legendHelpers.appendToForeignObject(), (r || !t.axisCharts) && i.legend.show) {
      for (; t.dom.elLegendWrap.firstChild; ) t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
      this.drawLegends(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : i.legend.position !== "right" && i.legend.position !== "left" || this.legendAlignVertical();
    }
  } }, { key: "createLegendMarker", value: function(e) {
    var t = e.i, i = e.fillcolor, r = this.w, a = document.createElement("span");
    a.classList.add("apexcharts-legend-marker");
    var n = r.config.legend.markers.shape || r.config.markers.shape, o = n;
    Array.isArray(n) && (o = n[t]);
    var l = Array.isArray(r.config.legend.markers.size) ? parseFloat(r.config.legend.markers.size[t]) : parseFloat(r.config.legend.markers.size), c = Array.isArray(r.config.legend.markers.offsetX) ? parseFloat(r.config.legend.markers.offsetX[t]) : parseFloat(r.config.legend.markers.offsetX), h = Array.isArray(r.config.legend.markers.offsetY) ? parseFloat(r.config.legend.markers.offsetY[t]) : parseFloat(r.config.legend.markers.offsetY), d = Array.isArray(r.config.legend.markers.strokeWidth) ? parseFloat(r.config.legend.markers.strokeWidth[t]) : parseFloat(r.config.legend.markers.strokeWidth), u = a.style;
    if (u.height = 2 * (l + d) + "px", u.width = 2 * (l + d) + "px", u.left = c + "px", u.top = h + "px", r.config.legend.markers.customHTML) u.background = "transparent", u.color = i[t], Array.isArray(r.config.legend.markers.customHTML) ? r.config.legend.markers.customHTML[t] && (a.innerHTML = r.config.legend.markers.customHTML[t]()) : a.innerHTML = r.config.legend.markers.customHTML();
    else {
      var g = new ni(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(o), seriesIndex: t, strokeWidth: d, size: l }), p = window.SVG().addTo(a).size("100%", "100%"), f = new $(this.ctx).drawMarker(0, 0, J(J({}, g), {}, { pointFillColor: Array.isArray(i) ? i[t] : g.pointFillColor, shape: o }));
      r.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach(function(x) {
        x.node.classList.contains("apexcharts-marker-triangle") ? x.node.style.transform = "translate(50%, 45%)" : x.node.style.transform = "translate(50%, 50%)";
      }), p.add(f);
    }
    return a;
  } }, { key: "drawLegends", value: function() {
    var e = this, t = this, i = this.w, r = i.config.legend.fontFamily, a = i.globals.seriesNames, n = i.config.legend.markers.fillColors ? i.config.legend.markers.fillColors.slice() : i.globals.colors.slice();
    if (i.config.chart.type === "heatmap") {
      var o = i.config.plotOptions.heatmap.colorScale.ranges;
      a = o.map(function(g) {
        return g.name ? g.name : g.from + " - " + g.to;
      }), n = o.map(function(g) {
        return g.color;
      });
    } else this.isBarsDistributed && (a = i.globals.labels.slice());
    i.config.legend.customLegendItems.length && (a = i.config.legend.customLegendItems);
    var l = i.globals.legendFormatter, c = i.config.legend.inverseOrder, h = [];
    i.globals.seriesGroups.length > 1 && i.config.legend.clusterGroupedSeries && i.globals.seriesGroups.forEach(function(g, p) {
      h[p] = document.createElement("div"), h[p].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(p)), i.config.legend.clusterGroupedSeriesOrientation === "horizontal" ? i.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h[p].classList.add("apexcharts-legend-group-vertical");
    });
    for (var d = function(g) {
      var p, f = l(a[g], { seriesIndex: g, w: i }), x = !1, m = !1;
      if (i.globals.collapsedSeries.length > 0) for (var b = 0; b < i.globals.collapsedSeries.length; b++) i.globals.collapsedSeries[b].index === g && (x = !0);
      if (i.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var w = 0; w < i.globals.ancillaryCollapsedSeriesIndices.length; w++) i.globals.ancillaryCollapsedSeriesIndices[w] === g && (m = !0);
      var y = e.createLegendMarker({ i: g, fillcolor: n });
      $.setAttrs(y, { rel: g + 1, "data:collapsed": x || m }), (x || m) && y.classList.add("apexcharts-inactive-legend");
      var v = document.createElement("div"), k = document.createElement("span");
      k.classList.add("apexcharts-legend-text"), k.innerHTML = Array.isArray(f) ? f.join(" ") : f;
      var S = i.config.legend.labels.useSeriesColors ? i.globals.colors[g] : Array.isArray(i.config.legend.labels.colors) ? (p = i.config.legend.labels.colors) === null || p === void 0 ? void 0 : p[g] : i.config.legend.labels.colors;
      S || (S = i.config.chart.foreColor), k.style.color = S, k.style.fontSize = parseFloat(i.config.legend.fontSize) + "px", k.style.fontWeight = i.config.legend.fontWeight, k.style.fontFamily = r || i.config.chart.fontFamily, $.setAttrs(k, { rel: g + 1, i: g, "data:default-text": encodeURIComponent(f), "data:collapsed": x || m }), v.appendChild(y), v.appendChild(k);
      var C = new ze(e.ctx);
      i.config.legend.showForZeroSeries || C.getSeriesTotalByIndex(g) === 0 && C.seriesHaveSameValues(g) && !C.isSeriesNull(g) && i.globals.collapsedSeriesIndices.indexOf(g) === -1 && i.globals.ancillaryCollapsedSeriesIndices.indexOf(g) === -1 && v.classList.add("apexcharts-hidden-zero-series"), i.config.legend.showForNullSeries || C.isSeriesNull(g) && i.globals.collapsedSeriesIndices.indexOf(g) === -1 && i.globals.ancillaryCollapsedSeriesIndices.indexOf(g) === -1 && v.classList.add("apexcharts-hidden-null-series"), h.length ? i.globals.seriesGroups.forEach(function(M, R) {
        var P;
        M.includes((P = i.config.series[g]) === null || P === void 0 ? void 0 : P.name) && (i.globals.dom.elLegendWrap.appendChild(h[R]), h[R].appendChild(v));
      }) : i.globals.dom.elLegendWrap.appendChild(v), i.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i.config.legend.horizontalAlign)), i.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i.config.legend.position), v.classList.add("apexcharts-legend-series"), v.style.margin = "".concat(i.config.legend.itemMargin.vertical, "px ").concat(i.config.legend.itemMargin.horizontal, "px"), i.globals.dom.elLegendWrap.style.width = i.config.legend.width ? i.config.legend.width + "px" : "", i.globals.dom.elLegendWrap.style.height = i.config.legend.height ? i.config.legend.height + "px" : "", $.setAttrs(v, { rel: g + 1, seriesName: F.escapeString(a[g]), "data:collapsed": x || m }), (x || m) && v.classList.add("apexcharts-inactive-legend"), i.config.legend.onItemClick.toggleDataSeries || v.classList.add("apexcharts-no-click");
    }, u = c ? a.length - 1 : 0; c ? u >= 0 : u <= a.length - 1; c ? u-- : u++) d(u);
    i.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), i.config.legend.onItemHover.highlightDataSeries && i.config.legend.customLegendItems.length === 0 && (i.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), i.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
  } }, { key: "setLegendWrapXY", value: function(e, t) {
    var i = this.w, r = i.globals.dom.elLegendWrap, a = r.clientHeight, n = 0, o = 0;
    if (i.config.legend.position === "bottom") o = i.globals.svgHeight - Math.min(a, i.globals.svgHeight / 2) - 5;
    else if (i.config.legend.position === "top") {
      var l = new tr(this.ctx), c = l.dimHelpers.getTitleSubtitleCoords("title").height, h = l.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      o = (c > 0 ? c - 10 : 0) + (h > 0 ? h - 10 : 0);
    }
    r.style.position = "absolute", n = n + e + i.config.legend.offsetX, o = o + t + i.config.legend.offsetY, r.style.left = n + "px", r.style.top = o + "px", i.config.legend.position === "right" && (r.style.left = "auto", r.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(d) {
      r.style[d] && (r.style[d] = parseInt(i.config.legend[d], 10) + "px");
    });
  } }, { key: "legendAlignHorizontal", value: function() {
    var e = this.w;
    e.globals.dom.elLegendWrap.style.right = 0;
    var t = new tr(this.ctx), i = t.dimHelpers.getTitleSubtitleCoords("title"), r = t.dimHelpers.getTitleSubtitleCoords("subtitle"), a = 0;
    e.config.legend.position === "top" && (a = i.height + r.height + e.config.title.margin + e.config.subtitle.margin - 10), this.setLegendWrapXY(20, a);
  } }, { key: "legendAlignVertical", value: function() {
    var e = this.w, t = this.legendHelpers.getLegendDimensions(), i = 0;
    e.config.legend.position === "left" && (i = 20), e.config.legend.position === "right" && (i = e.globals.svgWidth - t.clww - 10), this.setLegendWrapXY(i, 20);
  } }, { key: "onLegendHovered", value: function(e) {
    var t = this.w, i = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
    if (t.config.chart.type === "heatmap" || this.isBarsDistributed) {
      if (i) {
        var r = parseInt(e.target.getAttribute("rel"), 10) - 1;
        this.ctx.events.fireEvent("legendHover", [this.ctx, r, this.w]), new ct(this.ctx).highlightRangeInSeries(e, e.target);
      }
    } else !e.target.classList.contains("apexcharts-inactive-legend") && i && new ct(this.ctx).toggleSeriesOnHover(e, e.target);
  } }, { key: "onLegendClick", value: function(e) {
    var t = this.w;
    if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
      var i = parseInt(e.target.getAttribute("rel"), 10) - 1, r = e.target.getAttribute("data:collapsed") === "true", a = this.w.config.chart.events.legendClick;
      typeof a == "function" && a(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
      var n = this.w.config.legend.markers.onClick;
      typeof n == "function" && e.target.classList.contains("apexcharts-legend-marker") && (n(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), t.config.chart.type !== "treemap" && t.config.chart.type !== "heatmap" && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, r);
    }
  } }]), s;
}(), Io = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = t.globals.minX, this.maxX = t.globals.maxX;
  }
  return ie(s, [{ key: "createToolbar", value: function() {
    var e = this, t = this.w, i = function() {
      return document.createElement("div");
    }, r = i();
    if (r.setAttribute("class", "apexcharts-toolbar"), r.style.top = t.config.chart.toolbar.offsetY + "px", r.style.right = 3 - t.config.chart.toolbar.offsetX + "px", t.globals.dom.elWrap.appendChild(r), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = t.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var a = 0; a < this.t.customIcons.length; a++) this.elCustomIcons.push(i());
    var n = [], o = function(d, u, g) {
      var p = d.toLowerCase();
      e.t[p] && t.config.chart.zoom.enabled && n.push({ el: u, icon: typeof e.t[p] == "string" ? e.t[p] : g, title: e.localeValues[d], class: "apexcharts-".concat(p, "-icon") });
    };
    o("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), o("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
    var l = function(d) {
      e.t[d] && t.config.chart[d].enabled && n.push({ el: d === "zoom" ? e.elZoom : e.elSelection, icon: typeof e.t[d] == "string" ? e.t[d] : d === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: e.localeValues[d === "zoom" ? "selectionZoom" : "selection"], class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(d, "-icon") });
    };
    l("zoom"), l("selection"), this.t.pan && t.config.chart.zoom.enabled && n.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && n.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var c = 0; c < this.elCustomIcons.length; c++) n.push({ el: this.elCustomIcons[c], icon: this.t.customIcons[c].icon, title: this.t.customIcons[c].title, index: this.t.customIcons[c].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[c].class });
    n.forEach(function(d, u) {
      d.index && F.moveIndexInArray(n, u, d.index);
    });
    for (var h = 0; h < n.length; h++) $.setAttrs(n[h].el, { class: n[h].class, title: n[h].title }), n[h].el.innerHTML = n[h].icon, r.appendChild(n[h].el);
    this._createHamburgerMenu(r), t.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: "_createHamburgerMenu", value: function(e) {
    this.elMenuItems = [], e.appendChild(this.elMenu), $.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var t = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i = 0; i < t.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = t[i].title, $.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(t[i].name), title: t[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
  } }, { key: "addToolbarEventListeners", value: function() {
    var e = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
      i.classList.contains("exportSVG") ? i.addEventListener("click", e.handleDownload.bind(e, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", e.handleDownload.bind(e, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", e.handleDownload.bind(e, "csv"));
    });
    for (var t = 0; t < this.t.customIcons.length; t++) this.elCustomIcons[t].addEventListener("click", this.t.customIcons[t].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleZoomSelection", value: function(e) {
    this.ctx.getSyncedCharts().forEach(function(t) {
      t.ctx.toolbar.toggleOtherControls();
      var i = e === "selection" ? t.ctx.toolbar.elSelection : t.ctx.toolbar.elZoom, r = e === "selection" ? "selectionEnabled" : "zoomEnabled";
      t.w.globals[r] = !t.w.globals[r], i.classList.contains(t.ctx.toolbar.selectedClass) ? i.classList.remove(t.ctx.toolbar.selectedClass) : i.classList.add(t.ctx.toolbar.selectedClass);
    });
  } }, { key: "getToolbarIconsReference", value: function() {
    var e = this.w;
    this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZoomPanFromToolbar", value: function(e) {
    this.toggleOtherControls(), e === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
    var t = e === "pan" ? this.elPan : this.elZoom, i = e === "pan" ? this.elZoom : this.elPan;
    t && t.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
  } }, { key: "togglePanning", value: function() {
    this.ctx.getSyncedCharts().forEach(function(e) {
      e.ctx.toolbar.toggleOtherControls(), e.w.globals.panEnabled = !e.w.globals.panEnabled, e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass);
    });
  } }, { key: "toggleOtherControls", value: function() {
    var e = this, t = this.w;
    t.globals.panEnabled = !1, t.globals.zoomEnabled = !1, t.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
      i && i.classList.remove(e.selectedClass);
    });
  } }, { key: "handleZoomIn", value: function() {
    var e = this.w;
    e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY);
    var t = (this.minX + this.maxX) / 2, i = (this.minX + t) / 2, r = (this.maxX + t) / 2, a = this._getNewMinXMaxX(i, r);
    e.globals.disableZoomIn || this.zoomUpdateOptions(a.minX, a.maxX);
  } }, { key: "handleZoomOut", value: function() {
    var e = this.w;
    if (e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY), !(e.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
      var t = (this.minX + this.maxX) / 2, i = this.minX - (t - this.minX), r = this.maxX - (t - this.maxX), a = this._getNewMinXMaxX(i, r);
      e.globals.disableZoomOut || this.zoomUpdateOptions(a.minX, a.maxX);
    }
  } }, { key: "_getNewMinXMaxX", value: function(e, t) {
    var i = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i ? Math.floor(e) : e, maxX: i ? Math.floor(t) : t };
  } }, { key: "zoomUpdateOptions", value: function(e, t) {
    var i = this.w;
    if (e !== void 0 || t !== void 0) {
      if (!(i.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1, t = i.globals.dataPoints), t - e < 2))) {
        var r = { min: e, max: t }, a = this.getBeforeZoomRange(r);
        a && (r = a.xaxis);
        var n = { xaxis: r }, o = F.clone(i.globals.initialConfig.yaxis);
        i.config.chart.group || (n.yaxis = o), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(n, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(r, o);
      }
    } else this.handleZoomReset();
  } }, { key: "zoomCallback", value: function(e, t) {
    typeof this.ev.zoomed == "function" && (this.ev.zoomed(this.ctx, { xaxis: e, yaxis: t }), this.ctx.events.fireEvent("zoomed", { xaxis: e, yaxis: t }));
  } }, { key: "getBeforeZoomRange", value: function(e, t) {
    var i = null;
    return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: e, yaxis: t })), i;
  } }, { key: "toggleMenu", value: function() {
    var e = this;
    window.setTimeout(function() {
      e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open");
    }, 0);
  } }, { key: "handleDownload", value: function(e) {
    var t = this.w, i = new bi(this.ctx);
    switch (e) {
      case "svg":
        i.exportToSVG(this.ctx);
        break;
      case "png":
        i.exportToPng(this.ctx);
        break;
      case "csv":
        i.exportToCSV({ series: t.config.series, columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: "handleZoomReset", value: function(e) {
    this.ctx.getSyncedCharts().forEach(function(t) {
      var i = t.w;
      if (i.globals.lastXAxis.min = i.globals.initialConfig.xaxis.min, i.globals.lastXAxis.max = i.globals.initialConfig.xaxis.max, t.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.beforeResetZoom == "function") {
        var r = i.config.chart.events.beforeResetZoom(t, i);
        r && t.updateHelpers.revertDefaultAxisMinMax(r);
      }
      typeof i.config.chart.events.zoomed == "function" && t.ctx.toolbar.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1;
      var a = t.ctx.series.emptyCollapsedSeries(F.clone(i.globals.initialSeries));
      t.updateHelpers._updateSeries(a, i.config.chart.animations.dynamicAnimation.enabled);
    });
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), s;
}(), ud = function(s) {
  Li(t, Io);
  var e = Pi(t);
  function t(i) {
    var r;
    return te(this, t), (r = e.call(this, i)).ctx = i, r.w = i.w, r.dragged = !1, r.graphics = new $(r.ctx), r.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], r.clientX = 0, r.clientY = 0, r.startX = 0, r.endX = 0, r.dragX = 0, r.startY = 0, r.endY = 0, r.dragY = 0, r.moveDirection = "none", r.debounceTimer = null, r.debounceDelay = 100, r.wheelDelay = 400, r;
  }
  return ie(t, [{ key: "init", value: function(i) {
    var r = this, a = i.xyRatios, n = this.w, o = this;
    this.xyRatios = a, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = n.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new Oe(0, 0, n.globals.gridWidth, n.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), n.globals.dom.Paper.add(this.zoomRect), n.globals.dom.Paper.add(this.selectionRect), n.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: n.globals.gridWidth, maxY: n.globals.gridHeight }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : n.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: n.globals.gridWidth }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = n.globals.dom.baseEl.querySelector("".concat(n.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(l) {
      r.hoverArea.addEventListener(l, o.svgMouseEvents.bind(o, a), { capture: !1, passive: !0 });
    }), n.config.chart.zoom.enabled && n.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", o.mouseWheelEvent.bind(o), { capture: !1, passive: !1 });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(i, r) {
    var a = this.w, n = this.ctx.toolbar, o = a.globals.zoomEnabled ? a.config.chart.zoom.type : a.config.chart.selection.type, l = a.config.chart.toolbar.autoSelected;
    if (r.shiftKey ? (this.shiftWasPressed = !0, n.enableZoomPanFromToolbar(l === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(l), this.shiftWasPressed = !1), r.target) {
      var c, h = r.target.classList;
      if (r.target.parentNode && r.target.parentNode !== null && (c = r.target.parentNode.classList), !(h.contains("apexcharts-legend-marker") || h.contains("apexcharts-legend-text") || c && c.contains("apexcharts-toolbar"))) {
        if (this.clientX = r.type === "touchmove" || r.type === "touchstart" ? r.touches[0].clientX : r.type === "touchend" ? r.changedTouches[0].clientX : r.clientX, this.clientY = r.type === "touchmove" || r.type === "touchstart" ? r.touches[0].clientY : r.type === "touchend" ? r.changedTouches[0].clientY : r.clientY, r.type === "mousedown" && r.which === 1 || r.type === "touchstart") {
          var d = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - d.left - a.globals.barPadForNumericAxis, this.startY = this.clientY - d.top, this.dragged = !1, this.w.globals.mousedown = !0;
        }
        (r.type === "mousemove" && r.which === 1 || r.type === "touchmove") && (this.dragged = !0, a.globals.panEnabled ? (a.globals.selection = null, this.w.globals.mousedown && this.panDragging({ context: this, zoomtype: o, xyRatios: i })) : (this.w.globals.mousedown && a.globals.zoomEnabled || this.w.globals.mousedown && a.globals.selectionEnabled) && (this.selection = this.selectionDrawing({ context: this, zoomtype: o }))), r.type !== "mouseup" && r.type !== "touchend" && r.type !== "mouseleave" || this.handleMouseUp({ zoomtype: o }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: "handleMouseUp", value: function(i) {
    var r, a = i.zoomtype, n = i.isResized, o = this.w, l = (r = this.gridRect) === null || r === void 0 ? void 0 : r.getBoundingClientRect();
    l && (this.w.globals.mousedown || n) && (this.endX = this.clientX - l.left - o.globals.barPadForNumericAxis, this.endY = this.clientY - l.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (o.globals.zoomEnabled || o.globals.selectionEnabled) && this.selectionDrawn({ context: this, zoomtype: a })), o.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = !1, this.w.globals.mousedown = !1;
  } }, { key: "mouseWheelEvent", value: function(i) {
    var r = this, a = this.w;
    i.preventDefault();
    var n = Date.now();
    n - a.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(i), a.globals.lastWheelExecution = n), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function() {
      n - a.globals.lastWheelExecution > r.wheelDelay && (r.executeMouseWheelZoom(i), a.globals.lastWheelExecution = n);
    }, this.debounceDelay);
  } }, { key: "executeMouseWheelZoom", value: function(i) {
    var r, a = this.w;
    this.minX = a.globals.isRangeBar ? a.globals.minY : a.globals.minX, this.maxX = a.globals.isRangeBar ? a.globals.maxY : a.globals.maxX;
    var n = (r = this.gridRect) === null || r === void 0 ? void 0 : r.getBoundingClientRect();
    if (n) {
      var o, l, c, h = (i.clientX - n.left) / n.width, d = this.minX, u = this.maxX, g = u - d;
      if (i.deltaY < 0) {
        var p = d + h * g;
        l = p - (o = 0.5 * g) / 2, c = p + o / 2;
      } else l = d - (o = 1.5 * g) / 2, c = u + o / 2;
      if (!a.globals.isRangeBar) {
        l = Math.max(l, a.globals.initialMinX), c = Math.min(c, a.globals.initialMaxX);
        var f = 0.01 * (a.globals.initialMaxX - a.globals.initialMinX);
        if (c - l < f) {
          var x = (l + c) / 2;
          l = x - f / 2, c = x + f / 2;
        }
      }
      var m = this._getNewMinXMaxX(l, c);
      isNaN(m.minX) || isNaN(m.maxX) || this.zoomUpdateOptions(m.minX, m.maxX);
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var i = this, r = this.w;
    if (this.selectionRect) {
      var a = this.selectionRect.node.getBoundingClientRect();
      a.width > 0 && a.height > 0 && (this.selectionRect.select(!1).resize(!1), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(n, o, l, c, h) {
        return h === "l" || h === "r" ? n.circle(8).css({ "stroke-width": 1, stroke: "#333", fill: "#fff" }) : n.circle(0);
      }, updateHandle: function(n, o) {
        return n.center(o[0], o[1]);
      } }).resize().on("resize", function() {
        var n = r.globals.zoomEnabled ? r.config.chart.zoom.type : r.config.chart.selection.type;
        i.handleMouseUp({ zoomtype: n, isResized: !0 });
      }));
    }
  } }, { key: "preselectedSelection", value: function() {
    var i = this.w, r = this.xyRatios;
    if (!i.globals.zoomEnabled) {
      if (i.globals.selection !== void 0 && i.globals.selection !== null) this.drawSelectionRect(J(J({}, i.globals.selection), {}, { translateX: i.globals.translateX, translateY: i.globals.translateY }));
      else if (i.config.chart.selection.xaxis.min !== void 0 && i.config.chart.selection.xaxis.max !== void 0) {
        var a = (i.config.chart.selection.xaxis.min - i.globals.minX) / r.xRatio, n = i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / r.xRatio - a;
        i.globals.isRangeBar && (a = (i.config.chart.selection.xaxis.min - i.globals.yAxisScale[0].niceMin) / r.invertedYRatio, n = (i.config.chart.selection.xaxis.max - i.config.chart.selection.xaxis.min) / r.invertedYRatio);
        var o = { x: a, y: 0, width: n, height: i.globals.gridHeight, translateX: i.globals.translateX, translateY: i.globals.translateY, selectionEnabled: !0 };
        this.drawSelectionRect(o), this.makeSelectionRectDraggable(), typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(this.ctx, { xaxis: { min: i.config.chart.selection.xaxis.min, max: i.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(i) {
    var r = i.x, a = i.y, n = i.width, o = i.height, l = i.translateX, c = l === void 0 ? 0 : l, h = i.translateY, d = h === void 0 ? 0 : h, u = this.w, g = this.zoomRect, p = this.selectionRect;
    if (this.dragged || u.globals.selection !== null) {
      var f = { transform: "translate(" + c + ", " + d + ")" };
      u.globals.zoomEnabled && this.dragged && (n < 0 && (n = 1), g.attr({ x: r, y: a, width: n, height: o, fill: u.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": u.config.chart.zoom.zoomedArea.fill.opacity, stroke: u.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": u.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": u.config.chart.zoom.zoomedArea.stroke.opacity }), $.setAttrs(g.node, f)), u.globals.selectionEnabled && (p.attr({ x: r, y: a, width: n > 0 ? n : 0, height: o > 0 ? o : 0, fill: u.config.chart.selection.fill.color, "fill-opacity": u.config.chart.selection.fill.opacity, stroke: u.config.chart.selection.stroke.color, "stroke-width": u.config.chart.selection.stroke.width, "stroke-dasharray": u.config.chart.selection.stroke.dashArray, "stroke-opacity": u.config.chart.selection.stroke.opacity }), $.setAttrs(p.node, f));
    }
  } }, { key: "hideSelectionRect", value: function(i) {
    i && i.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(i) {
    var r = i.context, a = i.zoomtype, n = this.w, o = r, l = this.gridRect.getBoundingClientRect(), c = o.startX - 1, h = o.startY, d = !1, u = !1, g = o.clientX - l.left - n.globals.barPadForNumericAxis, p = o.clientY - l.top, f = g - c, x = p - h, m = { translateX: n.globals.translateX, translateY: n.globals.translateY };
    return Math.abs(f + c) > n.globals.gridWidth ? f = n.globals.gridWidth - c : g < 0 && (f = c), c > g && (d = !0, f = Math.abs(f)), h > p && (u = !0, x = Math.abs(x)), m = J(J({}, m = a === "x" ? { x: d ? c - f : c, y: 0, width: f, height: n.globals.gridHeight } : a === "y" ? { x: 0, y: u ? h - x : h, width: n.globals.gridWidth, height: x } : { x: d ? c - f : c, y: u ? h - x : h, width: f, height: x }), {}, { translateX: n.globals.translateX, translateY: n.globals.translateY }), o.drawSelectionRect(m), o.selectionDragging("resizing"), m;
  } }, { key: "selectionDragging", value: function(i, r) {
    var a = this, n = this.w;
    if (r) {
      r.preventDefault();
      var o = r.detail, l = o.handler, c = o.box, h = c.x, d = c.y;
      h < this.constraints.x && (h = this.constraints.x), d < this.constraints.y && (d = this.constraints.y), c.x2 > this.constraints.x2 && (h = this.constraints.x2 - c.w), c.y2 > this.constraints.y2 && (d = this.constraints.y2 - c.h), l.move(h, d);
      var u = this.xyRatios, g = this.selectionRect, p = 0;
      i === "resizing" && (p = 30);
      var f = function(m) {
        return parseFloat(g.node.getAttribute(m));
      }, x = { x: f("x"), y: f("y"), width: f("width"), height: f("height") };
      n.globals.selection = x, typeof n.config.chart.events.selection == "function" && n.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var m, b, w, y, v = a.gridRect.getBoundingClientRect(), k = g.node.getBoundingClientRect();
        n.globals.isRangeBar ? (m = n.globals.yAxisScale[0].niceMin + (k.left - v.left) * u.invertedYRatio, b = n.globals.yAxisScale[0].niceMin + (k.right - v.left) * u.invertedYRatio, w = 0, y = 1) : (m = n.globals.xAxisScale.niceMin + (k.left - v.left) * u.xRatio, b = n.globals.xAxisScale.niceMin + (k.right - v.left) * u.xRatio, w = n.globals.yAxisScale[0].niceMin + (v.bottom - k.bottom) * u.yRatio[0], y = n.globals.yAxisScale[0].niceMax - (k.top - v.top) * u.yRatio[0]);
        var S = { xaxis: { min: m, max: b }, yaxis: { min: w, max: y } };
        n.config.chart.events.selection(a.ctx, S), n.config.chart.brush.enabled && n.config.chart.events.brushScrolled !== void 0 && n.config.chart.events.brushScrolled(a.ctx, S);
      }, p));
    }
  } }, { key: "selectionDrawn", value: function(i) {
    var r, a, n = i.context, o = i.zoomtype, l = this.w, c = n, h = this.xyRatios, d = this.ctx.toolbar, u = l.globals.zoomEnabled ? c.zoomRect.node.getBoundingClientRect() : c.selectionRect.node.getBoundingClientRect(), g = c.gridRect.getBoundingClientRect(), p = u.left - g.left - l.globals.barPadForNumericAxis, f = u.right - g.left - l.globals.barPadForNumericAxis, x = u.top - g.top, m = u.bottom - g.top;
    l.globals.isRangeBar ? (r = l.globals.yAxisScale[0].niceMin + p * h.invertedYRatio, a = l.globals.yAxisScale[0].niceMin + f * h.invertedYRatio) : (r = l.globals.xAxisScale.niceMin + p * h.xRatio, a = l.globals.xAxisScale.niceMin + f * h.xRatio);
    var b = [], w = [];
    if (l.config.yaxis.forEach(function(R, P) {
      var I = l.globals.seriesYAxisMap[P][0], D = l.globals.yAxisScale[P].niceMax - h.yRatio[I] * x, N = l.globals.yAxisScale[P].niceMax - h.yRatio[I] * m;
      b.push(D), w.push(N);
    }), c.dragged && (c.dragX > 10 || c.dragY > 10) && r !== a) {
      if (l.globals.zoomEnabled) {
        var y = F.clone(l.globals.initialConfig.yaxis), v = F.clone(l.globals.initialConfig.xaxis);
        if (l.globals.zoomed = !0, l.config.xaxis.convertedCatToNumeric && (r = Math.floor(r), a = Math.floor(a), r < 1 && (r = 1, a = l.globals.dataPoints), a - r < 2 && (a = r + 1)), o !== "xy" && o !== "x" || (v = { min: r, max: a }), o !== "xy" && o !== "y" || y.forEach(function(R, P) {
          y[P].min = w[P], y[P].max = b[P];
        }), d) {
          var k = d.getBeforeZoomRange(v, y);
          k && (v = k.xaxis ? k.xaxis : v, y = k.yaxis ? k.yaxis : y);
        }
        var S = { xaxis: v };
        l.config.chart.group || (S.yaxis = y), c.ctx.updateHelpers._updateOptions(S, !1, c.w.config.chart.animations.dynamicAnimation.enabled), typeof l.config.chart.events.zoomed == "function" && d.zoomCallback(v, y);
      } else if (l.globals.selectionEnabled) {
        var C, M = null;
        C = { min: r, max: a }, o !== "xy" && o !== "y" || (M = F.clone(l.config.yaxis)).forEach(function(R, P) {
          M[P].min = w[P], M[P].max = b[P];
        }), l.globals.selection = c.selection, typeof l.config.chart.events.selection == "function" && l.config.chart.events.selection(c.ctx, { xaxis: C, yaxis: M });
      }
    }
  } }, { key: "panDragging", value: function(i) {
    var r = i.context, a = this.w, n = r;
    if (a.globals.lastClientPosition.x !== void 0) {
      var o = a.globals.lastClientPosition.x - n.clientX, l = a.globals.lastClientPosition.y - n.clientY;
      Math.abs(o) > Math.abs(l) && o > 0 ? this.moveDirection = "left" : Math.abs(o) > Math.abs(l) && o < 0 ? this.moveDirection = "right" : Math.abs(l) > Math.abs(o) && l > 0 ? this.moveDirection = "up" : Math.abs(l) > Math.abs(o) && l < 0 && (this.moveDirection = "down");
    }
    a.globals.lastClientPosition = { x: n.clientX, y: n.clientY };
    var c = a.globals.isRangeBar ? a.globals.minY : a.globals.minX, h = a.globals.isRangeBar ? a.globals.maxY : a.globals.maxX;
    n.panScrolled(c, h);
  } }, { key: "panScrolled", value: function(i, r) {
    var a = this.w, n = this.xyRatios, o = F.clone(a.globals.initialConfig.yaxis), l = n.xRatio, c = a.globals.minX, h = a.globals.maxX;
    a.globals.isRangeBar && (l = n.invertedYRatio, c = a.globals.minY, h = a.globals.maxY), this.moveDirection === "left" ? (i = c + a.globals.gridWidth / 15 * l, r = h + a.globals.gridWidth / 15 * l) : this.moveDirection === "right" && (i = c - a.globals.gridWidth / 15 * l, r = h - a.globals.gridWidth / 15 * l), a.globals.isRangeBar || (i < a.globals.initialMinX || r > a.globals.initialMaxX) && (i = c, r = h);
    var d = { xaxis: { min: i, max: r } };
    a.config.chart.group || (d.yaxis = o), this.updateScrolledChart(d, i, r);
  } }, { key: "updateScrolledChart", value: function(i, r, a) {
    var n = this.w;
    if (this.ctx.updateHelpers._updateOptions(i, !1, !1), typeof n.config.chart.events.scrolled == "function") {
      var o = { xaxis: { min: r, max: a } };
      n.config.chart.events.scrolled(this.ctx, o), this.ctx.events.fireEvent("scrolled", o);
    }
  } }]), t;
}(), Eo = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx;
  }
  return ie(s, [{ key: "getNearestValues", value: function(e) {
    var t = e.hoverArea, i = e.elGrid, r = e.clientX, a = e.clientY, n = this.w, o = i.getBoundingClientRect(), l = o.width, c = o.height, h = l / (n.globals.dataPoints - 1), d = c / n.globals.dataPoints, u = this.hasBars();
    !n.globals.comboCharts && !u || n.config.xaxis.convertedCatToNumeric || (h = l / n.globals.dataPoints);
    var g = r - o.left - n.globals.barPadForNumericAxis, p = a - o.top;
    g < 0 || p < 0 || g > l || p > c ? (t.classList.remove("hovering-zoom"), t.classList.remove("hovering-pan")) : n.globals.zoomEnabled ? (t.classList.remove("hovering-pan"), t.classList.add("hovering-zoom")) : n.globals.panEnabled && (t.classList.remove("hovering-zoom"), t.classList.add("hovering-pan"));
    var f = Math.round(g / h), x = Math.floor(p / d);
    u && !n.config.xaxis.convertedCatToNumeric && (f = Math.ceil(g / h), f -= 1);
    var m = null, b = null, w = n.globals.seriesXvalues.map(function(C) {
      return C.filter(function(M) {
        return F.isNumber(M);
      });
    }), y = n.globals.seriesYvalues.map(function(C) {
      return C.filter(function(M) {
        return F.isNumber(M);
      });
    });
    if (n.globals.isXNumeric) {
      var v = this.ttCtx.getElGrid().getBoundingClientRect(), k = g * (v.width / l), S = p * (v.height / c);
      m = (b = this.closestInMultiArray(k, S, w, y)).index, f = b.j, m !== null && n.globals.hasNullValues && (w = n.globals.seriesXvalues[m], f = (b = this.closestInArray(k, w)).j);
    }
    return n.globals.capturedSeriesIndex = m === null ? -1 : m, (!f || f < 1) && (f = 0), n.globals.isBarHorizontal ? n.globals.capturedDataPointIndex = x : n.globals.capturedDataPointIndex = f, { capturedSeries: m, j: n.globals.isBarHorizontal ? x : f, hoverX: g, hoverY: p };
  } }, { key: "getFirstActiveXArray", value: function(e) {
    for (var t = this.w, i = 0, r = e.map(function(n, o) {
      return n.length > 0 ? o : -1;
    }), a = 0; a < r.length; a++) if (r[a] !== -1 && t.globals.collapsedSeriesIndices.indexOf(a) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(a) === -1) {
      i = r[a];
      break;
    }
    return i;
  } }, { key: "closestInMultiArray", value: function(e, t, i, r) {
    for (var a, n = this.w, o = 1 / 0, l = null, c = null, h = 0; h < i.length; h++) if (a = h, n.globals.collapsedSeriesIndices.indexOf(a) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(a) === -1) for (var d = i[h], u = r[h], g = Math.min(d.length, u.length), p = 0; p < g; p++) {
      var f = e - d[p], x = Math.sqrt(f * f);
      if (!n.globals.allSeriesHasEqualX) {
        var m = t - u[p];
        x = Math.sqrt(f * f + m * m);
      }
      x < o && (o = x, l = h, c = p);
    }
    return { index: l, j: c };
  } }, { key: "closestInArray", value: function(e, t) {
    for (var i = t[0], r = null, a = Math.abs(e - i), n = 0; n < t.length; n++) {
      var o = Math.abs(e - t[n]);
      o < a && (a = o, r = n);
    }
    return { j: r };
  } }, { key: "isXoverlap", value: function(e) {
    var t = [], i = this.w.globals.seriesX.filter(function(a) {
      return a[0] !== void 0;
    });
    if (i.length > 0) for (var r = 0; r < i.length - 1; r++) i[r][e] !== void 0 && i[r + 1][e] !== void 0 && i[r][e] !== i[r + 1][e] && t.push("unEqual");
    return t.length === 0;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var e = !0, t = this.w.globals.initialSeries, i = 0; i < t.length - 1; i++) if (t[i].data.length !== t[i + 1].data.length) {
      e = !1;
      break;
    }
    return e;
  } }, { key: "getBarsHeight", value: function(e) {
    return De(e).reduce(function(t, i) {
      return t + i.getBBox().height;
    }, 0);
  } }, { key: "getElMarkers", value: function(e) {
    return typeof e == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
  } }, { key: "getAllMarkers", value: function() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], i = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
    i = De(i), t && (i = i.filter(function(a) {
      var n = Number(a.getAttribute("data:realIndex"));
      return e.w.globals.collapsedSeriesIndices.indexOf(n) === -1;
    })), i.sort(function(a, n) {
      var o = Number(a.getAttribute("data:realIndex")), l = Number(n.getAttribute("data:realIndex"));
      return l < o ? 1 : l > o ? -1 : 0;
    });
    var r = [];
    return i.forEach(function(a) {
      r.push(a.querySelector(".apexcharts-marker"));
    }), r;
  } }, { key: "hasMarkers", value: function(e) {
    return this.getElMarkers(e).length > 0;
  } }, { key: "getPathFromPoint", value: function(e, t) {
    var i = Number(e.getAttribute("cx")), r = Number(e.getAttribute("cy")), a = e.getAttribute("shape");
    return new $(this.ctx).getMarkerPath(i, r, a, t);
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "getHoverMarkerSize", value: function(e) {
    var t = this.w, i = t.config.markers.hover.size;
    return i === void 0 && (i = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset), i;
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(e) {
    var t = this.w, i = this.ttCtx;
    i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var r = i.allTooltipSeriesGroups, a = 0; a < r.length; a++) e === "enable" ? (r[a].classList.add("apexcharts-active"), r[a].style.display = t.config.tooltip.items.display) : (r[a].classList.remove("apexcharts-active"), r[a].style.display = "none");
  } }]), s;
}(), gd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Eo(e);
  }
  return ie(s, [{ key: "drawSeriesTexts", value: function(e) {
    var t = e.shared, i = t === void 0 || t, r = e.ttItems, a = e.i, n = a === void 0 ? 0 : a, o = e.j, l = o === void 0 ? null : o, c = e.y1, h = e.y2, d = e.e, u = this.w;
    u.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: n, j: l, y1: c, y2: h, w: u }) : this.toggleActiveInactiveSeries(i, n);
    var g = this.getValuesToPrint({ i: n, j: l });
    this.printLabels({ i: n, j: l, values: g, ttItems: r, shared: i, e: d });
    var p = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(e) {
    var t, i = this, r = e.i, a = e.j, n = e.values, o = e.ttItems, l = e.shared, c = e.e, h = this.w, d = [], u = function(v) {
      return h.globals.seriesGoals[v] && h.globals.seriesGoals[v][a] && Array.isArray(h.globals.seriesGoals[v][a]);
    }, g = n.xVal, p = n.zVal, f = n.xAxisTTVal, x = "", m = h.globals.colors[r];
    a !== null && h.config.plotOptions.bar.distributed && (m = h.globals.colors[a]);
    for (var b = function(v, k) {
      var S = i.getFormatters(r);
      x = i.getSeriesName({ fn: S.yLbTitleFormatter, index: r, seriesIndex: r, j: a }), h.config.chart.type === "treemap" && (x = S.yLbTitleFormatter(String(h.config.series[r].data[a].x), { series: h.globals.series, seriesIndex: r, dataPointIndex: a, w: h }));
      var C = h.config.tooltip.inverseOrder ? k : v;
      if (h.globals.axisCharts) {
        var M = function(I) {
          var D, N, z, L;
          return h.globals.isRangeData ? S.yLbFormatter((D = h.globals.seriesRangeStart) === null || D === void 0 || (N = D[I]) === null || N === void 0 ? void 0 : N[a], { series: h.globals.seriesRangeStart, seriesIndex: I, dataPointIndex: a, w: h }) + " - " + S.yLbFormatter((z = h.globals.seriesRangeEnd) === null || z === void 0 || (L = z[I]) === null || L === void 0 ? void 0 : L[a], { series: h.globals.seriesRangeEnd, seriesIndex: I, dataPointIndex: a, w: h }) : S.yLbFormatter(h.globals.series[I][a], { series: h.globals.series, seriesIndex: I, dataPointIndex: a, w: h });
        };
        if (l) S = i.getFormatters(C), x = i.getSeriesName({ fn: S.yLbTitleFormatter, index: C, seriesIndex: r, j: a }), m = h.globals.colors[C], t = M(C), u(C) && (d = h.globals.seriesGoals[C][a].map(function(I) {
          return { attrs: I, val: S.yLbFormatter(I.value, { seriesIndex: C, dataPointIndex: a, w: h }) };
        }));
        else {
          var R, P = c == null || (R = c.target) === null || R === void 0 ? void 0 : R.getAttribute("fill");
          P && (P.indexOf("url") !== -1 ? P.indexOf("Pattern") !== -1 && (m = h.globals.dom.baseEl.querySelector(P.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : m = P), t = M(r), u(r) && Array.isArray(h.globals.seriesGoals[r][a]) && (d = h.globals.seriesGoals[r][a].map(function(I) {
            return { attrs: I, val: S.yLbFormatter(I.value, { seriesIndex: r, dataPointIndex: a, w: h }) };
          }));
        }
      }
      a === null && (t = S.yLbFormatter(h.globals.series[r], J(J({}, h), {}, { seriesIndex: r, dataPointIndex: r }))), i.DOMHandling({ i: r, t: C, j: a, ttItems: o, values: { val: t, goalVals: d, xVal: g, xAxisTTVal: f, zVal: p }, seriesName: x, shared: l, pColor: m });
    }, w = 0, y = h.globals.series.length - 1; w < h.globals.series.length; w++, y--) b(w, y);
  } }, { key: "getFormatters", value: function(e) {
    var t, i = this.w, r = i.globals.yLabelFormatters[e];
    return i.globals.ttVal !== void 0 ? Array.isArray(i.globals.ttVal) ? (r = i.globals.ttVal[e] && i.globals.ttVal[e].formatter, t = i.globals.ttVal[e] && i.globals.ttVal[e].title && i.globals.ttVal[e].title.formatter) : (r = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter == "function" && (t = i.globals.ttVal.title.formatter)) : t = i.config.tooltip.y.title.formatter, typeof r != "function" && (r = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(a) {
      return a;
    }), typeof t != "function" && (t = function(a) {
      return a ? a + ": " : "";
    }), { yLbFormatter: r, yLbTitleFormatter: t };
  } }, { key: "getSeriesName", value: function(e) {
    var t = e.fn, i = e.index, r = e.seriesIndex, a = e.j, n = this.w;
    return t(String(n.globals.seriesNames[i]), { series: n.globals.series, seriesIndex: r, dataPointIndex: a, w: n });
  } }, { key: "DOMHandling", value: function(e) {
    e.i;
    var t = e.t, i = e.j, r = e.ttItems, a = e.values, n = e.seriesName, o = e.shared, l = e.pColor, c = this.w, h = this.ttCtx, d = a.val, u = a.goalVals, g = a.xVal, p = a.xAxisTTVal, f = a.zVal, x = null;
    x = r[t].children, c.config.tooltip.fillSeriesColor && (r[t].style.backgroundColor = l, x[0].style.display = "none"), h.showTooltipTitle && (h.tooltipTitle === null && (h.tooltipTitle = c.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h.tooltipTitle.innerHTML = g), h.isXAxisTooltipEnabled && (h.xaxisTooltipText.innerHTML = p !== "" ? p : g);
    var m = r[t].querySelector(".apexcharts-tooltip-text-y-label");
    m && (m.innerHTML = n || "");
    var b = r[t].querySelector(".apexcharts-tooltip-text-y-value");
    b && (b.innerHTML = d !== void 0 ? d : ""), x[0] && x[0].classList.contains("apexcharts-tooltip-marker") && (c.config.tooltip.marker.fillColors && Array.isArray(c.config.tooltip.marker.fillColors) && (l = c.config.tooltip.marker.fillColors[t]), c.config.tooltip.fillSeriesColor ? x[0].style.backgroundColor = l : x[0].style.color = l), c.config.tooltip.marker.show || (x[0].style.display = "none");
    var w = r[t].querySelector(".apexcharts-tooltip-text-goals-label"), y = r[t].querySelector(".apexcharts-tooltip-text-goals-value");
    if (u.length && c.globals.seriesGoals[t]) {
      var v = function() {
        var C = "<div>", M = "<div>";
        u.forEach(function(R, P) {
          C += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(R.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(R.attrs.name, "</div>"), M += "<div>".concat(R.val, "</div>");
        }), w.innerHTML = C + "</div>", y.innerHTML = M + "</div>";
      };
      o ? c.globals.seriesGoals[t][i] && Array.isArray(c.globals.seriesGoals[t][i]) ? v() : (w.innerHTML = "", y.innerHTML = "") : v();
    } else w.innerHTML = "", y.innerHTML = "";
    if (f !== null && (r[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = c.config.tooltip.z.title, r[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = f !== void 0 ? f : ""), o && x[0]) {
      if (c.config.tooltip.hideEmptySeries) {
        var k = r[t].querySelector(".apexcharts-tooltip-marker"), S = r[t].querySelector(".apexcharts-tooltip-text");
        parseFloat(d) == 0 ? (k.style.display = "none", S.style.display = "none") : (k.style.display = "block", S.style.display = "block");
      }
      d == null || c.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || c.globals.collapsedSeriesIndices.indexOf(t) > -1 || Array.isArray(h.tConfig.enabledOnSeries) && h.tConfig.enabledOnSeries.indexOf(t) === -1 ? x[0].parentNode.style.display = "none" : x[0].parentNode.style.display = c.config.tooltip.items.display;
    } else Array.isArray(h.tConfig.enabledOnSeries) && h.tConfig.enabledOnSeries.indexOf(t) === -1 && (x[0].parentNode.style.display = "none");
  } }, { key: "toggleActiveInactiveSeries", value: function(e, t) {
    var i = this.w;
    if (e) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var r = i.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(t));
      r && (r.classList.add("apexcharts-active"), r.style.display = i.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(e) {
    var t = e.i, i = e.j, r = this.w, a = this.ctx.series.filteredSeriesX(), n = "", o = "", l = null, c = null, h = { series: r.globals.series, seriesIndex: t, dataPointIndex: i, w: r }, d = r.globals.ttZFormatter;
    i === null ? c = r.globals.series[t] : r.globals.isXNumeric && r.config.chart.type !== "treemap" ? (n = a[t][i], a[t].length === 0 && (n = a[this.tooltipUtil.getFirstActiveXArray(a)][i])) : n = new ea(this.ctx).isFormatXY() ? r.config.series[t].data[i] !== void 0 ? r.config.series[t].data[i].x : "" : r.globals.labels[i] !== void 0 ? r.globals.labels[i] : "";
    var u = n;
    return r.globals.isXNumeric && r.config.xaxis.type === "datetime" ? n = new _i(this.ctx).xLabelFormat(r.globals.ttKeyFormatter, u, u, { i: void 0, dateFormatter: new je(this.ctx).formatDate, w: this.w }) : n = r.globals.isBarHorizontal ? r.globals.yLabelFormatters[0](u, h) : r.globals.xLabelFormatter(u, h), r.config.tooltip.x.formatter !== void 0 && (n = r.globals.ttKeyFormatter(u, h)), r.globals.seriesZ.length > 0 && r.globals.seriesZ[t].length > 0 && (l = d(r.globals.seriesZ[t][i], r)), o = typeof r.config.xaxis.tooltip.formatter == "function" ? r.globals.xaxisTooltipFormatter(u, h) : n, { val: Array.isArray(c) ? c.join(" ") : c, xVal: Array.isArray(n) ? n.join(" ") : n, xAxisTTVal: Array.isArray(o) ? o.join(" ") : o, zVal: l };
  } }, { key: "handleCustomTooltip", value: function(e) {
    var t = e.i, i = e.j, r = e.y1, a = e.y2, n = e.w, o = this.ttCtx.getElTooltip(), l = n.config.tooltip.custom;
    Array.isArray(l) && l[t] && (l = l[t]);
    var c = l({ ctx: this.ctx, series: n.globals.series, seriesIndex: t, dataPointIndex: i, y1: r, y2: a, w: n });
    typeof c == "string" || typeof c == "number" ? o.innerHTML = c : (c instanceof Element || typeof c.nodeName == "string") && (o.innerHTML = "", o.appendChild(c.cloneNode(!0)));
  } }]), s;
}(), To = function() {
  function s(e) {
    te(this, s), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w;
  }
  return ie(s, [{ key: "moveXCrosshairs", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.ttCtx, r = this.w, a = i.getElXCrosshairs(), n = e - i.xcrosshairsWidth / 2, o = r.globals.labels.slice().length;
    if (t !== null && (n = r.globals.gridWidth / o * t), a === null || r.globals.isBarHorizontal || (a.setAttribute("x", n), a.setAttribute("x1", n), a.setAttribute("x2", n), a.setAttribute("y2", r.globals.gridHeight), a.classList.add("apexcharts-active")), n < 0 && (n = 0), n > r.globals.gridWidth && (n = r.globals.gridWidth), i.isXAxisTooltipEnabled) {
      var l = n;
      r.config.xaxis.crosshairs.width !== "tickWidth" && r.config.xaxis.crosshairs.width !== "barWidth" || (l = n + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(l);
    }
  } }, { key: "moveYCrosshairs", value: function(e) {
    var t = this.ttCtx;
    t.ycrosshairs !== null && $.setAttrs(t.ycrosshairs, { y1: e, y2: e }), t.ycrosshairsHidden !== null && $.setAttrs(t.ycrosshairsHidden, { y1: e, y2: e });
  } }, { key: "moveXAxisTooltip", value: function(e) {
    var t = this.w, i = this.ttCtx;
    if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
      i.xaxisTooltip.classList.add("apexcharts-active");
      var r = i.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY;
      if (e -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(e)) {
        e += t.globals.translateX;
        var a;
        a = new $(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = a.width + "px", i.xaxisTooltip.style.left = e + "px", i.xaxisTooltip.style.top = r + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(e) {
    var t = this.w, i = this.ttCtx;
    i.yaxisTTEls === null && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var r = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), a = t.globals.translateY + r, n = i.yaxisTTEls[e].getBoundingClientRect(), o = n.height, l = t.globals.translateYAxisX[e] - 2;
    t.config.yaxis[e].opposite && (l -= n.width), a -= o / 2, t.globals.ignoreYAxisIndexes.indexOf(e) === -1 && a > 0 && a < t.globals.gridHeight ? (i.yaxisTTEls[e].classList.add("apexcharts-active"), i.yaxisTTEls[e].style.top = a + "px", i.yaxisTTEls[e].style.left = l + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active");
  } }, { key: "moveTooltip", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = this.w, a = this.ttCtx, n = a.getElTooltip(), o = a.tooltipRect, l = i !== null ? parseFloat(i) : 1, c = parseFloat(e) + l + 5, h = parseFloat(t) + l / 2;
    if (c > r.globals.gridWidth / 2 && (c = c - o.ttWidth - l - 10), c > r.globals.gridWidth - o.ttWidth - 10 && (c = r.globals.gridWidth - o.ttWidth), c < -20 && (c = -20), r.config.tooltip.followCursor) {
      var d = a.getElGrid().getBoundingClientRect();
      (c = a.e.clientX - d.left) > r.globals.gridWidth / 2 && (c -= a.tooltipRect.ttWidth), (h = a.e.clientY + r.globals.translateY - d.top) > r.globals.gridHeight / 2 && (h -= a.tooltipRect.ttHeight);
    } else r.globals.isBarHorizontal || o.ttHeight / 2 + h > r.globals.gridHeight && (h = r.globals.gridHeight - o.ttHeight + r.globals.translateY);
    isNaN(c) || (c += r.globals.translateX, n.style.left = c + "px", n.style.top = h + "px");
  } }, { key: "moveMarkers", value: function(e, t) {
    var i = this.w, r = this.ttCtx;
    if (i.globals.markers.size[e] > 0) for (var a = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), n = 0; n < a.length; n++) parseInt(a[n].getAttribute("rel"), 10) === t && (r.marker.resetPointsSize(), r.marker.enlargeCurrentPoint(t, a[n]));
    else r.marker.resetPointsSize(), this.moveDynamicPointOnHover(t, e);
  } }, { key: "moveDynamicPointOnHover", value: function(e, t) {
    var i, r, a, n, o = this.w, l = this.ttCtx, c = new $(this.ctx), h = o.globals.pointsArray, d = l.tooltipUtil.getHoverMarkerSize(t), u = o.config.series[t].type;
    if (!u || u !== "column" && u !== "candlestick" && u !== "boxPlot") {
      a = (i = h[t][e]) === null || i === void 0 ? void 0 : i[0], n = ((r = h[t][e]) === null || r === void 0 ? void 0 : r[1]) || 0;
      var g = o.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers path"));
      if (g && n < o.globals.gridHeight && n > 0) {
        var p = g.getAttribute("shape"), f = c.getMarkerPath(a, n, p, 1.5 * d);
        g.setAttribute("d", f);
      }
      this.moveXCrosshairs(a), l.fixedTooltip || this.moveTooltip(a, n, d);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(e) {
    var t, i = this.ttCtx, r = i.w, a = 0, n = 0, o = r.globals.pointsArray, l = new ct(this.ctx), c = new $(this.ctx);
    t = l.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
    var h = i.tooltipUtil.getHoverMarkerSize(t);
    if (o[t] && (a = o[t][e][0], n = o[t][e][1]), !isNaN(a)) {
      var d = i.tooltipUtil.getAllMarkers();
      if (d.length) for (var u = 0; u < r.globals.series.length; u++) {
        var g = o[u];
        if (r.globals.comboCharts && g === void 0 && d.splice(u, 0, null), g && g.length) {
          var p = o[u][e][1], f = void 0;
          d[u].setAttribute("cx", a);
          var x = d[u].getAttribute("shape");
          if (r.config.chart.type === "rangeArea" && !r.globals.comboCharts) {
            var m = e + r.globals.series[u].length;
            f = o[u][m][1], p -= Math.abs(p - f) / 2;
          }
          if (p !== null && !isNaN(p) && p < r.globals.gridHeight + h && p + h > 0) {
            var b = c.getMarkerPath(a, p, x, h);
            d[u].setAttribute("d", b);
          } else d[u].setAttribute("d", "");
        }
      }
      this.moveXCrosshairs(a), i.fixedTooltip || this.moveTooltip(a, n || r.globals.gridHeight, h);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(e, t) {
    var i = this.w, r = this.ttCtx, a = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length;
    i.config.chart.stacked && (a = i.globals.barGroups.length);
    var n = a >= 2 && a % 2 == 0 ? Math.floor(a / 2) : Math.floor(a / 2) + 1;
    i.globals.isBarHorizontal && (n = new ct(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    var o = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(n, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "']"));
    o || typeof t != "number" || (o = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(t, "'] path[j='").concat(e, "']")));
    var l = o ? parseFloat(o.getAttribute("cx")) : 0, c = o ? parseFloat(o.getAttribute("cy")) : 0, h = o ? parseFloat(o.getAttribute("barWidth")) : 0, d = r.getElGrid().getBoundingClientRect(), u = o && (o.classList.contains("apexcharts-candlestick-area") || o.classList.contains("apexcharts-boxPlot-area"));
    i.globals.isXNumeric ? (o && !u && (l -= a % 2 != 0 ? h / 2 : 0), o && u && (l -= h / 2)) : i.globals.isBarHorizontal || (l = r.xAxisTicksPositions[e - 1] + r.dataPointsDividedWidth / 2, isNaN(l) && (l = r.xAxisTicksPositions[e] - r.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? c -= r.tooltipRect.ttHeight : i.config.tooltip.followCursor ? c = r.e.clientY - d.top - r.tooltipRect.ttHeight / 2 : c + r.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (c = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(l), r.fixedTooltip || this.moveTooltip(l, c || i.globals.gridHeight);
  } }]), s;
}(), fd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new To(e);
  }
  return ie(s, [{ key: "drawDynamicPoints", value: function() {
    var e = this.w, t = new $(this.ctx), i = new ni(this.ctx), r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    r = De(r), e.config.chart.stacked && r.sort(function(d, u) {
      return parseFloat(d.getAttribute("data:realIndex")) - parseFloat(u.getAttribute("data:realIndex"));
    });
    for (var a = 0; a < r.length; a++) {
      var n = r[a].querySelector(".apexcharts-series-markers-wrap");
      if (n !== null) {
        var o = void 0, l = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        e.config.chart.type !== "line" && e.config.chart.type !== "area" || e.globals.comboCharts || e.config.tooltip.intersect || (l += " no-pointer-events");
        var c = i.getMarkerConfig({ cssClass: l, seriesIndex: Number(n.getAttribute("data:realIndex")) });
        (o = t.drawMarker(0, 0, c)).node.setAttribute("default-marker-size", 0);
        var h = document.createElementNS(e.globals.SVGNS, "g");
        h.classList.add("apexcharts-series-markers"), h.appendChild(o.node), n.appendChild(h);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, a = this.w;
    a.config.chart.type !== "bubble" && this.newPointSize(e, t);
    var n = t.getAttribute("cx"), o = t.getAttribute("cy");
    if (i !== null && r !== null && (n = i, o = r), this.tooltipPosition.moveXCrosshairs(n), !this.fixedTooltip) {
      if (a.config.chart.type === "radar") {
        var l = this.ttCtx.getElGrid().getBoundingClientRect();
        n = this.ttCtx.e.clientX - l.left;
      }
      this.tooltipPosition.moveTooltip(n, o, a.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(e) {
    for (var t = this.w, i = this, r = this.ttCtx, a = e, n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o = t.config.markers.hover.size, l = 0; l < n.length; l++) {
      var c = n[l].getAttribute("rel"), h = n[l].getAttribute("index");
      if (o === void 0 && (o = t.globals.markers.size[h] + t.config.markers.hover.sizeOffset), a === parseInt(c, 10)) {
        i.newPointSize(a, n[l]);
        var d = n[l].getAttribute("cx"), u = n[l].getAttribute("cy");
        i.tooltipPosition.moveXCrosshairs(d), r.fixedTooltip || i.tooltipPosition.moveTooltip(d, u, o);
      } else i.oldPointSize(n[l]);
    }
  } }, { key: "newPointSize", value: function(e, t) {
    var i = this.w, r = i.config.markers.hover.size, a = e === 0 ? t.parentNode.firstChild : t.parentNode.lastChild;
    if (a.getAttribute("default-marker-size") !== "0") {
      var n = parseInt(a.getAttribute("index"), 10);
      r === void 0 && (r = i.globals.markers.size[n] + i.config.markers.hover.sizeOffset), r < 0 && (r = 0);
      var o = this.ttCtx.tooltipUtil.getPathFromPoint(t, r);
      t.setAttribute("d", o);
    }
  } }, { key: "oldPointSize", value: function(e) {
    var t = parseFloat(e.getAttribute("default-marker-size")), i = this.ttCtx.tooltipUtil.getPathFromPoint(e, t);
    e.setAttribute("d", i);
  } }, { key: "resetPointsSize", value: function() {
    for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
      var i = parseFloat(e[t].getAttribute("default-marker-size"));
      if (F.isNumber(i) && i > 0) {
        var r = this.ttCtx.tooltipUtil.getPathFromPoint(e[t], i);
        e[t].setAttribute("d", r);
      } else e[t].setAttribute("d", "M0,0");
    }
  } }]), s;
}(), pd = function() {
  function s(e) {
    te(this, s), this.w = e.w;
    var t = this.w;
    this.ttCtx = e, this.isVerticalGroupedRangeBar = !t.globals.isBarHorizontal && t.config.chart.type === "rangeBar" && t.config.plotOptions.bar.rangeBarGroupRows;
  }
  return ie(s, [{ key: "getAttr", value: function(e, t) {
    return parseFloat(e.target.getAttribute(t));
  } }, { key: "handleHeatTreeTooltip", value: function(e) {
    var t = e.e, i = e.opt, r = e.x, a = e.y, n = e.type, o = this.ttCtx, l = this.w;
    if (t.target.classList.contains("apexcharts-".concat(n, "-rect"))) {
      var c = this.getAttr(t, "i"), h = this.getAttr(t, "j"), d = this.getAttr(t, "cx"), u = this.getAttr(t, "cy"), g = this.getAttr(t, "width"), p = this.getAttr(t, "height");
      if (o.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: c, j: h, shared: !1, e: t }), l.globals.capturedSeriesIndex = c, l.globals.capturedDataPointIndex = h, r = d + o.tooltipRect.ttWidth / 2 + g, a = u + o.tooltipRect.ttHeight / 2 - p / 2, o.tooltipPosition.moveXCrosshairs(d + g / 2), r > l.globals.gridWidth / 2 && (r = d - o.tooltipRect.ttWidth / 2 + g), o.w.config.tooltip.followCursor) {
        var f = l.globals.dom.elWrap.getBoundingClientRect();
        r = l.globals.clientX - f.left - (r > l.globals.gridWidth / 2 ? o.tooltipRect.ttWidth : 0), a = l.globals.clientY - f.top - (a > l.globals.gridHeight / 2 ? o.tooltipRect.ttHeight : 0);
      }
    }
    return { x: r, y: a };
  } }, { key: "handleMarkerTooltip", value: function(e) {
    var t, i, r = e.e, a = e.opt, n = e.x, o = e.y, l = this.w, c = this.ttCtx;
    if (r.target.classList.contains("apexcharts-marker")) {
      var h = parseInt(a.paths.getAttribute("cx"), 10), d = parseInt(a.paths.getAttribute("cy"), 10), u = parseFloat(a.paths.getAttribute("val"));
      if (i = parseInt(a.paths.getAttribute("rel"), 10), t = parseInt(a.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, c.intersect) {
        var g = F.findAncestor(a.paths, "apexcharts-series");
        g && (t = parseInt(g.getAttribute("data:realIndex"), 10));
      }
      if (c.tooltipLabels.drawSeriesTexts({ ttItems: a.ttItems, i: t, j: i, shared: !c.showOnIntersect && l.config.tooltip.shared, e: r }), r.type === "mouseup" && c.markerClick(r, t, i), l.globals.capturedSeriesIndex = t, l.globals.capturedDataPointIndex = i, n = h, o = d + l.globals.translateY - 1.4 * c.tooltipRect.ttHeight, c.w.config.tooltip.followCursor) {
        var p = c.getElGrid().getBoundingClientRect();
        o = c.e.clientY + l.globals.translateY - p.top;
      }
      u < 0 && (o = d), c.marker.enlargeCurrentPoint(i, a.paths, n, o);
    }
    return { x: n, y: o };
  } }, { key: "handleBarTooltip", value: function(e) {
    var t, i, r = e.e, a = e.opt, n = this.w, o = this.ttCtx, l = o.getElTooltip(), c = 0, h = 0, d = 0, u = this.getBarTooltipXY({ e: r, opt: a });
    if (u.j !== null || u.barHeight !== 0 || u.barWidth !== 0) {
      t = u.i;
      var g = u.j;
      if (n.globals.capturedSeriesIndex = t, n.globals.capturedDataPointIndex = g, n.globals.isBarHorizontal && o.tooltipUtil.hasBars() || !n.config.tooltip.shared ? (h = u.x, d = u.y, i = Array.isArray(n.config.stroke.width) ? n.config.stroke.width[t] : n.config.stroke.width, c = h) : n.globals.comboCharts || n.config.tooltip.shared || (c /= 2), isNaN(d) && (d = n.globals.svgHeight - o.tooltipRect.ttHeight), parseInt(a.paths.parentNode.getAttribute("data:realIndex"), 10), h + o.tooltipRect.ttWidth > n.globals.gridWidth ? h -= o.tooltipRect.ttWidth : h < 0 && (h = 0), o.w.config.tooltip.followCursor) {
        var p = o.getElGrid().getBoundingClientRect();
        d = o.e.clientY - p.top;
      }
      o.tooltip === null && (o.tooltip = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), n.config.tooltip.shared || (n.globals.comboBarCount > 0 ? o.tooltipPosition.moveXCrosshairs(c + i / 2) : o.tooltipPosition.moveXCrosshairs(c)), !o.fixedTooltip && (!n.config.tooltip.shared || n.globals.isBarHorizontal && o.tooltipUtil.hasBars()) && (d = d + n.globals.translateY - o.tooltipRect.ttHeight / 2, l.style.left = h + n.globals.translateX + "px", l.style.top = d + "px");
    }
  } }, { key: "getBarTooltipXY", value: function(e) {
    var t = this, i = e.e, r = e.opt, a = this.w, n = null, o = this.ttCtx, l = 0, c = 0, h = 0, d = 0, u = 0, g = i.target.classList;
    if (g.contains("apexcharts-bar-area") || g.contains("apexcharts-candlestick-area") || g.contains("apexcharts-boxPlot-area") || g.contains("apexcharts-rangebar-area")) {
      var p = i.target, f = p.getBoundingClientRect(), x = r.elGrid.getBoundingClientRect(), m = f.height;
      u = f.height;
      var b = f.width, w = parseInt(p.getAttribute("cx"), 10), y = parseInt(p.getAttribute("cy"), 10);
      d = parseFloat(p.getAttribute("barWidth"));
      var v = i.type === "touchmove" ? i.touches[0].clientX : i.clientX;
      n = parseInt(p.getAttribute("j"), 10), l = parseInt(p.parentNode.getAttribute("rel"), 10) - 1;
      var k = p.getAttribute("data-range-y1"), S = p.getAttribute("data-range-y2");
      a.globals.comboCharts && (l = parseInt(p.parentNode.getAttribute("data:realIndex"), 10));
      var C = function(R) {
        return a.globals.isXNumeric ? w - b / 2 : t.isVerticalGroupedRangeBar ? w + b / 2 : w - o.dataPointsDividedWidth + b / 2;
      }, M = function() {
        return y - o.dataPointsDividedHeight + m / 2 - o.tooltipRect.ttHeight / 2;
      };
      o.tooltipLabels.drawSeriesTexts({ ttItems: r.ttItems, i: l, j: n, y1: k ? parseInt(k, 10) : null, y2: S ? parseInt(S, 10) : null, shared: !o.showOnIntersect && a.config.tooltip.shared, e: i }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (c = v - x.left + 15, h = M()) : (c = C(), h = i.clientY - x.top - o.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((c = w) < o.xyRatios.baseLineInvertedY && (c = w - o.tooltipRect.ttWidth), h = M()) : (c = C(), h = y);
    }
    return { x: c, y: h, barHeight: u, barWidth: d, i: l, j: n };
  } }]), s;
}(), xd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.ttCtx = e;
  }
  return ie(s, [{ key: "drawXaxisTooltip", value: function() {
    var e = this.w, t = this.ttCtx, i = e.config.xaxis.position === "bottom";
    t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
    var r = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", a = e.globals.dom.elWrap;
    t.isXAxisTooltipEnabled && e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (t.xaxisTooltip = document.createElement("div"), t.xaxisTooltip.setAttribute("class", r + " apexcharts-theme-" + e.config.tooltip.theme), a.appendChild(t.xaxisTooltip), t.xaxisTooltipText = document.createElement("div"), t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily, t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize, t.xaxisTooltip.appendChild(t.xaxisTooltipText));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var e = this.w, t = this.ttCtx, i = 0; i < e.config.yaxis.length; i++) {
      var r = e.config.yaxis[i].opposite || e.config.yaxis[i].crosshairs.opposite;
      t.yaxisOffX = r ? e.globals.gridWidth + 1 : 1;
      var a = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, r ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), n = e.globals.dom.elWrap;
      e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) === null && (t.yaxisTooltip = document.createElement("div"), t.yaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + e.config.tooltip.theme), n.appendChild(t.yaxisTooltip), i === 0 && (t.yaxisTooltipText = []), t.yaxisTooltipText[i] = document.createElement("div"), t.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), t.yaxisTooltip.appendChild(t.yaxisTooltipText[i]));
    }
  } }, { key: "setXCrosshairWidth", value: function() {
    var e = this.w, t = this.ttCtx, i = t.getElXCrosshairs();
    if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10), e.globals.comboCharts) {
      var r = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (r !== null && e.config.xaxis.crosshairs.width === "barWidth") {
        var a = parseFloat(r.getAttribute("barWidth"));
        t.xcrosshairsWidth = a;
      } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
        var n = e.globals.labels.length;
        t.xcrosshairsWidth = e.globals.gridWidth / n;
      }
    } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
      var o = e.globals.labels.length;
      t.xcrosshairsWidth = e.globals.gridWidth / o;
    } else if (e.config.xaxis.crosshairs.width === "barWidth") {
      var l = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (l !== null) {
        var c = parseFloat(l.getAttribute("barWidth"));
        t.xcrosshairsWidth = c;
      } else t.xcrosshairsWidth = 1;
    }
    e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0), i !== null && t.xcrosshairsWidth > 0 && i.setAttribute("width", t.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var e = this.w, t = this.ttCtx;
    t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(e, t, i) {
    var r = this.ttCtx, a = this.w, n = a.globals, o = n.seriesYAxisMap[e];
    if (r.yaxisTooltips[e] && o.length > 0) {
      var l = n.yLabelFormatters[e], c = r.getElGrid().getBoundingClientRect(), h = o[0], d = 0;
      i.yRatio.length > 1 && (d = h);
      var u = (t - c.top) * i.yRatio[d], g = n.maxYArr[h] - n.minYArr[h], p = n.minYArr[h] + (g - u);
      a.config.yaxis[e].reversed && (p = n.maxYArr[h] - (g - u)), r.tooltipPosition.moveYCrosshairs(t - c.top), r.yaxisTooltipText[e].innerHTML = l(p), r.tooltipPosition.moveYAxisTooltip(e);
    }
  } }]), s;
}(), Za = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.tConfig = t.config.tooltip, this.tooltipUtil = new Eo(this), this.tooltipLabels = new gd(this), this.tooltipPosition = new To(this), this.marker = new fd(this), this.intersect = new pd(this), this.axesTooltip = new xd(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !t.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return ie(s, [{ key: "getElTooltip", value: function(e) {
    return e || (e = this), e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(e) {
    var t = this.w;
    this.xyRatios = e, this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts, this.yaxisTooltips = t.config.yaxis.map(function(n, o) {
      return !!(n.show && n.tooltip.enabled && t.globals.axisCharts);
    }), this.allTooltipSeriesGroups = [], t.globals.axisCharts || (this.showTooltipTitle = !1);
    var i = document.createElement("div");
    if (i.classList.add("apexcharts-tooltip"), t.config.tooltip.cssClass && i.classList.add(t.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme || "light")), t.globals.dom.elWrap.appendChild(i), t.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var r = new Ri(this.ctx);
      this.xAxisTicksPositions = r.getXAxisTicksPositions();
    }
    if (!t.globals.comboCharts && !this.tConfig.intersect && t.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), t.config.markers.size !== 0 && t.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), t.globals.collapsedSeries.length !== t.globals.series.length) {
      this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints, this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
      var a = t.globals.series.length;
      (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (a = this.showOnIntersect ? 1 : t.globals.series.length), this.legendLabels = t.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(a), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(e) {
    for (var t = this, i = this.w, r = [], a = this.getElTooltip(), n = function(l) {
      var c = document.createElement("div");
      c.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(l)), c.style.order = i.config.tooltip.inverseOrder ? e - l : l + 1;
      var h = document.createElement("span");
      h.classList.add("apexcharts-tooltip-marker"), i.config.tooltip.fillSeriesColor ? h.style.backgroundColor = i.globals.colors[l] : h.style.color = i.globals.colors[l];
      var d = i.config.markers.shape, u = d;
      Array.isArray(d) && (u = d[l]), h.setAttribute("shape", u), c.appendChild(h);
      var g = document.createElement("div");
      g.classList.add("apexcharts-tooltip-text"), g.style.fontFamily = t.tConfig.style.fontFamily || i.config.chart.fontFamily, g.style.fontSize = t.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(p) {
        var f = document.createElement("div");
        f.classList.add("apexcharts-tooltip-".concat(p, "-group"));
        var x = document.createElement("span");
        x.classList.add("apexcharts-tooltip-text-".concat(p, "-label")), f.appendChild(x);
        var m = document.createElement("span");
        m.classList.add("apexcharts-tooltip-text-".concat(p, "-value")), f.appendChild(m), g.appendChild(f);
      }), c.appendChild(g), a.appendChild(c), r.push(c);
    }, o = 0; o < e; o++) n(o);
    return r;
  } }, { key: "addSVGEvents", value: function() {
    var e = this.w, t = e.config.chart.type, i = this.getElTooltip(), r = !(t !== "bar" && t !== "candlestick" && t !== "boxPlot" && t !== "rangeBar"), a = t === "area" || t === "line" || t === "scatter" || t === "bubble" || t === "radar", n = e.globals.dom.Paper.node, o = this.getElGrid();
    o && (this.seriesBound = o.getBoundingClientRect());
    var l, c = [], h = [], d = { hoverArea: n, elGrid: o, tooltipEl: i, tooltipY: c, tooltipX: h, ttItems: this.ttItems };
    if (e.globals.axisCharts && (a ? l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : r ? l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : t !== "heatmap" && t !== "treemap" || (l = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), l && l.length)) for (var u = 0; u < l.length; u++) c.push(l[u].getAttribute("cy")), h.push(l[u].getAttribute("cx"));
    if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || r && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([n], d);
    else if (r && !e.globals.comboCharts || a && this.showOnIntersect) this.addDatapointEventsListeners(d);
    else if (!e.globals.axisCharts || t === "heatmap" || t === "treemap") {
      var g = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(g, d);
    }
    if (this.showOnIntersect) {
      var p = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
      p.length > 0 && this.addPathsEventListeners(p, d), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(d);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var e = this.w, t = this.getElTooltip(), i = t.getBoundingClientRect(), r = i.width + 10, a = i.height + 10, n = this.tConfig.fixed.offsetX, o = this.tConfig.fixed.offsetY, l = this.tConfig.fixed.position.toLowerCase();
    return l.indexOf("right") > -1 && (n = n + e.globals.svgWidth - r + 10), l.indexOf("bottom") > -1 && (o = o + e.globals.svgHeight - a - 10), t.style.left = n + "px", t.style.top = o + "px", { x: n, y: o, ttWidth: r, ttHeight: a };
  } }, { key: "addDatapointEventsListeners", value: function(e) {
    var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(t, e);
  } }, { key: "addPathsEventListeners", value: function(e, t) {
    for (var i = this, r = function(n) {
      var o = { paths: e[n], tooltipEl: t.tooltipEl, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: t.ttItems };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(l) {
        return e[n].addEventListener(l, i.onSeriesHover.bind(i, o), { capture: !1, passive: !0 });
      });
    }, a = 0; a < e.length; a++) r(a);
  } }, { key: "onSeriesHover", value: function(e, t) {
    var i = this, r = Date.now() - this.lastHoverTime;
    r >= 20 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
      i.seriesHover(e, t);
    }, 20 - r));
  } }, { key: "seriesHover", value: function(e, t) {
    var i = this;
    this.lastHoverTime = Date.now();
    var r = [], a = this.w;
    a.config.chart.group && (r = this.ctx.getGroupedCharts()), a.globals.axisCharts && (a.globals.minX === -1 / 0 && a.globals.maxX === 1 / 0 || a.globals.dataPoints === 0) || (r.length ? r.forEach(function(n) {
      var o = i.getElTooltip(n), l = { paths: e.paths, tooltipEl: o, tooltipY: e.tooltipY, tooltipX: e.tooltipX, elGrid: e.elGrid, hoverArea: e.hoverArea, ttItems: n.w.globals.tooltip.ttItems };
      n.w.globals.minX === i.w.globals.minX && n.w.globals.maxX === i.w.globals.maxX && n.w.globals.tooltip.seriesHoverByContext({ chartCtx: n, ttCtx: n.w.globals.tooltip, opt: l, e: t });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: e, e: t }));
  } }, { key: "seriesHoverByContext", value: function(e) {
    var t = e.chartCtx, i = e.ttCtx, r = e.opt, a = e.e, n = t.w, o = this.getElTooltip(t);
    o && (i.tooltipRect = { x: 0, y: 0, ttWidth: o.getBoundingClientRect().width, ttHeight: o.getBoundingClientRect().height }, i.e = a, i.tooltipUtil.hasBars() && !n.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new ct(t).toggleSeriesOnHover(a, a.target.parentNode), n.globals.axisCharts ? i.axisChartsTooltips({ e: a, opt: r, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: a, opt: r, tooltipRect: i.tooltipRect }), i.fixedTooltip && i.drawFixedTooltipRect());
  } }, { key: "axisChartsTooltips", value: function(e) {
    var t, i, r = e.e, a = e.opt, n = this.w, o = a.elGrid.getBoundingClientRect(), l = r.type === "touchmove" ? r.touches[0].clientX : r.clientX, c = r.type === "touchmove" ? r.touches[0].clientY : r.clientY;
    if (this.clientY = c, this.clientX = l, n.globals.capturedSeriesIndex = -1, n.globals.capturedDataPointIndex = -1, c < o.top || c > o.top + o.height) this.handleMouseOut(a);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !n.config.tooltip.shared) {
        var h = parseInt(a.paths.getAttribute("index"), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h) < 0) return void this.handleMouseOut(a);
      }
      var d = this.getElTooltip(), u = this.getElXCrosshairs(), g = [];
      n.config.chart.group && (g = this.ctx.getSyncedCharts());
      var p = n.globals.xyCharts || n.config.chart.type === "bar" && !n.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || n.globals.comboCharts && this.tooltipUtil.hasBars();
      if (r.type === "mousemove" || r.type === "touchmove" || r.type === "mouseup") {
        if (n.globals.collapsedSeries.length + n.globals.ancillaryCollapsedSeries.length === n.globals.series.length) return;
        u !== null && u.classList.add("apexcharts-active");
        var f = this.yaxisTooltips.filter(function(b) {
          return b === !0;
        });
        if (this.ycrosshairs !== null && f.length && this.ycrosshairs.classList.add("apexcharts-active"), p && !this.showOnIntersect || g.length > 1) this.handleStickyTooltip(r, l, c, a);
        else if (n.config.chart.type === "heatmap" || n.config.chart.type === "treemap") {
          var x = this.intersect.handleHeatTreeTooltip({ e: r, opt: a, x: t, y: i, type: n.config.chart.type });
          t = x.x, i = x.y, d.style.left = t + "px", d.style.top = i + "px";
        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: r, opt: a }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: r, opt: a, x: t, y: i });
        if (this.yaxisTooltips.length) for (var m = 0; m < n.config.yaxis.length; m++) this.axesTooltip.drawYaxisTooltipText(m, c, this.xyRatios);
        n.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), a.tooltipEl.classList.add("apexcharts-active");
      } else r.type !== "mouseout" && r.type !== "touchend" || this.handleMouseOut(a);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(e) {
    var t = e.e, i = e.opt, r = e.tooltipRect, a = this.w, n = i.paths.getAttribute("rel"), o = this.getElTooltip(), l = a.globals.dom.elWrap.getBoundingClientRect();
    if (t.type === "mousemove" || t.type === "touchmove") {
      a.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), o.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(n, 10) - 1, shared: !1 });
      var c = a.globals.clientX - l.left - r.ttWidth / 2, h = a.globals.clientY - l.top - r.ttHeight - 10;
      if (o.style.left = c + "px", o.style.top = h + "px", a.config.legend.tooltipHoverFormatter) {
        var d = n - 1, u = (0, a.config.legend.tooltipHoverFormatter)(this.legendLabels[d].getAttribute("data:default-text"), { seriesIndex: d, dataPointIndex: d, w: a });
        this.legendLabels[d].innerHTML = u;
      }
    } else t.type !== "mouseout" && t.type !== "touchend" || (o.classList.remove("apexcharts-active"), a.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), a.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(g) {
      var p = g.getAttribute("data:default-text");
      g.innerHTML = decodeURIComponent(p);
    }));
  } }, { key: "handleStickyTooltip", value: function(e, t, i, r) {
    var a = this.w, n = this.tooltipUtil.getNearestValues({ context: this, hoverArea: r.hoverArea, elGrid: r.elGrid, clientX: t, clientY: i }), o = n.j, l = n.capturedSeries;
    a.globals.collapsedSeriesIndices.includes(l) && (l = null);
    var c = r.elGrid.getBoundingClientRect();
    if (n.hoverX < 0 || n.hoverX > c.width) this.handleMouseOut(r);
    else if (l !== null) this.handleStickyCapturedSeries(e, l, r, o);
    else if (this.tooltipUtil.isXoverlap(o) || a.globals.isBarHorizontal) {
      var h = a.globals.series.findIndex(function(d, u) {
        return !a.globals.collapsedSeriesIndices.includes(u);
      });
      this.create(e, this, h, o, r.ttItems);
    }
  } }, { key: "handleStickyCapturedSeries", value: function(e, t, i, r) {
    var a = this.w;
    if (!this.tConfig.shared && a.globals.series[t][r] === null) return void this.handleMouseOut(i);
    if (a.globals.series[t][r] !== void 0) this.tConfig.shared && this.tooltipUtil.isXoverlap(r) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, r, i.ttItems) : this.create(e, this, t, r, i.ttItems, !1);
    else if (this.tooltipUtil.isXoverlap(r)) {
      var n = a.globals.series.findIndex(function(o, l) {
        return !a.globals.collapsedSeriesIndices.includes(l);
      });
      this.create(e, this, n, r, i.ttItems);
    }
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var e = this.w, t = new $(this.ctx), i = e.globals.dom.Paper.find(".apexcharts-bar-area"), r = 0; r < i.length; r++) t.pathMouseLeave(i[r]);
  } }, { key: "handleMouseOut", value: function(e) {
    var t = this.w, i = this.getElXCrosshairs();
    if (t.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), e.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), t.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      this.yaxisTTEls === null && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var r = 0; r < this.yaxisTTEls.length; r++) this.yaxisTTEls[r].classList.remove("apexcharts-active");
    }
    t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(a) {
      var n = a.getAttribute("data:default-text");
      a.innerHTML = decodeURIComponent(n);
    });
  } }, { key: "markerClick", value: function(e, t, i) {
    var r = this.w;
    typeof r.config.chart.events.markerClick == "function" && r.config.chart.events.markerClick(e, this.ctx, { seriesIndex: t, dataPointIndex: i, w: r }), this.ctx.events.fireEvent("markerClick", [e, this.ctx, { seriesIndex: t, dataPointIndex: i, w: r }]);
  } }, { key: "create", value: function(e, t, i, r, a) {
    var n, o, l, c, h, d, u, g, p, f, x, m, b, w, y, v, k = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, S = this.w, C = t;
    e.type === "mouseup" && this.markerClick(e, i, r), k === null && (k = this.tConfig.shared);
    var M = this.tooltipUtil.hasMarkers(i), R = this.tooltipUtil.getElBars(), P = function() {
      S.globals.markers.largestSize > 0 ? C.marker.enlargePoints(r) : C.tooltipPosition.moveDynamicPointsOnHover(r);
    };
    if (S.config.legend.tooltipHoverFormatter) {
      var I = S.config.legend.tooltipHoverFormatter, D = Array.from(this.legendLabels);
      D.forEach(function(X) {
        var V = X.getAttribute("data:default-text");
        X.innerHTML = decodeURIComponent(V);
      });
      for (var N = 0; N < D.length; N++) {
        var z = D[N], L = parseInt(z.getAttribute("i"), 10), T = decodeURIComponent(z.getAttribute("data:default-text")), H = I(T, { seriesIndex: k ? L : i, dataPointIndex: r, w: S });
        if (k) z.innerHTML = S.globals.collapsedSeriesIndices.indexOf(L) < 0 ? H : T;
        else if (z.innerHTML = L === i ? H : T, i === L) break;
      }
    }
    var B = J(J({ ttItems: a, i, j: r }, ((n = S.globals.seriesRange) === null || n === void 0 || (o = n[i]) === null || o === void 0 || (l = o[r]) === null || l === void 0 || (c = l.y[0]) === null || c === void 0 ? void 0 : c.y1) !== void 0 && { y1: (h = S.globals.seriesRange) === null || h === void 0 || (d = h[i]) === null || d === void 0 || (u = d[r]) === null || u === void 0 || (g = u.y[0]) === null || g === void 0 ? void 0 : g.y1 }), ((p = S.globals.seriesRange) === null || p === void 0 || (f = p[i]) === null || f === void 0 || (x = f[r]) === null || x === void 0 || (m = x.y[0]) === null || m === void 0 ? void 0 : m.y2) !== void 0 && { y2: (b = S.globals.seriesRange) === null || b === void 0 || (w = b[i]) === null || w === void 0 || (y = w[r]) === null || y === void 0 || (v = y.y[0]) === null || v === void 0 ? void 0 : v.y2 });
    if (k) {
      if (C.tooltipLabels.drawSeriesTexts(J(J({}, B), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), M) P();
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(R), this.barSeriesHeight > 0)) {
        var _ = new $(this.ctx), O = S.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(r, "']"));
        this.deactivateHoverFilter(), C.tooltipUtil.getAllMarkers(!0).length && !this.barSeriesHeight && P(), C.tooltipPosition.moveStickyTooltipOverBars(r, i);
        for (var Y = 0; Y < O.length; Y++) _.pathMouseEnter(O[Y]);
      }
    } else C.tooltipLabels.drawSeriesTexts(J({ shared: !1 }, B)), this.tooltipUtil.hasBars() && C.tooltipPosition.moveStickyTooltipOverBars(r, i), M && C.tooltipPosition.moveMarkers(i, r);
  } }]), s;
}(), md = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.barCtx = e, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return ie(s, [{ key: "handleBarDataLabels", value: function(e) {
    var t, i, r = e.x, a = e.y, n = e.y1, o = e.y2, l = e.i, c = e.j, h = e.realIndex, d = e.columnGroupIndex, u = e.series, g = e.barHeight, p = e.barWidth, f = e.barXPosition, x = e.barYPosition, m = e.visibleSeries, b = this.w, w = new $(this.barCtx.ctx), y = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h] : this.barCtx.strokeWidth;
    b.globals.isXNumeric && !b.globals.isBarHorizontal ? (t = r + parseFloat(p * (m + 1)), i = a + parseFloat(g * (m + 1)) - y) : (t = r + parseFloat(p * m), i = a + parseFloat(g * m));
    var v, k = null, S = r, C = a, M = {}, R = b.config.dataLabels, P = this.barCtx.barOptions.dataLabels, I = this.barCtx.barOptions.dataLabels.total;
    x !== void 0 && this.barCtx.isRangeBar && (i = x, C = x), f !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (t = f, S = f);
    var D = R.offsetX, N = R.offsetY, z = { width: 0, height: 0 };
    if (b.config.dataLabels.enabled) {
      var L = b.globals.series[l][c];
      z = w.getTextRects(b.config.dataLabels.formatter ? b.config.dataLabels.formatter(L, J(J({}, b), {}, { seriesIndex: l, dataPointIndex: c, w: b })) : b.globals.yLabelFormatters[0](L), parseFloat(R.style.fontSize));
    }
    var T = { x: r, y: a, i: l, j: c, realIndex: h, columnGroupIndex: d, bcx: t, bcy: i, barHeight: g, barWidth: p, textRects: z, strokeWidth: y, dataLabelsX: S, dataLabelsY: C, dataLabelsConfig: R, barDataLabelsConfig: P, barTotalDataLabelsConfig: I, offX: D, offY: N };
    return M = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(T) : this.calculateColumnsDataLabelsPosition(T), v = this.drawCalculatedDataLabels({ x: M.dataLabelsX, y: M.dataLabelsY, val: this.barCtx.isRangeBar ? [n, o] : b.config.chart.stackType === "100%" ? u[h][c] : b.globals.series[h][c], i: h, j: c, barWidth: p, barHeight: g, textRects: z, dataLabelsConfig: R }), b.config.chart.stacked && I.enabled && (k = this.drawTotalDataLabels({ x: M.totalDataLabelsX, y: M.totalDataLabelsY, barWidth: p, barHeight: g, realIndex: h, textAnchor: M.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h, j: c }), dataLabelsConfig: R, barTotalDataLabelsConfig: I })), { dataLabelsPos: M, dataLabels: v, totalDataLabels: k };
  } }, { key: "getStackedTotalDataLabel", value: function(e) {
    var t = e.realIndex, i = e.j, r = this.w, a = this.barCtx.stackedSeriesTotals[i];
    return this.totalFormatter && (a = this.totalFormatter(a, J(J({}, r), {}, { seriesIndex: t, dataPointIndex: i, w: r }))), a;
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(e) {
    var t = this, i = this.w, r = e.i, a = e.j, n = e.realIndex;
    e.columnGroupIndex;
    var o, l, c = e.y, h = e.bcx, d = e.barWidth, u = e.barHeight, g = e.textRects, p = e.dataLabelsX, f = e.dataLabelsY, x = e.dataLabelsConfig, m = e.barDataLabelsConfig, b = e.barTotalDataLabelsConfig, w = e.strokeWidth, y = e.offX, v = e.offY, k = h;
    u = Math.abs(u);
    var S = i.config.plotOptions.bar.dataLabels.orientation === "vertical", C = this.barCtx.barHelpers.getZeroValueEncounters({ i: r, j: a }).zeroEncounters;
    h -= w / 2;
    var M = i.globals.gridWidth / i.globals.dataPoints;
    this.barCtx.isVerticalGroupedRangeBar ? p += d / 2 : (p = i.globals.isXNumeric ? h - d / 2 + y : h - M + d / 2 + y, !i.config.chart.stacked && C > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (p -= d * C)), S && (p = p + g.height / 2 - w / 2 - 2);
    var R = i.globals.series[r][a] < 0, P = c;
    switch (this.barCtx.isReversed && (P = c + (R ? u : -u)), m.position) {
      case "center":
        f = S ? R ? P - u / 2 + v : P + u / 2 - v : R ? P - u / 2 + g.height / 2 + v : P + u / 2 + g.height / 2 - v;
        break;
      case "bottom":
        f = S ? R ? P - u + v : P + u - v : R ? P - u + g.height + w + v : P + u - g.height / 2 + w - v;
        break;
      case "top":
        f = S ? R ? P + v : P - v : R ? P - g.height / 2 - v : P + g.height + v;
    }
    var I = P;
    if (i.globals.seriesGroups.forEach(function(z) {
      var L;
      (L = t.barCtx[z.join(",")]) === null || L === void 0 || L.prevY.forEach(function(T) {
        I = R ? Math.max(T[a], I) : Math.min(T[a], I);
      });
    }), this.barCtx.lastActiveBarSerieIndex === n && b.enabled) {
      var D = new $(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n, j: a }), x.fontSize);
      o = R ? I - D.height / 2 - v - b.offsetY + 18 : I + D.height + v + b.offsetY - 18;
      var N = M;
      l = k + (i.globals.isXNumeric ? -d * i.globals.barGroups.length / 2 : i.globals.barGroups.length * d / 2 - (i.globals.barGroups.length - 1) * d - N) + b.offsetX;
    }
    return i.config.chart.stacked || (f < 0 ? f = 0 + w : f + g.height / 3 > i.globals.gridHeight && (f = i.globals.gridHeight - w)), { bcx: h, bcy: c, dataLabelsX: p, dataLabelsY: f, totalDataLabelsX: l, totalDataLabelsY: o, totalDataLabelsAnchor: "middle" };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(e) {
    var t = this, i = this.w, r = e.x, a = e.i, n = e.j, o = e.realIndex, l = e.bcy, c = e.barHeight, h = e.barWidth, d = e.textRects, u = e.dataLabelsX, g = e.strokeWidth, p = e.dataLabelsConfig, f = e.barDataLabelsConfig, x = e.barTotalDataLabelsConfig, m = e.offX, b = e.offY, w = i.globals.gridHeight / i.globals.dataPoints, y = this.barCtx.barHelpers.getZeroValueEncounters({ i: a, j: n }).zeroEncounters;
    h = Math.abs(h);
    var v, k, S = l - (this.barCtx.isRangeBar ? 0 : w) + c / 2 + d.height / 2 + b - 3;
    !i.config.chart.stacked && y > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (S -= c * y);
    var C = "start", M = i.globals.series[a][n] < 0, R = r;
    switch (this.barCtx.isReversed && (R = r + (M ? -h : h), C = M ? "start" : "end"), f.position) {
      case "center":
        u = M ? R + h / 2 - m : Math.max(d.width / 2, R - h / 2) + m;
        break;
      case "bottom":
        u = M ? R + h - g - m : R - h + g + m;
        break;
      case "top":
        u = M ? R - g - m : R - g + m;
    }
    var P = R;
    if (i.globals.seriesGroups.forEach(function(D) {
      var N;
      (N = t.barCtx[D.join(",")]) === null || N === void 0 || N.prevX.forEach(function(z) {
        P = M ? Math.min(z[n], P) : Math.max(z[n], P);
      });
    }), this.barCtx.lastActiveBarSerieIndex === o && x.enabled) {
      var I = new $(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: o, j: n }), p.fontSize);
      M ? (v = P - g - m - x.offsetX, C = "end") : v = P + m + x.offsetX + (this.barCtx.isReversed ? -(h + g) : g), k = S - d.height / 2 + I.height / 2 + x.offsetY + g, i.globals.barGroups.length > 1 && (k -= i.globals.barGroups.length / 2 * (c / 2));
    }
    return i.config.chart.stacked || (p.textAnchor === "start" ? u - d.width < 0 ? u = M ? d.width + g : g : u + d.width > i.globals.gridWidth && (u = M ? i.globals.gridWidth - g : i.globals.gridWidth - d.width - g) : p.textAnchor === "middle" ? u - d.width / 2 < 0 ? u = d.width / 2 + g : u + d.width / 2 > i.globals.gridWidth && (u = i.globals.gridWidth - d.width / 2 - g) : p.textAnchor === "end" && (u < 1 ? u = d.width + g : u + 1 > i.globals.gridWidth && (u = i.globals.gridWidth - d.width - g))), { bcx: r, bcy: l, dataLabelsX: u, dataLabelsY: S, totalDataLabelsX: v, totalDataLabelsY: k, totalDataLabelsAnchor: C };
  } }, { key: "drawCalculatedDataLabels", value: function(e) {
    var t = e.x, i = e.y, r = e.val, a = e.i, n = e.j, o = e.textRects, l = e.barHeight, c = e.barWidth, h = e.dataLabelsConfig, d = this.w, u = "rotate(0)";
    d.config.plotOptions.bar.dataLabels.orientation === "vertical" && (u = "rotate(-90, ".concat(t, ", ").concat(i, ")"));
    var g = new Jt(this.barCtx.ctx), p = new $(this.barCtx.ctx), f = h.formatter, x = null, m = d.globals.collapsedSeriesIndices.indexOf(a) > -1;
    if (h.enabled && !m) {
      x = p.group({ class: "apexcharts-data-labels", transform: u });
      var b = "";
      r !== void 0 && (b = f(r, J(J({}, d), {}, { seriesIndex: a, dataPointIndex: n, w: d }))), !r && d.config.plotOptions.bar.hideZeroBarsWhenGrouped && (b = "");
      var w = d.globals.series[a][n] < 0, y = d.config.plotOptions.bar.dataLabels.position;
      d.config.plotOptions.bar.dataLabels.orientation === "vertical" && (y === "top" && (h.textAnchor = w ? "end" : "start"), y === "center" && (h.textAnchor = "middle"), y === "bottom" && (h.textAnchor = w ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && c < p.getTextRects(b, parseFloat(h.style.fontSize)).width && (b = ""), d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? o.width / 1.6 > Math.abs(c) && (b = "") : o.height / 1.6 > Math.abs(l) && (b = ""));
      var v = J({}, h);
      this.barCtx.isHorizontal && r < 0 && (h.textAnchor === "start" ? v.textAnchor = "end" : h.textAnchor === "end" && (v.textAnchor = "start")), g.plotDataLabelsText({ x: t, y: i, text: b, i: a, j: n, parent: x, dataLabelsConfig: v, alwaysDrawDataLabel: !0, offsetCorrection: !0 });
    }
    return x;
  } }, { key: "drawTotalDataLabels", value: function(e) {
    var t = e.x, i = e.y, r = e.val, a = e.realIndex, n = e.textAnchor, o = e.barTotalDataLabelsConfig;
    this.w;
    var l, c = new $(this.barCtx.ctx);
    return o.enabled && t !== void 0 && i !== void 0 && this.barCtx.lastActiveBarSerieIndex === a && (l = c.drawText({ x: t, y: i, foreColor: o.style.color, text: r, textAnchor: n, fontFamily: o.style.fontFamily, fontSize: o.style.fontSize, fontWeight: o.style.fontWeight })), l;
  } }]), s;
}(), bd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.barCtx = e;
  }
  return ie(s, [{ key: "initVariables", value: function(e) {
    var t = this.w;
    this.barCtx.series = e, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i = 0; i < e.length; i++) if (e[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += e[i].length), t.globals.isXNumeric) for (var r = 0; r < e[i].length; r++) t.globals.seriesX[i][r] > t.globals.minX && t.globals.seriesX[i][r] < t.globals.maxX && this.barCtx.visibleItems++;
    else this.barCtx.visibleItems = t.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(t.globals.series), F.isSafari() && (this.arrBorderRadius = this.arrBorderRadius.map(function(a) {
      return a.map(function(n) {
        return "none";
      });
    })), this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], t.globals.comboCharts || this.checkZeroSeries({ series: e });
  } }, { key: "initialPositions", value: function(e) {
    var t, i, r, a, n, o, l, c, h = this.w, d = h.globals.dataPoints;
    this.barCtx.isRangeBar && (d = h.globals.labels.length);
    var u = this.barCtx.seriesLen;
    if (h.config.plotOptions.bar.rangeBarGroupRows && (u = 1), this.barCtx.isHorizontal) n = (r = h.globals.gridHeight / d) / u, h.globals.isXNumeric && (n = (r = h.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), n = n * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (n = parseInt(this.barCtx.barOptions.barHeight, 10)), c = this.barCtx.baseLineInvertedY + h.globals.padHorizontal + (this.barCtx.isReversed ? h.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (c = h.globals.gridWidth / 2), i = (r - n * this.barCtx.seriesLen) / 2;
    else {
      if (a = h.globals.gridWidth / this.barCtx.visibleItems, h.config.xaxis.convertedCatToNumeric && (a = h.globals.gridWidth / h.globals.dataPoints), o = a / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h.globals.isXNumeric) {
        var g = this.barCtx.xRatio;
        h.globals.minXDiff && h.globals.minXDiff !== 0.5 && h.globals.minXDiff / g > 0 && (a = h.globals.minXDiff / g), (o = a / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (o = 1);
      }
      String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (o = parseInt(this.barCtx.barOptions.columnWidth, 10)), l = h.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h.globals.isXNumeric ? t = this.barCtx.getBarXForNumericXAxis({ x: t, j: 0, realIndex: e, barWidth: o }).x : t = h.globals.padHorizontal + F.noExponents(a - o * this.barCtx.seriesLen) / 2;
    }
    return h.globals.barHeight = n, h.globals.barWidth = o, { x: t, y: i, yDivision: r, xDivision: a, barHeight: n, barWidth: o, zeroH: l, zeroW: c };
  } }, { key: "initializeStackedPrevVars", value: function(e) {
    e.w.globals.seriesGroups.forEach(function(t) {
      e[t] || (e[t] = {}), e[t].prevY = [], e[t].prevX = [], e[t].prevYF = [], e[t].prevXF = [], e[t].prevYVal = [], e[t].prevXVal = [];
    });
  } }, { key: "initializeStackedXYVars", value: function(e) {
    e.w.globals.seriesGroups.forEach(function(t) {
      e[t] || (e[t] = {}), e[t].xArrj = [], e[t].xArrjF = [], e[t].xArrjVal = [], e[t].yArrj = [], e[t].yArrjF = [], e[t].yArrjVal = [];
    });
  } }, { key: "getPathFillColor", value: function(e, t, i, r) {
    var a, n, o, l, c = this.w, h = this.barCtx.ctx.fill, d = null, u = this.barCtx.barOptions.distributed ? i : t, g = !1;
    return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(p) {
      e[t][i] >= p.from && e[t][i] <= p.to && (d = p.color, g = !0);
    }), { color: h.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? u : r, dataPointIndex: i, color: d, value: e[t][i], fillConfig: (a = c.config.series[t].data[i]) === null || a === void 0 ? void 0 : a.fill, fillType: (n = c.config.series[t].data[i]) !== null && n !== void 0 && (o = n.fill) !== null && o !== void 0 && o.type ? (l = c.config.series[t].data[i]) === null || l === void 0 ? void 0 : l.fill.type : Array.isArray(c.config.fill.type) ? c.config.fill.type[r] : c.config.fill.type }), useRangeColor: g };
  } }, { key: "getStrokeWidth", value: function(e, t, i) {
    var r = 0, a = this.w;
    return this.barCtx.series[e][t] === void 0 || this.barCtx.series[e][t] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, a.config.stroke.show && (this.barCtx.isNullValue || (r = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), r;
  } }, { key: "createBorderRadiusArr", value: function(e) {
    var t, i = this.w, r = !this.w.config.chart.stacked || i.config.plotOptions.bar.borderRadius <= 0, a = e.length, n = 0 | ((t = e[0]) === null || t === void 0 ? void 0 : t.length), o = Array.from({ length: a }, function() {
      return Array(n).fill(r ? "top" : "none");
    });
    if (r) return o;
    for (var l = 0; l < n; l++) {
      for (var c = [], h = [], d = 0, u = 0; u < a; u++) {
        var g = e[u][l];
        g > 0 ? (c.push(u), d++) : g < 0 && (h.push(u), d++);
      }
      if (c.length > 0 && h.length === 0) if (c.length === 1) o[c[0]][l] = "both";
      else {
        var p, f = c[0], x = c[c.length - 1], m = fi(c);
        try {
          for (m.s(); !(p = m.n()).done; ) {
            var b = p.value;
            o[b][l] = b === f ? "bottom" : b === x ? "top" : "none";
          }
        } catch (L) {
          m.e(L);
        } finally {
          m.f();
        }
      }
      else if (h.length > 0 && c.length === 0) if (h.length === 1) o[h[0]][l] = "both";
      else {
        var w, y = Math.max.apply(Math, h), v = Math.min.apply(Math, h), k = fi(h);
        try {
          for (k.s(); !(w = k.n()).done; ) {
            var S = w.value;
            o[S][l] = S === y ? "bottom" : S === v ? "top" : "none";
          }
        } catch (L) {
          k.e(L);
        } finally {
          k.f();
        }
      }
      else if (c.length > 0 && h.length > 0) {
        var C, M = c[c.length - 1], R = fi(c);
        try {
          for (R.s(); !(C = R.n()).done; ) {
            var P = C.value;
            o[P][l] = P === M ? "top" : "none";
          }
        } catch (L) {
          R.e(L);
        } finally {
          R.f();
        }
        var I, D = Math.max.apply(Math, h), N = fi(h);
        try {
          for (N.s(); !(I = N.n()).done; ) {
            var z = I.value;
            o[z][l] = z === D ? "bottom" : "none";
          }
        } catch (L) {
          N.e(L);
        } finally {
          N.f();
        }
      } else d === 1 && (o[c[0] || h[0]][l] = "both");
    }
    return o;
  } }, { key: "barBackground", value: function(e) {
    var t = e.j, i = e.i, r = e.x1, a = e.x2, n = e.y1, o = e.y2, l = e.elSeries, c = this.w, h = new $(this.barCtx.ctx), d = new ct(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && d === i) {
      t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var u = this.barCtx.barOptions.colors.backgroundBarColors[t], g = h.drawRect(r !== void 0 ? r : 0, n !== void 0 ? n : 0, a !== void 0 ? a : c.globals.gridWidth, o !== void 0 ? o : c.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, u, this.barCtx.barOptions.colors.backgroundBarOpacity);
      l.add(g), g.node.classList.add("apexcharts-backgroundBar");
    }
  } }, { key: "getColumnPaths", value: function(e) {
    var t, i = e.barWidth, r = e.barXPosition, a = e.y1, n = e.y2, o = e.strokeWidth, l = e.isReversed, c = e.series, h = e.seriesGroup, d = e.realIndex, u = e.i, g = e.j, p = e.w, f = new $(this.barCtx.ctx);
    (o = Array.isArray(o) ? o[d] : o) || (o = 0);
    var x = i, m = r;
    (t = p.config.series[d].data[g]) !== null && t !== void 0 && t.columnWidthOffset && (m = r - p.config.series[d].data[g].columnWidthOffset / 2, x = i + p.config.series[d].data[g].columnWidthOffset);
    var b = o / 2, w = m + b, y = m + x - b, v = (c[u][g] >= 0 ? 1 : -1) * (l ? -1 : 1);
    a += 1e-3 - b * v, n += 1e-3 + b * v;
    var k = f.move(w, a), S = f.move(w, a), C = f.line(y, a);
    if (p.globals.previousPaths.length > 0 && (S = this.barCtx.getPreviousPath(d, g, !1)), k = k + f.line(w, n) + f.line(y, n) + C + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), S = S + f.line(w, a) + C + C + C + C + C + f.line(w, a) + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), this.arrBorderRadius[d][g] !== "none" && (k = f.roundPathCorners(k, p.config.plotOptions.bar.borderRadius)), p.config.chart.stacked) {
      var M = this.barCtx;
      (M = this.barCtx[h]).yArrj.push(n - b * v), M.yArrjF.push(Math.abs(a - n + o * v)), M.yArrjVal.push(this.barCtx.series[u][g]);
    }
    return { pathTo: k, pathFrom: S };
  } }, { key: "getBarpaths", value: function(e) {
    var t, i = e.barYPosition, r = e.barHeight, a = e.x1, n = e.x2, o = e.strokeWidth, l = e.isReversed, c = e.series, h = e.seriesGroup, d = e.realIndex, u = e.i, g = e.j, p = e.w, f = new $(this.barCtx.ctx);
    (o = Array.isArray(o) ? o[d] : o) || (o = 0);
    var x = i, m = r;
    (t = p.config.series[d].data[g]) !== null && t !== void 0 && t.barHeightOffset && (x = i - p.config.series[d].data[g].barHeightOffset / 2, m = r + p.config.series[d].data[g].barHeightOffset);
    var b = o / 2, w = x + b, y = x + m - b, v = (c[u][g] >= 0 ? 1 : -1) * (l ? -1 : 1);
    a += 1e-3 + b * v, n += 1e-3 - b * v;
    var k = f.move(a, w), S = f.move(a, w);
    p.globals.previousPaths.length > 0 && (S = this.barCtx.getPreviousPath(d, g, !1));
    var C = f.line(a, y);
    if (k = k + f.line(n, w) + f.line(n, y) + C + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), S = S + f.line(a, w) + C + C + C + C + C + f.line(a, w) + (p.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[d][g] === "both" ? " Z" : " z"), this.arrBorderRadius[d][g] !== "none" && (k = f.roundPathCorners(k, p.config.plotOptions.bar.borderRadius)), p.config.chart.stacked) {
      var M = this.barCtx;
      (M = this.barCtx[h]).xArrj.push(n + b * v), M.xArrjF.push(Math.abs(a - n - o * v)), M.xArrjVal.push(this.barCtx.series[u][g]);
    }
    return { pathTo: k, pathFrom: S };
  } }, { key: "checkZeroSeries", value: function(e) {
    for (var t = e.series, i = this.w, r = 0; r < t.length; r++) {
      for (var a = 0, n = 0; n < t[i.globals.maxValsInArrayIndex].length; n++) a += t[r][n];
      a === 0 && this.barCtx.zeroSerieses.push(r);
    }
  } }, { key: "getXForValue", value: function(e, t) {
    var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? t : null;
    return e != null && (i = t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0)), i;
  } }, { key: "getYForValue", value: function(e, t, i) {
    var r = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3] ? t : null;
    return e != null && (r = t - e / this.barCtx.yRatio[i] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[i] : 0)), r;
  } }, { key: "getGoalValues", value: function(e, t, i, r, a, n) {
    var o = this, l = this.w, c = [], h = function(g, p) {
      var f;
      c.push((Ki(f = {}, e, e === "x" ? o.getXForValue(g, t, !1) : o.getYForValue(g, i, n, !1)), Ki(f, "attrs", p), f));
    };
    if (l.globals.seriesGoals[r] && l.globals.seriesGoals[r][a] && Array.isArray(l.globals.seriesGoals[r][a]) && l.globals.seriesGoals[r][a].forEach(function(g) {
      h(g.value, g);
    }), this.barCtx.barOptions.isDumbbell && l.globals.seriesRange.length) {
      var d = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l.globals.colors, u = { strokeHeight: e === "x" ? 0 : l.globals.markers.size[r], strokeWidth: e === "x" ? l.globals.markers.size[r] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d[r]) ? d[r][0] : d[r] };
      h(l.globals.seriesRangeStart[r][a], u), h(l.globals.seriesRangeEnd[r][a], J(J({}, u), {}, { strokeColor: Array.isArray(d[r]) ? d[r][1] : d[r] }));
    }
    return c;
  } }, { key: "drawGoalLine", value: function(e) {
    var t = e.barXPosition, i = e.barYPosition, r = e.goalX, a = e.goalY, n = e.barWidth, o = e.barHeight, l = new $(this.barCtx.ctx), c = l.group({ className: "apexcharts-bar-goals-groups" });
    c.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: c.node }), c.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
    var h = null;
    return this.barCtx.isHorizontal ? Array.isArray(r) && r.forEach(function(d) {
      if (d.x >= -1 && d.x <= l.w.globals.gridWidth + 1) {
        var u = d.attrs.strokeHeight !== void 0 ? d.attrs.strokeHeight : o / 2, g = i + u + o / 2;
        h = l.drawLine(d.x, g - 2 * u, d.x, g, d.attrs.strokeColor ? d.attrs.strokeColor : void 0, d.attrs.strokeDashArray, d.attrs.strokeWidth ? d.attrs.strokeWidth : 2, d.attrs.strokeLineCap), c.add(h);
      }
    }) : Array.isArray(a) && a.forEach(function(d) {
      if (d.y >= -1 && d.y <= l.w.globals.gridHeight + 1) {
        var u = d.attrs.strokeWidth !== void 0 ? d.attrs.strokeWidth : n / 2, g = t + u + n / 2;
        h = l.drawLine(g - 2 * u, d.y, g, d.y, d.attrs.strokeColor ? d.attrs.strokeColor : void 0, d.attrs.strokeDashArray, d.attrs.strokeHeight ? d.attrs.strokeHeight : 2, d.attrs.strokeLineCap), c.add(h);
      }
    }), c;
  } }, { key: "drawBarShadow", value: function(e) {
    var t = e.prevPaths, i = e.currPaths, r = e.color, a = this.w, n = t.x, o = t.x1, l = t.barYPosition, c = i.x, h = i.x1, d = i.barYPosition, u = l + i.barHeight, g = new $(this.barCtx.ctx), p = new F(), f = g.move(o, u) + g.line(n, u) + g.line(c, d) + g.line(h, d) + g.line(o, u) + (a.config.plotOptions.bar.borderRadiusApplication === "around" || this.arrBorderRadius[realIndex][j] === "both" ? " Z" : " z");
    return g.drawPath({ d: f, fill: p.shadeColor(0.5, F.rgb2hex(r)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadow apexcharts-decoration-element" });
  } }, { key: "getZeroValueEncounters", value: function(e) {
    var t, i = e.i, r = e.j, a = this.w, n = 0, o = 0;
    return (a.config.plotOptions.bar.horizontal ? a.globals.series.map(function(l, c) {
      return c;
    }) : ((t = a.globals.columnSeries) === null || t === void 0 ? void 0 : t.i.map(function(l) {
      return l;
    })) || []).forEach(function(l) {
      var c = a.globals.seriesPercent[l][r];
      c && n++, l < i && c === 0 && o++;
    }), { nonZeroColumns: n, zeroEncounters: o };
  } }, { key: "getGroupIndex", value: function(e) {
    var t = this.w, i = t.globals.seriesGroups.findIndex(function(n) {
      return n.indexOf(t.globals.seriesNames[e]) > -1;
    }), r = this.barCtx.columnGroupIndices, a = r.indexOf(i);
    return a < 0 && (r.push(i), a = r.length - 1), { groupIndex: i, columnGroupIndex: a };
  } }]), s;
}(), Qt = function() {
  function s(e, t) {
    te(this, s), this.ctx = e, this.w = e.w;
    var i = this.w;
    this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = t, this.xyRatios !== null && (this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.invertedXRatio = t.invertedXRatio, this.invertedYRatio = t.invertedYRatio, this.baseLineY = t.baseLineY, this.baseLineInvertedY = t.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var r = new ct(this.ctx);
    this.lastActiveBarSerieIndex = r.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
    var a = r.getBarSeriesIndices(), n = new ze(this.ctx);
    this.stackedSeriesTotals = n.getStackedSeriesTotals(this.w.config.series.map(function(o, l) {
      return a.indexOf(l) === -1 ? l : -1;
    }).filter(function(o) {
      return o !== -1;
    })), this.barHelpers = new bd(this);
  }
  return ie(s, [{ key: "draw", value: function(e, t) {
    var i = this.w, r = new $(this.ctx), a = new ze(this.ctx, i);
    e = a.getLogSeries(e), this.series = e, this.yRatio = a.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e);
    var n = r.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
    for (var o = 0, l = 0; o < e.length; o++, l++) {
      var c, h, d, u, g = void 0, p = void 0, f = [], x = [], m = i.globals.comboCharts ? t[o] : o, b = this.barHelpers.getGroupIndex(m).columnGroupIndex, w = r.group({ class: "apexcharts-series", rel: o + 1, seriesName: F.escapeString(i.globals.seriesNames[m]), "data:realIndex": m });
      this.ctx.series.addCollapsedClassToSeries(w, m), e[o].length > 0 && (this.visibleI = this.visibleI + 1);
      var y = 0, v = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[m], this.translationsIndex = m);
      var k = this.translationsIndex;
      this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      var S = this.barHelpers.initialPositions(m);
      p = S.y, y = S.barHeight, h = S.yDivision, u = S.zeroW, g = S.x, v = S.barWidth, c = S.xDivision, d = S.zeroH, this.isHorizontal || x.push(g + v / 2);
      var C = r.group({ class: "apexcharts-datalabels", "data:realIndex": m });
      i.globals.delayedElements.push({ el: C.node }), C.node.classList.add("apexcharts-element-hidden");
      var M = r.group({ class: "apexcharts-bar-goals-markers" }), R = r.group({ class: "apexcharts-bar-shadows" });
      i.globals.delayedElements.push({ el: R.node }), R.node.classList.add("apexcharts-element-hidden");
      for (var P = 0; P < e[o].length; P++) {
        var I = this.barHelpers.getStrokeWidth(o, P, m), D = null, N = { indexes: { i: o, j: P, realIndex: m, translationsIndex: k, bc: l }, x: g, y: p, strokeWidth: I, elSeries: w };
        this.isHorizontal ? (D = this.drawBarPaths(J(J({}, N), {}, { barHeight: y, zeroW: u, yDivision: h })), v = this.series[o][P] / this.invertedYRatio) : (D = this.drawColumnPaths(J(J({}, N), {}, { xDivision: c, barWidth: v, zeroH: d })), y = this.series[o][P] / this.yRatio[k]);
        var z = this.barHelpers.getPathFillColor(e, o, P, m);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && P > 0) {
          var L, T = this.barHelpers.drawBarShadow({ color: typeof z.color == "string" && ((L = z.color) === null || L === void 0 ? void 0 : L.indexOf("url")) === -1 ? z.color : F.hexToRgba(i.globals.colors[o]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: D });
          R.add(T), i.config.chart.dropShadow.enabled && new Ye(this.ctx).dropShadow(T, i.config.chart.dropShadow, m);
        }
        this.pathArr.push(D);
        var H = this.barHelpers.drawGoalLine({ barXPosition: D.barXPosition, barYPosition: D.barYPosition, goalX: D.goalX, goalY: D.goalY, barHeight: y, barWidth: v });
        H && M.add(H), p = D.y, g = D.x, P > 0 && x.push(g + v / 2), f.push(p), this.renderSeries(J(J({ realIndex: m, pathFill: z.color }, z.useRangeColor ? { lineFill: z.color } : {}), {}, { j: P, i: o, columnGroupIndex: b, pathFrom: D.pathFrom, pathTo: D.pathTo, strokeWidth: I, elSeries: w, x: g, y: p, series: e, barHeight: Math.abs(D.barHeight ? D.barHeight : y), barWidth: Math.abs(D.barWidth ? D.barWidth : v), elDataLabelsWrap: C, elGoalsMarkers: M, elBarShadows: R, visibleSeries: this.visibleI, type: "bar" }));
      }
      i.globals.seriesXvalues[m] = x, i.globals.seriesYvalues[m] = f, n.add(w);
    }
    return n;
  } }, { key: "renderSeries", value: function(e) {
    var t = e.realIndex, i = e.pathFill, r = e.lineFill, a = e.j, n = e.i, o = e.columnGroupIndex, l = e.pathFrom, c = e.pathTo, h = e.strokeWidth, d = e.elSeries, u = e.x, g = e.y, p = e.y1, f = e.y2, x = e.series, m = e.barHeight, b = e.barWidth, w = e.barXPosition, y = e.barYPosition, v = e.elDataLabelsWrap, k = e.elGoalsMarkers, S = e.elBarShadows, C = e.visibleSeries, M = e.type, R = e.classes, P = this.w, I = new $(this.ctx), D = !1;
    if (!r) {
      var N = typeof P.globals.stroke.colors[t] == "function" ? function(B) {
        var _, O = P.config.stroke.colors;
        return Array.isArray(O) && O.length > 0 && ((_ = O[B]) || (_ = ""), typeof _ == "function") ? _({ value: P.globals.series[B][a], dataPointIndex: a, w: P }) : _;
      }(t) : P.globals.stroke.colors[t];
      r = this.barOptions.distributed ? P.globals.stroke.colors[a] : N;
    }
    var z = new md(this).handleBarDataLabels({ x: u, y: g, y1: p, y2: f, i: n, j: a, series: x, realIndex: t, columnGroupIndex: o, barHeight: m, barWidth: b, barXPosition: w, barYPosition: y, visibleSeries: C });
    P.globals.isBarHorizontal || (z.dataLabelsPos.dataLabelsX + b < 0 || z.dataLabelsPos.dataLabelsX - b > P.globals.gridWidth) && (D = !0), P.config.series[n].data[a] && P.config.series[n].data[a].strokeColor && (r = P.config.series[n].data[a].strokeColor), this.isNullValue && (i = "none");
    var L = a / P.config.chart.animations.animateGradually.delay * (P.config.chart.animations.speed / P.globals.dataPoints) / 2.4;
    if (!D) {
      var T = I.renderPaths({ i: n, j: a, realIndex: t, pathFrom: l, pathTo: c, stroke: r, strokeWidth: h, strokeLineCap: P.config.stroke.lineCap, fill: i, animationDelay: L, initialSpeed: P.config.chart.animations.speed, dataChangeSpeed: P.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(M, "-area ").concat(R), chartType: M });
      T.attr("clip-path", "url(#gridRectBarMask".concat(P.globals.cuid, ")"));
      var H = P.config.forecastDataPoints;
      H.count > 0 && a >= P.globals.dataPoints - H.count && (T.node.setAttribute("stroke-dasharray", H.dashArray), T.node.setAttribute("stroke-width", H.strokeWidth), T.node.setAttribute("fill-opacity", H.fillOpacity)), p !== void 0 && f !== void 0 && (T.attr("data-range-y1", p), T.attr("data-range-y2", f)), new Ye(this.ctx).setSelectionFilter(T, t, a), d.add(T), T.attr({ cy: z.dataLabelsPos.bcy, cx: z.dataLabelsPos.bcx, j: a, val: P.globals.series[n][a], barHeight: m, barWidth: b }), z.dataLabels !== null && v.add(z.dataLabels), z.totalDataLabels && v.add(z.totalDataLabels), d.add(v), k && d.add(k), S && d.add(S);
    }
    return d;
  } }, { key: "drawBarPaths", value: function(e) {
    var t, i = e.indexes, r = e.barHeight, a = e.strokeWidth, n = e.zeroW, o = e.x, l = e.y, c = e.yDivision, h = e.elSeries, d = this.w, u = i.i, g = i.j;
    if (d.globals.isXNumeric) t = (l = (d.globals.seriesX[u][g] - d.globals.minX) / this.invertedXRatio - r) + r * this.visibleI;
    else if (d.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var p = this.barHelpers.getZeroValueEncounters({ i: u, j: g }), f = p.nonZeroColumns, x = p.zeroEncounters;
      f > 0 && (r = this.seriesLen * r / f), t = l + r * this.visibleI, t -= r * x;
    } else t = l + r * this.visibleI;
    this.isFunnel && (n -= (this.barHelpers.getXForValue(this.series[u][g], n) - n) / 2), o = this.barHelpers.getXForValue(this.series[u][g], n);
    var m = this.barHelpers.getBarpaths({ barYPosition: t, barHeight: r, x1: n, x2: o, strokeWidth: a, isReversed: this.isReversed, series: this.series, realIndex: i.realIndex, i: u, j: g, w: d });
    return d.globals.isXNumeric || (l += c), this.barHelpers.barBackground({ j: g, i: u, y1: t - r * this.visibleI, y2: r * this.seriesLen, elSeries: h }), { pathTo: m.pathTo, pathFrom: m.pathFrom, x1: n, x: o, y: l, goalX: this.barHelpers.getGoalValues("x", n, null, u, g), barYPosition: t, barHeight: r };
  } }, { key: "drawColumnPaths", value: function(e) {
    var t, i = e.indexes, r = e.x, a = e.y, n = e.xDivision, o = e.barWidth, l = e.zeroH, c = e.strokeWidth, h = e.elSeries, d = this.w, u = i.realIndex, g = i.translationsIndex, p = i.i, f = i.j, x = i.bc;
    if (d.globals.isXNumeric) {
      var m = this.getBarXForNumericXAxis({ x: r, j: f, realIndex: u, barWidth: o });
      r = m.x, t = m.barXPosition;
    } else if (d.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var b = this.barHelpers.getZeroValueEncounters({ i: p, j: f }), w = b.nonZeroColumns, y = b.zeroEncounters;
      w > 0 && (o = this.seriesLen * o / w), t = r + o * this.visibleI, t -= o * y;
    } else t = r + o * this.visibleI;
    a = this.barHelpers.getYForValue(this.series[p][f], l, g);
    var v = this.barHelpers.getColumnPaths({ barXPosition: t, barWidth: o, y1: l, y2: a, strokeWidth: c, isReversed: this.isReversed, series: this.series, realIndex: u, i: p, j: f, w: d });
    return d.globals.isXNumeric || (r += n), this.barHelpers.barBackground({ bc: x, j: f, i: p, x1: t - c / 2 - o * this.visibleI, x2: o * this.seriesLen + c / 2, elSeries: h }), { pathTo: v.pathTo, pathFrom: v.pathFrom, x: r, y: a, goalY: this.barHelpers.getGoalValues("y", null, l, p, f, g), barXPosition: t, barWidth: o };
  } }, { key: "getBarXForNumericXAxis", value: function(e) {
    var t = e.x, i = e.barWidth, r = e.realIndex, a = e.j, n = this.w, o = r;
    return n.globals.seriesX[r].length || (o = n.globals.maxValsInArrayIndex), F.isNumber(n.globals.seriesX[o][a]) && (t = (n.globals.seriesX[o][a] - n.globals.minX) / this.xRatio - i * this.seriesLen / 2), { barXPosition: t + i * this.visibleI, x: t };
  } }, { key: "getPreviousPath", value: function(e, t) {
    for (var i = this.w, r = "M 0 0", a = 0; a < i.globals.previousPaths.length; a++) {
      var n = i.globals.previousPaths[a];
      n.paths && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(e, 10) && i.globals.previousPaths[a].paths[t] !== void 0 && (r = i.globals.previousPaths[a].paths[t].d);
    }
    return r;
  } }]), s;
}(), Ka = function(s) {
  Li(t, Qt);
  var e = Pi(t);
  function t() {
    return te(this, t), e.apply(this, arguments);
  }
  return ie(t, [{ key: "draw", value: function(i, r) {
    var a = this, n = this.w;
    this.graphics = new $(this.ctx), this.bar = new Qt(this.ctx, this.xyRatios);
    var o = new ze(this.ctx, n);
    i = o.getLogSeries(i), this.yRatio = o.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), n.config.chart.stackType === "100%" && (i = n.globals.comboCharts ? r.map(function(p) {
      return n.globals.seriesPercent[p];
    }) : n.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
    for (var l = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), c = 0, h = 0, d = function(p, f) {
      var x = void 0, m = void 0, b = void 0, w = void 0, y = n.globals.comboCharts ? r[p] : p, v = a.barHelpers.getGroupIndex(y), k = v.groupIndex, S = v.columnGroupIndex;
      a.groupCtx = a[n.globals.seriesGroups[k]];
      var C = [], M = [], R = 0;
      a.yRatio.length > 1 && (a.yaxisIndex = n.globals.seriesYAxisReverseMap[y][0], R = y), a.isReversed = n.config.yaxis[a.yaxisIndex] && n.config.yaxis[a.yaxisIndex].reversed;
      var P = a.graphics.group({ class: "apexcharts-series", seriesName: F.escapeString(n.globals.seriesNames[y]), rel: p + 1, "data:realIndex": y });
      a.ctx.series.addCollapsedClassToSeries(P, y);
      var I = a.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": y }), D = a.graphics.group({ class: "apexcharts-bar-goals-markers" }), N = 0, z = 0, L = a.initialPositions(c, h, x, m, b, w, R);
      h = L.y, N = L.barHeight, m = L.yDivision, w = L.zeroW, c = L.x, z = L.barWidth, x = L.xDivision, b = L.zeroH, n.globals.barHeight = N, n.globals.barWidth = z, a.barHelpers.initializeStackedXYVars(a), a.groupCtx.prevY.length === 1 && a.groupCtx.prevY[0].every(function(W) {
        return isNaN(W);
      }) && (a.groupCtx.prevY[0] = a.groupCtx.prevY[0].map(function() {
        return b;
      }), a.groupCtx.prevYF[0] = a.groupCtx.prevYF[0].map(function() {
        return 0;
      }));
      for (var T = 0; T < n.globals.dataPoints; T++) {
        var H = a.barHelpers.getStrokeWidth(p, T, y), B = { indexes: { i: p, j: T, realIndex: y, translationsIndex: R, bc: f }, strokeWidth: H, x: c, y: h, elSeries: P, columnGroupIndex: S, seriesGroup: n.globals.seriesGroups[k] }, _ = null;
        a.isHorizontal ? (_ = a.drawStackedBarPaths(J(J({}, B), {}, { zeroW: w, barHeight: N, yDivision: m })), z = a.series[p][T] / a.invertedYRatio) : (_ = a.drawStackedColumnPaths(J(J({}, B), {}, { xDivision: x, barWidth: z, zeroH: b })), N = a.series[p][T] / a.yRatio[R]);
        var O = a.barHelpers.drawGoalLine({ barXPosition: _.barXPosition, barYPosition: _.barYPosition, goalX: _.goalX, goalY: _.goalY, barHeight: N, barWidth: z });
        O && D.add(O), h = _.y, c = _.x, C.push(c), M.push(h);
        var Y = a.barHelpers.getPathFillColor(i, p, T, y), X = "", V = n.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
        (a.barHelpers.arrBorderRadius[y][T] === "bottom" && n.globals.series[y][T] > 0 || a.barHelpers.arrBorderRadius[y][T] === "top" && n.globals.series[y][T] < 0) && (X = V), P = a.renderSeries(J(J({ realIndex: y, pathFill: Y.color }, Y.useRangeColor ? { lineFill: Y.color } : {}), {}, { j: T, i: p, columnGroupIndex: S, pathFrom: _.pathFrom, pathTo: _.pathTo, strokeWidth: H, elSeries: P, x: c, y: h, series: i, barHeight: N, barWidth: z, elDataLabelsWrap: I, elGoalsMarkers: D, type: "bar", visibleSeries: S, classes: X }));
      }
      n.globals.seriesXvalues[y] = C, n.globals.seriesYvalues[y] = M, a.groupCtx.prevY.push(a.groupCtx.yArrj), a.groupCtx.prevYF.push(a.groupCtx.yArrjF), a.groupCtx.prevYVal.push(a.groupCtx.yArrjVal), a.groupCtx.prevX.push(a.groupCtx.xArrj), a.groupCtx.prevXF.push(a.groupCtx.xArrjF), a.groupCtx.prevXVal.push(a.groupCtx.xArrjVal), l.add(P);
    }, u = 0, g = 0; u < i.length; u++, g++) d(u, g);
    return l;
  } }, { key: "initialPositions", value: function(i, r, a, n, o, l, c) {
    var h, d, u = this.w;
    if (this.isHorizontal) {
      n = u.globals.gridHeight / u.globals.dataPoints;
      var g = u.config.plotOptions.bar.barHeight;
      h = String(g).indexOf("%") === -1 ? parseInt(g, 10) : n * parseInt(g, 10) / 100, l = u.globals.padHorizontal + (this.isReversed ? u.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), r = (n - h) / 2;
    } else {
      d = a = u.globals.gridWidth / u.globals.dataPoints;
      var p = u.config.plotOptions.bar.columnWidth;
      u.globals.isXNumeric && u.globals.dataPoints > 1 ? d = (a = u.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : String(p).indexOf("%") === -1 ? d = parseInt(p, 10) : d *= parseInt(p, 10) / 100, o = this.isReversed ? this.baseLineY[c] : u.globals.gridHeight - this.baseLineY[c], i = u.globals.padHorizontal + (a - d) / 2;
    }
    var f = u.globals.barGroups.length || 1;
    return { x: i, y: r, yDivision: n, xDivision: a, barHeight: h / f, barWidth: d / f, zeroH: o, zeroW: l };
  } }, { key: "drawStackedBarPaths", value: function(i) {
    for (var r, a = i.indexes, n = i.barHeight, o = i.strokeWidth, l = i.zeroW, c = i.x, h = i.y, d = i.columnGroupIndex, u = i.seriesGroup, g = i.yDivision, p = i.elSeries, f = this.w, x = h + d * n, m = a.i, b = a.j, w = a.realIndex, y = a.translationsIndex, v = 0, k = 0; k < this.groupCtx.prevXF.length; k++) v += this.groupCtx.prevXF[k][b];
    var S = m;
    if (f.config.series[w].name && (S = u.indexOf(f.config.series[w].name)), S > 0) {
      var C = l;
      this.groupCtx.prevXVal[S - 1][b] < 0 ? C = this.series[m][b] >= 0 ? this.groupCtx.prevX[S - 1][b] + v - 2 * (this.isReversed ? v : 0) : this.groupCtx.prevX[S - 1][b] : this.groupCtx.prevXVal[S - 1][b] >= 0 && (C = this.series[m][b] >= 0 ? this.groupCtx.prevX[S - 1][b] : this.groupCtx.prevX[S - 1][b] - v + 2 * (this.isReversed ? v : 0)), r = C;
    } else r = l;
    c = this.series[m][b] === null ? r : r + this.series[m][b] / this.invertedYRatio - 2 * (this.isReversed ? this.series[m][b] / this.invertedYRatio : 0);
    var M = this.barHelpers.getBarpaths({ barYPosition: x, barHeight: n, x1: r, x2: c, strokeWidth: o, isReversed: this.isReversed, series: this.series, realIndex: a.realIndex, seriesGroup: u, i: m, j: b, w: f });
    return this.barHelpers.barBackground({ j: b, i: m, y1: x, y2: n, elSeries: p }), h += g, { pathTo: M.pathTo, pathFrom: M.pathFrom, goalX: this.barHelpers.getGoalValues("x", l, null, m, b, y), barXPosition: r, barYPosition: x, x: c, y: h };
  } }, { key: "drawStackedColumnPaths", value: function(i) {
    var r = i.indexes, a = i.x, n = i.y, o = i.xDivision, l = i.barWidth, c = i.zeroH, h = i.columnGroupIndex, d = i.seriesGroup, u = i.elSeries, g = this.w, p = r.i, f = r.j, x = r.bc, m = r.realIndex, b = r.translationsIndex;
    if (g.globals.isXNumeric) {
      var w = g.globals.seriesX[m][f];
      w || (w = 0), a = (w - g.globals.minX) / this.xRatio - l / 2 * g.globals.barGroups.length;
    }
    for (var y, v = a + h * l, k = 0, S = 0; S < this.groupCtx.prevYF.length; S++) k += isNaN(this.groupCtx.prevYF[S][f]) ? 0 : this.groupCtx.prevYF[S][f];
    var C = p;
    if (d && (C = d.indexOf(g.globals.seriesNames[m])), C > 0 && !g.globals.isXNumeric || C > 0 && g.globals.isXNumeric && g.globals.seriesX[m - 1][f] === g.globals.seriesX[m][f]) {
      var M, R, P, I = Math.min(this.yRatio.length + 1, m + 1);
      if (this.groupCtx.prevY[C - 1] !== void 0 && this.groupCtx.prevY[C - 1].length) for (var D = 1; D < I; D++) {
        var N;
        if (!isNaN((N = this.groupCtx.prevY[C - D]) === null || N === void 0 ? void 0 : N[f])) {
          P = this.groupCtx.prevY[C - D][f];
          break;
        }
      }
      for (var z = 1; z < I; z++) {
        var L, T;
        if (((L = this.groupCtx.prevYVal[C - z]) === null || L === void 0 ? void 0 : L[f]) < 0) {
          R = this.series[p][f] >= 0 ? P - k + 2 * (this.isReversed ? k : 0) : P;
          break;
        }
        if (((T = this.groupCtx.prevYVal[C - z]) === null || T === void 0 ? void 0 : T[f]) >= 0) {
          R = this.series[p][f] >= 0 ? P : P + k - 2 * (this.isReversed ? k : 0);
          break;
        }
      }
      R === void 0 && (R = g.globals.gridHeight), y = (M = this.groupCtx.prevYF[0]) !== null && M !== void 0 && M.every(function(B) {
        return B === 0;
      }) && this.groupCtx.prevYF.slice(1, C).every(function(B) {
        return B.every(function(_) {
          return isNaN(_);
        });
      }) ? c : R;
    } else y = c;
    n = this.series[p][f] ? y - this.series[p][f] / this.yRatio[b] + 2 * (this.isReversed ? this.series[p][f] / this.yRatio[b] : 0) : y;
    var H = this.barHelpers.getColumnPaths({ barXPosition: v, barWidth: l, y1: y, y2: n, yRatio: this.yRatio[b], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: d, realIndex: r.realIndex, i: p, j: f, w: g });
    return this.barHelpers.barBackground({ bc: x, j: f, i: p, x1: v, x2: l, elSeries: u }), { pathTo: H.pathTo, pathFrom: H.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, c, p, f), barXPosition: v, x: g.globals.isXNumeric ? a : a + o, y: n };
  } }]), t;
}(), Tr = function(s) {
  Li(t, Qt);
  var e = Pi(t);
  function t() {
    return te(this, t), e.apply(this, arguments);
  }
  return ie(t, [{ key: "draw", value: function(i, r, a) {
    var n = this, o = this.w, l = new $(this.ctx), c = o.globals.comboCharts ? r : o.config.chart.type, h = new gt(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = o.config.plotOptions.bar.horizontal, this.isOHLC = this.candlestickOptions && this.candlestickOptions.type === "ohlc";
    var d = new ze(this.ctx, o);
    i = d.getLogSeries(i), this.series = i, this.yRatio = d.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
    for (var u = l.group({ class: "apexcharts-".concat(c, "-series apexcharts-plot-series") }), g = function(f) {
      n.isBoxPlot = o.config.chart.type === "boxPlot" || o.config.series[f].type === "boxPlot";
      var x, m, b, w, y = void 0, v = void 0, k = [], S = [], C = o.globals.comboCharts ? a[f] : f, M = n.barHelpers.getGroupIndex(C).columnGroupIndex, R = l.group({ class: "apexcharts-series", seriesName: F.escapeString(o.globals.seriesNames[C]), rel: f + 1, "data:realIndex": C });
      n.ctx.series.addCollapsedClassToSeries(R, C), i[f].length > 0 && (n.visibleI = n.visibleI + 1);
      var P, I, D = 0;
      n.yRatio.length > 1 && (n.yaxisIndex = o.globals.seriesYAxisReverseMap[C][0], D = C);
      var N = n.barHelpers.initialPositions(C);
      v = N.y, P = N.barHeight, m = N.yDivision, w = N.zeroW, y = N.x, I = N.barWidth, x = N.xDivision, b = N.zeroH, S.push(y + I / 2);
      for (var z = l.group({ class: "apexcharts-datalabels", "data:realIndex": C }), L = l.group({ class: "apexcharts-bar-goals-markers" }), T = function(B) {
        var _ = n.barHelpers.getStrokeWidth(f, B, C), O = null, Y = { indexes: { i: f, j: B, realIndex: C, translationsIndex: D }, x: y, y: v, strokeWidth: _, elSeries: R };
        O = n.isHorizontal ? n.drawHorizontalBoxPaths(J(J({}, Y), {}, { yDivision: m, barHeight: P, zeroW: w })) : n.drawVerticalBoxPaths(J(J({}, Y), {}, { xDivision: x, barWidth: I, zeroH: b })), v = O.y, y = O.x;
        var X = n.barHelpers.drawGoalLine({ barXPosition: O.barXPosition, barYPosition: O.barYPosition, goalX: O.goalX, goalY: O.goalY, barHeight: P, barWidth: I });
        X && L.add(X), B > 0 && S.push(y + I / 2), k.push(v), O.pathTo.forEach(function(V, W) {
          var G = !n.isBoxPlot && n.candlestickOptions.wick.useFillColor ? O.color[W] : o.globals.stroke.colors[f], U = h.fillPath({ seriesNumber: C, dataPointIndex: B, color: O.color[W], value: i[f][B] });
          n.renderSeries({ realIndex: C, pathFill: U, lineFill: G, j: B, i: f, pathFrom: O.pathFrom, pathTo: V, strokeWidth: _, elSeries: R, x: y, y: v, series: i, columnGroupIndex: M, barHeight: P, barWidth: I, elDataLabelsWrap: z, elGoalsMarkers: L, visibleSeries: n.visibleI, type: o.config.chart.type });
        });
      }, H = 0; H < o.globals.dataPoints; H++) T(H);
      o.globals.seriesXvalues[C] = S, o.globals.seriesYvalues[C] = k, u.add(R);
    }, p = 0; p < i.length; p++) g(p);
    return u;
  } }, { key: "drawVerticalBoxPaths", value: function(i) {
    var r = i.indexes, a = i.x;
    i.y;
    var n = i.xDivision, o = i.barWidth, l = i.zeroH, c = i.strokeWidth, h = this.w, d = new $(this.ctx), u = r.i, g = r.j, p = h.config.plotOptions.candlestick.colors, f = this.boxOptions.colors, x = r.realIndex, m = function(H) {
      return Array.isArray(H) ? H[x] : H;
    }, b = m(p.upward), w = m(p.downward), y = this.yRatio[r.translationsIndex], v = this.getOHLCValue(x, g), k = l, S = l, C = v.o < v.c ? [b] : [w];
    this.isBoxPlot && (C = [m(f.lower), m(f.upper)]);
    var M = Math.min(v.o, v.c), R = Math.max(v.o, v.c), P = v.m;
    h.globals.isXNumeric && (a = (h.globals.seriesX[x][g] - h.globals.minX) / this.xRatio - o / 2);
    var I = a + o * this.visibleI;
    this.series[u][g] === void 0 || this.series[u][g] === null ? (M = l, R = l) : (M = l - M / y, R = l - R / y, k = l - v.h / y, S = l - v.l / y, P = l - v.m / y);
    var D = d.move(I, l), N = d.move(I + o / 2, M);
    if (h.globals.previousPaths.length > 0 && (N = this.getPreviousPath(x, g, !0)), this.isOHLC) {
      var z = I + o / 2, L = l - v.o / y, T = l - v.c / y;
      D = [d.move(z, k) + d.line(z, S) + d.move(z, L) + d.line(I, L) + d.move(z, T) + d.line(I + o, T)];
    } else D = this.isBoxPlot ? [d.move(I, M) + d.line(I + o / 2, M) + d.line(I + o / 2, k) + d.line(I + o / 4, k) + d.line(I + o - o / 4, k) + d.line(I + o / 2, k) + d.line(I + o / 2, M) + d.line(I + o, M) + d.line(I + o, P) + d.line(I, P) + d.line(I, M + c / 2), d.move(I, P) + d.line(I + o, P) + d.line(I + o, R) + d.line(I + o / 2, R) + d.line(I + o / 2, S) + d.line(I + o - o / 4, S) + d.line(I + o / 4, S) + d.line(I + o / 2, S) + d.line(I + o / 2, R) + d.line(I, R) + d.line(I, P) + "z"] : [d.move(I, R) + d.line(I + o / 2, R) + d.line(I + o / 2, k) + d.line(I + o / 2, R) + d.line(I + o, R) + d.line(I + o, M) + d.line(I + o / 2, M) + d.line(I + o / 2, S) + d.line(I + o / 2, M) + d.line(I, M) + d.line(I, R - c / 2)];
    return N += d.move(I, M), h.globals.isXNumeric || (a += n), { pathTo: D, pathFrom: N, x: a, y: R, goalY: this.barHelpers.getGoalValues("y", null, l, u, g, r.translationsIndex), barXPosition: I, color: C };
  } }, { key: "drawHorizontalBoxPaths", value: function(i) {
    var r = i.indexes;
    i.x;
    var a = i.y, n = i.yDivision, o = i.barHeight, l = i.zeroW, c = i.strokeWidth, h = this.w, d = new $(this.ctx), u = r.i, g = r.j, p = this.boxOptions.colors.lower;
    this.isBoxPlot && (p = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var f = this.invertedYRatio, x = r.realIndex, m = this.getOHLCValue(x, g), b = l, w = l, y = Math.min(m.o, m.c), v = Math.max(m.o, m.c), k = m.m;
    h.globals.isXNumeric && (a = (h.globals.seriesX[x][g] - h.globals.minX) / this.invertedXRatio - o / 2);
    var S = a + o * this.visibleI;
    this.series[u][g] === void 0 || this.series[u][g] === null ? (y = l, v = l) : (y = l + y / f, v = l + v / f, b = l + m.h / f, w = l + m.l / f, k = l + m.m / f);
    var C = d.move(l, S), M = d.move(y, S + o / 2);
    return h.globals.previousPaths.length > 0 && (M = this.getPreviousPath(x, g, !0)), C = [d.move(y, S) + d.line(y, S + o / 2) + d.line(b, S + o / 2) + d.line(b, S + o / 2 - o / 4) + d.line(b, S + o / 2 + o / 4) + d.line(b, S + o / 2) + d.line(y, S + o / 2) + d.line(y, S + o) + d.line(k, S + o) + d.line(k, S) + d.line(y + c / 2, S), d.move(k, S) + d.line(k, S + o) + d.line(v, S + o) + d.line(v, S + o / 2) + d.line(w, S + o / 2) + d.line(w, S + o - o / 4) + d.line(w, S + o / 4) + d.line(w, S + o / 2) + d.line(v, S + o / 2) + d.line(v, S) + d.line(k, S) + "z"], M += d.move(y, S), h.globals.isXNumeric || (a += n), { pathTo: C, pathFrom: M, x: v, y: a, goalX: this.barHelpers.getGoalValues("x", l, null, u, g), barYPosition: S, color: p };
  } }, { key: "getOHLCValue", value: function(i, r) {
    var a = this.w, n = new ze(this.ctx, a), o = n.getLogValAtSeriesIndex(a.globals.seriesCandleH[i][r], i), l = n.getLogValAtSeriesIndex(a.globals.seriesCandleO[i][r], i), c = n.getLogValAtSeriesIndex(a.globals.seriesCandleM[i][r], i), h = n.getLogValAtSeriesIndex(a.globals.seriesCandleC[i][r], i), d = n.getLogValAtSeriesIndex(a.globals.seriesCandleL[i][r], i);
    return { o: this.isBoxPlot ? o : l, h: this.isBoxPlot ? l : o, m: c, l: this.isBoxPlot ? h : d, c: this.isBoxPlot ? d : h };
  } }]), t;
}(), _o = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "checkColorRange", value: function() {
    var e = this.w, t = !1, i = e.config.plotOptions[e.config.chart.type];
    return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(r, a) {
      r.from <= 0 && (t = !0);
    }), t;
  } }, { key: "getShadeColor", value: function(e, t, i, r) {
    var a = this.w, n = 1, o = a.config.plotOptions[e].shadeIntensity, l = this.determineColor(e, t, i);
    a.globals.hasNegs || r ? n = a.config.plotOptions[e].reverseNegativeShade ? l.percent < 0 ? l.percent / 100 * (1.25 * o) : (1 - l.percent / 100) * (1.25 * o) : l.percent <= 0 ? 1 - (1 + l.percent / 100) * o : (1 - l.percent / 100) * o : (n = 1 - l.percent / 100, e === "treemap" && (n = (1 - l.percent / 100) * (1.25 * o)));
    var c = l.color, h = new F();
    if (a.config.plotOptions[e].enableShades) if (this.w.config.theme.mode === "dark") {
      var d = h.shadeColor(-1 * n, l.color);
      c = F.hexToRgba(F.isColorHex(d) ? d : F.rgb2hex(d), a.config.fill.opacity);
    } else {
      var u = h.shadeColor(n, l.color);
      c = F.hexToRgba(F.isColorHex(u) ? u : F.rgb2hex(u), a.config.fill.opacity);
    }
    return { color: c, colorProps: l };
  } }, { key: "determineColor", value: function(e, t, i) {
    var r = this.w, a = r.globals.series[t][i], n = r.config.plotOptions[e], o = n.colorScale.inverse ? i : t;
    n.distributed && r.config.chart.type === "treemap" && (o = i);
    var l = r.globals.colors[o], c = null, h = Math.min.apply(Math, De(r.globals.series[t])), d = Math.max.apply(Math, De(r.globals.series[t]));
    n.distributed || e !== "heatmap" || (h = r.globals.minY, d = r.globals.maxY), n.colorScale.min !== void 0 && (h = n.colorScale.min < r.globals.minY ? n.colorScale.min : r.globals.minY, d = n.colorScale.max > r.globals.maxY ? n.colorScale.max : r.globals.maxY);
    var u = Math.abs(d) + Math.abs(h), g = 100 * a / (u === 0 ? u - 1e-6 : u);
    return n.colorScale.ranges.length > 0 && n.colorScale.ranges.map(function(p, f) {
      if (a >= p.from && a <= p.to) {
        l = p.color, c = p.foreColor ? p.foreColor : null, h = p.from, d = p.to;
        var x = Math.abs(d) + Math.abs(h);
        g = 100 * a / (x === 0 ? x - 1e-6 : x);
      }
    }), { color: l, foreColor: c, percent: g };
  } }, { key: "calculateDataLabels", value: function(e) {
    var t = e.text, i = e.x, r = e.y, a = e.i, n = e.j, o = e.colorProps, l = e.fontSize, c = this.w.config.dataLabels, h = new $(this.ctx), d = new Jt(this.ctx), u = null;
    if (c.enabled) {
      u = h.group({ class: "apexcharts-data-labels" });
      var g = c.offsetX, p = c.offsetY, f = i + g, x = r + parseFloat(c.style.fontSize) / 3 + p;
      d.plotDataLabelsText({ x: f, y: x, text: t, i: a, j: n, color: o.foreColor, parent: u, fontSize: l, dataLabelsConfig: c });
    }
    return u;
  } }, { key: "addListeners", value: function(e) {
    var t = new $(this.ctx);
    e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)), e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e));
  } }]), s;
}(), vd = function() {
  function s(e, t) {
    te(this, s), this.ctx = e, this.w = e.w, this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new _o(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return ie(s, [{ key: "draw", value: function(e) {
    var t = this.w, i = new $(this.ctx), r = i.group({ class: "apexcharts-heatmap" });
    r.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")"));
    var a = t.globals.gridWidth / t.globals.dataPoints, n = t.globals.gridHeight / t.globals.series.length, o = 0, l = !1;
    this.negRange = this.helpers.checkColorRange();
    var c = e.slice();
    t.config.yaxis[0].reversed && (l = !0, c.reverse());
    for (var h = l ? 0 : c.length - 1; l ? h < c.length : h >= 0; l ? h++ : h--) {
      var d = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: F.escapeString(t.globals.seriesNames[h]), rel: h + 1, "data:realIndex": h });
      if (this.ctx.series.addCollapsedClassToSeries(d, h), t.config.chart.dropShadow.enabled) {
        var u = t.config.chart.dropShadow;
        new Ye(this.ctx).dropShadow(d, u, h);
      }
      for (var g = 0, p = t.config.plotOptions.heatmap.shadeIntensity, f = 0, x = 0; x < t.globals.dataPoints; x++) if (t.globals.seriesX.length && !t.globals.allSeriesHasEqualX && t.globals.minX + t.globals.minXDiff * x < t.globals.seriesX[h][f]) g += a;
      else {
        if (f >= c[h].length) break;
        var m = this.helpers.getShadeColor(t.config.chart.type, h, f, this.negRange), b = m.color, w = m.colorProps;
        t.config.fill.type === "image" && (b = new gt(this.ctx).fillPath({ seriesNumber: h, dataPointIndex: f, opacity: t.globals.hasNegs ? w.percent < 0 ? 1 - (1 + w.percent / 100) : p + w.percent / 100 : w.percent / 100, patternID: F.randomId(), width: t.config.fill.image.width ? t.config.fill.image.width : a, height: t.config.fill.image.height ? t.config.fill.image.height : n }));
        var y = this.rectRadius, v = i.drawRect(g, o, a, n, y);
        if (v.attr({ cx: g, cy: o }), v.node.classList.add("apexcharts-heatmap-rect"), d.add(v), v.attr({ fill: b, i: h, index: h, j: f, val: e[h][f], "stroke-width": this.strokeWidth, stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? b : t.globals.stroke.colors[0], color: b }), this.helpers.addListeners(v), t.config.chart.animations.enabled && !t.globals.dataChanged) {
          var k = 1;
          t.globals.resized || (k = t.config.chart.animations.speed), this.animateHeatMap(v, g, o, a, n, k);
        }
        if (t.globals.dataChanged) {
          var S = 1;
          if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
            S = this.dynamicAnim.speed;
            var C = t.globals.previousPaths[h] && t.globals.previousPaths[h][f] && t.globals.previousPaths[h][f].color;
            C || (C = "rgba(255, 255, 255, 0)"), this.animateHeatColor(v, F.isColorHex(C) ? C : F.rgb2hex(C), F.isColorHex(b) ? b : F.rgb2hex(b), S);
          }
        }
        var M = (0, t.config.dataLabels.formatter)(t.globals.series[h][f], { value: t.globals.series[h][f], seriesIndex: h, dataPointIndex: f, w: t }), R = this.helpers.calculateDataLabels({ text: M, x: g + a / 2, y: o + n / 2, i: h, j: f, colorProps: w, series: c });
        R !== null && d.add(R), g += a, f++;
      }
      o += n, r.add(d);
    }
    var P = t.globals.yAxisScale[0].result.slice();
    return t.config.yaxis[0].reversed ? P.unshift("") : P.push(""), t.globals.yAxisScale[0].result = P, r;
  } }, { key: "animateHeatMap", value: function(e, t, i, r, a, n) {
    var o = new ii(this.ctx);
    o.animateRect(e, { x: t + r / 2, y: i + a / 2, width: 0, height: 0 }, { x: t, y: i, width: r, height: a }, n, function() {
      o.animationCompleted(e);
    });
  } }, { key: "animateHeatColor", value: function(e, t, i, r) {
    e.attr({ fill: t }).animate(r).attr({ fill: i });
  } }]), s;
}(), Oo = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "drawYAxisTexts", value: function(e, t, i, r) {
    var a = this.w, n = a.config.yaxis[0], o = a.globals.yLabelFormatters[0];
    return new $(this.ctx).drawText({ x: e + n.labels.offsetX, y: t + n.labels.offsetY, text: o(r, i), textAnchor: "middle", fontSize: n.labels.style.fontSize, fontFamily: n.labels.style.fontFamily, foreColor: Array.isArray(n.labels.style.colors) ? n.labels.style.colors[i] : n.labels.style.colors });
  } }]), s;
}(), zo = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
    var t = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = Math.min(t.globals.gridWidth, t.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = t.globals.gridWidth / 2, t.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(t.config.plotOptions.pie.endAngle - t.config.plotOptions.pie.startAngle), this.initialAngle = t.config.plotOptions.pie.startAngle % this.fullAngle, t.globals.radialSize = this.defaultSize / 2.05 - t.config.stroke.width - (t.config.chart.sparkline.enabled ? 0 : t.config.chart.dropShadow.blur), this.donutSize = t.globals.radialSize * parseInt(t.config.plotOptions.pie.donut.size, 10) / 100;
    var i = t.config.plotOptions.pie.customScale, r = t.globals.gridWidth / 2, a = t.globals.gridHeight / 2;
    this.translateX = r - r * i, this.translateY = a - a * i, this.dataLabelsGroup = new $(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return ie(s, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, r = new $(this.ctx), a = r.group({ class: "apexcharts-pie" });
    if (i.globals.noData) return a;
    for (var n = 0, o = 0; o < e.length; o++) n += F.negToZero(e[o]);
    var l = [], c = r.group();
    n === 0 && (n = 1e-5), e.forEach(function(w) {
      t.maxY = Math.max(t.maxY, w);
    }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(a);
    for (var h = 0; h < e.length; h++) {
      var d = this.fullAngle * F.negToZero(e[h]) / n;
      l.push(d), this.chartType === "polarArea" ? (l[h] = this.fullAngle / e.length, this.sliceSizes.push(i.globals.radialSize * e[h] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
    }
    if (i.globals.dataChanged) {
      for (var u, g = 0, p = 0; p < i.globals.previousPaths.length; p++) g += F.negToZero(i.globals.previousPaths[p]);
      for (var f = 0; f < i.globals.previousPaths.length; f++) u = this.fullAngle * F.negToZero(i.globals.previousPaths[f]) / g, this.prevSectorAngleArr.push(u);
    }
    if (this.donutSize < 0 && (this.donutSize = 0), this.chartType === "donut") {
      var x = r.drawCircle(this.donutSize);
      x.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), c.add(x);
    }
    var m = this.drawArcs(l, e);
    if (this.sliceLabels.forEach(function(w) {
      m.add(w);
    }), c.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), c.add(m), a.add(c), this.donutDataLabels.show) {
      var b = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      a.add(b);
    }
    return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(a), a;
  } }, { key: "drawArcs", value: function(e, t) {
    var i = this.w, r = new Ye(this.ctx), a = new $(this.ctx), n = new gt(this.ctx), o = a.group({ class: "apexcharts-slices" }), l = this.initialAngle, c = this.initialAngle, h = this.initialAngle, d = this.initialAngle;
    this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
    for (var u = 0; u < e.length; u++) {
      var g = a.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: F.escapeString(i.globals.seriesNames[u]), rel: u + 1, "data:realIndex": u });
      o.add(g), c = d, h = (l = h) + e[u], d = c + this.prevSectorAngleArr[u];
      var p = h < l ? this.fullAngle + h - l : h - l, f = n.fillPath({ seriesNumber: u, size: this.sliceSizes[u], value: t[u] }), x = this.getChangedPath(c, d), m = a.drawPath({ d: x, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[u] : this.lineColorArr, strokeWidth: 0, fill: f, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(u) });
      if (m.attr({ index: 0, j: u }), r.setSelectionFilter(m, 0, u), i.config.chart.dropShadow.enabled) {
        var b = i.config.chart.dropShadow;
        r.dropShadow(m, b, u);
      }
      this.addListeners(m, this.donutDataLabels), $.setAttrs(m.node, { "data:angle": p, "data:startAngle": l, "data:strokeWidth": this.strokeWidth, "data:value": t[u] });
      var w = { x: 0, y: 0 };
      this.chartType === "pie" || this.chartType === "polarArea" ? w = F.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (l + p / 2) % this.fullAngle) : this.chartType === "donut" && (w = F.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (l + p / 2) % this.fullAngle)), g.add(m);
      var y = 0;
      if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((y = p / this.fullAngle * i.config.chart.animations.speed) === 0 && (y = 1), this.animDur = y + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(m, { size: this.sliceSizes[u], endAngle: h, startAngle: l, prevStartAngle: c, prevEndAngle: d, animateStartingPos: !0, i: u, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(m, { size: this.sliceSizes[u], endAngle: h, startAngle: l, i: u, totalItems: e.length - 1, animBeginArr: this.animBeginArr, dur: y }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && m.node.addEventListener("mouseup", this.pieClicked.bind(this, u)), i.globals.selectedDataPoints[0] !== void 0 && i.globals.selectedDataPoints[0].indexOf(u) > -1 && this.pieClicked(u), i.config.dataLabels.enabled) {
        var v = w.x, k = w.y, S = 100 * p / this.fullAngle + "%";
        if (p !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[u]) {
          var C = i.config.dataLabels.formatter;
          C !== void 0 && (S = C(i.globals.seriesPercent[u][0], { seriesIndex: u, w: i }));
          var M = i.globals.dataLabels.style.colors[u], R = a.group({ class: "apexcharts-datalabels" }), P = a.drawText({ x: v, y: k, text: S, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: M });
          if (R.add(P), i.config.dataLabels.dropShadow.enabled) {
            var I = i.config.dataLabels.dropShadow;
            r.dropShadow(P, I);
          }
          P.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === !1 && (P.node.classList.add("apexcharts-pie-label-delay"), P.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(R);
        }
      }
    }
    return o;
  } }, { key: "addListeners", value: function(e, t) {
    var i = new $(this.ctx);
    e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e)), e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e)), this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)));
  } }, { key: "animatePaths", value: function(e, t) {
    var i = this.w, r = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle, a = r, n = t.startAngle, o = t.startAngle;
    t.prevStartAngle !== void 0 && t.prevEndAngle !== void 0 && (n = t.prevEndAngle, a = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle), t.i === i.config.series.length - 1 && (r + o > this.fullAngle ? t.endAngle = t.endAngle - (r + o) : r + o < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (r + o)))), r === this.fullAngle && (r = this.fullAngle - 0.01), this.animateArc(e, n, o, r, a, t);
  } }, { key: "animateArc", value: function(e, t, i, r, a, n) {
    var o, l = this, c = this.w, h = new ii(this.ctx), d = n.size;
    (isNaN(t) || isNaN(a)) && (t = i, a = r, n.dur = 0);
    var u = r, g = i, p = t < i ? this.fullAngle + t - i : t - i;
    c.globals.dataChanged && n.shouldSetPrevPaths && n.prevEndAngle && (o = l.getPiePath({ me: l, startAngle: n.prevStartAngle, angle: n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle, size: d }), e.attr({ d: o })), n.dur !== 0 ? e.animate(n.dur, n.animBeginArr[n.i]).after(function() {
      l.chartType !== "pie" && l.chartType !== "donut" && l.chartType !== "polarArea" || this.animate(c.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": l.strokeWidth }), n.i === c.config.series.length - 1 && h.animationCompleted(e);
    }).during(function(f) {
      u = p + (r - p) * f, n.animateStartingPos && (u = a + (r - a) * f, g = t - a + (i - (t - a)) * f), o = l.getPiePath({ me: l, startAngle: g, angle: u, size: d }), e.node.setAttribute("data:pathOrig", o), e.attr({ d: o });
    }) : (o = l.getPiePath({ me: l, startAngle: g, angle: r, size: d }), n.isTrack || (c.globals.animationEnded = !0), e.node.setAttribute("data:pathOrig", o), e.attr({ d: o, "stroke-width": l.strokeWidth }));
  } }, { key: "pieClicked", value: function(e) {
    var t, i = this.w, r = this, a = r.sliceSizes[e] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), n = i.globals.dom.Paper.findOne(".apexcharts-".concat(r.chartType.toLowerCase(), "-slice-").concat(e));
    if (n.attr("data:pieClicked") !== "true") {
      var o = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
      Array.prototype.forEach.call(o, function(d) {
        d.setAttribute("data:pieClicked", "false");
        var u = d.getAttribute("data:pathOrig");
        u && d.setAttribute("d", u);
      }), i.globals.capturedDataPointIndex = e, n.attr("data:pieClicked", "true");
      var l = parseInt(n.attr("data:startAngle"), 10), c = parseInt(n.attr("data:angle"), 10);
      t = r.getPiePath({ me: r, startAngle: l, angle: c, size: a }), c !== 360 && n.plot(t);
    } else {
      n.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(n.node, this.donutDataLabels);
      var h = n.attr("data:pathOrig");
      n.attr({ d: h });
    }
  } }, { key: "getChangedPath", value: function(e, t) {
    var i = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: e, angle: t - e, size: this.size })), i;
  } }, { key: "getPiePath", value: function(e) {
    var t, i = e.me, r = e.startAngle, a = e.angle, n = e.size, o = new $(this.ctx), l = r, c = Math.PI * (l - 90) / 180, h = a + r;
    Math.ceil(h) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h) > this.fullAngle && (h -= this.fullAngle);
    var d = Math.PI * (h - 90) / 180, u = i.centerX + n * Math.cos(c), g = i.centerY + n * Math.sin(c), p = i.centerX + n * Math.cos(d), f = i.centerY + n * Math.sin(d), x = F.polarToCartesian(i.centerX, i.centerY, i.donutSize, h), m = F.polarToCartesian(i.centerX, i.centerY, i.donutSize, l), b = a > 180 ? 1 : 0, w = ["M", u, g, "A", n, n, 0, b, 1, p, f];
    return t = i.chartType === "donut" ? [].concat(w, ["L", x.x, x.y, "A", i.donutSize, i.donutSize, 0, b, 0, m.x, m.y, "L", u, g, "z"]).join(" ") : i.chartType === "pie" || i.chartType === "polarArea" ? [].concat(w, ["L", i.centerX, i.centerY, "L", u, g]).join(" ") : [].concat(w).join(" "), o.roundPathCorners(t, 2 * this.strokeWidth);
  } }, { key: "drawPolarElements", value: function(e) {
    var t = this.w, i = new Po(this.ctx), r = new $(this.ctx), a = new Oo(this.ctx), n = r.group(), o = r.group(), l = i.niceScale(0, Math.ceil(this.maxY), 0), c = l.result.reverse(), h = l.result.length;
    this.maxY = l.niceMax;
    for (var d = t.globals.radialSize, u = d / (h - 1), g = 0; g < h - 1; g++) {
      var p = r.drawCircle(d);
      if (p.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth, stroke: t.config.plotOptions.polarArea.rings.strokeColor }), t.config.yaxis[0].show) {
        var f = a.drawYAxisTexts(this.centerX, this.centerY - d + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, g, c[g]);
        o.add(f);
      }
      n.add(p), d -= u;
    }
    this.drawSpokes(e), e.add(n), e.add(o);
  } }, { key: "renderInnerDataLabels", value: function(e, t, i) {
    var r = this.w, a = new $(this.ctx), n = t.total.show;
    e.node.innerHTML = "", e.node.style.opacity = i.opacity;
    var o, l, c = i.centerX, h = this.donutDataLabels.total.label ? i.centerY : i.centerY - i.centerY / 6;
    o = t.name.color === void 0 ? r.globals.colors[0] : t.name.color;
    var d = t.name.fontSize, u = t.name.fontFamily, g = t.name.fontWeight;
    l = t.value.color === void 0 ? r.config.chart.foreColor : t.value.color;
    var p = t.value.formatter, f = "", x = "";
    if (n ? (o = t.total.color, d = t.total.fontSize, u = t.total.fontFamily, g = t.total.fontWeight, x = this.donutDataLabels.total.label ? t.total.label : "", f = t.total.formatter(r)) : r.globals.series.length === 1 && (f = p(r.globals.series[0], r), x = r.globals.seriesNames[0]), x && (x = t.name.formatter(x, t.total.show, r)), t.name.show) {
      var m = a.drawText({ x: c, y: h + parseFloat(t.name.offsetY), text: x, textAnchor: "middle", foreColor: o, fontSize: d, fontWeight: g, fontFamily: u });
      m.node.classList.add("apexcharts-datalabel-label"), e.add(m);
    }
    if (t.value.show) {
      var b = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, w = a.drawText({ x: c, y: h + b, text: f, textAnchor: "middle", foreColor: l, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily });
      w.node.classList.add("apexcharts-datalabel-value"), e.add(w);
    }
    return e;
  } }, { key: "printInnerLabels", value: function(e, t, i, r) {
    var a, n = this.w;
    r ? a = e.name.color === void 0 ? n.globals.colors[parseInt(r.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : n.globals.series.length > 1 && e.total.show && (a = e.total.color);
    var o = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), l = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i = (0, e.value.formatter)(i, n), r || typeof e.total.formatter != "function" || (i = e.total.formatter(n));
    var c = t === e.total.label;
    t = this.donutDataLabels.total.label ? e.name.formatter(t, c, n) : "", o !== null && (o.textContent = t), l !== null && (l.textContent = i), o !== null && (o.style.fill = a);
  } }, { key: "printDataLabelsInner", value: function(e, t) {
    var i = this.w, r = e.getAttribute("data:value"), a = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
    i.globals.series.length > 1 && this.printInnerLabels(t, a, r, e);
    var n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    n !== null && (n.style.opacity = 1);
  } }, { key: "drawSpokes", value: function(e) {
    var t = this, i = this.w, r = new $(this.ctx), a = i.config.plotOptions.polarArea.spokes;
    if (a.strokeWidth !== 0) {
      for (var n = [], o = 360 / i.globals.series.length, l = 0; l < i.globals.series.length; l++) n.push(F.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + o * l));
      n.forEach(function(c, h) {
        var d = r.drawLine(c.x, c.y, t.centerX, t.centerY, Array.isArray(a.connectorColors) ? a.connectorColors[h] : a.connectorColors);
        e.add(d);
      });
    }
  } }, { key: "revertDataLabelsInner", value: function() {
    var e = this.w;
    if (this.donutDataLabels.show) {
      var t = e.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i = this.renderInnerDataLabels(t, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      e.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i);
    }
  } }]), s;
}(), yd = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var t = this.w;
    this.graphics = new $(this.ctx), this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = t.globals.svgHeight < t.globals.svgWidth ? t.globals.gridHeight : t.globals.gridWidth, this.isLog = t.config.yaxis[0].logarithmic, this.logBase = t.config.yaxis[0].logBase, this.coreUtils = new ze(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, t.globals.maxY, 0) : t.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : t.globals.minY, this.polygons = t.config.plotOptions.radar.polygons, this.strokeWidth = t.config.stroke.show ? t.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - t.config.chart.dropShadow.blur, t.config.xaxis.labels.show && (this.size = this.size - t.globals.xAxisLabelsWidth / 1.75), t.config.plotOptions.radar.size !== void 0 && (this.size = t.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return ie(s, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, r = new gt(this.ctx), a = [], n = new Jt(this.ctx);
    e.length && (this.dataPointsLen = e[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var o = i.globals.gridWidth / 2, l = i.globals.gridHeight / 2, c = o + i.config.plotOptions.radar.offsetX, h = l + i.config.plotOptions.radar.offsetY, d = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(c || 0, ", ").concat(h || 0, ")") }), u = [], g = null, p = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), e.forEach(function(x, m) {
      var b = x.length === i.globals.dataPoints, w = t.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": b, seriesName: F.escapeString(i.globals.seriesNames[m]), rel: m + 1, "data:realIndex": m });
      t.dataRadiusOfPercent[m] = [], t.dataRadius[m] = [], t.angleArr[m] = [], x.forEach(function(D, N) {
        var z = Math.abs(t.maxValue - t.minValue);
        D -= t.minValue, t.isLog && (D = t.coreUtils.getLogVal(t.logBase, D, 0)), t.dataRadiusOfPercent[m][N] = D / z, t.dataRadius[m][N] = t.dataRadiusOfPercent[m][N] * t.size, t.angleArr[m][N] = N * t.disAngle;
      }), u = t.getDataPointsPos(t.dataRadius[m], t.angleArr[m]);
      var y = t.createPaths(u, { x: 0, y: 0 });
      g = t.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p = t.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": m }), i.globals.delayedElements.push({ el: g.node, index: m });
      var v = { i: m, realIndex: m, animationDelay: m, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[m], strokeLineCap: i.config.stroke.lineCap }, k = null;
      i.globals.previousPaths.length > 0 && (k = t.getPreviousPath(m));
      for (var S = 0; S < y.linePathsTo.length; S++) {
        var C = t.graphics.renderPaths(J(J({}, v), {}, { pathFrom: k === null ? y.linePathsFrom[S] : k, pathTo: y.linePathsTo[S], strokeWidth: Array.isArray(t.strokeWidth) ? t.strokeWidth[m] : t.strokeWidth, fill: "none", drawShadow: !1 }));
        w.add(C);
        var M = r.fillPath({ seriesNumber: m }), R = t.graphics.renderPaths(J(J({}, v), {}, { pathFrom: k === null ? y.areaPathsFrom[S] : k, pathTo: y.areaPathsTo[S], strokeWidth: 0, fill: M, drawShadow: !1 }));
        if (i.config.chart.dropShadow.enabled) {
          var P = new Ye(t.ctx), I = i.config.chart.dropShadow;
          P.dropShadow(R, Object.assign({}, I, { noUserSpaceOnUse: !0 }), m);
        }
        w.add(R);
      }
      x.forEach(function(D, N) {
        var z = new ni(t.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: m, dataPointIndex: N }), L = t.graphics.drawMarker(u[N].x, u[N].y, z);
        L.attr("rel", N), L.attr("j", N), L.attr("index", m), L.node.setAttribute("default-marker-size", z.pSize);
        var T = t.graphics.group({ class: "apexcharts-series-markers" });
        T && T.add(L), g.add(T), w.add(g);
        var H = i.config.dataLabels;
        if (H.enabled) {
          var B = H.formatter(i.globals.series[m][N], { seriesIndex: m, dataPointIndex: N, w: i });
          n.plotDataLabelsText({ x: u[N].x, y: u[N].y, text: B, textAnchor: "middle", i: m, j: m, parent: p, offsetCorrection: !1, dataLabelsConfig: J({}, H) });
        }
        w.add(p);
      }), a.push(w);
    }), this.drawPolygons({ parent: d }), i.config.xaxis.labels.show) {
      var f = this.drawXAxisTexts();
      d.add(f);
    }
    return a.forEach(function(x) {
      d.add(x);
    }), d.add(this.yaxisLabels), d;
  } }, { key: "drawPolygons", value: function(e) {
    for (var t = this, i = this.w, r = e.parent, a = new Oo(this.ctx), n = i.globals.yAxisScale[0].result.reverse(), o = n.length, l = [], c = this.size / (o - 1), h = 0; h < o; h++) l[h] = c * h;
    l.reverse();
    var d = [], u = [];
    l.forEach(function(g, p) {
      var f = F.getPolygonPos(g, t.dataPointsLen), x = "";
      f.forEach(function(m, b) {
        if (p === 0) {
          var w = t.graphics.drawLine(m.x, m.y, 0, 0, Array.isArray(t.polygons.connectorColors) ? t.polygons.connectorColors[b] : t.polygons.connectorColors);
          u.push(w);
        }
        b === 0 && t.yaxisLabelsTextsPos.push({ x: m.x, y: m.y }), x += m.x + "," + m.y + " ";
      }), d.push(x);
    }), d.forEach(function(g, p) {
      var f = t.polygons.strokeColors, x = t.polygons.strokeWidth, m = t.graphics.drawPolygon(g, Array.isArray(f) ? f[p] : f, Array.isArray(x) ? x[p] : x, i.globals.radarPolygons.fill.colors[p]);
      r.add(m);
    }), u.forEach(function(g) {
      r.add(g);
    }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(g, p) {
      var f = a.drawYAxisTexts(g.x, g.y, p, n[p]);
      t.yaxisLabels.add(f);
    });
  } }, { key: "drawXAxisTexts", value: function() {
    var e = this, t = this.w, i = t.config.xaxis.labels, r = this.graphics.group({ class: "apexcharts-xaxis" }), a = F.getPolygonPos(this.size, this.dataPointsLen);
    return t.globals.labels.forEach(function(n, o) {
      var l = t.config.xaxis.labels.formatter, c = new Jt(e.ctx);
      if (a[o]) {
        var h = e.getTextPos(a[o], e.size), d = l(n, { seriesIndex: -1, dataPointIndex: o, w: t });
        c.plotDataLabelsText({ x: h.newX, y: h.newY, text: d, textAnchor: h.textAnchor, i: o, j: o, parent: r, className: "apexcharts-xaxis-label", color: Array.isArray(i.style.colors) && i.style.colors[o] ? i.style.colors[o] : "#a8a8a8", dataLabelsConfig: J({ textAnchor: h.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1 }).on("click", function(u) {
          if (typeof t.config.chart.events.xAxisLabelClick == "function") {
            var g = Object.assign({}, t, { labelIndex: o });
            t.config.chart.events.xAxisLabelClick(u, e.ctx, g);
          }
        });
      }
    }), r;
  } }, { key: "createPaths", value: function(e, t) {
    var i = this, r = [], a = [], n = [], o = [];
    if (e.length) {
      a = [this.graphics.move(t.x, t.y)], o = [this.graphics.move(t.x, t.y)];
      var l = this.graphics.move(e[0].x, e[0].y), c = this.graphics.move(e[0].x, e[0].y);
      e.forEach(function(h, d) {
        l += i.graphics.line(h.x, h.y), c += i.graphics.line(h.x, h.y), d === e.length - 1 && (l += "Z", c += "Z");
      }), r.push(l), n.push(c);
    }
    return { linePathsFrom: a, linePathsTo: r, areaPathsFrom: o, areaPathsTo: n };
  } }, { key: "getTextPos", value: function(e, t) {
    var i = "middle", r = e.x, a = e.y;
    return Math.abs(e.x) >= 10 ? e.x > 0 ? (i = "start", r += 10) : e.x < 0 && (i = "end", r -= 10) : i = "middle", Math.abs(e.y) >= t - 10 && (e.y < 0 ? a -= 10 : e.y > 0 && (a += 10)), { textAnchor: i, newX: r, newY: a };
  } }, { key: "getPreviousPath", value: function(e) {
    for (var t = this.w, i = null, r = 0; r < t.globals.previousPaths.length; r++) {
      var a = t.globals.previousPaths[r];
      a.paths.length > 0 && parseInt(a.realIndex, 10) === parseInt(e, 10) && t.globals.previousPaths[r].paths[0] !== void 0 && (i = t.globals.previousPaths[r].paths[0].d);
    }
    return i;
  } }, { key: "getDataPointsPos", value: function(e, t) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
    e = e || [], t = t || [];
    for (var r = [], a = 0; a < i; a++) {
      var n = {};
      n.x = e[a] * Math.sin(t[a]), n.y = -e[a] * Math.cos(t[a]), r.push(n);
    }
    return r;
  } }]), s;
}(), wd = function(s) {
  Li(t, zo);
  var e = Pi(t);
  function t(i) {
    var r;
    te(this, t), (r = e.call(this, i)).ctx = i, r.w = i.w, r.animBeginArr = [0], r.animDur = 0;
    var a = r.w;
    return r.startAngle = a.config.plotOptions.radialBar.startAngle, r.endAngle = a.config.plotOptions.radialBar.endAngle, r.totalAngle = Math.abs(a.config.plotOptions.radialBar.endAngle - a.config.plotOptions.radialBar.startAngle), r.trackStartAngle = a.config.plotOptions.radialBar.track.startAngle, r.trackEndAngle = a.config.plotOptions.radialBar.track.endAngle, r.barLabels = r.w.config.plotOptions.radialBar.barLabels, r.donutDataLabels = r.w.config.plotOptions.radialBar.dataLabels, r.radialDataLabels = r.donutDataLabels, r.trackStartAngle || (r.trackStartAngle = r.startAngle), r.trackEndAngle || (r.trackEndAngle = r.endAngle), r.endAngle === 360 && (r.endAngle = 359.99), r.margin = parseInt(a.config.plotOptions.radialBar.track.margin, 10), r.onBarLabelClick = r.onBarLabelClick.bind($n(r)), r;
  }
  return ie(t, [{ key: "draw", value: function(i) {
    var r = this.w, a = new $(this.ctx), n = a.group({ class: "apexcharts-radialbar" });
    if (r.globals.noData) return n;
    var o = a.group(), l = this.defaultSize / 2, c = r.globals.gridWidth / 2, h = this.defaultSize / 2.05;
    r.config.chart.sparkline.enabled || (h = h - r.config.stroke.width - r.config.chart.dropShadow.blur);
    var d = r.globals.fill.colors;
    if (r.config.plotOptions.radialBar.track.show) {
      var u = this.drawTracks({ size: h, centerX: c, centerY: l, colorArr: d, series: i });
      o.add(u);
    }
    var g = this.drawArcs({ size: h, centerX: c, centerY: l, colorArr: d, series: i }), p = 360;
    r.config.plotOptions.radialBar.startAngle < 0 && (p = this.totalAngle);
    var f = (360 - p) / 360;
    if (r.globals.radialSize = h - h * f, this.radialDataLabels.value.show) {
      var x = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      r.globals.radialSize += x * f;
    }
    return o.add(g.g), r.config.plotOptions.radialBar.hollow.position === "front" && (g.g.add(g.elHollow), g.dataLabels && g.g.add(g.dataLabels)), n.add(o), n;
  } }, { key: "drawTracks", value: function(i) {
    var r = this.w, a = new $(this.ctx), n = a.group({ class: "apexcharts-tracks" }), o = new Ye(this.ctx), l = new gt(this.ctx), c = this.getStrokeWidth(i);
    i.size = i.size - c / 2;
    for (var h = 0; h < i.series.length; h++) {
      var d = a.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      n.add(d), d.attr({ rel: h + 1 }), i.size = i.size - c - this.margin;
      var u = r.config.plotOptions.radialBar.track, g = l.fillPath({ seriesNumber: 0, size: i.size, fillColors: Array.isArray(u.background) ? u.background[h] : u.background, solid: !0 }), p = this.trackStartAngle, f = this.trackEndAngle;
      Math.abs(f) + Math.abs(p) >= 360 && (f = 360 - Math.abs(this.startAngle) - 0.1);
      var x = a.drawPath({ d: "", stroke: g, strokeWidth: c * parseInt(u.strokeWidth, 10) / 100, fill: "none", strokeOpacity: u.opacity, classes: "apexcharts-radialbar-area" });
      if (u.dropShadow.enabled) {
        var m = u.dropShadow;
        o.dropShadow(x, m);
      }
      d.add(x), x.attr("id", "apexcharts-radialbarTrack-" + h), this.animatePaths(x, { centerX: i.centerX, centerY: i.centerY, endAngle: f, startAngle: p, size: i.size, i: h, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0 });
    }
    return n;
  } }, { key: "drawArcs", value: function(i) {
    var r = this.w, a = new $(this.ctx), n = new gt(this.ctx), o = new Ye(this.ctx), l = a.group(), c = this.getStrokeWidth(i);
    i.size = i.size - c / 2;
    var h = r.config.plotOptions.radialBar.hollow.background, d = i.size - c * i.series.length - this.margin * i.series.length - c * parseInt(r.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, u = d - r.config.plotOptions.radialBar.hollow.margin;
    r.config.plotOptions.radialBar.hollow.image !== void 0 && (h = this.drawHollowImage(i, l, d, h));
    var g = this.drawHollow({ size: u, centerX: i.centerX, centerY: i.centerY, fill: h || "transparent" });
    if (r.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var p = r.config.plotOptions.radialBar.hollow.dropShadow;
      o.dropShadow(g, p);
    }
    var f = 1;
    !this.radialDataLabels.total.show && r.globals.series.length > 1 && (f = 0);
    var x = null;
    if (this.radialDataLabels.show) {
      var m = r.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
      x = this.renderInnerDataLabels(m, this.radialDataLabels, { hollowSize: d, centerX: i.centerX, centerY: i.centerY, opacity: f });
    }
    r.config.plotOptions.radialBar.hollow.position === "back" && (l.add(g), x && l.add(x));
    var b = !1;
    r.config.plotOptions.radialBar.inverseOrder && (b = !0);
    for (var w = b ? i.series.length - 1 : 0; b ? w >= 0 : w < i.series.length; b ? w-- : w++) {
      var y = a.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: F.escapeString(r.globals.seriesNames[w]) });
      l.add(y), y.attr({ rel: w + 1, "data:realIndex": w }), this.ctx.series.addCollapsedClassToSeries(y, w), i.size = i.size - c - this.margin;
      var v = n.fillPath({ seriesNumber: w, size: i.size, value: i.series[w] }), k = this.startAngle, S = void 0, C = F.negToZero(i.series[w] > 100 ? 100 : i.series[w]) / 100, M = Math.round(this.totalAngle * C) + this.startAngle, R = void 0;
      r.globals.dataChanged && (S = this.startAngle, R = Math.round(this.totalAngle * F.negToZero(r.globals.previousPaths[w]) / 100) + S), Math.abs(M) + Math.abs(k) > 360 && (M -= 0.01), Math.abs(R) + Math.abs(S) > 360 && (R -= 0.01);
      var P = M - k, I = Array.isArray(r.config.stroke.dashArray) ? r.config.stroke.dashArray[w] : r.config.stroke.dashArray, D = a.drawPath({ d: "", stroke: v, strokeWidth: c, fill: "none", fillOpacity: r.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + w, strokeDashArray: I });
      if ($.setAttrs(D.node, { "data:angle": P, "data:value": i.series[w] }), r.config.chart.dropShadow.enabled) {
        var N = r.config.chart.dropShadow;
        o.dropShadow(D, N, w);
      }
      if (o.setSelectionFilter(D, 0, w), this.addListeners(D, this.radialDataLabels), y.add(D), D.attr({ index: 0, j: w }), this.barLabels.enabled) {
        var z = F.polarToCartesian(i.centerX, i.centerY, i.size, k), L = this.barLabels.formatter(r.globals.seriesNames[w], { seriesIndex: w, w: r }), T = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || T.push("apexcharts-no-click");
        var H = this.barLabels.useSeriesColors ? r.globals.colors[w] : r.config.chart.foreColor;
        H || (H = r.config.chart.foreColor);
        var B = z.x + this.barLabels.offsetX, _ = z.y + this.barLabels.offsetY, O = a.drawText({ x: B, y: _, text: L, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: H, cssClass: T.join(" ") });
        O.on("click", this.onBarLabelClick), O.attr({ rel: w + 1 }), k !== 0 && O.attr({ "transform-origin": "".concat(B, " ").concat(_), transform: "rotate(".concat(k, " 0 0)") }), y.add(O);
      }
      var Y = 0;
      !this.initialAnim || r.globals.resized || r.globals.dataChanged || (Y = r.config.chart.animations.speed), r.globals.dataChanged && (Y = r.config.chart.animations.dynamicAnimation.speed), this.animDur = Y / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(D, { centerX: i.centerX, centerY: i.centerY, endAngle: M, startAngle: k, prevEndAngle: R, prevStartAngle: S, size: i.size, i: w, totalItems: 2, animBeginArr: this.animBeginArr, dur: Y, shouldSetPrevPaths: !0 });
    }
    return { g: l, elHollow: g, dataLabels: x };
  } }, { key: "drawHollow", value: function(i) {
    var r = new $(this.ctx).drawCircle(2 * i.size);
    return r.attr({ class: "apexcharts-radialbar-hollow", cx: i.centerX, cy: i.centerY, r: i.size, fill: i.fill }), r;
  } }, { key: "drawHollowImage", value: function(i, r, a, n) {
    var o = this.w, l = new gt(this.ctx), c = F.randomId(), h = o.config.plotOptions.radialBar.hollow.image;
    if (o.config.plotOptions.radialBar.hollow.imageClipped) l.clippedImgArea({ width: a, height: a, image: h, patternID: "pattern".concat(o.globals.cuid).concat(c) }), n = "url(#pattern".concat(o.globals.cuid).concat(c, ")");
    else {
      var d = o.config.plotOptions.radialBar.hollow.imageWidth, u = o.config.plotOptions.radialBar.hollow.imageHeight;
      if (d === void 0 && u === void 0) {
        var g = o.globals.dom.Paper.image(h, function(f) {
          this.move(i.centerX - f.width / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - f.height / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        r.add(g);
      } else {
        var p = o.globals.dom.Paper.image(h, function(f) {
          this.move(i.centerX - d / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - u / 2 + o.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(d, u);
        });
        r.add(p);
      }
    }
    return n;
  } }, { key: "getStrokeWidth", value: function(i) {
    var r = this.w;
    return i.size * (100 - parseInt(r.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin;
  } }, { key: "onBarLabelClick", value: function(i) {
    var r = parseInt(i.target.getAttribute("rel"), 10) - 1, a = this.barLabels.onClick, n = this.w;
    a && a(n.globals.seriesNames[r], { w: n, seriesIndex: r });
  } }]), t;
}(), kd = function(s) {
  Li(t, Qt);
  var e = Pi(t);
  function t() {
    return te(this, t), e.apply(this, arguments);
  }
  return ie(t, [{ key: "draw", value: function(i, r) {
    var a = this.w, n = new $(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = a.globals.seriesRangeStart, this.seriesRangeEnd = a.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
    for (var o = n.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), l = 0; l < i.length; l++) {
      var c, h, d, u, g = void 0, p = void 0, f = a.globals.comboCharts ? r[l] : l, x = this.barHelpers.getGroupIndex(f).columnGroupIndex, m = n.group({ class: "apexcharts-series", seriesName: F.escapeString(a.globals.seriesNames[f]), rel: l + 1, "data:realIndex": f });
      this.ctx.series.addCollapsedClassToSeries(m, f), i[l].length > 0 && (this.visibleI = this.visibleI + 1);
      var b = 0, w = 0, y = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = a.globals.seriesYAxisReverseMap[f][0], y = f);
      var v = this.barHelpers.initialPositions(f);
      p = v.y, u = v.zeroW, g = v.x, w = v.barWidth, b = v.barHeight, c = v.xDivision, h = v.yDivision, d = v.zeroH;
      for (var k = n.group({ class: "apexcharts-datalabels", "data:realIndex": f }), S = n.group({ class: "apexcharts-rangebar-goals-markers" }), C = 0; C < a.globals.dataPoints; C++) {
        var M = this.barHelpers.getStrokeWidth(l, C, f), R = this.seriesRangeStart[l][C], P = this.seriesRangeEnd[l][C], I = null, D = null, N = null, z = { x: g, y: p, strokeWidth: M, elSeries: m }, L = this.seriesLen;
        if (a.config.plotOptions.bar.rangeBarGroupRows && (L = 1), a.config.series[l].data[C] === void 0) break;
        if (this.isHorizontal) {
          N = p + b * this.visibleI;
          var T = (h - b * L) / 2;
          if (a.config.series[l].data[C].x) {
            var H = this.detectOverlappingBars({ i: l, j: C, barYPosition: N, srty: T, barHeight: b, yDivision: h, initPositions: v });
            b = H.barHeight, N = H.barYPosition;
          }
          w = (I = this.drawRangeBarPaths(J({ indexes: { i: l, j: C, realIndex: f }, barHeight: b, barYPosition: N, zeroW: u, yDivision: h, y1: R, y2: P }, z))).barWidth;
        } else {
          a.globals.isXNumeric && (g = (a.globals.seriesX[l][C] - a.globals.minX) / this.xRatio - w / 2), D = g + w * this.visibleI;
          var B = (c - w * L) / 2;
          if (a.config.series[l].data[C].x) {
            var _ = this.detectOverlappingBars({ i: l, j: C, barXPosition: D, srtx: B, barWidth: w, xDivision: c, initPositions: v });
            w = _.barWidth, D = _.barXPosition;
          }
          b = (I = this.drawRangeColumnPaths(J({ indexes: { i: l, j: C, realIndex: f, translationsIndex: y }, barWidth: w, barXPosition: D, zeroH: d, xDivision: c }, z))).barHeight;
        }
        var O = this.barHelpers.drawGoalLine({ barXPosition: I.barXPosition, barYPosition: N, goalX: I.goalX, goalY: I.goalY, barHeight: b, barWidth: w });
        O && S.add(O), p = I.y, g = I.x;
        var Y = this.barHelpers.getPathFillColor(i, l, C, f);
        this.renderSeries({ realIndex: f, pathFill: Y.color, lineFill: Y.useRangeColor ? Y.color : a.globals.stroke.colors[f], j: C, i: l, x: g, y: p, y1: R, y2: P, pathFrom: I.pathFrom, pathTo: I.pathTo, strokeWidth: M, elSeries: m, series: i, barHeight: b, barWidth: w, barXPosition: D, barYPosition: N, columnGroupIndex: x, elDataLabelsWrap: k, elGoalsMarkers: S, visibleSeries: this.visibleI, type: "rangebar" });
      }
      o.add(m);
    }
    return o;
  } }, { key: "detectOverlappingBars", value: function(i) {
    var r = i.i, a = i.j, n = i.barYPosition, o = i.barXPosition, l = i.srty, c = i.srtx, h = i.barHeight, d = i.barWidth, u = i.yDivision, g = i.xDivision, p = i.initPositions, f = this.w, x = [], m = f.config.series[r].data[a].rangeName, b = f.config.series[r].data[a].x, w = Array.isArray(b) ? b.join(" ") : b, y = f.globals.labels.map(function(k) {
      return Array.isArray(k) ? k.join(" ") : k;
    }).indexOf(w), v = f.globals.seriesRange[r].findIndex(function(k) {
      return k.x === w && k.overlaps.length > 0;
    });
    return this.isHorizontal ? (n = f.config.plotOptions.bar.rangeBarGroupRows ? l + u * y : l + h * this.visibleI + u * y, v > -1 && !f.config.plotOptions.bar.rangeBarOverlap && (x = f.globals.seriesRange[r][v].overlaps).indexOf(m) > -1 && (n = (h = p.barHeight / x.length) * this.visibleI + u * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + h * (this.visibleI + x.indexOf(m)) + u * y)) : (y > -1 && !f.globals.timescaleLabels.length && (o = f.config.plotOptions.bar.rangeBarGroupRows ? c + g * y : c + d * this.visibleI + g * y), v > -1 && !f.config.plotOptions.bar.rangeBarOverlap && (x = f.globals.seriesRange[r][v].overlaps).indexOf(m) > -1 && (o = (d = p.barWidth / x.length) * this.visibleI + g * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + d * (this.visibleI + x.indexOf(m)) + g * y)), { barYPosition: n, barXPosition: o, barHeight: h, barWidth: d };
  } }, { key: "drawRangeColumnPaths", value: function(i) {
    var r = i.indexes, a = i.x, n = i.xDivision, o = i.barWidth, l = i.barXPosition, c = i.zeroH, h = this.w, d = r.i, u = r.j, g = r.realIndex, p = r.translationsIndex, f = this.yRatio[p], x = this.getRangeValue(g, u), m = Math.min(x.start, x.end), b = Math.max(x.start, x.end);
    this.series[d][u] === void 0 || this.series[d][u] === null ? m = c : (m = c - m / f, b = c - b / f);
    var w = Math.abs(b - m), y = this.barHelpers.getColumnPaths({ barXPosition: l, barWidth: o, y1: m, y2: b, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: g, i: g, j: u, w: h });
    if (h.globals.isXNumeric) {
      var v = this.getBarXForNumericXAxis({ x: a, j: u, realIndex: g, barWidth: o });
      a = v.x, l = v.barXPosition;
    } else a += n;
    return { pathTo: y.pathTo, pathFrom: y.pathFrom, barHeight: w, x: a, y: x.start < 0 && x.end < 0 ? m : b, goalY: this.barHelpers.getGoalValues("y", null, c, d, u, p), barXPosition: l };
  } }, { key: "preventBarOverflow", value: function(i) {
    var r = this.w;
    return i < 0 && (i = 0), i > r.globals.gridWidth && (i = r.globals.gridWidth), i;
  } }, { key: "drawRangeBarPaths", value: function(i) {
    var r = i.indexes, a = i.y, n = i.y1, o = i.y2, l = i.yDivision, c = i.barHeight, h = i.barYPosition, d = i.zeroW, u = this.w, g = r.realIndex, p = r.j, f = this.preventBarOverflow(d + n / this.invertedYRatio), x = this.preventBarOverflow(d + o / this.invertedYRatio), m = this.getRangeValue(g, p), b = Math.abs(x - f), w = this.barHelpers.getBarpaths({ barYPosition: h, barHeight: c, x1: f, x2: x, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: g, realIndex: g, j: p, w: u });
    return u.globals.isXNumeric || (a += l), { pathTo: w.pathTo, pathFrom: w.pathFrom, barWidth: b, x: m.start < 0 && m.end < 0 ? f : x, goalX: this.barHelpers.getGoalValues("x", d, null, g, p), y: a };
  } }, { key: "getRangeValue", value: function(i, r) {
    var a = this.w;
    return { start: a.globals.seriesRangeStart[i][r], end: a.globals.seriesRangeEnd[i][r] };
  } }]), t;
}(), Sd = function() {
  function s(e) {
    te(this, s), this.w = e.w, this.lineCtx = e;
  }
  return ie(s, [{ key: "sameValueSeriesFix", value: function(e, t) {
    var i = this.w;
    if ((i.config.fill.type === "gradient" || i.config.fill.type[e] === "gradient") && new ze(this.lineCtx.ctx, i).seriesHaveSameValues(e)) {
      var r = t[e].slice();
      r[r.length - 1] = r[r.length - 1] + 1e-6, t[e] = r;
    }
    return t;
  } }, { key: "calculatePoints", value: function(e) {
    var t = e.series, i = e.realIndex, r = e.x, a = e.y, n = e.i, o = e.j, l = e.prevY, c = this.w, h = [], d = [], u = this.lineCtx.categoryAxisCorrection + c.config.markers.offsetX;
    return c.globals.isXNumeric && (u = (c.globals.seriesX[i][0] - c.globals.minX) / this.lineCtx.xRatio + c.config.markers.offsetX), o === 0 && (h.push(u), d.push(F.isNumber(t[n][0]) ? l + c.config.markers.offsetY : null)), h.push(r + c.config.markers.offsetX), d.push(F.isNumber(t[n][o + 1]) ? a + c.config.markers.offsetY : null), { x: h, y: d };
  } }, { key: "checkPreviousPaths", value: function(e) {
    for (var t = e.pathFromLine, i = e.pathFromArea, r = e.realIndex, a = this.w, n = 0; n < a.globals.previousPaths.length; n++) {
      var o = a.globals.previousPaths[n];
      (o.type === "line" || o.type === "area") && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(r, 10) && (o.type === "line" ? (this.lineCtx.appendPathFrom = !1, t = a.globals.previousPaths[n].paths[0].d) : o.type === "area" && (this.lineCtx.appendPathFrom = !1, i = a.globals.previousPaths[n].paths[0].d, a.config.stroke.show && a.globals.previousPaths[n].paths[1] && (t = a.globals.previousPaths[n].paths[1].d)));
    }
    return { pathFromLine: t, pathFromArea: i };
  } }, { key: "determineFirstPrevY", value: function(e) {
    var t, i, r, a = e.i, n = e.realIndex, o = e.series, l = e.prevY, c = e.lineYPosition, h = e.translationsIndex, d = this.w, u = d.config.chart.stacked && !d.globals.comboCharts || d.config.chart.stacked && d.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t = this.w.config.series[n]) === null || t === void 0 ? void 0 : t.type) === "bar" || ((i = this.w.config.series[n]) === null || i === void 0 ? void 0 : i.type) === "column");
    if (((r = o[a]) === null || r === void 0 ? void 0 : r[0]) !== void 0) l = (c = u && a > 0 ? this.lineCtx.prevSeriesY[a - 1][0] : this.lineCtx.zeroY) - o[a][0] / this.lineCtx.yRatio[h] + 2 * (this.lineCtx.isReversed ? o[a][0] / this.lineCtx.yRatio[h] : 0);
    else if (u && a > 0 && o[a][0] === void 0) {
      for (var g = a - 1; g >= 0; g--) if (o[g][0] !== null && o[g][0] !== void 0) {
        l = c = this.lineCtx.prevSeriesY[g][0];
        break;
      }
    }
    return { prevY: l, lineYPosition: c };
  } }]), s;
}(), Cd = function(s) {
  for (var e, t, i, r, a = function(h) {
    for (var d = [], u = h[0], g = h[1], p = d[0] = _r(u, g), f = 1, x = h.length - 1; f < x; f++) u = g, g = h[f + 1], d[f] = 0.5 * (p + (p = _r(u, g)));
    return d[f] = p, d;
  }(s), n = s.length - 1, o = [], l = 0; l < n; l++) i = _r(s[l], s[l + 1]), Math.abs(i) < 1e-6 ? a[l] = a[l + 1] = 0 : (r = (e = a[l] / i) * e + (t = a[l + 1] / i) * t) > 9 && (r = 3 * i / Math.sqrt(r), a[l] = r * e, a[l + 1] = r * t);
  for (var c = 0; c <= n; c++) r = (s[Math.min(n, c + 1)][0] - s[Math.max(0, c - 1)][0]) / (6 * (1 + a[c] * a[c])), o.push([r || 0, a[c] * r || 0]);
  return o;
}, Ad = function(s) {
  var e = Cd(s), t = s[1], i = s[0], r = [], a = e[1], n = e[0];
  r.push(i, [i[0] + n[0], i[1] + n[1], t[0] - a[0], t[1] - a[1], t[0], t[1]]);
  for (var o = 2, l = e.length; o < l; o++) {
    var c = s[o], h = e[o];
    r.push([c[0] - h[0], c[1] - h[1], c[0], c[1]]);
  }
  return r;
}, Md = function(s, e, t) {
  var i = s.slice(e, t);
  if (e) {
    if (t - e > 1 && i[1].length < 6) {
      var r = i[0].length;
      i[1] = [2 * i[0][r - 2] - i[0][r - 4], 2 * i[0][r - 1] - i[0][r - 3]].concat(i[1]);
    }
    i[0] = i[0].slice(-2);
  }
  return i;
};
function _r(s, e) {
  return (e[1] - s[1]) / (e[0] - s[0]);
}
var Or = function() {
  function s(e, t, i) {
    te(this, s), this.ctx = e, this.w = e.w, this.xyRatios = t, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new Mo(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Sd(this), this.markers = new ni(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return ie(s, [{ key: "draw", value: function(e, t, i, r) {
    var a, n = this.w, o = new $(this.ctx), l = n.globals.comboCharts ? t : n.config.chart.type, c = o.group({ class: "apexcharts-".concat(l, "-series apexcharts-plot-series") }), h = new ze(this.ctx, n);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, e = h.getLogSeries(e), this.yRatio = h.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var d = [], u = 0; u < e.length; u++) {
      e = this.lineHelpers.sameValueSeriesFix(u, e);
      var g = n.globals.comboCharts ? i[u] : u, p = this.yRatio.length > 1 ? g : 0;
      this._initSerieVariables(e, u, g);
      var f = [], x = [], m = [], b = n.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, g), n.globals.isXNumeric && n.globals.seriesX.length > 0 && (b = (n.globals.seriesX[g][0] - n.globals.minX) / this.xRatio), m.push(b);
      var w, y = b, v = void 0, k = y, S = this.zeroY, C = this.zeroY;
      S = this.lineHelpers.determineFirstPrevY({ i: u, realIndex: g, series: e, prevY: S, lineYPosition: 0, translationsIndex: p }).prevY, n.config.stroke.curve === "monotoneCubic" && e[u][0] === null ? f.push(null) : f.push(S), w = S, l === "rangeArea" && (v = C = this.lineHelpers.determineFirstPrevY({ i: u, realIndex: g, series: r, prevY: C, lineYPosition: 0, translationsIndex: p }).prevY, x.push(f[0] !== null ? C : null));
      var M = this._calculatePathsFrom({ type: l, series: e, i: u, realIndex: g, translationsIndex: p, prevX: k, prevY: S, prevY2: C }), R = [f[0]], P = [x[0]], I = { type: l, series: e, realIndex: g, translationsIndex: p, i: u, x: b, y: 1, pX: y, pY: w, pathsFrom: M, linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: m, yArrj: f, y2Arrj: x, seriesRangeEnd: r }, D = this._iterateOverDataPoints(J(J({}, I), {}, { iterations: l === "rangeArea" ? e[u].length - 1 : void 0, isRangeStart: !0 }));
      if (l === "rangeArea") {
        for (var N = this._calculatePathsFrom({ series: r, i: u, realIndex: g, prevX: k, prevY: C }), z = this._iterateOverDataPoints(J(J({}, I), {}, { series: r, xArrj: [b], yArrj: R, y2Arrj: P, pY: v, areaPaths: D.areaPaths, pathsFrom: N, iterations: r[u].length - 1, isRangeStart: !1 })), L = D.linePaths.length / 2, T = 0; T < L; T++) D.linePaths[T] = z.linePaths[T + L] + D.linePaths[T];
        D.linePaths.splice(L), D.pathFromLine = z.pathFromLine + D.pathFromLine;
      } else D.pathFromArea += "z";
      this._handlePaths({ type: l, realIndex: g, i: u, paths: D }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), d.push(this.elSeries);
    }
    if (((a = n.config.series[0]) === null || a === void 0 ? void 0 : a.zIndex) !== void 0 && d.sort(function(_, O) {
      return Number(_.node.getAttribute("zIndex")) - Number(O.node.getAttribute("zIndex"));
    }), n.config.chart.stacked) for (var H = d.length - 1; H >= 0; H--) c.add(d[H]);
    else for (var B = 0; B < d.length; B++) c.add(d[B]);
    return c;
  } }, { key: "_initSerieVariables", value: function(e, t, i) {
    var r = this.w, a = new $(this.ctx);
    this.xDivision = r.globals.gridWidth / (r.globals.dataPoints - (r.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[i] : r.config.stroke.width;
    var n = 0;
    if (this.yRatio.length > 1 && (this.yaxisIndex = r.globals.seriesYAxisReverseMap[i], n = i), this.isReversed = r.config.yaxis[this.yaxisIndex] && r.config.yaxis[this.yaxisIndex].reversed, this.zeroY = r.globals.gridHeight - this.baseLineY[n] - (this.isReversed ? r.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[n] : 0), this.areaBottomY = this.zeroY, (this.zeroY > r.globals.gridHeight || r.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = r.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = a.group({ class: "apexcharts-series", zIndex: r.config.series[i].zIndex !== void 0 ? r.config.series[i].zIndex : i, seriesName: F.escapeString(r.globals.seriesNames[i]) }), this.elPointsMain = a.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), r.globals.hasNullValues) {
      var o = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [r.globals.gridHeight + r.globals.markers.largestSize] }, seriesIndex: t, j: 0, pSize: 0.1, alwaysDrawMarker: !0, isVirtualPoint: !0 });
      o !== null && this.elPointsMain.add(o);
    }
    this.elDataLabelsWrap = a.group({ class: "apexcharts-datalabels", "data:realIndex": i });
    var l = e[t].length === r.globals.dataPoints;
    this.elSeries.attr({ "data:longestSeries": l, rel: t + 1, "data:realIndex": i }), this.appendPathFrom = !0;
  } }, { key: "_calculatePathsFrom", value: function(e) {
    var t, i, r, a, n = e.type, o = e.series, l = e.i, c = e.realIndex, h = e.translationsIndex, d = e.prevX, u = e.prevY, g = e.prevY2, p = this.w, f = new $(this.ctx);
    if (o[l][0] === null) {
      for (var x = 0; x < o[l].length; x++) if (o[l][x] !== null) {
        d = this.xDivision * x, u = this.zeroY - o[l][x] / this.yRatio[h], t = f.move(d, u), i = f.move(d, this.areaBottomY);
        break;
      }
    } else t = f.move(d, u), n === "rangeArea" && (t = f.move(d, g) + f.line(d, u)), i = f.move(d, this.areaBottomY) + f.line(d, u);
    if (r = f.move(0, this.areaBottomY) + f.line(0, this.areaBottomY), a = f.move(0, this.areaBottomY) + f.line(0, this.areaBottomY), p.globals.previousPaths.length > 0) {
      var m = this.lineHelpers.checkPreviousPaths({ pathFromLine: r, pathFromArea: a, realIndex: c });
      r = m.pathFromLine, a = m.pathFromArea;
    }
    return { prevX: d, prevY: u, linePath: t, areaPath: i, pathFromLine: r, pathFromArea: a };
  } }, { key: "_handlePaths", value: function(e) {
    var t = e.type, i = e.realIndex, r = e.i, a = e.paths, n = this.w, o = new $(this.ctx), l = new gt(this.ctx);
    this.prevSeriesY.push(a.yArrj), n.globals.seriesXvalues[i] = a.xArrj, n.globals.seriesYvalues[i] = a.yArrj;
    var c = n.config.forecastDataPoints;
    if (c.count > 0 && t !== "rangeArea") {
      var h = n.globals.seriesXvalues[i][n.globals.seriesXvalues[i].length - c.count - 1], d = o.drawRect(h, 0, n.globals.gridWidth, n.globals.gridHeight, 0);
      n.globals.dom.elForecastMask.appendChild(d.node);
      var u = o.drawRect(0, 0, h, n.globals.gridHeight, 0);
      n.globals.dom.elNonForecastMask.appendChild(u.node);
    }
    this.pointsChart || n.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
    var g = { i: r, realIndex: i, animationDelay: r, initialSpeed: n.config.chart.animations.speed, dataChangeSpeed: n.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(t) };
    if (t === "area") for (var p = l.fillPath({ seriesNumber: i }), f = 0; f < a.areaPaths.length; f++) {
      var x = o.renderPaths(J(J({}, g), {}, { pathFrom: a.pathFromArea, pathTo: a.areaPaths[f], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p }));
      this.elSeries.add(x);
    }
    if (n.config.stroke.show && !this.pointsChart) {
      var m = null;
      if (t === "line") m = l.fillPath({ seriesNumber: i, i: r });
      else if (n.config.stroke.fill.type === "solid") m = n.globals.stroke.colors[i];
      else {
        var b = n.config.fill;
        n.config.fill = n.config.stroke.fill, m = l.fillPath({ seriesNumber: i, i: r }), n.config.fill = b;
      }
      for (var w = 0; w < a.linePaths.length; w++) {
        var y = m;
        t === "rangeArea" && (y = l.fillPath({ seriesNumber: i }));
        var v = J(J({}, g), {}, { pathFrom: a.pathFromLine, pathTo: a.linePaths[w], stroke: m, strokeWidth: this.strokeWidth, strokeLineCap: n.config.stroke.lineCap, fill: t === "rangeArea" ? y : "none" }), k = o.renderPaths(v);
        if (this.elSeries.add(k), k.attr("fill-rule", "evenodd"), c.count > 0 && t !== "rangeArea") {
          var S = o.renderPaths(v);
          S.node.setAttribute("stroke-dasharray", c.dashArray), c.strokeWidth && S.node.setAttribute("stroke-width", c.strokeWidth), this.elSeries.add(S), S.attr("clip-path", "url(#forecastMask".concat(n.globals.cuid, ")")), k.attr("clip-path", "url(#nonForecastMask".concat(n.globals.cuid, ")"));
        }
      }
    }
  } }, { key: "_iterateOverDataPoints", value: function(e) {
    var t, i, r = this, a = e.type, n = e.series, o = e.iterations, l = e.realIndex, c = e.translationsIndex, h = e.i, d = e.x, u = e.y, g = e.pX, p = e.pY, f = e.pathsFrom, x = e.linePaths, m = e.areaPaths, b = e.seriesIndex, w = e.lineYPosition, y = e.xArrj, v = e.yArrj, k = e.y2Arrj, S = e.isRangeStart, C = e.seriesRangeEnd, M = this.w, R = new $(this.ctx), P = this.yRatio, I = f.prevY, D = f.linePath, N = f.areaPath, z = f.pathFromLine, L = f.pathFromArea, T = F.isNumber(M.globals.minYArr[l]) ? M.globals.minYArr[l] : M.globals.minY;
    o || (o = M.globals.dataPoints > 1 ? M.globals.dataPoints - 1 : M.globals.dataPoints);
    var H = function(re, ee) {
      return ee - re / P[c] + 2 * (r.isReversed ? re / P[c] : 0);
    }, B = u, _ = M.config.chart.stacked && !M.globals.comboCharts || M.config.chart.stacked && M.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((t = this.w.config.series[l]) === null || t === void 0 ? void 0 : t.type) === "bar" || ((i = this.w.config.series[l]) === null || i === void 0 ? void 0 : i.type) === "column"), O = M.config.stroke.curve;
    Array.isArray(O) && (O = Array.isArray(b) ? O[b[h]] : O[h]);
    for (var Y, X = 0, V = 0; V < o && n[h].length !== 0; V++) {
      var W = n[h][V + 1] === void 0 || n[h][V + 1] === null;
      if (M.globals.isXNumeric) {
        var G = M.globals.seriesX[l][V + 1];
        M.globals.seriesX[l][V + 1] === void 0 && (G = M.globals.seriesX[l][o - 1]), d = (G - M.globals.minX) / this.xRatio;
      } else d += this.xDivision;
      _ ? h > 0 && M.globals.collapsedSeries.length < M.config.series.length - 1 ? w = this.prevSeriesY[function(re) {
        for (var ee = re; ee > 0; ee--) {
          if (!(M.globals.collapsedSeriesIndices.indexOf((b == null ? void 0 : b[ee]) || ee) > -1)) return ee;
          ee--;
        }
        return 0;
      }(h - 1)][V + 1] : w = this.zeroY : w = this.zeroY, W ? u = H(T, w) : (u = H(n[h][V + 1], w), a === "rangeArea" && (B = H(C[h][V + 1], w))), y.push(n[h][V + 1] === null ? null : d), !W || M.config.stroke.curve !== "smooth" && M.config.stroke.curve !== "monotoneCubic" ? (v.push(u), k.push(B)) : (v.push(null), k.push(null));
      var U = this.lineHelpers.calculatePoints({ series: n, x: d, y: u, realIndex: l, i: h, j: V, prevY: I }), Z = this._createPaths({ type: a, series: n, i: h, realIndex: l, j: V, x: d, y: u, y2: B, xArrj: y, yArrj: v, y2Arrj: k, pX: g, pY: p, pathState: X, segmentStartX: Y, linePath: D, areaPath: N, linePaths: x, areaPaths: m, curve: O, isRangeStart: S });
      m = Z.areaPaths, x = Z.linePaths, g = Z.pX, p = Z.pY, X = Z.pathState, Y = Z.segmentStartX, N = Z.areaPath, D = Z.linePath, !this.appendPathFrom || M.globals.hasNullValues || O === "monotoneCubic" && a === "rangeArea" || (z += R.line(d, this.areaBottomY), L += R.line(d, this.areaBottomY)), this.handleNullDataPoints(n, U, h, V, l), this._handleMarkersAndLabels({ type: a, pointsPos: U, i: h, j: V, realIndex: l, isRangeStart: S });
    }
    return { yArrj: v, xArrj: y, pathFromArea: L, areaPaths: m, pathFromLine: z, linePaths: x, linePath: D, areaPath: N };
  } }, { key: "_handleMarkersAndLabels", value: function(e) {
    var t = e.type, i = e.pointsPos, r = e.isRangeStart, a = e.i, n = e.j, o = e.realIndex, l = this.w, c = new Jt(this.ctx);
    if (this.pointsChart) this.scatter.draw(this.elSeries, n, { realIndex: o, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      l.globals.series[a].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      var h = this.markers.plotChartMarkers({ pointsPos: i, seriesIndex: o, j: n + 1 });
      h !== null && this.elPointsMain.add(h);
    }
    var d = c.drawDataLabel({ type: t, isRangeStart: r, pos: i, i: o, j: n + 1 });
    d !== null && this.elDataLabelsWrap.add(d);
  } }, { key: "_createPaths", value: function(e) {
    var t = e.type, i = e.series, r = e.i;
    e.realIndex;
    var a, n = e.j, o = e.x, l = e.y, c = e.xArrj, h = e.yArrj, d = e.y2, u = e.y2Arrj, g = e.pX, p = e.pY, f = e.pathState, x = e.segmentStartX, m = e.linePath, b = e.areaPath, w = e.linePaths, y = e.areaPaths, v = e.curve, k = e.isRangeStart, S = new $(this.ctx), C = this.areaBottomY, M = t === "rangeArea", R = t === "rangeArea" && k;
    switch (v) {
      case "monotoneCubic":
        var P = k ? h : u;
        switch (f) {
          case 0:
            if (P[n + 1] === null) break;
            f = 1;
          case 1:
            if (!(M ? c.length === i[r].length : n === i[r].length - 2)) break;
          case 2:
            var I = k ? c : c.slice().reverse(), D = k ? P : P.slice().reverse(), N = (a = D, I.map(function(G, U) {
              return [G, a[U]];
            }).filter(function(G) {
              return G[1] !== null;
            })), z = N.length > 1 ? Ad(N) : N, L = [];
            M && (R ? y = N : L = y.reverse());
            var T = 0, H = 0;
            if (function(G, U) {
              for (var Z = function(q) {
                var ne = [], _e = 0;
                return q.forEach(function(Be) {
                  Be !== null ? _e++ : _e > 0 && (ne.push(_e), _e = 0);
                }), _e > 0 && ne.push(_e), ne;
              }(G), re = [], ee = 0, de = 0; ee < Z.length; de += Z[ee++]) re[ee] = Md(U, de, de + Z[ee]);
              return re;
            }(D, z).forEach(function(G) {
              T++;
              var U = function(ee) {
                for (var de = "", q = 0; q < ee.length; q++) {
                  var ne = ee[q], _e = ne.length;
                  _e > 4 ? (de += "C".concat(ne[0], ", ").concat(ne[1]), de += ", ".concat(ne[2], ", ").concat(ne[3]), de += ", ".concat(ne[4], ", ").concat(ne[5])) : _e > 2 && (de += "S".concat(ne[0], ", ").concat(ne[1]), de += ", ".concat(ne[2], ", ").concat(ne[3]));
                }
                return de;
              }(G), Z = H, re = (H += G.length) - 1;
              R ? m = S.move(N[Z][0], N[Z][1]) + U : M ? m = S.move(L[Z][0], L[Z][1]) + S.line(N[Z][0], N[Z][1]) + U + S.line(L[re][0], L[re][1]) : (m = S.move(N[Z][0], N[Z][1]) + U, b = m + S.line(N[re][0], C) + S.line(N[Z][0], C) + "z", y.push(b)), w.push(m);
            }), M && T > 1 && !R) {
              var B = w.slice(T).reverse();
              w.splice(T), B.forEach(function(G) {
                return w.push(G);
              });
            }
            f = 0;
        }
        break;
      case "smooth":
        var _ = 0.35 * (o - g);
        if (i[r][n] === null) f = 0;
        else switch (f) {
          case 0:
            if (x = g, m = R ? S.move(g, u[n]) + S.line(g, p) : S.move(g, p), b = S.move(g, p), i[r][n + 1] === null || i[r][n + 1] === void 0) {
              w.push(m), y.push(b);
              break;
            }
            if (f = 1, n < i[r].length - 2) {
              var O = S.curve(g + _, p, o - _, l, o, l);
              m += O, b += O;
              break;
            }
          case 1:
            if (i[r][n + 1] === null) m += R ? S.line(g, d) : S.move(g, p), b += S.line(g, C) + S.line(x, C) + "z", w.push(m), y.push(b), f = -1;
            else {
              var Y = S.curve(g + _, p, o - _, l, o, l);
              m += Y, b += Y, n >= i[r].length - 2 && (R && (m += S.curve(o, l, o, l, o, d) + S.move(o, d)), b += S.curve(o, l, o, l, o, C) + S.line(x, C) + "z", w.push(m), y.push(b), f = -1);
            }
        }
        g = o, p = l;
        break;
      default:
        var X = function(G, U, Z) {
          var re = [];
          switch (G) {
            case "stepline":
              re = S.line(U, null, "H") + S.line(null, Z, "V");
              break;
            case "linestep":
              re = S.line(null, Z, "V") + S.line(U, null, "H");
              break;
            case "straight":
              re = S.line(U, Z);
          }
          return re;
        };
        if (i[r][n] === null) f = 0;
        else switch (f) {
          case 0:
            if (x = g, m = R ? S.move(g, u[n]) + S.line(g, p) : S.move(g, p), b = S.move(g, p), i[r][n + 1] === null || i[r][n + 1] === void 0) {
              w.push(m), y.push(b);
              break;
            }
            if (f = 1, n < i[r].length - 2) {
              var V = X(v, o, l);
              m += V, b += V;
              break;
            }
          case 1:
            if (i[r][n + 1] === null) m += R ? S.line(g, d) : S.move(g, p), b += S.line(g, C) + S.line(x, C) + "z", w.push(m), y.push(b), f = -1;
            else {
              var W = X(v, o, l);
              m += W, b += W, n >= i[r].length - 2 && (R && (m += S.line(o, d)), b += S.line(o, C) + S.line(x, C) + "z", w.push(m), y.push(b), f = -1);
            }
        }
        g = o, p = l;
    }
    return { linePaths: w, areaPaths: y, pX: g, pY: p, pathState: f, segmentStartX: x, linePath: m, areaPath: b };
  } }, { key: "handleNullDataPoints", value: function(e, t, i, r, a) {
    var n = this.w;
    if (e[i][r] === null && n.config.markers.showNullDataPoints || e[i].length === 1) {
      var o = this.strokeWidth - n.config.markers.strokeWidth / 2;
      o > 0 || (o = 0);
      var l = this.markers.plotChartMarkers({ pointsPos: t, seriesIndex: a, j: r + 1, pSize: o, alwaysDrawMarker: !0 });
      l !== null && this.elPointsMain.add(l);
    }
  } }]), s;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = /* @__PURE__ */ function() {
  function s(o, l, c, h) {
    this.xoffset = o, this.yoffset = l, this.height = h, this.width = c, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(d) {
      var u, g = [], p = this.xoffset, f = this.yoffset, x = a(d) / this.height, m = a(d) / this.width;
      if (this.width >= this.height) for (u = 0; u < d.length; u++) g.push([p, f, p + x, f + d[u] / x]), f += d[u] / x;
      else for (u = 0; u < d.length; u++) g.push([p, f, p + d[u] / m, f + m]), p += d[u] / m;
      return g;
    }, this.cutArea = function(d) {
      var u;
      if (this.width >= this.height) {
        var g = d / this.height, p = this.width - g;
        u = new s(this.xoffset + g, this.yoffset, p, this.height);
      } else {
        var f = d / this.width, x = this.height - f;
        u = new s(this.xoffset, this.yoffset + f, this.width, x);
      }
      return u;
    };
  }
  function e(o, l, c, h, d) {
    h = h === void 0 ? 0 : h, d = d === void 0 ? 0 : d;
    var u = t(function(g, p) {
      var f, x = [], m = p / a(g);
      for (f = 0; f < g.length; f++) x[f] = g[f] * m;
      return x;
    }(o, l * c), [], new s(h, d, l, c), []);
    return function(g) {
      var p, f, x = [];
      for (p = 0; p < g.length; p++) for (f = 0; f < g[p].length; f++) x.push(g[p][f]);
      return x;
    }(u);
  }
  function t(o, l, c, h) {
    var d, u, g;
    if (o.length !== 0) return d = c.shortestEdge(), function(p, f, x) {
      var m;
      if (p.length === 0) return !0;
      (m = p.slice()).push(f);
      var b = i(p, x), w = i(m, x);
      return b >= w;
    }(l, u = o[0], d) ? (l.push(u), t(o.slice(1), l, c, h)) : (g = c.cutArea(a(l), h), h.push(c.getCoordinates(l)), t(o, [], g, h)), h;
    h.push(c.getCoordinates(l));
  }
  function i(o, l) {
    var c = Math.min.apply(Math, o), h = Math.max.apply(Math, o), d = a(o);
    return Math.max(Math.pow(l, 2) * h / Math.pow(d, 2), Math.pow(d, 2) / (Math.pow(l, 2) * c));
  }
  function r(o) {
    return o && o.constructor === Array;
  }
  function a(o) {
    var l, c = 0;
    for (l = 0; l < o.length; l++) c += o[l];
    return c;
  }
  function n(o) {
    var l, c = 0;
    if (r(o[0])) for (l = 0; l < o.length; l++) c += n(o[l]);
    else c = a(o);
    return c;
  }
  return function o(l, c, h, d, u) {
    d = d === void 0 ? 0 : d, u = u === void 0 ? 0 : u;
    var g, p, f = [], x = [];
    if (r(l[0])) {
      for (p = 0; p < l.length; p++) f[p] = n(l[p]);
      for (g = e(f, c, h, d, u), p = 0; p < l.length; p++) x.push(o(l[p], g[p][2] - g[p][0], g[p][3] - g[p][1], g[p][0], g[p][1]));
    } else x = e(l, c, h, d, u);
    return x;
  };
}();
var Rd = function() {
  function s(e, t) {
    te(this, s), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new _o(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return ie(s, [{ key: "draw", value: function(e) {
    var t = this, i = this.w, r = new $(this.ctx), a = new gt(this.ctx), n = r.group({ class: "apexcharts-treemap" });
    if (i.globals.noData) return n;
    var o = [];
    return e.forEach(function(l) {
      var c = l.map(function(h) {
        return Math.abs(h);
      });
      o.push(c);
    }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(l, c) {
      l.data.forEach(function(h) {
        Array.isArray(t.labels[c]) || (t.labels[c] = []), t.labels[c].push(h.x);
      });
    }), window.TreemapSquared.generate(o, i.globals.gridWidth, i.globals.gridHeight).forEach(function(l, c) {
      var h = r.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: F.escapeString(i.globals.seriesNames[c]), rel: c + 1, "data:realIndex": c });
      if (i.config.chart.dropShadow.enabled) {
        var d = i.config.chart.dropShadow;
        new Ye(t.ctx).dropShadow(n, d, c);
      }
      var u = r.group({ class: "apexcharts-data-labels" }), g = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      l.forEach(function(z, L) {
        var T = z[0], H = z[1], B = z[2], _ = z[3];
        g.xMin = Math.min(g.xMin, T), g.yMin = Math.min(g.yMin, H), g.xMax = Math.max(g.xMax, B), g.yMax = Math.max(g.yMax, _);
        var O = t.helpers.getShadeColor(i.config.chart.type, c, L, t.negRange), Y = O.color, X = a.fillPath({ color: Y, seriesNumber: c, dataPointIndex: L }), V = r.drawRect(T, H, B - T, _ - H, i.config.plotOptions.treemap.borderRadius, "#fff", 1, t.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? Y : i.globals.stroke.colors[c]);
        V.attr({ cx: T, cy: H, index: c, i: c, j: L, width: B - T, height: _ - H, fill: X }), V.node.classList.add("apexcharts-treemap-rect"), t.helpers.addListeners(V);
        var W = { x: T + (B - T) / 2, y: H + (_ - H) / 2, width: 0, height: 0 }, G = { x: T, y: H, width: B - T, height: _ - H };
        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
          var U = 1;
          i.globals.resized || (U = i.config.chart.animations.speed), t.animateTreemap(V, W, G, U);
        }
        if (i.globals.dataChanged) {
          var Z = 1;
          t.dynamicAnim.enabled && i.globals.shouldAnimate && (Z = t.dynamicAnim.speed, i.globals.previousPaths[c] && i.globals.previousPaths[c][L] && i.globals.previousPaths[c][L].rect && (W = i.globals.previousPaths[c][L].rect), t.animateTreemap(V, W, G, Z));
        }
        var re = t.getFontSize(z), ee = i.config.dataLabels.formatter(t.labels[c][L], { value: i.globals.series[c][L], seriesIndex: c, dataPointIndex: L, w: i });
        i.config.plotOptions.treemap.dataLabels.format === "truncate" && (re = parseInt(i.config.dataLabels.style.fontSize, 10), ee = t.truncateLabels(ee, re, T, H, B, _));
        var de = null;
        i.globals.series[c][L] && (de = t.helpers.calculateDataLabels({ text: ee, x: (T + B) / 2, y: (H + _) / 2 + t.strokeWidth / 2 + re / 3, i: c, j: L, colorProps: O, fontSize: re, series: e })), i.config.dataLabels.enabled && de && t.rotateToFitLabel(de, re, ee, T, H, B, _), h.add(V), de !== null && h.add(de);
      });
      var p = i.config.plotOptions.treemap.seriesTitle;
      if (i.config.series.length > 1 && p && p.show) {
        var f = i.config.series[c].name || "";
        if (f && g.xMin < 1 / 0 && g.yMin < 1 / 0) {
          var x = p.offsetX, m = p.offsetY, b = p.borderColor, w = p.borderWidth, y = p.borderRadius, v = p.style, k = v.color || i.config.chart.foreColor, S = { left: v.padding.left, right: v.padding.right, top: v.padding.top, bottom: v.padding.bottom }, C = r.getTextRects(f, v.fontSize, v.fontFamily), M = C.width + S.left + S.right, R = C.height + S.top + S.bottom, P = g.xMin + (x || 0), I = g.yMin + (m || 0), D = r.drawRect(P, I, M, R, y, v.background, 1, w, b), N = r.drawText({ x: P + S.left, y: I + S.top + 0.75 * C.height, text: f, fontSize: v.fontSize, fontFamily: v.fontFamily, fontWeight: v.fontWeight, foreColor: k, cssClass: v.cssClass || "" });
          h.add(D), h.add(N);
        }
      }
      h.add(u), n.add(h);
    }), n;
  } }, { key: "getFontSize", value: function(e) {
    var t = this.w, i = function r(a) {
      var n, o = 0;
      if (Array.isArray(a[0])) for (n = 0; n < a.length; n++) o += r(a[n]);
      else for (n = 0; n < a.length; n++) o += a[n].length;
      return o;
    }(this.labels) / function r(a) {
      var n, o = 0;
      if (Array.isArray(a[0])) for (n = 0; n < a.length; n++) o += r(a[n]);
      else for (n = 0; n < a.length; n++) o += 1;
      return o;
    }(this.labels);
    return function(r, a) {
      var n = r * a, o = Math.pow(n, 0.5);
      return Math.min(o / i, parseInt(t.config.dataLabels.style.fontSize, 10));
    }(e[2] - e[0], e[3] - e[1]);
  } }, { key: "rotateToFitLabel", value: function(e, t, i, r, a, n, o) {
    var l = new $(this.ctx), c = l.getTextRects(i, t);
    if (c.width + this.w.config.stroke.width + 5 > n - r && c.width <= o - a) {
      var h = l.rotateAroundCenter(e.node);
      e.node.setAttribute("transform", "rotate(-90 ".concat(h.x, " ").concat(h.y, ") translate(").concat(c.height / 3, ")"));
    }
  } }, { key: "truncateLabels", value: function(e, t, i, r, a, n) {
    var o = new $(this.ctx), l = o.getTextRects(e, t).width + this.w.config.stroke.width + 5 > a - i && n - r > a - i ? n - r : a - i, c = o.getTextBasedOnMaxWidth({ text: e, maxWidth: l, fontSize: t });
    return e.length !== c.length && l / t < 5 ? "" : c;
  } }, { key: "animateTreemap", value: function(e, t, i, r) {
    var a = new ii(this.ctx);
    a.animateRect(e, t, i, r, function() {
      a.animationCompleted(e);
    });
  } }]), s;
}(), Fo = 86400, Pd = 10 / Fo, Ld = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return ie(s, [{ key: "calculateTimeScaleTicks", value: function(e, t) {
    var i = this, r = this.w;
    if (r.globals.allSeriesCollapsed) return r.globals.labels = [], r.globals.timescaleLabels = [], [];
    var a = new je(this.ctx), n = (t - e) / 864e5;
    this.determineInterval(n), r.globals.disableZoomIn = !1, r.globals.disableZoomOut = !1, n < Pd ? r.globals.disableZoomIn = !0 : n > 5e4 && (r.globals.disableZoomOut = !0);
    var o = a.getTimeUnitsfromTimestamp(e, t, this.utc), l = r.globals.gridWidth / n, c = l / 24, h = c / 60, d = h / 60, u = Math.floor(24 * n), g = Math.floor(1440 * n), p = Math.floor(n * Fo), f = Math.floor(n), x = Math.floor(n / 30), m = Math.floor(n / 365), b = { minMillisecond: o.minMillisecond, minSecond: o.minSecond, minMinute: o.minMinute, minHour: o.minHour, minDate: o.minDate, minMonth: o.minMonth, minYear: o.minYear }, w = { firstVal: b, currentMillisecond: b.minMillisecond, currentSecond: b.minSecond, currentMinute: b.minMinute, currentHour: b.minHour, currentMonthDate: b.minDate, currentDate: b.minDate, currentMonth: b.minMonth, currentYear: b.minYear, daysWidthOnXAxis: l, hoursWidthOnXAxis: c, minutesWidthOnXAxis: h, secondsWidthOnXAxis: d, numberOfSeconds: p, numberOfMinutes: g, numberOfHours: u, numberOfDays: f, numberOfMonths: x, numberOfYears: m };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(w);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(w);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(w);
        break;
      case "hours":
        this.generateHourScale(w);
        break;
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(w);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(w);
    }
    var y = this.timeScaleArray.map(function(v) {
      var k = { position: v.position, unit: v.unit, year: v.year, day: v.day ? v.day : 1, hour: v.hour ? v.hour : 0, month: v.month + 1 };
      return v.unit === "month" ? J(J({}, k), {}, { day: 1, value: v.value + 1 }) : v.unit === "day" || v.unit === "hour" ? J(J({}, k), {}, { value: v.value }) : v.unit === "minute" ? J(J({}, k), {}, { value: v.value, minute: v.value }) : v.unit === "second" ? J(J({}, k), {}, { value: v.value, minute: v.minute, second: v.second }) : v;
    });
    return y.filter(function(v) {
      var k = 1, S = Math.ceil(r.globals.gridWidth / 120), C = v.value;
      r.config.xaxis.tickAmount !== void 0 && (S = r.config.xaxis.tickAmount), y.length > S && (k = Math.floor(y.length / S));
      var M = !1, R = !1;
      switch (i.tickInterval) {
        case "years":
          v.unit === "year" && (M = !0);
          break;
        case "half_year":
          k = 7, v.unit === "year" && (M = !0);
          break;
        case "months":
          k = 1, v.unit === "year" && (M = !0);
          break;
        case "months_fortnight":
          k = 15, v.unit !== "year" && v.unit !== "month" || (M = !0), C === 30 && (R = !0);
          break;
        case "months_days":
          k = 10, v.unit === "month" && (M = !0), C === 30 && (R = !0);
          break;
        case "week_days":
          k = 8, v.unit === "month" && (M = !0);
          break;
        case "days":
          k = 1, v.unit === "month" && (M = !0);
          break;
        case "hours":
          v.unit === "day" && (M = !0);
          break;
        case "minutes_fives":
        case "seconds_fives":
          C % 5 != 0 && (R = !0);
          break;
        case "seconds_tens":
          C % 10 != 0 && (R = !0);
      }
      if (i.tickInterval === "hours" || i.tickInterval === "minutes_fives" || i.tickInterval === "seconds_tens" || i.tickInterval === "seconds_fives") {
        if (!R) return !0;
      } else if ((C % k == 0 || M) && !R) return !0;
    });
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(e, t) {
    var i = this.w, r = this.formatDates(e), a = this.removeOverlappingTS(r);
    i.globals.timescaleLabels = a.slice(), new tr(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(e) {
    var t = 24 * e, i = 60 * t;
    switch (!0) {
      case e / 365 > 5:
        this.tickInterval = "years";
        break;
      case e > 800:
        this.tickInterval = "half_year";
        break;
      case e > 180:
        this.tickInterval = "months";
        break;
      case e > 90:
        this.tickInterval = "months_fortnight";
        break;
      case e > 60:
        this.tickInterval = "months_days";
        break;
      case e > 30:
        this.tickInterval = "week_days";
        break;
      case e > 2:
        this.tickInterval = "days";
        break;
      case t > 2.4:
        this.tickInterval = "hours";
        break;
      case i > 15:
        this.tickInterval = "minutes_fives";
        break;
      case i > 5:
        this.tickInterval = "minutes";
        break;
      case i > 1:
        this.tickInterval = "seconds_tens";
        break;
      case 60 * i > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
    }
  } }, { key: "generateYearScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonth, r = e.currentYear, a = e.daysWidthOnXAxis, n = e.numberOfYears, o = t.minYear, l = 0, c = new je(this.ctx), h = "year";
    if (t.minDate > 1 || t.minMonth > 0) {
      var d = c.determineRemainingDaysOfYear(t.minYear, t.minMonth, t.minDate);
      l = (c.determineDaysOfYear(t.minYear) - d + 1) * a, o = t.minYear + 1, this.timeScaleArray.push({ position: l, value: o, unit: h, year: o, month: F.monthMod(i + 1) });
    } else t.minDate === 1 && t.minMonth === 0 && this.timeScaleArray.push({ position: l, value: o, unit: h, year: r, month: F.monthMod(i + 1) });
    for (var u = o, g = l, p = 0; p < n; p++) u++, g = c.determineDaysOfYear(u - 1) * a + g, this.timeScaleArray.push({ position: g, value: u, unit: h, year: u, month: 1 });
  } }, { key: "generateMonthScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonthDate, r = e.currentMonth, a = e.currentYear, n = e.daysWidthOnXAxis, o = e.numberOfMonths, l = r, c = 0, h = new je(this.ctx), d = "month", u = 0;
    if (t.minDate > 1) {
      c = (h.determineDaysOfMonths(r + 1, t.minYear) - i + 1) * n, l = F.monthMod(r + 1);
      var g = a + u, p = F.monthMod(l), f = l;
      l === 0 && (d = "year", f = g, p = 1, g += u += 1), this.timeScaleArray.push({ position: c, value: f, unit: d, year: g, month: p });
    } else this.timeScaleArray.push({ position: c, value: l, unit: d, year: a, month: F.monthMod(r) });
    for (var x = l + 1, m = c, b = 0, w = 1; b < o; b++, w++) {
      (x = F.monthMod(x)) === 0 ? (d = "year", u += 1) : d = "month";
      var y = this._getYear(a, x, u);
      m = h.determineDaysOfMonths(x, y) * n + m;
      var v = x === 0 ? y : x;
      this.timeScaleArray.push({ position: m, value: v, unit: d, year: y, month: x === 0 ? 1 : x }), x++;
    }
  } }, { key: "generateDayScale", value: function(e) {
    var t = e.firstVal, i = e.currentMonth, r = e.currentYear, a = e.hoursWidthOnXAxis, n = e.numberOfDays, o = new je(this.ctx), l = "day", c = t.minDate + 1, h = c, d = function(w, y, v) {
      return w > o.determineDaysOfMonths(y + 1, v) && (h = 1, l = "month", g = y += 1), y;
    }, u = (24 - t.minHour) * a, g = c, p = d(h, i, r);
    t.minHour === 0 && t.minDate === 1 ? (u = 0, g = F.monthMod(t.minMonth), l = "month", h = t.minDate) : t.minDate !== 1 && t.minHour === 0 && t.minMinute === 0 && (u = 0, c = t.minDate, g = c, p = d(h = c, i, r), g !== 1 && (l = "day")), this.timeScaleArray.push({ position: u, value: g, unit: l, year: this._getYear(r, p, 0), month: F.monthMod(p), day: h });
    for (var f = u, x = 0; x < n; x++) {
      l = "day", p = d(h += 1, p, this._getYear(r, p, 0));
      var m = this._getYear(r, p, 0);
      f = 24 * a + f;
      var b = h === 1 ? F.monthMod(p) : h;
      this.timeScaleArray.push({ position: f, value: b, unit: l, year: m, month: F.monthMod(p), day: b });
    }
  } }, { key: "generateHourScale", value: function(e) {
    var t = e.firstVal, i = e.currentDate, r = e.currentMonth, a = e.currentYear, n = e.minutesWidthOnXAxis, o = e.numberOfHours, l = new je(this.ctx), c = "hour", h = function(k, S) {
      return k > l.determineDaysOfMonths(S + 1, a) && (x = 1, S += 1), { month: S, date: x };
    }, d = function(k, S) {
      return k > l.determineDaysOfMonths(S + 1, a) ? S += 1 : S;
    }, u = 60 - (t.minMinute + t.minSecond / 60), g = u * n, p = t.minHour + 1, f = p;
    u === 60 && (g = 0, f = p = t.minHour);
    var x = i;
    f >= 24 && (f = 0, c = "day", p = x += 1);
    var m = h(x, r).month;
    m = d(x, m), p > 31 && (p = x = 1), this.timeScaleArray.push({ position: g, value: p, unit: c, day: x, hour: f, year: a, month: F.monthMod(m) }), f++;
    for (var b = g, w = 0; w < o; w++) {
      c = "hour", f >= 24 && (f = 0, c = "day", m = h(x += 1, m).month, m = d(x, m));
      var y = this._getYear(a, m, 0);
      b = 60 * n + b;
      var v = f === 0 ? x : f;
      this.timeScaleArray.push({ position: b, value: v, unit: c, hour: f, day: x, year: y, month: F.monthMod(m) }), f++;
    }
  } }, { key: "generateMinuteScale", value: function(e) {
    for (var t = e.currentMillisecond, i = e.currentSecond, r = e.currentMinute, a = e.currentHour, n = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.minutesWidthOnXAxis, h = e.secondsWidthOnXAxis, d = e.numberOfMinutes, u = r + 1, g = n, p = o, f = l, x = a, m = (60 - i - t / 1e3) * h, b = 0; b < d; b++) u >= 60 && (u = 0, (x += 1) === 24 && (x = 0)), this.timeScaleArray.push({ position: m, value: u, unit: "minute", hour: x, minute: u, day: g, year: this._getYear(f, p, 0), month: F.monthMod(p) }), m += c, u++;
  } }, { key: "generateSecondScale", value: function(e) {
    for (var t = e.currentMillisecond, i = e.currentSecond, r = e.currentMinute, a = e.currentHour, n = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.secondsWidthOnXAxis, h = e.numberOfSeconds, d = i + 1, u = r, g = n, p = o, f = l, x = a, m = (1e3 - t) / 1e3 * c, b = 0; b < h; b++) d >= 60 && (d = 0, ++u >= 60 && (u = 0, ++x === 24 && (x = 0))), this.timeScaleArray.push({ position: m, value: d, unit: "second", hour: x, minute: u, second: d, day: g, year: this._getYear(f, p, 0), month: F.monthMod(p) }), m += c, d++;
  } }, { key: "createRawDateString", value: function(e, t) {
    var i = e.year;
    return e.month === 0 && (e.month = 1), i += "-" + ("0" + e.month.toString()).slice(-2), e.unit === "day" ? i += e.unit === "day" ? "-" + ("0" + t).slice(-2) : "-01" : i += "-" + ("0" + (e.day ? e.day : "1")).slice(-2), e.unit === "hour" ? i += e.unit === "hour" ? "T" + ("0" + t).slice(-2) : "T00" : i += "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2), e.unit === "minute" ? i += ":" + ("0" + t).slice(-2) : i += ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"), e.unit === "second" ? i += ":" + ("0" + t).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
  } }, { key: "formatDates", value: function(e) {
    var t = this, i = this.w;
    return e.map(function(r) {
      var a = r.value.toString(), n = new je(t.ctx), o = t.createRawDateString(r, a), l = n.getDate(n.parseDate(o));
      if (t.utc || (l = n.getDate(n.parseDateWithTimezone(o))), i.config.xaxis.labels.format === void 0) {
        var c = "dd MMM", h = i.config.xaxis.labels.datetimeFormatter;
        r.unit === "year" && (c = h.year), r.unit === "month" && (c = h.month), r.unit === "day" && (c = h.day), r.unit === "hour" && (c = h.hour), r.unit === "minute" && (c = h.minute), r.unit === "second" && (c = h.second), a = n.formatDate(l, c);
      } else a = n.formatDate(l, i.config.xaxis.labels.format);
      return { dateString: o, position: r.position, value: a, unit: r.unit, year: r.year, month: r.month };
    });
  } }, { key: "removeOverlappingTS", value: function(e) {
    var t, i = this, r = new $(this.ctx), a = !1;
    e.length > 0 && e[0].value && e.every(function(l) {
      return l.value.length === e[0].value.length;
    }) && (a = !0, t = r.getTextRects(e[0].value).width);
    var n = 0, o = e.map(function(l, c) {
      if (c > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
        var h = a ? t : r.getTextRects(e[n].value).width, d = e[n].position;
        return l.position > d + h + 10 ? (n = c, l) : null;
      }
      return l;
    });
    return o = o.filter(function(l) {
      return l !== null;
    });
  } }, { key: "_getYear", value: function(e, t, i) {
    return e + Math.floor(t / 12) + i;
  } }]), s;
}(), Id = function() {
  function s(e, t) {
    te(this, s), this.ctx = t, this.w = t.w, this.el = e;
  }
  return ie(s, [{ key: "setupElements", value: function() {
    var e = this.w, t = e.globals, i = e.config, r = i.chart.type;
    t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(r), t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(r), t.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(r) && i.plotOptions.bar.horizontal, t.chartClass = ".apexcharts".concat(t.chartID), t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), $.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: "apexcharts-canvas ".concat(t.chartClass.substring(1)) }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = window.SVG().addTo(t.dom.elWrap), t.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i.chart.offsetX, ", ").concat(i.chart.offsetY, ")") }), t.dom.Paper.node.style.background = i.theme.mode !== "dark" || i.chart.background ? i.theme.mode !== "light" || i.chart.background ? i.chart.background : "#fff" : "#343A3F", this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), $.setAttrs(t.dom.elLegendForeign, { x: 0, y: 0, width: t.svgWidth, height: t.svgHeight }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
  } }, { key: "plotChartType", value: function(e, t) {
    var i = this.w, r = this.ctx, a = i.config, n = i.globals, o = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, l = a.chart.type || "line", c = null, h = 0;
    n.series.forEach(function(k, S) {
      var C = e[S].type === "column" ? "bar" : e[S].type || (l === "column" ? "bar" : l);
      o[C] ? (C === "rangeArea" ? (o[C].series.push(n.seriesRangeStart[S]), o[C].seriesRangeEnd.push(n.seriesRangeEnd[S])) : o[C].series.push(k), o[C].i.push(S), C === "bar" && (i.globals.columnSeries = o.bar)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(C) ? c = C : console.warn("You have specified an unrecognized series type (".concat(C, ").")), l !== C && C !== "scatter" && h++;
    }), h > 0 && (c && console.warn("Chart or series type ".concat(c, " cannot appear with other chart or series types.")), o.bar.series.length > 0 && a.plotOptions.bar.horizontal && (h -= o.bar.series.length, o.bar = { series: [], i: [] }, i.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), n.comboCharts || (n.comboCharts = h > 0);
    var d = new Or(r, t), u = new Tr(r, t);
    r.pie = new zo(r);
    var g = new wd(r);
    r.rangeBar = new kd(r, t);
    var p = new yd(r), f = [];
    if (n.comboCharts) {
      var x, m, b = new ze(r);
      if (o.area.series.length > 0 && (x = f).push.apply(x, De(b.drawSeriesByGroup(o.area, n.areaGroups, "area", d))), o.bar.series.length > 0) if (a.chart.stacked) {
        var w = new Ka(r, t);
        f.push(w.draw(o.bar.series, o.bar.i));
      } else r.bar = new Qt(r, t), f.push(r.bar.draw(o.bar.series, o.bar.i));
      if (o.rangeArea.series.length > 0 && f.push(d.draw(o.rangeArea.series, "rangeArea", o.rangeArea.i, o.rangeArea.seriesRangeEnd)), o.line.series.length > 0 && (m = f).push.apply(m, De(b.drawSeriesByGroup(o.line, n.lineGroups, "line", d))), o.candlestick.series.length > 0 && f.push(u.draw(o.candlestick.series, "candlestick", o.candlestick.i)), o.boxPlot.series.length > 0 && f.push(u.draw(o.boxPlot.series, "boxPlot", o.boxPlot.i)), o.rangeBar.series.length > 0 && f.push(r.rangeBar.draw(o.rangeBar.series, o.rangeBar.i)), o.scatter.series.length > 0) {
        var y = new Or(r, t, !0);
        f.push(y.draw(o.scatter.series, "scatter", o.scatter.i));
      }
      if (o.bubble.series.length > 0) {
        var v = new Or(r, t, !0);
        f.push(v.draw(o.bubble.series, "bubble", o.bubble.i));
      }
    } else switch (a.chart.type) {
      case "line":
        f = d.draw(n.series, "line");
        break;
      case "area":
        f = d.draw(n.series, "area");
        break;
      case "bar":
        a.chart.stacked ? f = new Ka(r, t).draw(n.series) : (r.bar = new Qt(r, t), f = r.bar.draw(n.series));
        break;
      case "candlestick":
        f = new Tr(r, t).draw(n.series, "candlestick");
        break;
      case "boxPlot":
        f = new Tr(r, t).draw(n.series, a.chart.type);
        break;
      case "rangeBar":
        f = r.rangeBar.draw(n.series);
        break;
      case "rangeArea":
        f = d.draw(n.seriesRangeStart, "rangeArea", void 0, n.seriesRangeEnd);
        break;
      case "heatmap":
        f = new vd(r, t).draw(n.series);
        break;
      case "treemap":
        f = new Rd(r, t).draw(n.series);
        break;
      case "pie":
      case "donut":
      case "polarArea":
        f = r.pie.draw(n.series);
        break;
      case "radialBar":
        f = g.draw(n.series);
        break;
      case "radar":
        f = p.draw(n.series);
        break;
      default:
        f = d.draw(n.series);
    }
    return f;
  } }, { key: "setSVGDimensions", value: function() {
    var e = this.w, t = e.globals, i = e.config;
    i.chart.width = i.chart.width || "100%", i.chart.height = i.chart.height || "auto", t.svgWidth = i.chart.width, t.svgHeight = i.chart.height;
    var r = F.getDimensions(this.el), a = i.chart.width.toString().split(/[0-9]+/g).pop();
    a === "%" ? F.isNumber(r[0]) && (r[0].width === 0 && (r = F.getDimensions(this.el.parentNode)), t.svgWidth = r[0] * parseInt(i.chart.width, 10) / 100) : a !== "px" && a !== "" || (t.svgWidth = parseInt(i.chart.width, 10));
    var n = String(i.chart.height).toString().split(/[0-9]+/g).pop();
    if (t.svgHeight !== "auto" && t.svgHeight !== "") if (n === "%") {
      var o = F.getDimensions(this.el.parentNode);
      t.svgHeight = o[1] * parseInt(i.chart.height, 10) / 100;
    } else t.svgHeight = parseInt(i.chart.height, 10);
    else t.svgHeight = t.axisCharts ? t.svgWidth / 1.61 : t.svgWidth / 1.2;
    if (t.svgWidth = Math.max(t.svgWidth, 0), t.svgHeight = Math.max(t.svgHeight, 0), $.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }), n !== "%") {
      var l = i.chart.sparkline.enabled ? 0 : t.axisCharts ? i.chart.parentHeightOffset : 0;
      t.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(t.svgHeight + l, "px");
    }
    t.dom.elWrap.style.width = "".concat(t.svgWidth, "px"), t.dom.elWrap.style.height = "".concat(t.svgHeight, "px");
  } }, { key: "shiftGraphPosition", value: function() {
    var e = this.w.globals, t = e.translateY, i = e.translateX;
    $.setAttrs(e.dom.elGraphical.node, { transform: "translate(".concat(i, ", ").concat(t, ")") });
  } }, { key: "resizeNonAxisCharts", value: function() {
    var e = this.w, t = e.globals, i = 0, r = e.config.chart.sparkline.enabled ? 1 : 15;
    r += e.config.grid.padding.bottom, ["top", "bottom"].includes(e.config.legend.position) && e.config.legend.show && !e.config.legend.floating && (i = new Lo(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var a = e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), n = 2.05 * e.globals.radialSize;
    if (a && !e.config.chart.sparkline.enabled && e.config.plotOptions.radialBar.startAngle !== 0) {
      var o = F.getBoundingClientRect(a);
      n = o.bottom;
      var l = o.bottom - o.top;
      n = Math.max(2.05 * e.globals.radialSize, l);
    }
    var c = Math.ceil(n + t.translateY + i + r);
    t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", c), e.config.chart.height && String(e.config.chart.height).includes("%") || (t.dom.elWrap.style.height = "".concat(c, "px"), $.setAttrs(t.dom.Paper.node, { height: c }), t.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(c, "px"));
  } }, { key: "coreCalculations", value: function() {
    new ks(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var e = this, t = function() {
      return e.w.config.series.map(function() {
        return [];
      });
    }, i = new Ao(), r = this.w.globals;
    i.initGlobalVars(r), r.seriesXvalues = t(), r.seriesYvalues = t();
  } }, { key: "isMultipleY", value: function() {
    return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = !0, !0);
  } }, { key: "xySettings", value: function() {
    var e = this.w, t = null;
    if (e.globals.axisCharts) {
      if (e.config.xaxis.crosshairs.position === "back" && new Ss(this.ctx).drawXCrosshairs(), e.config.yaxis[0].crosshairs.position === "back" && new Ss(this.ctx).drawYCrosshairs(), e.config.xaxis.type === "datetime" && e.config.xaxis.labels.formatter === void 0) {
        this.ctx.timeScale = new Ld(this.ctx);
        var i = [];
        isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
      }
      t = new ze(this.ctx).getCalculatedRatios();
    }
    return t;
  } }, { key: "updateSourceChart", value: function(e) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: e.w.globals.minX, max: e.w.globals.maxX } } } }, !1, !1);
  } }, { key: "setupBrushHandler", value: function() {
    var e = this, t = this.ctx, i = this.w;
    if (i.config.chart.brush.enabled && typeof i.config.chart.events.selection != "function") {
      var r = Array.isArray(i.config.chart.brush.targets) ? i.config.chart.brush.targets : [i.config.chart.brush.target];
      r.forEach(function(a) {
        var n = t.constructor.getChartByID(a);
        n.w.globals.brushSource = e.ctx, typeof n.w.config.chart.events.zoomed != "function" && (n.w.config.chart.events.zoomed = function() {
          return e.updateSourceChart(n);
        }), typeof n.w.config.chart.events.scrolled != "function" && (n.w.config.chart.events.scrolled = function() {
          return e.updateSourceChart(n);
        });
      }), i.config.chart.events.selection = function(a, n) {
        r.forEach(function(o) {
          t.constructor.getChartByID(o).ctx.updateHelpers._updateOptions({ xaxis: { min: n.xaxis.min, max: n.xaxis.max } }, !1, !1, !1, !1);
        });
      };
    }
  } }]), s;
}(), Ed = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "_updateOptions", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], r = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], n = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
    return new Promise(function(o) {
      var l = [t.ctx];
      a && (l = t.ctx.getSyncedCharts()), t.ctx.w.globals.isExecCalled && (l = [t.ctx], t.ctx.w.globals.isExecCalled = !1), l.forEach(function(c, h) {
        var d = c.w;
        if (d.globals.shouldAnimate = r, i || (d.globals.resized = !0, d.globals.dataChanged = !0, r && c.series.getPreviousPaths()), e && Kt(e) === "object" && (c.config = new Mi(e), e = ze.extendArrayProps(c.config, e, d), c.w.globals.chartID !== t.ctx.w.globals.chartID && delete e.series, d.config = F.extend(d.config, e), n && (d.globals.lastXAxis = e.xaxis ? F.clone(e.xaxis) : [], d.globals.lastYAxis = e.yaxis ? F.clone(e.yaxis) : [], d.globals.initialConfig = F.extend({}, d.config), d.globals.initialSeries = F.clone(d.config.series), e.series))) {
          for (var u = 0; u < d.globals.collapsedSeriesIndices.length; u++) {
            var g = d.config.series[d.globals.collapsedSeriesIndices[u]];
            d.globals.collapsedSeries[u].data = d.globals.axisCharts ? g.data.slice() : g;
          }
          for (var p = 0; p < d.globals.ancillaryCollapsedSeriesIndices.length; p++) {
            var f = d.config.series[d.globals.ancillaryCollapsedSeriesIndices[p]];
            d.globals.ancillaryCollapsedSeries[p].data = d.globals.axisCharts ? f.data.slice() : f;
          }
          c.series.emptyCollapsedSeries(d.config.series);
        }
        return c.update(e).then(function() {
          h === l.length - 1 && o(c);
        });
      });
    });
  } }, { key: "_updateSeries", value: function(e, t) {
    var i = this, r = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    return new Promise(function(a) {
      var n, o = i.w;
      return o.globals.shouldAnimate = t, o.globals.dataChanged = !0, t && i.ctx.series.getPreviousPaths(), o.globals.axisCharts ? ((n = e.map(function(l, c) {
        return i._extendSeries(l, c);
      })).length === 0 && (n = [{ data: [] }]), o.config.series = n) : o.config.series = e.slice(), r && (o.globals.initialConfig.series = F.clone(o.config.series), o.globals.initialSeries = F.clone(o.config.series)), i.ctx.update().then(function() {
        a(i.ctx);
      });
    });
  } }, { key: "_extendSeries", value: function(e, t) {
    var i = this.w, r = i.config.series[t];
    return J(J({}, i.config.series[t]), {}, { name: e.name ? e.name : r == null ? void 0 : r.name, color: e.color ? e.color : r == null ? void 0 : r.color, type: e.type ? e.type : r == null ? void 0 : r.type, group: e.group ? e.group : r == null ? void 0 : r.group, hidden: e.hidden !== void 0 ? e.hidden : r == null ? void 0 : r.hidden, data: e.data ? e.data : r == null ? void 0 : r.data, zIndex: e.zIndex !== void 0 ? e.zIndex : t });
  } }, { key: "toggleDataPointSelection", value: function(e, t) {
    var i = this.w, r = null, a = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
    return i.globals.axisCharts ? r = i.globals.dom.Paper.findOne("".concat(a, " path[j='").concat(t, "'], ").concat(a, " circle[j='").concat(t, "'], ").concat(a, " rect[j='").concat(t, "']")) : t === void 0 && (r = i.globals.dom.Paper.findOne("".concat(a, " path[j='").concat(e, "']")), i.config.chart.type !== "pie" && i.config.chart.type !== "polarArea" && i.config.chart.type !== "donut" || this.ctx.pie.pieClicked(e)), r ? (new $(this.ctx).pathMouseDown(r, null), r.node ? r.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
  } }, { key: "forceXAxisUpdate", value: function(e) {
    var t = this.w;
    if (["min", "max"].forEach(function(r) {
      e.xaxis[r] !== void 0 && (t.config.xaxis[r] = e.xaxis[r], t.globals.lastXAxis[r] = e.xaxis[r]);
    }), e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories), t.config.xaxis.convertedCatToNumeric) {
      var i = new Ai(e);
      e = i.convertCatToNumericXaxis(e, this.ctx);
    }
    return e;
  } }, { key: "forceYAxisUpdate", value: function(e) {
    return e.chart && e.chart.stacked && e.chart.stackType === "100%" && (Array.isArray(e.yaxis) ? e.yaxis.forEach(function(t, i) {
      e.yaxis[i].min = 0, e.yaxis[i].max = 100;
    }) : (e.yaxis.min = 0, e.yaxis.max = 100)), e;
  } }, { key: "revertDefaultAxisMinMax", value: function(e) {
    var t = this, i = this.w, r = i.globals.lastXAxis, a = i.globals.lastYAxis;
    e && e.xaxis && (r = e.xaxis), e && e.yaxis && (a = e.yaxis), i.config.xaxis.min = r.min, i.config.xaxis.max = r.max;
    var n = function(o) {
      a[o] !== void 0 && (i.config.yaxis[o].min = a[o].min, i.config.yaxis[o].max = a[o].max);
    };
    i.config.yaxis.map(function(o, l) {
      i.globals.zoomed || a[l] !== void 0 ? n(l) : t.ctx.opts.yaxis[l] !== void 0 && (o.min = t.ctx.opts.yaxis[l].min, o.max = t.ctx.opts.yaxis[l].max);
    });
  } }]), s;
}();
(function() {
  function s() {
    for (var a = arguments.length > 0 && arguments[0] !== d ? arguments[0] : [], n = arguments.length > 1 ? arguments[1] : d, o = arguments.length > 2 ? arguments[2] : d, l = arguments.length > 3 ? arguments[3] : d, c = arguments.length > 4 ? arguments[4] : d, h = arguments.length > 5 ? arguments[5] : d, d = arguments.length > 6 ? arguments[6] : d, u = a.slice(n, o || d), g = l.slice(c, h || d), p = 0, f = { pos: [0, 0], start: [0, 0] }, x = { pos: [0, 0], start: [0, 0] }; u[p] = e.call(f, u[p]), g[p] = e.call(x, g[p]), u[p][0] != g[p][0] || u[p][0] == "M" || u[p][0] == "A" && (u[p][4] != g[p][4] || u[p][5] != g[p][5]) ? (Array.prototype.splice.apply(u, [p, 1].concat(i.call(f, u[p]))), Array.prototype.splice.apply(g, [p, 1].concat(i.call(x, g[p])))) : (u[p] = t.call(f, u[p]), g[p] = t.call(x, g[p])), !(++p == u.length && p == g.length); )
      p == u.length && u.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]), p == g.length && g.push(["C", x.pos[0], x.pos[1], x.pos[0], x.pos[1], x.pos[0], x.pos[1]]);
    return { start: u, dest: g };
  }
  function e(a) {
    switch (a[0]) {
      case "z":
      case "Z":
        a[0] = "L", a[1] = this.start[0], a[2] = this.start[1];
        break;
      case "H":
        a[0] = "L", a[2] = this.pos[1];
        break;
      case "V":
        a[0] = "L", a[2] = a[1], a[1] = this.pos[0];
        break;
      case "T":
        a[0] = "Q", a[3] = a[1], a[4] = a[2], a[1] = this.reflection[1], a[2] = this.reflection[0];
        break;
      case "S":
        a[0] = "C", a[6] = a[4], a[5] = a[3], a[4] = a[2], a[3] = a[1], a[2] = this.reflection[1], a[1] = this.reflection[0];
    }
    return a;
  }
  function t(a) {
    var n = a.length;
    return this.pos = [a[n - 2], a[n - 1]], "SCQT".indexOf(a[0]) != -1 && (this.reflection = [2 * this.pos[0] - a[n - 4], 2 * this.pos[1] - a[n - 3]]), a;
  }
  function i(a) {
    var n = [a];
    switch (a[0]) {
      case "M":
        return this.pos = this.start = [a[1], a[2]], n;
      case "L":
        a[5] = a[3] = a[1], a[6] = a[4] = a[2], a[1] = this.pos[0], a[2] = this.pos[1];
        break;
      case "Q":
        a[6] = a[4], a[5] = a[3], a[4] = 1 * a[4] / 3 + 2 * a[2] / 3, a[3] = 1 * a[3] / 3 + 2 * a[1] / 3, a[2] = 1 * this.pos[1] / 3 + 2 * a[2] / 3, a[1] = 1 * this.pos[0] / 3 + 2 * a[1] / 3;
        break;
      case "A":
        n = function(o, l) {
          var c, h, d, u, g, p, f, x, m, b, w, y, v, k, S, C, M, R, P, I, D, N, z, L, T, H, B = Math.abs(l[1]), _ = Math.abs(l[2]), O = l[3] % 360, Y = l[4], X = l[5], V = l[6], W = l[7], G = new ye(o), U = new ye(V, W), Z = [];
          if (B === 0 || _ === 0 || G.x === U.x && G.y === U.y) return [["C", G.x, G.y, U.x, U.y, U.x, U.y]];
          for (c = new ye((G.x - U.x) / 2, (G.y - U.y) / 2).transform(new ae().rotate(O)), h = c.x * c.x / (B * B) + c.y * c.y / (_ * _), h > 1 && (B *= h = Math.sqrt(h), _ *= h), d = new ae().rotate(O).scale(1 / B, 1 / _).rotate(-O), G = G.transform(d), U = U.transform(d), u = [U.x - G.x, U.y - G.y], p = u[0] * u[0] + u[1] * u[1], g = Math.sqrt(p), u[0] /= g, u[1] /= g, f = p < 4 ? Math.sqrt(1 - p / 4) : 0, Y === X && (f *= -1), x = new ye((U.x + G.x) / 2 + f * -u[1], (U.y + G.y) / 2 + f * u[0]), m = new ye(G.x - x.x, G.y - x.y), b = new ye(U.x - x.x, U.y - x.y), w = Math.acos(m.x / Math.sqrt(m.x * m.x + m.y * m.y)), m.y < 0 && (w *= -1), y = Math.acos(b.x / Math.sqrt(b.x * b.x + b.y * b.y)), b.y < 0 && (y *= -1), X && w > y && (y += 2 * Math.PI), !X && w < y && (y -= 2 * Math.PI), k = Math.ceil(2 * Math.abs(w - y) / Math.PI), C = [], M = w, v = (y - w) / k, S = 4 * Math.tan(v / 4) / 3, D = 0; D <= k; D++) P = Math.cos(M), R = Math.sin(M), I = new ye(x.x + P, x.y + R), C[D] = [new ye(I.x + S * R, I.y - S * P), I, new ye(I.x - S * R, I.y + S * P)], M += v;
          for (C[0][0] = C[0][1].clone(), C[C.length - 1][2] = C[C.length - 1][1].clone(), d = new ae().rotate(O).scale(B, _).rotate(-O), D = 0, N = C.length; D < N; D++) C[D][0] = C[D][0].transform(d), C[D][1] = C[D][1].transform(d), C[D][2] = C[D][2].transform(d);
          for (D = 1, N = C.length; D < N; D++) z = (I = C[D - 1][2]).x, L = I.y, T = (I = C[D][0]).x, H = I.y, V = (I = C[D][1]).x, W = I.y, Z.push(["C", z, L, T, H, V, W]);
          return Z;
        }(this.pos, a), a = n[0];
    }
    return a[0] = "C", this.pos = [a[5], a[6]], this.reflection = [2 * a[5] - a[3], 2 * a[6] - a[4]], n;
  }
  function r() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 ? arguments[1] : void 0;
    if (n === !1) return !1;
    for (var o = n, l = a.length; o < l; ++o) if (a[o][0] == "M") return o;
    return !1;
  }
  oe(dt, { morph: function(a, n, o, l, c) {
    for (var h = this.parse(a), d = this.parse(n), u = 0, g = 0, p = !1, f = !1; u !== !1 || g !== !1; ) {
      var x;
      p = r(h, u !== !1 && u + 1), f = r(d, g !== !1 && g + 1), u === !1 && (u = (x = new dt(m.start).bbox()).height == 0 || x.width == 0 ? h.push(h[0]) - 1 : h.push(["M", x.x + x.width / 2, x.y + x.height / 2]) - 1), g === !1 && (g = (x = new dt(m.dest).bbox()).height == 0 || x.width == 0 ? d.push(d[0]) - 1 : d.push(["M", x.x + x.width / 2, x.y + x.height / 2]) - 1);
      var m = s(h, u, p, d, g, f);
      h = h.slice(0, u).concat(m.start, p === !1 ? [] : h.slice(p)), d = d.slice(0, g).concat(m.dest, f === !1 ? [] : d.slice(f)), u = p !== !1 && u + m.start.length, g = f !== !1 && g + m.dest.length;
    }
    this._array = h, this.destination = new dt(), this.destination._array = d;
    var b = this.fromArray(h.map(function(w, y) {
      var v = d[y].map(function(k, S) {
        return S === 0 ? k : l.step(w[S], d[y][S], o, c[y], c);
      });
      return v;
    }));
    return b;
  } });
})();
const Ja = (s) => (s.changedTouches && (s = s.changedTouches[0]), { x: s.clientX, y: s.clientY });
class Td {
  constructor(e) {
    e.remember("_draggable", this), this.el = e, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(e) {
    e ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: !1 })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
  }
  startDrag(e) {
    const t = !e.type.indexOf("mouse");
    if (t && e.which !== 1 && e.buttons !== 0 || this.el.dispatch("beforedrag", { event: e, handler: this }).defaultPrevented) return;
    e.preventDefault(), e.stopPropagation(), this.init(!1), this.box = this.el.bbox(), this.lastClick = this.el.point(Ja(e));
    const i = (t ? "mouseup" : "touchend") + ".drag";
    vt(window, (t ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: !1 }), vt(window, i, this.endDrag, this, { passive: !1 }), this.el.fire("dragstart", { event: e, handler: this, box: this.box });
  }
  drag(e) {
    const { box: t, lastClick: i } = this, r = this.el.point(Ja(e)), a = r.x - i.x, n = r.y - i.y;
    if (!a && !n) return t;
    const o = t.x + a, l = t.y + n;
    this.box = new Oe(o, l, t.w, t.h), this.lastClick = r, this.el.dispatch("dragmove", { event: e, handler: this, box: this.box }).defaultPrevented || this.move(o, l);
  }
  move(e, t) {
    this.el.type === "svg" ? Mt.prototype.move.call(this.el, e, t) : this.el.move(e, t);
  }
  endDrag(e) {
    this.drag(e), this.el.fire("dragend", { event: e, handler: this, box: this.box }), lt(window, "mousemove.drag"), lt(window, "touchmove.drag"), lt(window, "mouseup.drag"), lt(window, "touchend.drag"), this.init(!0);
  }
}
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Cs(s, e, t, i = null) {
  return function(r) {
    r.preventDefault(), r.stopPropagation();
    var a = r.pageX || r.touches[0].pageX, n = r.pageY || r.touches[0].pageY;
    e.fire(s, { x: a, y: n, event: r, index: i, points: t });
  };
}
function As([s, e], { a: t, b: i, c: r, d: a, e: n, f: o }) {
  return [s * t + e * r + n, s * i + e * a + o];
}
oe(Xe, { draggable(s = !0) {
  return (this.remember("_draggable") || new Td(this)).init(s), this;
} });
let No = class {
  constructor(s) {
    this.el = s, s.remember("_selectHandler", this), this.selection = new Mt(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = Ii();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(s) {
    this.createHandle = s.createHandle || this.createHandleFn, this.createRot = s.createRot || this.createRotFn, this.updateHandle = s.updateHandle || this.updateHandleFn, this.updateRot = s.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(s, e) {
    if (!s) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((s, e, t) => {
      const i = this.order[e];
      this.createHandle.call(this, this.selection, s, e, t, i), this.selection.get(e + 1).addClass("svg_select_handle svg_select_handle_" + i).on("mousedown.selection touchstart.selection", Cs(i, this.el, this.handlePoints, e));
    });
  }
  createHandleFn(s) {
    s.polyline();
  }
  updateHandleFn(s, e, t, i) {
    const r = i.at(t - 1), a = i[(t + 1) % i.length], n = e, o = [n[0] - r[0], n[1] - r[1]], l = [n[0] - a[0], n[1] - a[1]], c = Math.sqrt(o[0] * o[0] + o[1] * o[1]), h = Math.sqrt(l[0] * l[0] + l[1] * l[1]), d = [o[0] / c, o[1] / c], u = [l[0] / h, l[1] / h], g = [n[0] - 10 * d[0], n[1] - 10 * d[1]], p = [n[0] - 10 * u[0], n[1] - 10 * u[1]];
    s.plot([g, n, p]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((s, e, t) => {
      const i = this.order[e];
      this.updateHandle.call(this, this.selection.get(e + 1), s, e, t, i);
    });
  }
  createRotFn(s) {
    s.line(), s.circle(5);
  }
  getPoint(s) {
    return this.handlePoints[this.order.indexOf(s)];
  }
  getPointHandle(s) {
    return this.selection.get(this.order.indexOf(s) + 1);
  }
  updateRotFn(s, e) {
    const t = this.getPoint("t");
    s.get(0).plot(t[0], t[1], e[0], e[1]), s.get(1).center(e[0], e[1]);
  }
  createRotationHandle() {
    const s = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Cs("rot", this.el, this.handlePoints));
    this.createRot.call(this, s);
  }
  updateRotationHandle() {
    const s = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(s, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const s = this.el.bbox(), e = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(s).map((t) => As(t, e)), this.rotationPoint = As(this.getRotationPoint(s), e);
  }
  getHandlePoints({ x: s, x2: e, y: t, y2: i, cx: r, cy: a } = this.el.bbox()) {
    return [[s, t], [r, t], [e, t], [e, a], [e, i], [r, i], [s, i], [s, a]];
  }
  getRotationPoint({ y: s, cx: e } = this.el.bbox()) {
    return [e, s - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
const Qa = (s) => function(e = !0, t = {}) {
  typeof e == "object" && (t = e, e = !0);
  let i = this.remember("_" + s.name);
  return i || (e.prototype instanceof No ? (i = new e(this), e = !0) : i = new s(this), this.remember("_" + s.name, i)), i.active(e, t), this;
};
/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Ms(s, e, t, i = null) {
  return function(r) {
    r.preventDefault(), r.stopPropagation();
    var a = r.pageX || r.touches[0].pageX, n = r.pageY || r.touches[0].pageY;
    e.fire(s, { x: a, y: n, event: r, index: i, points: t });
  };
}
function Rs([s, e], { a: t, b: i, c: r, d: a, e: n, f: o }) {
  return [s * t + e * r + n, s * i + e * a + o];
}
oe(Xe, { select: Qa(No) }), oe([Ft, Nt, zt], { pointSelect: Qa(class {
  constructor(s) {
    this.el = s, s.remember("_pointSelectHandler", this), this.selection = new Mt(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = Ii();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(s) {
    this.createHandle = s.createHandle || this.createHandleFn, this.updateHandle = s.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(s, e) {
    if (!s) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((s, e, t) => {
      this.createHandle.call(this, this.selection, s, e, t), this.selection.get(e + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Cs("point", this.el, this.points, e));
    });
  }
  createHandleFn(s) {
    s.circle(5);
  }
  updateHandleFn(s, e) {
    s.center(e[0], e[1]);
  }
  updatePointHandles() {
    this.points.forEach((s, e, t) => {
      this.updateHandle.call(this, this.selection.get(e + 1), s, e, t);
    });
  }
  updatePoints() {
    const s = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e) => As(e, s));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
class Do {
  constructor(e) {
    this.el = e, e.remember("_selectHandler", this), this.selection = new Mt(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const t = Ii();
    this.observer = new t.MutationObserver(this.mutationHandler);
  }
  init(e) {
    this.createHandle = e.createHandle || this.createHandleFn, this.createRot = e.createRot || this.createRotFn, this.updateHandle = e.updateHandle || this.updateHandleFn, this.updateRot = e.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(e, t) {
    if (!e) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(t);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((e, t, i) => {
      const r = this.order[t];
      this.createHandle.call(this, this.selection, e, t, i, r), this.selection.get(t + 1).addClass("svg_select_handle svg_select_handle_" + r).on("mousedown.selection touchstart.selection", Ms(r, this.el, this.handlePoints, t));
    });
  }
  createHandleFn(e) {
    e.polyline();
  }
  updateHandleFn(e, t, i, r) {
    const a = r.at(i - 1), n = r[(i + 1) % r.length], o = t, l = [o[0] - a[0], o[1] - a[1]], c = [o[0] - n[0], o[1] - n[1]], h = Math.sqrt(l[0] * l[0] + l[1] * l[1]), d = Math.sqrt(c[0] * c[0] + c[1] * c[1]), u = [l[0] / h, l[1] / h], g = [c[0] / d, c[1] / d], p = [o[0] - 10 * u[0], o[1] - 10 * u[1]], f = [o[0] - 10 * g[0], o[1] - 10 * g[1]];
    e.plot([p, o, f]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((e, t, i) => {
      const r = this.order[t];
      this.updateHandle.call(this, this.selection.get(t + 1), e, t, i, r);
    });
  }
  createRotFn(e) {
    e.line(), e.circle(5);
  }
  getPoint(e) {
    return this.handlePoints[this.order.indexOf(e)];
  }
  getPointHandle(e) {
    return this.selection.get(this.order.indexOf(e) + 1);
  }
  updateRotFn(e, t) {
    const i = this.getPoint("t");
    e.get(0).plot(i[0], i[1], t[0], t[1]), e.get(1).center(t[0], t[1]);
  }
  createRotationHandle() {
    const e = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Ms("rot", this.el, this.handlePoints));
    this.createRot.call(this, e);
  }
  updateRotationHandle() {
    const e = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(e, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const e = this.el.bbox(), t = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(e).map((i) => Rs(i, t)), this.rotationPoint = Rs(this.getRotationPoint(e), t);
  }
  getHandlePoints({ x: e, x2: t, y: i, y2: r, cx: a, cy: n } = this.el.bbox()) {
    return [[e, i], [a, i], [t, i], [t, n], [t, r], [a, r], [e, r], [e, n]];
  }
  getRotationPoint({ y: e, cx: t } = this.el.bbox()) {
    return [t, e - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
}
const en = (s) => function(e = !0, t = {}) {
  typeof e == "object" && (t = e, e = !0);
  let i = this.remember("_" + s.name);
  return i || (e.prototype instanceof Do ? (i = new e(this), e = !0) : i = new s(this), this.remember("_" + s.name, i)), i.active(e, t), this;
};
oe(Xe, { select: en(Do) }), oe([Ft, Nt, zt], { pointSelect: en(class {
  constructor(s) {
    this.el = s, s.remember("_pointSelectHandler", this), this.selection = new Mt(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e = Ii();
    this.observer = new e.MutationObserver(this.mutationHandler);
  }
  init(s) {
    this.createHandle = s.createHandle || this.createHandleFn, this.updateHandle = s.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
  }
  active(s, e) {
    if (!s) return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((s, e, t) => {
      this.createHandle.call(this, this.selection, s, e, t), this.selection.get(e + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Ms("point", this.el, this.points, e));
    });
  }
  createHandleFn(s) {
    s.circle(5);
  }
  updateHandleFn(s, e) {
    s.center(e[0], e[1]);
  }
  updatePointHandles() {
    this.points.forEach((s, e, t) => {
      this.updateHandle.call(this, this.selection.get(e + 1), s, e, t);
    });
  }
  updatePoints() {
    const s = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e) => Rs(e, s));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
const Di = (s) => (s.changedTouches && (s = s.changedTouches[0]), { x: s.clientX, y: s.clientY }), tn = (s) => {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, r = -1 / 0;
  for (let a = 0; a < s.length; a++) {
    const n = s[a];
    e = Math.min(e, n[0]), t = Math.min(t, n[1]), i = Math.max(i, n[0]), r = Math.max(r, n[1]);
  }
  return new Oe(e, t, i - e, r - t);
};
class rn {
  constructor(e) {
    this.el = e, e.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(e, t) {
    this.preserveAspectRatio = t.preserveAspectRatio ?? !1, this.aroundCenter = t.aroundCenter ?? !1, this.grid = t.grid ?? 0, this.degree = t.degree ?? 0, this.el.off(".resize"), e && (this.el.on(["lt.resize", "rt.resize", "rb.resize", "lb.resize", "t.resize", "r.resize", "b.resize", "l.resize", "rot.resize", "point.resize"], this.handleResize), this.lastEvent && (this.eventType === "rot" ? this.rotate(this.lastEvent) : this.eventType === "point" ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(e) {
    this.eventType = e.type;
    const { event: t, index: i, points: r } = e.detail, a = !t.type.indexOf("mouse");
    if (a && (t.which || t.buttons) !== 1 || this.el.dispatch("beforeresize", { event: e, handler: this }).defaultPrevented) return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(Di(t)), this.index = i, this.points = r.slice();
    const n = (a ? "mousemove" : "touchmove") + ".resize", o = (a ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    e.type === "point" ? vt(window, n, this.movePoint) : e.type === "rot" ? vt(window, n, this.rotate) : vt(window, n, this.resize), vt(window, o, this.endResize);
  }
  resize(e) {
    this.lastEvent = e;
    const t = this.snapToGrid(this.el.point(Di(e)));
    let i = t.x - this.startPoint.x, r = t.y - this.startPoint.y;
    this.preserveAspectRatio && this.aroundCenter && (i *= 2, r *= 2);
    const a = this.box.x + i, n = this.box.y + r, o = this.box.x2 + i, l = this.box.y2 + r;
    let c = new Oe(this.box);
    if (this.eventType.includes("l") && (c.x = Math.min(a, this.box.x2), c.x2 = Math.max(a, this.box.x2)), this.eventType.includes("r") && (c.x = Math.min(o, this.box.x), c.x2 = Math.max(o, this.box.x)), this.eventType.includes("t") && (c.y = Math.min(n, this.box.y2), c.y2 = Math.max(n, this.box.y2)), this.eventType.includes("b") && (c.y = Math.min(l, this.box.y), c.y2 = Math.max(l, this.box.y)), c.width = c.x2 - c.x, c.height = c.y2 - c.y, this.preserveAspectRatio) {
      const h = c.width / this.box.width, d = c.height / this.box.height, u = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"], g = (u.indexOf(this.eventType) + 4) % u.length, p = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[g];
      let f = this.eventType.includes("t") || this.eventType.includes("b") ? d : h;
      f = this.eventType.length === 2 ? Math.max(h, d) : f, c = function(x, m, b) {
        const w = [[x.x, x.y], [x.x + x.width, x.y], [x.x + x.width, x.y + x.height], [x.x, x.y + x.height]].map(([y, v]) => {
          const k = y - m[0], S = (v - m[1]) * b;
          return [k * b + m[0], S + m[1]];
        });
        return tn(w);
      }(this.box, p, f);
    }
    this.el.dispatch("resize", { box: new Oe(c), angle: 0, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.size(c.width, c.height).move(c.x, c.y);
  }
  movePoint(e) {
    this.lastEvent = e;
    const { x: t, y: i } = this.snapToGrid(this.el.point(Di(e))), r = this.el.array().slice();
    r[this.index] = [t, i], this.el.dispatch("resize", { box: tn(r), angle: 0, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.plot(r);
  }
  rotate(e) {
    this.lastEvent = e;
    const t = this.startPoint, i = this.el.point(Di(e)), { cx: r, cy: a } = this.box, n = t.x - r, o = t.y - a, l = i.x - r, c = i.y - a, h = Math.sqrt(n * n + o * o) * Math.sqrt(l * l + c * c);
    if (h === 0) return;
    let d = Math.acos((n * l + o * c) / h) / Math.PI * 180;
    if (!d) return;
    i.x < t.x && (d = -d);
    const u = new ae(this.el), { x: g, y: p } = new ye(r, a).transformO(u), { rotate: f } = u.decompose(), x = this.snapToAngle(f + d) - f;
    this.el.dispatch("resize", { box: this.box, angle: x, eventType: this.eventType, event: e, handler: this }).defaultPrevented || this.el.transform(u.rotateO(x, g, p));
  }
  endResize(e) {
    this.eventType !== "rot" && this.eventType !== "point" && this.resize(e), this.lastEvent = null, this.eventType = "", lt(window, "mousemove.resize touchmove.resize"), lt(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(e) {
    return this.grid && (e.x = Math.round(e.x / this.grid) * this.grid, e.y = Math.round(e.y / this.grid) * this.grid), e;
  }
  snapToAngle(e) {
    return this.degree && (e = Math.round(e / this.degree) * this.degree), e;
  }
}
oe(Xe, { resize: function(s = !0, e = {}) {
  typeof s == "object" && (e = s, s = !0);
  let t = this.remember("_ResizeHandler");
  return t || (s.prototype instanceof rn ? (t = new s(this), s = !0) : t = new rn(this), this.remember("_resizeHandler", t)), t.active(s, e), this;
} }), window.SVG === void 0 && (window.SVG = $h), window.Apex === void 0 && (window.Apex = {});
var sn = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "initModules", value: function() {
    this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new ii(this.ctx), this.ctx.axes = new rd(this.ctx), this.ctx.core = new Id(this.ctx.el, this.ctx), this.ctx.config = new Mi({}), this.ctx.data = new ea(this.ctx), this.ctx.grid = new Ro(this.ctx), this.ctx.graphics = new $(this.ctx), this.ctx.coreUtils = new ze(this.ctx), this.ctx.crosshairs = new Ss(this.ctx), this.ctx.events = new td(this.ctx), this.ctx.exports = new bi(this.ctx), this.ctx.fill = new gt(this.ctx), this.ctx.localization = new id(this.ctx), this.ctx.options = new Ot(), this.ctx.responsive = new sd(this.ctx), this.ctx.series = new ct(this.ctx), this.ctx.theme = new ad(this.ctx), this.ctx.formatters = new _i(this.ctx), this.ctx.titleSubtitle = new nd(this.ctx), this.ctx.legend = new Lo(this.ctx), this.ctx.toolbar = new Io(this.ctx), this.ctx.tooltip = new Za(this.ctx), this.ctx.dimensions = new tr(this.ctx), this.ctx.updateHelpers = new Ed(this.ctx), this.ctx.zoomPanSelection = new ud(this.ctx), this.ctx.w.globals.tooltip = new Za(this.ctx);
  } }]), s;
}(), an = function() {
  function s(e) {
    te(this, s), this.ctx = e, this.w = e.w;
  }
  return ie(s, [{ key: "clear", value: function(e) {
    var t = e.isUpdating;
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: t });
  } }, { key: "killSVG", value: function(e) {
    e.each(function() {
      this.removeClass("*"), this.off();
    }, !0), e.clear();
  } }, { key: "clearDomElements", value: function(e) {
    var t = this, i = e.isUpdating, r = this.w.globals.dom.Paper.node;
    r.parentNode && r.parentNode.parentNode && !i && (r.parentNode.parentNode.style.minHeight = "unset");
    var a = this.w.globals.dom.baseEl;
    a && this.ctx.eventList.forEach(function(o) {
      a.removeEventListener(o, t.ctx.events.documentEvent);
    });
    var n = this.w.globals.dom;
    if (this.ctx.el !== null) for (; this.ctx.el.firstChild; ) this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(n.Paper), n.Paper.remove(), n.elWrap = null, n.elGraphical = null, n.elLegendWrap = null, n.elLegendForeign = null, n.baseEl = null, n.elGridRect = null, n.elGridRectMask = null, n.elGridRectBarMask = null, n.elGridRectMarkerMask = null, n.elForecastMask = null, n.elNonForecastMask = null, n.elDefs = null;
  } }]), s;
}(), zr = /* @__PURE__ */ new WeakMap(), _d = function() {
  function s(e, t) {
    te(this, s), this.opts = t, this.ctx = this, this.w = new ed(t).init(), this.el = e, this.w.globals.cuid = F.randomId(), this.w.globals.chartID = this.w.config.chart.id ? F.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new sn(this).initModules(), this.lastUpdateOptions = null, this.create = F.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return ie(s, [{ key: "render", value: function() {
    var e = this;
    return new Promise(function(t, i) {
      if (F.elementExists(e.el)) {
        Apex._chartInstances === void 0 && (Apex._chartInstances = []), e.w.config.chart.id && Apex._chartInstances.push({ id: e.w.globals.chartID, group: e.w.config.chart.group, chart: e }), e.setLocale(e.w.config.chart.defaultLocale);
        var r = e.w.config.chart.events.beforeMount;
        typeof r == "function" && r(e, e.w), e.events.fireEvent("beforeMount", [e, e.w]), window.addEventListener("resize", e.windowResizeHandler), function(u, g) {
          var p = !1;
          if (u.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var f = u.getBoundingClientRect();
            u.style.display !== "none" && f.width !== 0 || (p = !0);
          }
          var x = new ResizeObserver(function(m) {
            p && g.call(u, m), p = !0;
          });
          u.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(u.children).forEach(function(m) {
            return x.observe(m);
          }) : x.observe(u), zr.set(g, x);
        }(e.el.parentNode, e.parentResizeHandler);
        var a = e.el.getRootNode && e.el.getRootNode(), n = F.is("ShadowRoot", a), o = e.el.ownerDocument, l = n ? a.getElementById("apexcharts-css") : o.getElementById("apexcharts-css");
        if (!l) {
          var c;
          (l = document.createElement("style")).id = "apexcharts-css", l.textContent = `@keyframes opaque {
  0% {
    opacity: 0
  }

  to {
    opacity: 1
  }
}

@keyframes resizeanim {

  0%,
  to {
    opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  direction: ltr !important;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0, 0, 0, .5);
  box-shadow: 0 0 1px rgba(255, 255, 255, .5);
  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

rect.legend-mouseover-inactive,
.legend-mouseover-inactive rect,
.legend-mouseover-inactive path,
.legend-mouseover-inactive circle,
.legend-mouseover-inactive line,
.legend-mouseover-inactive text.apexcharts-yaxis-title-text,
.legend-mouseover-inactive text.apexcharts-yaxis-label {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255, 255, 255, .96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30, 30, 30, .8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0, 0, 0, .7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,
.apexcharts-tooltip-text-y-value,
.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,
.apexcharts-tooltip-text-goals-value:empty,
.apexcharts-tooltip-text-y-label:empty,
.apexcharts-tooltip-text-y-value:empty,
.apexcharts-tooltip-text-z-value:empty,
.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,
.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,
.apexcharts-tooltip-text-goals-label,
.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),
.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  display: inline-block;
  position: relative;
  width: 16px;
  height: 16px;
  font-size: 16px;
  line-height: 16px;
  margin-right: 4px;
  text-align: center;
  vertical-align: middle;
  color: inherit;
}

.apexcharts-tooltip-marker::before {
  content: "";
  display: inline-block;
  width: 100%;
  text-align: center;
  color: currentcolor;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  font-size: 26px;
  font-family: Arial, Helvetica, sans-serif;
  line-height: 14px;
  font-weight: 900;
}

.apexcharts-tooltip-marker[shape="circle"]::before {
  content: "\\25CF";
}

.apexcharts-tooltip-marker[shape="square"]::before,
.apexcharts-tooltip-marker[shape="rect"]::before {
  content: "\\25A0";
  transform: translate(-1px, -2px);
}

.apexcharts-tooltip-marker[shape="line"]::before {
  content: "\\2500";
}

.apexcharts-tooltip-marker[shape="diamond"]::before {
  content: "\\25C6";
  font-size: 28px;
}

.apexcharts-tooltip-marker[shape="triangle"]::before {
  content: "\\25B2";
  font-size: 22px;
}

.apexcharts-tooltip-marker[shape="cross"]::before {
  content: "\\2715";
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="plus"]::before {
  content: "\\2715";
  transform: rotate(45deg) translate(-1px, -1px);
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="star"]::before {
  content: "\\2605";
  font-size: 18px;
}

.apexcharts-tooltip-marker[shape="sparkle"]::before {
  content: "\\2726";
  font-size: 20px;
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,
.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,
.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,
.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0, 0, 0, .7);
  border: 1px solid rgba(0, 0, 0, .5);
  color: #fff
}

.apexcharts-xaxistooltip:after,
.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,
.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,
.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,
.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0, 0, 0, .5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,
.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0, 0, 0, .5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0, 0, 0, .7);
  border: 1px solid rgba(0, 0, 0, .5);
  color: #fff
}

.apexcharts-yaxistooltip:after,
.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,
.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,
.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,
.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0, 0, 0, .5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,
.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0, 0, 0, .5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,
.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,
.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_shape {
  stroke-width: 1;
  stroke-dasharray: 10 10;
  stroke: black;
  stroke-opacity: 0.1;
  pointer-events: none;
  fill: none;
}

.svg_select_handle {
  stroke-width: 3;
  stroke: black;
  fill: none;
}

.svg_select_handle_r {
  cursor: e-resize;
}

.svg_select_handle_l {
  cursor: w-resize;
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,
.apexcharts-pan-icon,
.apexcharts-reset-icon,
.apexcharts-selection-icon,
.apexcharts-toolbar-custom-icon,
.apexcharts-zoom-icon,
.apexcharts-zoomin-icon,
.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,
.apexcharts-reset-icon svg,
.apexcharts-zoom-icon svg,
.apexcharts-zoomin-icon svg,
.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,
.apexcharts-theme-dark .apexcharts-pan-icon svg,
.apexcharts-theme-dark .apexcharts-reset-icon svg,
.apexcharts-theme-dark .apexcharts-selection-icon svg,
.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,
.apexcharts-theme-dark .apexcharts-zoom-icon svg,
.apexcharts-theme-dark .apexcharts-zoomin-icon svg,
.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,
.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,
.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,
.apexcharts-theme-light .apexcharts-reset-icon:hover svg,
.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,
.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,
.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,
.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,
.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,
.apexcharts-reset-icon,
.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,
.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0, 0, 0, .7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
    opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,
.apexcharts-datalabel.apexcharts-element-hidden,
.apexcharts-hide .apexcharts-series-points {
  opacity: 0;
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}

.apexcharts-datalabel,
.apexcharts-datalabel-label,
.apexcharts-datalabel-value,
.apexcharts-datalabels,
.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-radialbar-label {
  cursor: pointer;
}

.apexcharts-annotation-rect,
.apexcharts-area-series .apexcharts-area,
.apexcharts-gridline,
.apexcharts-line,
.apexcharts-point-annotation-label,
.apexcharts-radar-series path:not(.apexcharts-marker),
.apexcharts-radar-series polygon,
.apexcharts-toolbar svg,
.apexcharts-tooltip .apexcharts-marker,
.apexcharts-xaxis-annotation-label,
.apexcharts-yaxis-annotation-label,
.apexcharts-zoom-rect,
.no-pointer-events {
  pointer-events: none
}

.apexcharts-tooltip-active .apexcharts-marker {
  transition: .15s ease all
}

.apexcharts-radar-series .apexcharts-yaxis {
  pointer-events: none;
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,
.resize-triggers,
.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers {
  pointer-events: none
}

.apexcharts-bar-shadows {
  pointer-events: none
}

.apexcharts-rangebar-goals-markers {
  pointer-events: none
}

.apexcharts-disable-transitions * {
  transition: none !important;
}`;
          var h = ((c = e.opts.chart) === null || c === void 0 ? void 0 : c.nonce) || e.w.config.chart.nonce;
          h && l.setAttribute("nonce", h), n ? a.prepend(l) : o.head.appendChild(l);
        }
        var d = e.create(e.w.config.series, {});
        if (!d) return t(e);
        e.mount(d).then(function() {
          typeof e.w.config.chart.events.mounted == "function" && e.w.config.chart.events.mounted(e, e.w), e.events.fireEvent("mounted", [e, e.w]), t(d);
        }).catch(function(u) {
          i(u);
        });
      } else i(new Error("Element not found"));
    });
  } }, { key: "create", value: function(e, t) {
    var i = this, r = this.w;
    new sn(this).initModules();
    var a = this.w.globals;
    if (a.noData = !1, a.animationEnded = !1, !F.elementExists(this.el) || (this.responsive.checkResponsiveConfig(t), r.config.xaxis.convertedCatToNumeric && new Ai(r.config).convertCatToNumericXaxis(r.config, this.ctx), this.core.setupElements(), r.config.chart.type === "treemap" && (r.config.grid.show = !1, r.config.yaxis[0].show = !1), a.svgWidth === 0)) return a.animationEnded = !0, null;
    var n = e;
    e.forEach(function(u, g) {
      u.hidden && (n = i.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: g }));
    });
    var o = ze.checkComboSeries(n, r.config.chart.type);
    a.comboCharts = o.comboCharts, a.comboBarCount = o.comboBarCount;
    var l = n.every(function(u) {
      return u.data && u.data.length === 0;
    });
    (n.length === 0 || l && a.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(n), this.theme.init(), new ni(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length && !r.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), r.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = r.globals.minX, this.ctx.toolbar.maxX = r.globals.maxX), this.formatters.heatmapLabelFormatters(), new ze(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var c = this.core.xySettings();
    this.grid.createGridMask();
    var h = this.core.plotChartType(n, c), d = new Jt(this);
    return d.bringForward(), r.config.dataLabels.background.enabled && d.dataLabelsBackground(), this.core.shiftGraphPosition(), r.globals.dataPoints > 50 && r.globals.dom.elWrap.classList.add("apexcharts-disable-transitions"), { elGraph: h, xyRatios: c, dimensions: { plot: { left: r.globals.translateX, top: r.globals.translateY, width: r.globals.gridWidth, height: r.globals.gridHeight } } };
  } }, { key: "mount", value: function() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i = this, r = i.w;
    return new Promise(function(a, n) {
      if (i.el === null) return n(new Error("Not enough data to display or target element not found"));
      (t === null || r.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new Ro(i);
      var o, l, c = i.grid.drawGrid();
      if (i.annotations = new Qh(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), r.config.grid.position === "back" && (c && r.globals.dom.elGraphical.add(c.el), c != null && (o = c.elGridBorders) !== null && o !== void 0 && o.node && r.globals.dom.elGraphical.add(c.elGridBorders)), Array.isArray(t.elGraph)) for (var h = 0; h < t.elGraph.length; h++) r.globals.dom.elGraphical.add(t.elGraph[h]);
      else r.globals.dom.elGraphical.add(t.elGraph);
      r.config.grid.position === "front" && (c && r.globals.dom.elGraphical.add(c.el), c != null && (l = c.elGridBorders) !== null && l !== void 0 && l.node && r.globals.dom.elGraphical.add(c.elGridBorders)), r.config.xaxis.crosshairs.position === "front" && i.crosshairs.drawXCrosshairs(), r.config.yaxis[0].crosshairs.position === "front" && i.crosshairs.drawYCrosshairs(), r.config.chart.type !== "treemap" && i.axes.drawAxis(r.config.chart.type, c);
      var d = new Ri(e.ctx, c), u = new ta(e.ctx, c);
      if (c !== null && (d.xAxisLabelCorrections(c.xAxisTickWidth), u.setYAxisTextAlignments(), r.config.yaxis.map(function(p, f) {
        r.globals.ignoreYAxisIndexes.indexOf(f) === -1 && u.yAxisTitleRotate(f, p.opposite);
      })), i.annotations.drawAxesAnnotations(), !r.globals.noData) {
        if (r.config.tooltip.enabled && !r.globals.noData && i.w.globals.tooltip.drawTooltip(t.xyRatios), r.globals.axisCharts && (r.globals.isXNumeric || r.config.xaxis.convertedCatToNumeric || r.globals.isRangeBar)) (r.config.chart.zoom.enabled || r.config.chart.selection && r.config.chart.selection.enabled || r.config.chart.pan && r.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: t.xyRatios });
        else {
          var g = r.config.chart.toolbar.tools;
          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(p) {
            g[p] = !1;
          });
        }
        r.config.chart.toolbar.show && !r.globals.allSeriesCollapsed && i.toolbar.createToolbar();
      }
      r.globals.memory.methodsToExec.length > 0 && r.globals.memory.methodsToExec.forEach(function(p) {
        p.method(p.params, !1, p.context);
      }), r.globals.axisCharts || r.globals.noData || i.core.resizeNonAxisCharts(), a(i);
    });
  } }, { key: "destroy", value: function() {
    window.removeEventListener("resize", this.windowResizeHandler), function(t, i) {
      var r = zr.get(i);
      r && (r.disconnect(), zr.delete(i));
    }(this.el.parentNode, this.parentResizeHandler);
    var e = this.w.config.chart.id;
    e && Apex._chartInstances.forEach(function(t, i) {
      t.id === F.escapeString(e) && Apex._chartInstances.splice(i, 1);
    }), new an(this.ctx).clear({ isUpdating: !1 });
  } }, { key: "updateOptions", value: function(e) {
    var t = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], r = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], a = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], n = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], o = this.w;
    return o.globals.selection = void 0, this.lastUpdateOptions && JSON.stringify(this.lastUpdateOptions) === JSON.stringify(e) ? this : (this.lastUpdateOptions = F.clone(e), e.series && (this.series.resetSeries(!1, !0, !1), e.series.length && e.series[0].data && (e.series = e.series.map(function(l, c) {
      return t.updateHelpers._extendSeries(l, c);
    })), this.updateHelpers.revertDefaultAxisMinMax()), e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)), e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)), o.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), e.theme && (e = this.theme.updateThemeOptions(e)), this.updateHelpers._updateOptions(e, i, r, a, n));
  } }, { key: "updateSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
    return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(e, t, i);
  } }, { key: "appendSeries", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], r = this.w.config.series.slice();
    return r.push(e), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(r, t, i);
  } }, { key: "appendData", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this;
    i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
    for (var r = i.w.config.series.slice(), a = 0; a < r.length; a++) if (e[a] !== null && e[a] !== void 0) for (var n = 0; n < e[a].data.length; n++) r[a].data.push(e[a].data[n]);
    return i.w.config.series = r, t && (i.w.globals.initialSeries = F.clone(i.w.config.series)), this.update();
  } }, { key: "update", value: function(e) {
    var t = this;
    return new Promise(function(i, r) {
      if (t.lastUpdateOptions && JSON.stringify(t.lastUpdateOptions) === JSON.stringify(e)) return i(t);
      t.lastUpdateOptions = F.clone(e), new an(t.ctx).clear({ isUpdating: !0 });
      var a = t.create(t.w.config.series, e);
      if (!a) return i(t);
      t.mount(a).then(function() {
        typeof t.w.config.chart.events.updated == "function" && t.w.config.chart.events.updated(t, t.w), t.events.fireEvent("updated", [t, t.w]), t.w.globals.isDirty = !0, i(t);
      }).catch(function(n) {
        r(n);
      });
    });
  } }, { key: "getSyncedCharts", value: function() {
    var e = this.getGroupedCharts(), t = [this];
    return e.length && (t = [], e.forEach(function(i) {
      t.push(i);
    })), t;
  } }, { key: "getGroupedCharts", value: function() {
    var e = this;
    return Apex._chartInstances.filter(function(t) {
      if (t.group) return !0;
    }).map(function(t) {
      return e.w.config.chart.group === t.group ? t.chart : e;
    });
  } }, { key: "toggleSeries", value: function(e) {
    return this.series.toggleSeries(e);
  } }, { key: "highlightSeriesOnLegendHover", value: function(e, t) {
    return this.series.toggleSeriesOnHover(e, t);
  } }, { key: "showSeries", value: function(e) {
    this.series.showSeries(e);
  } }, { key: "hideSeries", value: function(e) {
    this.series.hideSeries(e);
  } }, { key: "highlightSeries", value: function(e) {
    this.series.highlightSeries(e);
  } }, { key: "isSeriesHidden", value: function(e) {
    this.series.isSeriesHidden(e);
  } }, { key: "resetSeries", value: function() {
    var e = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    this.series.resetSeries(e, t);
  } }, { key: "addEventListener", value: function(e, t) {
    this.events.addEventListener(e, t);
  } }, { key: "removeEventListener", value: function(e, t) {
    this.events.removeEventListener(e, t);
  } }, { key: "addXaxisAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, r = this;
    i && (r = i), r.annotations.addXaxisAnnotationExternal(e, t, r);
  } }, { key: "addYaxisAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, r = this;
    i && (r = i), r.annotations.addYaxisAnnotationExternal(e, t, r);
  } }, { key: "addPointAnnotation", value: function(e) {
    var t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, r = this;
    i && (r = i), r.annotations.addPointAnnotationExternal(e, t, r);
  } }, { key: "clearAnnotations", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, t = this;
    e && (t = e), t.annotations.clearAnnotations(t);
  } }, { key: "removeAnnotation", value: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i = this;
    t && (i = t), i.annotations.removeAnnotation(i, e);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(e, t) {
    return this.coreUtils.getSeriesTotalsXRange(e, t);
  } }, { key: "getHighestValueInSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new ks(this.ctx).getMinYMaxY(e).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new ks(this.ctx).getMinYMaxY(e).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "toggleDataPointSelection", value: function(e, t) {
    return this.updateHelpers.toggleDataPointSelection(e, t);
  } }, { key: "zoomX", value: function(e, t) {
    this.ctx.toolbar.zoomUpdateOptions(e, t);
  } }, { key: "setLocale", value: function(e) {
    this.localization.setCurrentLocaleValues(e);
  } }, { key: "dataURI", value: function(e) {
    return new bi(this.ctx).dataURI(e);
  } }, { key: "getSvgString", value: function(e) {
    return new bi(this.ctx).getSvgString(e);
  } }, { key: "exportToCSV", value: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new bi(this.ctx).exportToCSV(e);
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "_parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  } }, { key: "_windowResize", value: function() {
    var e = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      e.w.globals.resized = !0, e.w.globals.dataChanged = !1, e.ctx.update();
    }, 150);
  } }, { key: "_windowResizeHandler", value: function() {
    var e = this.w.config.chart.redrawOnWindowResize;
    typeof e == "function" && (e = e()), e && this._windowResize();
  } }], [{ key: "getChartByID", value: function(e) {
    var t = F.escapeString(e);
    if (Apex._chartInstances) {
      var i = Apex._chartInstances.filter(function(r) {
        return r.id === t;
      })[0];
      return i && i.chart;
    }
  } }, { key: "initOnLoad", value: function() {
    for (var e = document.querySelectorAll("[data-apexcharts]"), t = 0; t < e.length; t++)
      new s(e[t], JSON.parse(e[t].getAttribute("data-options"))).render();
  } }, { key: "exec", value: function(e, t) {
    var i = this.getChartByID(e);
    if (i) {
      i.w.globals.isExecCalled = !0;
      var r = null;
      if (i.publicMethods.indexOf(t) !== -1) {
        for (var a = arguments.length, n = new Array(a > 2 ? a - 2 : 0), o = 2; o < a; o++) n[o - 2] = arguments[o];
        r = i[t].apply(i, n);
      }
      return r;
    }
  } }, { key: "merge", value: function(e, t) {
    return F.extend(e, t);
  } }]), s;
}();
const Od = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _d
}, Symbol.toStringTag, { value: "Module" })), zd = /* @__PURE__ */ El(Od);
var Ps = { exports: {} }, Hi = { exports: {} }, ke = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nn;
function Fd() {
  if (nn) return ke;
  nn = 1;
  var s = typeof Symbol == "function" && Symbol.for, e = s ? Symbol.for("react.element") : 60103, t = s ? Symbol.for("react.portal") : 60106, i = s ? Symbol.for("react.fragment") : 60107, r = s ? Symbol.for("react.strict_mode") : 60108, a = s ? Symbol.for("react.profiler") : 60114, n = s ? Symbol.for("react.provider") : 60109, o = s ? Symbol.for("react.context") : 60110, l = s ? Symbol.for("react.async_mode") : 60111, c = s ? Symbol.for("react.concurrent_mode") : 60111, h = s ? Symbol.for("react.forward_ref") : 60112, d = s ? Symbol.for("react.suspense") : 60113, u = s ? Symbol.for("react.suspense_list") : 60120, g = s ? Symbol.for("react.memo") : 60115, p = s ? Symbol.for("react.lazy") : 60116, f = s ? Symbol.for("react.block") : 60121, x = s ? Symbol.for("react.fundamental") : 60117, m = s ? Symbol.for("react.responder") : 60118, b = s ? Symbol.for("react.scope") : 60119;
  function w(v) {
    if (typeof v == "object" && v !== null) {
      var k = v.$$typeof;
      switch (k) {
        case e:
          switch (v = v.type, v) {
            case l:
            case c:
            case i:
            case a:
            case r:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case o:
                case h:
                case p:
                case g:
                case n:
                  return v;
                default:
                  return k;
              }
          }
        case t:
          return k;
      }
    }
  }
  function y(v) {
    return w(v) === c;
  }
  return ke.AsyncMode = l, ke.ConcurrentMode = c, ke.ContextConsumer = o, ke.ContextProvider = n, ke.Element = e, ke.ForwardRef = h, ke.Fragment = i, ke.Lazy = p, ke.Memo = g, ke.Portal = t, ke.Profiler = a, ke.StrictMode = r, ke.Suspense = d, ke.isAsyncMode = function(v) {
    return y(v) || w(v) === l;
  }, ke.isConcurrentMode = y, ke.isContextConsumer = function(v) {
    return w(v) === o;
  }, ke.isContextProvider = function(v) {
    return w(v) === n;
  }, ke.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, ke.isForwardRef = function(v) {
    return w(v) === h;
  }, ke.isFragment = function(v) {
    return w(v) === i;
  }, ke.isLazy = function(v) {
    return w(v) === p;
  }, ke.isMemo = function(v) {
    return w(v) === g;
  }, ke.isPortal = function(v) {
    return w(v) === t;
  }, ke.isProfiler = function(v) {
    return w(v) === a;
  }, ke.isStrictMode = function(v) {
    return w(v) === r;
  }, ke.isSuspense = function(v) {
    return w(v) === d;
  }, ke.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === i || v === c || v === a || v === r || v === d || v === u || typeof v == "object" && v !== null && (v.$$typeof === p || v.$$typeof === g || v.$$typeof === n || v.$$typeof === o || v.$$typeof === h || v.$$typeof === x || v.$$typeof === m || v.$$typeof === b || v.$$typeof === f);
  }, ke.typeOf = w, ke;
}
var Se = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var on;
function Nd() {
  return on || (on = 1, process.env.NODE_ENV !== "production" && function() {
    var s = typeof Symbol == "function" && Symbol.for, e = s ? Symbol.for("react.element") : 60103, t = s ? Symbol.for("react.portal") : 60106, i = s ? Symbol.for("react.fragment") : 60107, r = s ? Symbol.for("react.strict_mode") : 60108, a = s ? Symbol.for("react.profiler") : 60114, n = s ? Symbol.for("react.provider") : 60109, o = s ? Symbol.for("react.context") : 60110, l = s ? Symbol.for("react.async_mode") : 60111, c = s ? Symbol.for("react.concurrent_mode") : 60111, h = s ? Symbol.for("react.forward_ref") : 60112, d = s ? Symbol.for("react.suspense") : 60113, u = s ? Symbol.for("react.suspense_list") : 60120, g = s ? Symbol.for("react.memo") : 60115, p = s ? Symbol.for("react.lazy") : 60116, f = s ? Symbol.for("react.block") : 60121, x = s ? Symbol.for("react.fundamental") : 60117, m = s ? Symbol.for("react.responder") : 60118, b = s ? Symbol.for("react.scope") : 60119;
    function w(q) {
      return typeof q == "string" || typeof q == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      q === i || q === c || q === a || q === r || q === d || q === u || typeof q == "object" && q !== null && (q.$$typeof === p || q.$$typeof === g || q.$$typeof === n || q.$$typeof === o || q.$$typeof === h || q.$$typeof === x || q.$$typeof === m || q.$$typeof === b || q.$$typeof === f);
    }
    function y(q) {
      if (typeof q == "object" && q !== null) {
        var ne = q.$$typeof;
        switch (ne) {
          case e:
            var _e = q.type;
            switch (_e) {
              case l:
              case c:
              case i:
              case a:
              case r:
              case d:
                return _e;
              default:
                var Be = _e && _e.$$typeof;
                switch (Be) {
                  case o:
                  case h:
                  case p:
                  case g:
                  case n:
                    return Be;
                  default:
                    return ne;
                }
            }
          case t:
            return ne;
        }
      }
    }
    var v = l, k = c, S = o, C = n, M = e, R = h, P = i, I = p, D = g, N = t, z = a, L = r, T = d, H = !1;
    function B(q) {
      return H || (H = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(q) || y(q) === l;
    }
    function _(q) {
      return y(q) === c;
    }
    function O(q) {
      return y(q) === o;
    }
    function Y(q) {
      return y(q) === n;
    }
    function X(q) {
      return typeof q == "object" && q !== null && q.$$typeof === e;
    }
    function V(q) {
      return y(q) === h;
    }
    function W(q) {
      return y(q) === i;
    }
    function G(q) {
      return y(q) === p;
    }
    function U(q) {
      return y(q) === g;
    }
    function Z(q) {
      return y(q) === t;
    }
    function re(q) {
      return y(q) === a;
    }
    function ee(q) {
      return y(q) === r;
    }
    function de(q) {
      return y(q) === d;
    }
    Se.AsyncMode = v, Se.ConcurrentMode = k, Se.ContextConsumer = S, Se.ContextProvider = C, Se.Element = M, Se.ForwardRef = R, Se.Fragment = P, Se.Lazy = I, Se.Memo = D, Se.Portal = N, Se.Profiler = z, Se.StrictMode = L, Se.Suspense = T, Se.isAsyncMode = B, Se.isConcurrentMode = _, Se.isContextConsumer = O, Se.isContextProvider = Y, Se.isElement = X, Se.isForwardRef = V, Se.isFragment = W, Se.isLazy = G, Se.isMemo = U, Se.isPortal = Z, Se.isProfiler = re, Se.isStrictMode = ee, Se.isSuspense = de, Se.isValidElementType = w, Se.typeOf = y;
  }()), Se;
}
var ln;
function Ho() {
  return ln || (ln = 1, process.env.NODE_ENV === "production" ? Hi.exports = Fd() : Hi.exports = Nd()), Hi.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Fr, cn;
function Dd() {
  if (cn) return Fr;
  cn = 1;
  var s = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function i(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function r() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var n = {}, o = 0; o < 10; o++)
        n["_" + String.fromCharCode(o)] = o;
      var l = Object.getOwnPropertyNames(n).map(function(h) {
        return n[h];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(h) {
        c[h] = h;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Fr = r() ? Object.assign : function(a, n) {
    for (var o, l = i(a), c, h = 1; h < arguments.length; h++) {
      o = Object(arguments[h]);
      for (var d in o)
        e.call(o, d) && (l[d] = o[d]);
      if (s) {
        c = s(o);
        for (var u = 0; u < c.length; u++)
          t.call(o, c[u]) && (l[c[u]] = o[c[u]]);
      }
    }
    return l;
  }, Fr;
}
var Nr, hn;
function ia() {
  if (hn) return Nr;
  hn = 1;
  var s = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Nr = s, Nr;
}
var Dr, dn;
function jo() {
  return dn || (dn = 1, Dr = Function.call.bind(Object.prototype.hasOwnProperty)), Dr;
}
var Hr, un;
function Hd() {
  if (un) return Hr;
  un = 1;
  var s = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = ia(), t = {}, i = jo();
    s = function(a) {
      var n = "Warning: " + a;
      typeof console < "u" && console.error(n);
      try {
        throw new Error(n);
      } catch {
      }
    };
  }
  function r(a, n, o, l, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var h in a)
        if (i(a, h)) {
          var d;
          try {
            if (typeof a[h] != "function") {
              var u = Error(
                (l || "React class") + ": " + o + " type `" + h + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[h] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw u.name = "Invariant Violation", u;
            }
            d = a[h](n, h, l, o, null, e);
          } catch (p) {
            d = p;
          }
          if (d && !(d instanceof Error) && s(
            (l || "React class") + ": type specification of " + o + " `" + h + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in t)) {
            t[d.message] = !0;
            var g = c ? c() : "";
            s(
              "Failed " + o + " type: " + d.message + (g ?? "")
            );
          }
        }
    }
  }
  return r.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, Hr = r, Hr;
}
var jr, gn;
function jd() {
  if (gn) return jr;
  gn = 1;
  var s = Ho(), e = Dd(), t = ia(), i = jo(), r = Hd(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(o) {
    var l = "Warning: " + o;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function n() {
    return null;
  }
  return jr = function(o, l) {
    var c = typeof Symbol == "function" && Symbol.iterator, h = "@@iterator";
    function d(_) {
      var O = _ && (c && _[c] || _[h]);
      if (typeof O == "function")
        return O;
    }
    var u = "<<anonymous>>", g = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: b(),
      arrayOf: w,
      element: y(),
      elementType: v(),
      instanceOf: k,
      node: R(),
      objectOf: C,
      oneOf: S,
      oneOfType: M,
      shape: I,
      exact: D
    };
    function p(_, O) {
      return _ === O ? _ !== 0 || 1 / _ === 1 / O : _ !== _ && O !== O;
    }
    function f(_, O) {
      this.message = _, this.data = O && typeof O == "object" ? O : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function x(_) {
      if (process.env.NODE_ENV !== "production")
        var O = {}, Y = 0;
      function X(W, G, U, Z, re, ee, de) {
        if (Z = Z || u, ee = ee || U, de !== t) {
          if (l) {
            var q = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw q.name = "Invariant Violation", q;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ne = Z + ":" + U;
            !O[ne] && // Avoid spamming the console because they are often not actionable except for lib authors
            Y < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + ee + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), O[ne] = !0, Y++);
          }
        }
        return G[U] == null ? W ? G[U] === null ? new f("The " + re + " `" + ee + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new f("The " + re + " `" + ee + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : _(G, U, Z, re, ee);
      }
      var V = X.bind(null, !1);
      return V.isRequired = X.bind(null, !0), V;
    }
    function m(_) {
      function O(Y, X, V, W, G, U) {
        var Z = Y[X], re = L(Z);
        if (re !== _) {
          var ee = T(Z);
          return new f(
            "Invalid " + W + " `" + G + "` of type " + ("`" + ee + "` supplied to `" + V + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return x(O);
    }
    function b() {
      return x(n);
    }
    function w(_) {
      function O(Y, X, V, W, G) {
        if (typeof _ != "function")
          return new f("Property `" + G + "` of component `" + V + "` has invalid PropType notation inside arrayOf.");
        var U = Y[X];
        if (!Array.isArray(U)) {
          var Z = L(U);
          return new f("Invalid " + W + " `" + G + "` of type " + ("`" + Z + "` supplied to `" + V + "`, expected an array."));
        }
        for (var re = 0; re < U.length; re++) {
          var ee = _(U, re, V, W, G + "[" + re + "]", t);
          if (ee instanceof Error)
            return ee;
        }
        return null;
      }
      return x(O);
    }
    function y() {
      function _(O, Y, X, V, W) {
        var G = O[Y];
        if (!o(G)) {
          var U = L(G);
          return new f("Invalid " + V + " `" + W + "` of type " + ("`" + U + "` supplied to `" + X + "`, expected a single ReactElement."));
        }
        return null;
      }
      return x(_);
    }
    function v() {
      function _(O, Y, X, V, W) {
        var G = O[Y];
        if (!s.isValidElementType(G)) {
          var U = L(G);
          return new f("Invalid " + V + " `" + W + "` of type " + ("`" + U + "` supplied to `" + X + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return x(_);
    }
    function k(_) {
      function O(Y, X, V, W, G) {
        if (!(Y[X] instanceof _)) {
          var U = _.name || u, Z = B(Y[X]);
          return new f("Invalid " + W + " `" + G + "` of type " + ("`" + Z + "` supplied to `" + V + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return x(O);
    }
    function S(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), n;
      function O(Y, X, V, W, G) {
        for (var U = Y[X], Z = 0; Z < _.length; Z++)
          if (p(U, _[Z]))
            return null;
        var re = JSON.stringify(_, function(de, q) {
          var ne = T(q);
          return ne === "symbol" ? String(q) : q;
        });
        return new f("Invalid " + W + " `" + G + "` of value `" + String(U) + "` " + ("supplied to `" + V + "`, expected one of " + re + "."));
      }
      return x(O);
    }
    function C(_) {
      function O(Y, X, V, W, G) {
        if (typeof _ != "function")
          return new f("Property `" + G + "` of component `" + V + "` has invalid PropType notation inside objectOf.");
        var U = Y[X], Z = L(U);
        if (Z !== "object")
          return new f("Invalid " + W + " `" + G + "` of type " + ("`" + Z + "` supplied to `" + V + "`, expected an object."));
        for (var re in U)
          if (i(U, re)) {
            var ee = _(U, re, V, W, G + "." + re, t);
            if (ee instanceof Error)
              return ee;
          }
        return null;
      }
      return x(O);
    }
    function M(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), n;
      for (var O = 0; O < _.length; O++) {
        var Y = _[O];
        if (typeof Y != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H(Y) + " at index " + O + "."
          ), n;
      }
      function X(V, W, G, U, Z) {
        for (var re = [], ee = 0; ee < _.length; ee++) {
          var de = _[ee], q = de(V, W, G, U, Z, t);
          if (q == null)
            return null;
          q.data && i(q.data, "expectedType") && re.push(q.data.expectedType);
        }
        var ne = re.length > 0 ? ", expected one of type [" + re.join(", ") + "]" : "";
        return new f("Invalid " + U + " `" + Z + "` supplied to " + ("`" + G + "`" + ne + "."));
      }
      return x(X);
    }
    function R() {
      function _(O, Y, X, V, W) {
        return N(O[Y]) ? null : new f("Invalid " + V + " `" + W + "` supplied to " + ("`" + X + "`, expected a ReactNode."));
      }
      return x(_);
    }
    function P(_, O, Y, X, V) {
      return new f(
        (_ || "React class") + ": " + O + " type `" + Y + "." + X + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + V + "`."
      );
    }
    function I(_) {
      function O(Y, X, V, W, G) {
        var U = Y[X], Z = L(U);
        if (Z !== "object")
          return new f("Invalid " + W + " `" + G + "` of type `" + Z + "` " + ("supplied to `" + V + "`, expected `object`."));
        for (var re in _) {
          var ee = _[re];
          if (typeof ee != "function")
            return P(V, W, G, re, T(ee));
          var de = ee(U, re, V, W, G + "." + re, t);
          if (de)
            return de;
        }
        return null;
      }
      return x(O);
    }
    function D(_) {
      function O(Y, X, V, W, G) {
        var U = Y[X], Z = L(U);
        if (Z !== "object")
          return new f("Invalid " + W + " `" + G + "` of type `" + Z + "` " + ("supplied to `" + V + "`, expected `object`."));
        var re = e({}, Y[X], _);
        for (var ee in re) {
          var de = _[ee];
          if (i(_, ee) && typeof de != "function")
            return P(V, W, G, ee, T(de));
          if (!de)
            return new f(
              "Invalid " + W + " `" + G + "` key `" + ee + "` supplied to `" + V + "`.\nBad object: " + JSON.stringify(Y[X], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var q = de(U, ee, V, W, G + "." + ee, t);
          if (q)
            return q;
        }
        return null;
      }
      return x(O);
    }
    function N(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(N);
          if (_ === null || o(_))
            return !0;
          var O = d(_);
          if (O) {
            var Y = O.call(_), X;
            if (O !== _.entries) {
              for (; !(X = Y.next()).done; )
                if (!N(X.value))
                  return !1;
            } else
              for (; !(X = Y.next()).done; ) {
                var V = X.value;
                if (V && !N(V[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function z(_, O) {
      return _ === "symbol" ? !0 : O ? O["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && O instanceof Symbol : !1;
    }
    function L(_) {
      var O = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : z(O, _) ? "symbol" : O;
    }
    function T(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var O = L(_);
      if (O === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return O;
    }
    function H(_) {
      var O = T(_);
      switch (O) {
        case "array":
        case "object":
          return "an " + O;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + O;
        default:
          return O;
      }
    }
    function B(_) {
      return !_.constructor || !_.constructor.name ? u : _.constructor.name;
    }
    return g.checkPropTypes = r, g.resetWarningCache = r.resetWarningCache, g.PropTypes = g, g;
  }, jr;
}
var Yr, fn;
function Yd() {
  if (fn) return Yr;
  fn = 1;
  var s = ia();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, Yr = function() {
    function i(n, o, l, c, h, d) {
      if (d !== s) {
        var u = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw u.name = "Invariant Violation", u;
      }
    }
    i.isRequired = i;
    function r() {
      return i;
    }
    var a = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: r,
      element: i,
      elementType: i,
      instanceOf: r,
      node: i,
      objectOf: r,
      oneOf: r,
      oneOfType: r,
      shape: r,
      exact: r,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return a.PropTypes = a, a;
  }, Yr;
}
if (process.env.NODE_ENV !== "production") {
  var Xd = Ho(), Bd = !0;
  Ps.exports = jd()(Xd.isElement, Bd);
} else
  Ps.exports = Yd()();
var Wd = Ps.exports;
(function(s) {
  Object.defineProperty(s, "__esModule", { value: !0 }), s.default = w;
  var e = o(He), t = a(zd), i = a(Wd), r = ["type", "width", "height", "series", "options"];
  function a(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function n(y) {
    var v, k;
    return typeof WeakMap != "function" ? null : (v = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), (n = function(S) {
      return S ? k : v;
    })(y));
  }
  function o(y, v) {
    if (!v && y && y.__esModule) return y;
    if (y === null || d(y) != "object" && typeof y != "function") return { default: y };
    if (v = n(v), v && v.has(y)) return v.get(y);
    var k, S, C = { __proto__: null }, M = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (k in y) k !== "default" && {}.hasOwnProperty.call(y, k) && ((S = M ? Object.getOwnPropertyDescriptor(y, k) : null) && (S.get || S.set) ? Object.defineProperty(C, k, S) : C[k] = y[k]);
    return C.default = y, v && v.set(y, C), C;
  }
  function l() {
    return (l = Object.assign ? Object.assign.bind() : function(y) {
      for (var v = 1; v < arguments.length; v++) {
        var k, S = arguments[v];
        for (k in S) !{}.hasOwnProperty.call(S, k) || (y[k] = S[k]);
      }
      return y;
    }).apply(null, arguments);
  }
  function c(y, v) {
    if (y == null) return {};
    var k, S = h(y, v);
    if (Object.getOwnPropertySymbols) for (var C = Object.getOwnPropertySymbols(y), M = 0; M < C.length; M++) k = C[M], v.includes(k) || {}.propertyIsEnumerable.call(y, k) && (S[k] = y[k]);
    return S;
  }
  function h(y, v) {
    if (y == null) return {};
    var k, S = {};
    for (k in y) if ({}.hasOwnProperty.call(y, k)) {
      if (v.includes(k)) continue;
      S[k] = y[k];
    }
    return S;
  }
  function d(y) {
    return (d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(v) {
      return typeof v;
    } : function(v) {
      return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
    })(y);
  }
  function u(y, v) {
    var k, S = Object.keys(y);
    return Object.getOwnPropertySymbols && (k = Object.getOwnPropertySymbols(y), v && (k = k.filter(function(C) {
      return Object.getOwnPropertyDescriptor(y, C).enumerable;
    })), S.push.apply(S, k)), S;
  }
  function g(y) {
    for (var v = 1; v < arguments.length; v++) {
      var k = arguments[v] != null ? arguments[v] : {};
      v % 2 ? u(Object(k), !0).forEach(function(S) {
        p(y, S, k[S]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(k)) : u(Object(k)).forEach(function(S) {
        Object.defineProperty(y, S, Object.getOwnPropertyDescriptor(k, S));
      });
    }
    return y;
  }
  function p(y, v, k) {
    return (v = f(v)) in y ? Object.defineProperty(y, v, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : y[v] = k, y;
  }
  function f(y) {
    return y = x(y, "string"), d(y) == "symbol" ? y : y + "";
  }
  function x(y, v) {
    if (d(y) != "object" || !y) return y;
    var k = y[Symbol.toPrimitive];
    if (k === void 0) return (v === "string" ? String : Number)(y);
    if (k = k.call(y, v), d(k) != "object") return k;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  function m(y, v) {
    var k = g({}, y);
    return v.forEach(function(S) {
      delete k[S];
    }), k;
  }
  function b(y, v) {
    var k = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new WeakSet();
    if (y !== v) {
      if (d(y) !== "object" || y === null || d(v) !== "object" || v === null) return !1;
      if (!k.has(y) && !k.has(v)) {
        k.add(y), k.add(v);
        var S = Object.keys(y), C = Object.keys(v);
        if (S.length !== C.length) return !1;
        for (var M = 0, R = S; M < R.length; M++) {
          var P = R[M];
          if (!C.includes(P) || !b(y[P], v[P], k)) return !1;
        }
      }
    }
    return !0;
  }
  function w(T) {
    function v(H) {
      return H && d(H) === "object" && !Array.isArray(H);
    }
    var P = T.type, k = P === void 0 ? "line" : P, P = T.width, S = P === void 0 ? "100%" : P, P = T.height, C = P === void 0 ? "auto" : P, M = T.series, R = T.options, P = c(T, r), I = (0, e.useRef)(null), D = (0, e.useRef)(null), N = (0, e.useRef)(), z = ((0, e.useEffect)(function() {
      N.current = R;
      var H = I.current;
      return D.current = new t.default(H, z()), D.current.render(), function() {
        D.current && typeof D.current.destroy == "function" && D.current.destroy();
      };
    }, []), (0, e.useEffect)(function() {
      var H = !b(D.current.w.config.series, M), B = !b(N.current, R) || C !== D.current.opts.chart.height || S !== D.current.opts.chart.width;
      (H || B) && (!H || B ? D.current.updateOptions(z()) : D.current.updateSeries(M)), N.current = R;
    }, [R, M, C, S]), function() {
      return L(R, { chart: { type: k, height: C, width: S }, series: M });
    }), L = function(H, B) {
      var _ = g({}, H);
      return v(H) && v(B) && Object.keys(B).forEach(function(O) {
        v(B[O]) && O in H ? _[O] = L(H[O], B[O]) : Object.assign(_, p({}, O, B[O]));
      }), _;
    }, T = m(P, Object.keys(w.propTypes));
    return e.default.createElement("div", l({ ref: I }, T));
  }
  w.propTypes = { type: i.default.string.isRequired, series: i.default.array.isRequired, options: i.default.object.isRequired, width: i.default.oneOfType([i.default.string, i.default.number]), height: i.default.oneOfType([i.default.string, i.default.number]) };
})(Gn);
const Vd = /* @__PURE__ */ yn(Gn), pn = {
  chart: {
    toolbar: {
      show: !1
    },
    zoom: {
      enabled: !1
    }
  },
  colors: ["#3B82F6", "#10B981", "#F59E0B", "#EF4444", "#8B5CF6"],
  grid: {
    borderColor: "#E5E7EB",
    strokeDashArray: 4,
    xaxis: {
      lines: {
        show: !0
      }
    },
    yaxis: {
      lines: {
        show: !0
      }
    }
  },
  stroke: {
    curve: "smooth",
    width: 2
  },
  tooltip: {
    theme: "light",
    x: {
      show: !0
    }
  }
}, Ig = ({
  type: s,
  series: e,
  width: t = "100%",
  height: i = 350,
  options: r = {},
  className: a
}) => {
  const n = {
    ...pn,
    ...r,
    chart: {
      ...pn.chart,
      ...r.chart,
      type: s
    }
  };
  return /* @__PURE__ */ A.jsx("div", { className: a, children: /* @__PURE__ */ A.jsx(
    Vd,
    {
      type: s,
      series: e,
      options: n,
      width: t,
      height: i
    }
  ) });
}, Eg = ({
  label: s,
  error: e,
  disabled: t = !1,
  indeterminate: i = !1,
  variantSize: r = "sm",
  variant: a = "square",
  color: n = "primary",
  className: o = "",
  ...l
}) => {
  const c = {
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  }, h = {
    primary: "checked:bg-primary-600 checked:border-primary-600 hover:border-primary-600",
    secondary: "checked:bg-secondary-600 checked:border-secondary-600 hover:border-secondary-600",
    success: "checked:bg-success-600 checked:border-success-600 hover:border-success-600",
    warning: "checked:bg-warning-600 checked:border-warning-600 hover:border-warning-600",
    error: "checked:bg-danger-600 checked:border-danger-600 hover:border-danger-600"
  }, u = Zt(
    "border-2 transition-colors duration-200",
    "appearance-none cursor-pointer",
    "checked:bg-no-repeat checked:bg-center",
    a === "circle" ? 'checked:bg-[url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI2IiBjeT0iNiIgcj0iNCIgZmlsbD0id2hpdGUiLz48L3N2Zz4=")]' : 'checked:bg-[url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTAgM0w0LjUgOC41TDIgNiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L3N2Zz4=")]',
    {
      square: "rounded",
      circle: "rounded-full"
    }[a],
    c[r],
    h[n],
    t && "opacity-50 cursor-not-allowed",
    o
  ), g = Zt(
    "ml-2 text-sm font-medium",
    t && "opacity-50 cursor-not-allowed",
    e && "text-danger-600"
  );
  return /* @__PURE__ */ A.jsxs("div", { className: "items-center", children: [
    /* @__PURE__ */ A.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ A.jsx(
        "input",
        {
          type: "checkbox",
          className: u,
          disabled: t,
          ref: (p) => {
            p && (p.indeterminate = i);
          },
          ...l
        }
      ),
      s && /* @__PURE__ */ A.jsx("label", { className: g, children: s })
    ] }),
    e && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-sm text-danger-600", children: e })
  ] });
}, Gd = {
  solid: {
    primary: "bg-primary-500 text-white",
    success: "bg-success-500 text-white",
    warning: "bg-warning-500 text-white",
    error: "bg-danger-500 text-white",
    info: "bg-info-500 text-white",
    danger: "bg-danger-500 text-white",
    default: "bg-neutral-500 text-white"
  },
  outline: {
    primary: "border border-primary-500 text-primary-500",
    success: "border border-success-500 text-success-500",
    warning: "border border-warning-500 text-warning-500",
    error: "border border-error-500 text-error-500",
    info: "border border-info-500 text-info-500",
    danger: "border border-danger-500 text-danger-500",
    default: "border border-neutral-500 text-neutral-500"
  },
  subtle: {
    primary: "bg-primary-100 text-primary-700",
    success: "bg-success-100 text-success-700",
    warning: "bg-warning-100 text-warning-700",
    error: "bg-error-100 text-error-700",
    info: "bg-info-100 text-info-700",
    danger: "bg-danger-100 text-danger-700",
    default: "bg-neutral-100 text-neutral-700"
  },
  soft: {
    primary: "bg-primary-50 text-primary-600",
    success: "bg-success-50 text-success-600",
    warning: "bg-warning-50 text-warning-600",
    error: "bg-error-50 text-error-600",
    info: "bg-info-50 text-info-600",
    danger: "bg-danger-50 text-danger-600",
    default: "bg-neutral-50 text-neutral-600"
  }
}, $d = {
  sm: "text-xs px-2 py-0.5",
  md: "text-sm px-3 py-1",
  lg: "text-base px-4 py-1.5"
}, Ud = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  full: "rounded-full"
}, Tg = ({
  children: s,
  variant: e = "solid",
  color: t = "primary",
  size: i = "md",
  rounded: r = "md",
  onClose: a,
  className: n,
  icon: o
}) => /* @__PURE__ */ A.jsxs(
  "div",
  {
    className: Q(
      "inline-flex items-center gap-1.5 font-medium",
      Gd[e][t],
      $d[i],
      Ud[r],
      n
    ),
    children: [
      o && /* @__PURE__ */ A.jsx("span", { className: "inline-flex items-center", children: /* @__PURE__ */ A.jsx(Le, { icon: o, className: "w-4 h-4" }) }),
      s,
      a && /* @__PURE__ */ A.jsx(
        "button",
        {
          onClick: a,
          className: "ml-1 rounded-full hover:bg-black/10 p-0.5",
          "aria-label": "Close",
          children: /* @__PURE__ */ A.jsx(Le, { icon: "mdi:close", className: "w-3 h-3" })
        }
      )
    ]
  }
);
var Yo = { exports: {} };
(function(s, e) {
  (function(t, i) {
    s.exports = i();
  })(Il, function() {
    var t = 1e3, i = 6e4, r = 36e5, a = "millisecond", n = "second", o = "minute", l = "hour", c = "day", h = "week", d = "month", u = "quarter", g = "year", p = "date", f = "Invalid Date", x = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(N) {
      var z = ["th", "st", "nd", "rd"], L = N % 100;
      return "[" + N + (z[(L - 20) % 10] || z[L] || z[0]) + "]";
    } }, w = function(N, z, L) {
      var T = String(N);
      return !T || T.length >= z ? N : "" + Array(z + 1 - T.length).join(L) + N;
    }, y = { s: w, z: function(N) {
      var z = -N.utcOffset(), L = Math.abs(z), T = Math.floor(L / 60), H = L % 60;
      return (z <= 0 ? "+" : "-") + w(T, 2, "0") + ":" + w(H, 2, "0");
    }, m: function N(z, L) {
      if (z.date() < L.date()) return -N(L, z);
      var T = 12 * (L.year() - z.year()) + (L.month() - z.month()), H = z.clone().add(T, d), B = L - H < 0, _ = z.clone().add(T + (B ? -1 : 1), d);
      return +(-(T + (L - H) / (B ? H - _ : _ - H)) || 0);
    }, a: function(N) {
      return N < 0 ? Math.ceil(N) || 0 : Math.floor(N);
    }, p: function(N) {
      return { M: d, y: g, w: h, d: c, D: p, h: l, m: o, s: n, ms: a, Q: u }[N] || String(N || "").toLowerCase().replace(/s$/, "");
    }, u: function(N) {
      return N === void 0;
    } }, v = "en", k = {};
    k[v] = b;
    var S = "$isDayjsObject", C = function(N) {
      return N instanceof I || !(!N || !N[S]);
    }, M = function N(z, L, T) {
      var H;
      if (!z) return v;
      if (typeof z == "string") {
        var B = z.toLowerCase();
        k[B] && (H = B), L && (k[B] = L, H = B);
        var _ = z.split("-");
        if (!H && _.length > 1) return N(_[0]);
      } else {
        var O = z.name;
        k[O] = z, H = O;
      }
      return !T && H && (v = H), H || !T && v;
    }, R = function(N, z) {
      if (C(N)) return N.clone();
      var L = typeof z == "object" ? z : {};
      return L.date = N, L.args = arguments, new I(L);
    }, P = y;
    P.l = M, P.i = C, P.w = function(N, z) {
      return R(N, { locale: z.$L, utc: z.$u, x: z.$x, $offset: z.$offset });
    };
    var I = function() {
      function N(L) {
        this.$L = M(L.locale, null, !0), this.parse(L), this.$x = this.$x || L.x || {}, this[S] = !0;
      }
      var z = N.prototype;
      return z.parse = function(L) {
        this.$d = function(T) {
          var H = T.date, B = T.utc;
          if (H === null) return /* @__PURE__ */ new Date(NaN);
          if (P.u(H)) return /* @__PURE__ */ new Date();
          if (H instanceof Date) return new Date(H);
          if (typeof H == "string" && !/Z$/i.test(H)) {
            var _ = H.match(x);
            if (_) {
              var O = _[2] - 1 || 0, Y = (_[7] || "0").substring(0, 3);
              return B ? new Date(Date.UTC(_[1], O, _[3] || 1, _[4] || 0, _[5] || 0, _[6] || 0, Y)) : new Date(_[1], O, _[3] || 1, _[4] || 0, _[5] || 0, _[6] || 0, Y);
            }
          }
          return new Date(H);
        }(L), this.init();
      }, z.init = function() {
        var L = this.$d;
        this.$y = L.getFullYear(), this.$M = L.getMonth(), this.$D = L.getDate(), this.$W = L.getDay(), this.$H = L.getHours(), this.$m = L.getMinutes(), this.$s = L.getSeconds(), this.$ms = L.getMilliseconds();
      }, z.$utils = function() {
        return P;
      }, z.isValid = function() {
        return this.$d.toString() !== f;
      }, z.isSame = function(L, T) {
        var H = R(L);
        return this.startOf(T) <= H && H <= this.endOf(T);
      }, z.isAfter = function(L, T) {
        return R(L) < this.startOf(T);
      }, z.isBefore = function(L, T) {
        return this.endOf(T) < R(L);
      }, z.$g = function(L, T, H) {
        return P.u(L) ? this[T] : this.set(H, L);
      }, z.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, z.valueOf = function() {
        return this.$d.getTime();
      }, z.startOf = function(L, T) {
        var H = this, B = !!P.u(T) || T, _ = P.p(L), O = function(re, ee) {
          var de = P.w(H.$u ? Date.UTC(H.$y, ee, re) : new Date(H.$y, ee, re), H);
          return B ? de : de.endOf(c);
        }, Y = function(re, ee) {
          return P.w(H.toDate()[re].apply(H.toDate("s"), (B ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ee)), H);
        }, X = this.$W, V = this.$M, W = this.$D, G = "set" + (this.$u ? "UTC" : "");
        switch (_) {
          case g:
            return B ? O(1, 0) : O(31, 11);
          case d:
            return B ? O(1, V) : O(0, V + 1);
          case h:
            var U = this.$locale().weekStart || 0, Z = (X < U ? X + 7 : X) - U;
            return O(B ? W - Z : W + (6 - Z), V);
          case c:
          case p:
            return Y(G + "Hours", 0);
          case l:
            return Y(G + "Minutes", 1);
          case o:
            return Y(G + "Seconds", 2);
          case n:
            return Y(G + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, z.endOf = function(L) {
        return this.startOf(L, !1);
      }, z.$set = function(L, T) {
        var H, B = P.p(L), _ = "set" + (this.$u ? "UTC" : ""), O = (H = {}, H[c] = _ + "Date", H[p] = _ + "Date", H[d] = _ + "Month", H[g] = _ + "FullYear", H[l] = _ + "Hours", H[o] = _ + "Minutes", H[n] = _ + "Seconds", H[a] = _ + "Milliseconds", H)[B], Y = B === c ? this.$D + (T - this.$W) : T;
        if (B === d || B === g) {
          var X = this.clone().set(p, 1);
          X.$d[O](Y), X.init(), this.$d = X.set(p, Math.min(this.$D, X.daysInMonth())).$d;
        } else O && this.$d[O](Y);
        return this.init(), this;
      }, z.set = function(L, T) {
        return this.clone().$set(L, T);
      }, z.get = function(L) {
        return this[P.p(L)]();
      }, z.add = function(L, T) {
        var H, B = this;
        L = Number(L);
        var _ = P.p(T), O = function(V) {
          var W = R(B);
          return P.w(W.date(W.date() + Math.round(V * L)), B);
        };
        if (_ === d) return this.set(d, this.$M + L);
        if (_ === g) return this.set(g, this.$y + L);
        if (_ === c) return O(1);
        if (_ === h) return O(7);
        var Y = (H = {}, H[o] = i, H[l] = r, H[n] = t, H)[_] || 1, X = this.$d.getTime() + L * Y;
        return P.w(X, this);
      }, z.subtract = function(L, T) {
        return this.add(-1 * L, T);
      }, z.format = function(L) {
        var T = this, H = this.$locale();
        if (!this.isValid()) return H.invalidDate || f;
        var B = L || "YYYY-MM-DDTHH:mm:ssZ", _ = P.z(this), O = this.$H, Y = this.$m, X = this.$M, V = H.weekdays, W = H.months, G = H.meridiem, U = function(ee, de, q, ne) {
          return ee && (ee[de] || ee(T, B)) || q[de].slice(0, ne);
        }, Z = function(ee) {
          return P.s(O % 12 || 12, ee, "0");
        }, re = G || function(ee, de, q) {
          var ne = ee < 12 ? "AM" : "PM";
          return q ? ne.toLowerCase() : ne;
        };
        return B.replace(m, function(ee, de) {
          return de || function(q) {
            switch (q) {
              case "YY":
                return String(T.$y).slice(-2);
              case "YYYY":
                return P.s(T.$y, 4, "0");
              case "M":
                return X + 1;
              case "MM":
                return P.s(X + 1, 2, "0");
              case "MMM":
                return U(H.monthsShort, X, W, 3);
              case "MMMM":
                return U(W, X);
              case "D":
                return T.$D;
              case "DD":
                return P.s(T.$D, 2, "0");
              case "d":
                return String(T.$W);
              case "dd":
                return U(H.weekdaysMin, T.$W, V, 2);
              case "ddd":
                return U(H.weekdaysShort, T.$W, V, 3);
              case "dddd":
                return V[T.$W];
              case "H":
                return String(O);
              case "HH":
                return P.s(O, 2, "0");
              case "h":
                return Z(1);
              case "hh":
                return Z(2);
              case "a":
                return re(O, Y, !0);
              case "A":
                return re(O, Y, !1);
              case "m":
                return String(Y);
              case "mm":
                return P.s(Y, 2, "0");
              case "s":
                return String(T.$s);
              case "ss":
                return P.s(T.$s, 2, "0");
              case "SSS":
                return P.s(T.$ms, 3, "0");
              case "Z":
                return _;
            }
            return null;
          }(ee) || _.replace(":", "");
        });
      }, z.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, z.diff = function(L, T, H) {
        var B, _ = this, O = P.p(T), Y = R(L), X = (Y.utcOffset() - this.utcOffset()) * i, V = this - Y, W = function() {
          return P.m(_, Y);
        };
        switch (O) {
          case g:
            B = W() / 12;
            break;
          case d:
            B = W();
            break;
          case u:
            B = W() / 3;
            break;
          case h:
            B = (V - X) / 6048e5;
            break;
          case c:
            B = (V - X) / 864e5;
            break;
          case l:
            B = V / r;
            break;
          case o:
            B = V / i;
            break;
          case n:
            B = V / t;
            break;
          default:
            B = V;
        }
        return H ? B : P.a(B);
      }, z.daysInMonth = function() {
        return this.endOf(d).$D;
      }, z.$locale = function() {
        return k[this.$L];
      }, z.locale = function(L, T) {
        if (!L) return this.$L;
        var H = this.clone(), B = M(L, T, !0);
        return B && (H.$L = B), H;
      }, z.clone = function() {
        return P.w(this.$d, this);
      }, z.toDate = function() {
        return new Date(this.valueOf());
      }, z.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, z.toISOString = function() {
        return this.$d.toISOString();
      }, z.toString = function() {
        return this.$d.toUTCString();
      }, N;
    }(), D = I.prototype;
    return R.prototype = D, [["$ms", a], ["$s", n], ["$m", o], ["$H", l], ["$W", c], ["$M", d], ["$y", g], ["$D", p]].forEach(function(N) {
      D[N[1]] = function(z) {
        return this.$g(z, N[0], N[1]);
      };
    }), R.extend = function(N, z) {
      return N.$i || (N(z, I, R), N.$i = !0), R;
    }, R.locale = M, R.isDayjs = C, R.unix = function(N) {
      return R(1e3 * N);
    }, R.en = k[v], R.Ls = k, R.p = {}, R;
  });
})(Yo);
var qd = Yo.exports;
const Qe = /* @__PURE__ */ yn(qd), Zd = rt(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "md",
      fullWidth: !0
    }
  }
), Kd = Ge(
  ({
    value: s,
    endDate: e,
    onChange: t,
    onEndDateChange: i,
    isRangeSelection: r = !1,
    minDate: a,
    maxDate: n,
    variant: o = "default",
    size: l = "md",
    rounded: c = "md",
    disabled: h = !1,
    errorText: d,
    helperText: u,
    label: g,
    required: p = !1,
    labelPlacement: f = "top",
    fullWidth: x = !1,
    className: m,
    placeholder: b = "Select date",
    ...w
  }, y) => {
    const [v, k] = Ee(!1), [S, C] = Ee(s || null), [M, R] = Ee(e || null), [P, I] = Ee(s || /* @__PURE__ */ new Date()), D = Ve(null), N = Ve(null), z = Ve(null), L = () => {
      if (!v || !N.current || !z.current) return;
      const { bottom: W, left: G, width: U } = N.current.getBoundingClientRect(), Z = z.current;
      Object.assign(Z.style, {
        position: "fixed",
        left: `${G}px`,
        top: `${W + 4}px`,
        width: `${U}px`,
        maxHeight: `${window.innerHeight - W - 8}px`
      });
    };
    ht(() => {
      const W = () => {
        v && L();
      }, G = () => {
        v && L();
      }, U = (Z) => {
        const re = Z.target;
        D.current && !D.current.contains(re) && z.current && !z.current.contains(re) && k(!1);
      };
      return v && (L(), window.addEventListener("scroll", W, !0), window.addEventListener("resize", G)), document.addEventListener("click", U), () => {
        window.removeEventListener("scroll", W, !0), window.removeEventListener("resize", G), document.removeEventListener("click", U);
      };
    }, [v]);
    const T = (W) => {
      r ? S ? (Qe(W).isBefore(S) ? (R(S), C(W), t == null || t(W), i == null || i(S)) : (R(W), i == null || i(W)), k(!1)) : (C(W), t == null || t(W)) : (C(W), t == null || t(W), k(!1));
    }, H = () => {
      I(Qe(P).subtract(1, "month").toDate());
    }, B = () => {
      I(Qe(P).add(1, "month").toDate());
    }, _ = () => {
      const W = Qe(P).startOf("month"), G = Qe(P).endOf("month"), U = [];
      let Z = W;
      for (; Z.isBefore(G) || Z.isSame(G, "day"); )
        U.push(Z.toDate()), Z = Z.add(1, "day");
      return U;
    }, O = (W) => !!(a && Qe(W).isBefore(a, "day") || n && Qe(W).isAfter(n, "day")), Y = _(), X = Qe(P).startOf("month").day(), V = () => {
      if (!S) return "";
      const W = Qe(S).format("DD MMM YYYY");
      return r && M ? `${W} - ${Qe(M).format("DD MMM YYYY")}` : W;
    };
    return /* @__PURE__ */ A.jsxs("div", { ref: D, className: Q("relative", x && "w-full", m), children: [
      g && /* @__PURE__ */ A.jsxs(
        "label",
        {
          className: Q(
            "block text-sm font-medium text-gray-700 mb-1",
            f === "left" && "inline-block mr-2"
          ),
          children: [
            g,
            p && /* @__PURE__ */ A.jsx("span", { className: "text-red-500 ml-1", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ A.jsx("div", { ref: N, children: /* @__PURE__ */ A.jsx(
        "input",
        {
          ref: y,
          type: "text",
          value: V(),
          placeholder: b,
          onClick: () => !h && k(!v),
          readOnly: !0,
          className: Q(Zd({ variant: o, size: l, rounded: c, fullWidth: x })),
          disabled: h,
          ...w
        }
      ) }),
      v && ei(
        /* @__PURE__ */ A.jsxs(
          "div",
          {
            ref: z,
            className: "fixed z-[9999] bg-white border border-gray-200 rounded-md shadow-lg",
            children: [
              /* @__PURE__ */ A.jsxs("div", { className: "flex items-center justify-between p-2 border-b border-gray-200", children: [
                /* @__PURE__ */ A.jsx(
                  "button",
                  {
                    onClick: H,
                    className: "p-1 rounded-full hover:bg-primary-50 active:bg-primary-100 transition-colors duration-200",
                    children: /* @__PURE__ */ A.jsx(
                      Le,
                      {
                        icon: "mdi:chevron-left",
                        className: "w-5 h-5 text-neutral-600"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ A.jsx("span", { className: "font-medium text-gray-900", children: Qe(P).format("MMMM YYYY") }),
                /* @__PURE__ */ A.jsx(
                  "button",
                  {
                    onClick: B,
                    className: "p-1 rounded-full hover:bg-primary-50 active:bg-primary-100 transition-colors duration-200",
                    children: /* @__PURE__ */ A.jsx(
                      Le,
                      {
                        icon: "mdi:chevron-right",
                        className: "w-5 h-5 text-neutral-600"
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ A.jsxs("div", { className: "grid grid-cols-7 gap-1 p-2", children: [
                ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((W) => /* @__PURE__ */ A.jsx(
                  "div",
                  {
                    className: "text-center text-sm font-medium text-gray-500",
                    children: W
                  },
                  W
                )),
                Array.from({ length: X }).map((W, G) => /* @__PURE__ */ A.jsx("div", {}, `empty-${G}`)),
                Y.map((W) => {
                  const G = S && Qe(W).isSame(S, "day"), U = O(W), Z = Qe(W).isSame(P, "month");
                  return /* @__PURE__ */ A.jsx(
                    "button",
                    {
                      onClick: () => !U && T(W),
                      disabled: U,
                      className: Q(
                        "p-2 rounded-full text-sm transition-colors duration-200",
                        G && "bg-primary-500 text-white hover:bg-primary-600 active:bg-primary-700",
                        !G && !U && "hover:bg-primary-50 active:bg-primary-100",
                        !Z && "text-neutral-400",
                        U && "opacity-50 cursor-not-allowed"
                      ),
                      children: Qe(W).format("D")
                    },
                    W.toString()
                  );
                })
              ] })
            ]
          }
        ),
        document.body
      ),
      d && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-sm text-red-500", children: d }),
      u && !d && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-sm text-gray-500", children: u })
    ] });
  }
);
Kd.displayName = "DatePicker";
const Xo = Ge(
  ({ children: s, onClose: e, className: t, ...i }, r) => /* @__PURE__ */ A.jsxs(
    "div",
    {
      ref: r,
      className: Q("mb-4 flex items-center justify-between", t),
      ...i,
      children: [
        s,
        e && /* @__PURE__ */ A.jsx(
          "button",
          {
            onClick: e,
            className: "ml-4 rounded-full p-1 text-gray-500 hover:bg-gray-100 hover:text-gray-700",
            "aria-label": "Close dialog",
            children: /* @__PURE__ */ A.jsx(Le, { icon: "mdi:close", className: "h-5 w-5" })
          }
        )
      ]
    }
  )
), Jd = {
  sm: "max-w-sm",
  md: "max-w-md",
  lg: "max-w-lg",
  xl: "max-w-4xl",
  fullscreen: "w-full h-full max-w-none max-h-none rounded-none"
}, Qd = Ge(
  ({
    isOpen: s,
    onClose: e,
    children: t,
    className: i,
    backdrop: r = "dark",
    header: a,
    closeOnBackdropClick: n = !0,
    size: o = "md",
    ...l
  }, c) => {
    const [h, d] = Ee(!1), [u, g] = Ee(!1);
    if (ht(() => {
      if (s)
        d(!0), g(!0), document.body.style.overflow = "hidden";
      else {
        g(!1);
        const x = setTimeout(() => {
          d(!1), document.body.style.overflow = "";
        }, 300);
        return () => clearTimeout(x);
      }
    }, [s]), ht(() => {
      const x = (m) => {
        m.key === "Escape" && e();
      };
      return s && document.addEventListener("keydown", x), () => {
        document.removeEventListener("keydown", x);
      };
    }, [s, e]), !h) return null;
    const p = {
      blur: "backdrop-blur-sm bg-black/30",
      dark: "bg-black/50",
      transparent: "bg-transparent"
    }, f = () => {
      n && e();
    };
    return ei(
      /* @__PURE__ */ A.jsx(
        "div",
        {
          className: Q(
            "fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300",
            p[r],
            u ? "opacity-100" : "opacity-0",
            o === "fullscreen" && "items-start"
          ),
          onClick: f,
          children: /* @__PURE__ */ A.jsxs(
            "div",
            {
              ref: c,
              className: Q(
                "relative transform rounded-lg bg-white p-6 shadow-xl transition-all duration-300",
                Jd[o],
                u ? "scale-100 opacity-100" : "scale-95 opacity-0",
                i
              ),
              onClick: (x) => x.stopPropagation(),
              ...l,
              children: [
                a && /* @__PURE__ */ A.jsx(Xo, { onClose: e, children: a }),
                t
              ]
            }
          )
        }
      ),
      document.body
    );
  }
), eu = Ge(
  ({ children: s, className: e, ...t }, i) => /* @__PURE__ */ A.jsx(
    "h2",
    {
      ref: i,
      className: Q("text-xl font-semibold text-gray-900", e),
      ...t,
      children: s
    }
  )
), tu = Ge(
  ({ children: s, className: e, ...t }, i) => /* @__PURE__ */ A.jsx(
    "div",
    {
      ref: i,
      className: Q("text-gray-600", e),
      ...t,
      children: s
    }
  )
), iu = Ge(
  ({ children: s, className: e, ...t }, i) => /* @__PURE__ */ A.jsx(
    "div",
    {
      ref: i,
      className: Q("mt-6 flex justify-end gap-3", e),
      ...t,
      children: s
    }
  )
);
Qd.displayName = "Dialog";
eu.displayName = "DialogTitle";
tu.displayName = "DialogBody";
iu.displayName = "DialogActions";
Xo.displayName = "DialogHeader";
const ru = ({
  orientation: s = "horizontal",
  variant: e = "solid",
  color: t = "neutral",
  size: i = "sm",
  className: r = ""
}) => {
  const a = {
    horizontal: "w-full border-t-0 border-l-0 border-r-0 border-b",
    vertical: "h-full border-l border-t-0 border-r-0 border-b-0"
  }, n = {
    solid: "border-solid",
    dashed: "border-dashed",
    dotted: "border-dotted"
  }, o = {
    primary: "border-primary-300",
    secondary: "border-secondary-300",
    neutral: "border-neutral-300",
    success: "border-success-300",
    warning: "border-warning-300",
    error: "border-error-300"
  }, l = {
    sm: s === "horizontal" ? "border-b" : "border-l",
    md: s === "horizontal" ? "border-b-2" : "border-l-2",
    lg: s === "horizontal" ? "border-b-4" : "border-l-4"
  }, c = Zt(
    "inline-block",
    a[s],
    n[e],
    o[t],
    l[i],
    r
  );
  return /* @__PURE__ */ A.jsx("div", { className: c });
}, _g = ({
  accept: s = ["*"],
  maxSize: e = 5 * 1024 * 1024,
  // 5MB default
  multiple: t = !1,
  value: i = [],
  onChange: r,
  className: a,
  disabled: n = !1,
  placeholder: o = "Drag and drop files here or click to browse"
}) => {
  const [l, c] = Ee(!1), [h, d] = Ee(null), u = Ve(null), g = bt((y) => {
    y.preventDefault(), n || c(!0);
  }, [n]), p = bt((y) => {
    y.preventDefault(), c(!1);
  }, []), f = bt((y) => y.size > e ? `File size exceeds ${e / (1024 * 1024)}MB limit` : s[0] !== "*" && !s.some((v) => v.startsWith(".") ? y.name.toLowerCase().endsWith(v.toLowerCase()) : y.type.startsWith(v)) ? `File type not allowed. Allowed types: ${s.join(", ")}` : null, [s, e]), x = bt((y) => {
    if (y.preventDefault(), c(!1), d(null), n) return;
    const v = Array.from(y.dataTransfer.files), k = [], S = [];
    if (v.forEach((C) => {
      const M = f(C);
      M ? S.push(`${C.name}: ${M}`) : k.push(C);
    }), S.length > 0 && d(S.join(`
`)), k.length > 0) {
      const C = t ? [...i, ...k] : k;
      r == null || r(C);
    }
  }, [n, t, r, f, i]), m = bt((y) => {
    if (d(null), n || !y.target.files) return;
    const v = Array.from(y.target.files), k = [], S = [];
    if (v.forEach((C) => {
      const M = f(C);
      M ? S.push(`${C.name}: ${M}`) : k.push(C);
    }), S.length > 0 && d(S.join(`
`)), k.length > 0) {
      const C = t ? [...i, ...k] : k;
      r == null || r(C);
    }
    u.current && (u.current.value = "");
  }, [n, t, r, f, i]), b = bt((y) => {
    const v = [...i];
    v.splice(y, 1), r == null || r(v);
  }, [r, i]), w = (y) => y.type.startsWith("image/") ? /* @__PURE__ */ A.jsx(Le, { icon: "mdi:image", className: "w-5 h-5" }) : y.type.startsWith("text/") ? /* @__PURE__ */ A.jsx(Le, { icon: "mdi:file-document", className: "w-5 h-5" }) : /* @__PURE__ */ A.jsx(Le, { icon: "mdi:file", className: "w-5 h-5" });
  return /* @__PURE__ */ A.jsxs("div", { className: ve("w-full", a), children: [
    /* @__PURE__ */ A.jsxs(
      "div",
      {
        className: ve(
          "border-2 border-dashed rounded-lg p-6 text-center transition-colors",
          "bg-neutral-50",
          "border-neutral-300",
          l && "border-primary bg-primary-50",
          n && "opacity-50 cursor-not-allowed",
          !n && "cursor-pointer hover:border-primary/50"
        ),
        onDragOver: g,
        onDragLeave: p,
        onDrop: x,
        onClick: () => {
          var y;
          return !n && ((y = u.current) == null ? void 0 : y.click());
        },
        children: [
          /* @__PURE__ */ A.jsx(
            "input",
            {
              ref: u,
              type: "file",
              accept: s.join(","),
              multiple: t,
              onChange: m,
              className: "hidden",
              disabled: n
            }
          ),
          /* @__PURE__ */ A.jsx(Le, { icon: "mdi:upload", className: "w-12 h-12 mx-auto mb-4 text-neutral-400" }),
          /* @__PURE__ */ A.jsx("p", { className: "text-neutral-600", children: o }),
          /* @__PURE__ */ A.jsxs("p", { className: "text-sm text-neutral-500 mt-2", children: [
            "Max file size: ",
            e / (1024 * 1024),
            "MB"
          ] })
        ]
      }
    ),
    h && /* @__PURE__ */ A.jsx("p", { className: "mt-2 text-sm text-danger", children: h }),
    i.length > 0 && /* @__PURE__ */ A.jsx("div", { className: "mt-4 space-y-2", children: i.map((y, v) => /* @__PURE__ */ A.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-2 rounded-md bg-neutral-100",
        children: [
          /* @__PURE__ */ A.jsxs("div", { className: "flex items-center space-x-2", children: [
            w(y),
            /* @__PURE__ */ A.jsx("span", { className: "text-sm text-neutral-700", children: y.name }),
            /* @__PURE__ */ A.jsxs("span", { className: "text-xs text-neutral-500", children: [
              "(",
              (y.size / 1024).toFixed(1),
              " KB)"
            ] })
          ] }),
          !n && /* @__PURE__ */ A.jsx(
            "button",
            {
              onClick: () => b(v),
              className: "p-1 text-neutral-500 hover:text-danger",
              children: /* @__PURE__ */ A.jsx(Le, { icon: "mdi:close", className: "w-4 h-4" })
            }
          )
        ]
      },
      `${y.name}-${v}`
    )) })
  ] });
}, yt = ({
  icon: s,
  className: e,
  size: t,
  color: i,
  rotate: r,
  flip: a,
  spin: n,
  ...o
}) => /* @__PURE__ */ A.jsx(
  Le,
  {
    icon: s,
    className: Q(
      n && "animate-spin",
      e
    ),
    style: {
      color: i,
      transform: `rotate(${r || 0}deg)`
    },
    height: t,
    width: t,
    flip: a,
    ...o
  }
), su = rt(
  "flex items-start gap-3 p-4 shadow-sm",
  {
    variants: {
      variant: {
        default: "bg-white border border-neutral-200",
        primary: "bg-primary-50 border border-primary-200",
        success: "bg-success-50 border border-success-200",
        warning: "bg-warning-50 border border-warning-200",
        danger: "bg-danger-50 border border-danger-200",
        info: "bg-info-50 border border-info-200"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      rounded: "md"
    }
  }
), Og = ({
  title: s,
  children: e,
  icon: t,
  variant: i = "default",
  rounded: r = "md",
  showClose: a = !1,
  onClose: n,
  className: o
}) => {
  const l = () => {
    switch (i) {
      case "primary":
        return "text-primary-600";
      case "success":
        return "text-success-600";
      case "warning":
        return "text-warning-600";
      case "danger":
        return "text-danger-600";
      case "info":
        return "text-info-600";
      default:
        return "text-neutral-600";
    }
  }, c = () => {
    if (t) return t;
    switch (i) {
      case "primary":
        return "mdi:information";
      case "success":
        return "mdi:check-circle";
      case "warning":
        return "mdi:alert";
      case "danger":
        return "mdi:alert-circle";
      case "info":
        return "mdi:information";
      default:
        return "mdi:information";
    }
  };
  return /* @__PURE__ */ A.jsxs("div", { className: Q(su({ variant: i, rounded: r }), o), children: [
    t && /* @__PURE__ */ A.jsx(Le, { icon: c(), className: Q("h-5 w-5 flex-shrink-0", l()) }),
    /* @__PURE__ */ A.jsxs("div", { className: "flex-1", children: [
      s && /* @__PURE__ */ A.jsx("h3", { className: "text-sm font-medium text-neutral-900", children: s }),
      /* @__PURE__ */ A.jsx("div", { className: "mt-1 text-sm text-neutral-500", children: e })
    ] }),
    a && /* @__PURE__ */ A.jsx(
      "button",
      {
        type: "button",
        className: "ml-auto flex-shrink-0 text-neutral-400 hover:text-neutral-500",
        onClick: n,
        children: /* @__PURE__ */ A.jsx(Le, { icon: "mdi:close", className: "h-5 w-5" })
      }
    )
  ] });
}, Xr = "select-dropdown-opened", au = rt(
  "rounded-md px-3 py-2 text-sm ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50 bg-white",
        error: "border border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50 bg-white",
        success: "border border-success-500 hover:border-success-600 focus:border-success-600 bg-white",
        ghost: "border-0 hover:bg-neutral-100 focus:bg-neutral-100 bg-transparent",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      fullWidth: !0
    }
  }
), Bo = Ge(
  ({
    className: s,
    variant: e = "default",
    size: t = "md",
    rounded: i = "md",
    options: r,
    label: a,
    error: n = !1,
    helperText: o,
    required: l = !1,
    placeholder: c,
    value: h,
    onChange: d,
    disabled: u = !1,
    position: g = "bottom",
    fullWidth: p = !0,
    children: f,
    leftIcon: x,
    rightIcon: m,
    ...b
  }, w) => {
    const [y, v] = Ee(!1), k = Ve(null), S = Ve(null), M = `select-${He.useId().replace(/:/g, "")}`, R = () => {
      if (y && k.current && S.current) {
        const L = k.current.getBoundingClientRect(), T = S.current, H = window.innerHeight - L.bottom, B = L.top, O = L.bottom + T.offsetHeight + 4 >= window.innerHeight, Y = B > H, X = O && Y;
        g === "bottom" || g === "top" ? (T.style.position = "fixed", T.style.left = `${L.left}px`, T.style.width = `${L.width}px`, g === "bottom" && X ? (T.style.bottom = `${window.innerHeight - L.top + 4}px`, T.style.top = "auto", T.style.maxHeight = `${B - 8}px`) : g === "bottom" ? (T.style.top = `${L.bottom + 4}px`, T.style.bottom = "auto", T.style.maxHeight = `${H - 8}px`) : g === "top" && !X ? (T.style.top = `${L.bottom + 4}px`, T.style.bottom = "auto", T.style.maxHeight = `${H - 8}px`) : (T.style.bottom = `${window.innerHeight - L.top + 4}px`, T.style.top = "auto", T.style.maxHeight = `${B - 8}px`)) : g === "left" ? (T.style.position = "fixed", T.style.right = `${window.innerWidth - L.left + 4}px`, T.style.top = `${L.top}px`, T.style.maxHeight = `${window.innerHeight - L.top - 8}px`) : g === "right" && (T.style.position = "fixed", T.style.left = `${L.right + 4}px`, T.style.top = `${L.top}px`, T.style.maxHeight = `${window.innerHeight - L.top - 8}px`);
      }
    };
    ht(() => {
      const L = () => {
        y && R();
      }, T = () => {
        y && R();
      };
      return y && (R(), window.addEventListener("scroll", L, !0), window.addEventListener("resize", T)), () => {
        window.removeEventListener("scroll", L, !0), window.removeEventListener("resize", T);
      };
    }, [y, g]), ht(() => {
      const L = (H) => {
        H.detail.id !== M && v(!1);
      }, T = (H) => {
        const B = H.target, _ = k.current, O = S.current;
        _ && O && !_.contains(B) && !O.contains(B) && v(!1);
      };
      return document.addEventListener(Xr, L), document.addEventListener("click", T), () => {
        document.removeEventListener(Xr, L), document.removeEventListener("click", T);
      };
    }, [M]);
    const P = () => {
      if (!u) {
        if (y) {
          v(!1);
          return;
        }
        document.dispatchEvent(
          new CustomEvent(Xr, {
            detail: { id: M }
          })
        ), v(!0);
      }
    }, I = () => {
      if (r) {
        const L = r.find((T) => T.value === h);
        return L == null ? void 0 : L.label;
      }
      if (f) {
        const T = ba.toArray(f).find(
          (H) => gr(H) && "value" in H.props && H.props.value === h
        );
        return gr(T) ? T.props.children : null;
      }
      return null;
    }, D = (L) => {
      u || (d == null || d(L), v(!1));
    }, N = () => r ? r.map((L) => /* @__PURE__ */ A.jsx(
      sr,
      {
        value: L.value,
        disabled: L.disabled,
        selected: L.value === h,
        onClick: () => D(L.value),
        children: /* @__PURE__ */ A.jsxs("div", { className: "flex items-center gap-2", children: [
          L.icon,
          L.label
        ] })
      },
      L.value
    )) : f ? ba.map(f, (L) => gr(L) && "value" in L.props ? Rl(L, {
      selected: L.props.value === h,
      onClick: () => D(L.props.value)
    }) : null) : null, z = () => {
      if (!y || u) return null;
      const L = /* @__PURE__ */ A.jsx(
        "div",
        {
          ref: S,
          className: Q(
            "fixed z-[9999] min-w-[8rem] border border-neutral-200 bg-white py-1 shadow-lg",
            {
              "rounded-none": i === "none",
              "rounded-sm": i === "sm",
              "rounded-md": i === "md",
              "rounded-lg": i === "lg",
              "rounded-xl": i === "full"
            },
            g === "left" || g === "right" ? "w-max" : "w-full"
          ),
          onClick: (T) => T.stopPropagation(),
          style: {
            overflowY: "auto"
          },
          children: N()
        }
      );
      return ei(L, document.body);
    };
    return /* @__PURE__ */ A.jsxs("div", { className: Q(p ? "w-full" : "inline-block"), ref: w, ...b, children: [
      a && /* @__PURE__ */ A.jsxs(
        "label",
        {
          htmlFor: M,
          className: "mb-1.5 block text-sm text-neutral-900",
          children: [
            a,
            l && /* @__PURE__ */ A.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ A.jsxs("div", { className: Q("relative", !p && "inline-block"), children: [
        /* @__PURE__ */ A.jsxs(
          "button",
          {
            id: M,
            ref: k,
            type: "button",
            className: Q(
              au({ variant: n ? "error" : e, size: t, rounded: i, fullWidth: p }),
              "flex items-center justify-between",
              u && "cursor-not-allowed opacity-50",
              x && "pl-10",
              m && "pr-10",
              s
            ),
            onClick: P,
            "aria-haspopup": "listbox",
            "aria-expanded": y,
            "aria-describedby": n ? `${M}-error` : o ? `${M}-helper` : void 0,
            disabled: u,
            children: [
              x && /* @__PURE__ */ A.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ A.jsx(yt, { icon: x, className: "w-4 h-4" }) }),
              /* @__PURE__ */ A.jsx("span", { className: "flex items-center text-neutral-500 gap-2 min-w-0 flex-1", children: /* @__PURE__ */ A.jsx("span", { className: "truncate", children: I() || c }) }),
              m ? /* @__PURE__ */ A.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-neutral-500", children: /* @__PURE__ */ A.jsx(yt, { icon: m, className: "w-4 h-4" }) }) : /* @__PURE__ */ A.jsx(
                yt,
                {
                  icon: "mdi:chevron-down",
                  className: Q("transition-transform flex-shrink-0 ml-2", y && "rotate-180")
                }
              )
            ]
          }
        ),
        z()
      ] }),
      n && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-xs text-danger-500", id: `${M}-error`, children: n }),
      !n && o && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-xs text-neutral-500", id: `${M}-helper`, children: o })
    ] });
  }
);
Bo.displayName = "Select";
const nu = ({
  currentPage: s,
  totalPages: e,
  totalData: t,
  onPageChange: i,
  siblingCount: r = 1,
  className: a,
  perPageOptions: n,
  perPage: o = 10,
  label: l = "",
  onPerPageChange: c
}) => {
  const h = (g, p) => {
    const f = p - g + 1;
    return Array.from({ length: f }, (x, m) => m + g);
  }, u = (() => {
    const g = r * 2 + 3, p = g + 2;
    if (e > p) {
      const f = Math.max(2, s - r), x = Math.min(e - 1, s + r);
      let m = h(f, x);
      const b = f > 2, w = e - x > 1, y = g - (m.length + 1);
      if (b && !w)
        m = [...h(f - y, f - 1), ...m];
      else if (!b && w) {
        const v = h(x + 1, x + y);
        m = [...m, ...v];
      } else b && w && (m = [...m]);
      return [1, ...m, e];
    }
    return h(1, e);
  })();
  return /* @__PURE__ */ A.jsxs(
    "nav",
    {
      className: ve("flex items-center justify-between space-x-1", a),
      children: [
        /* @__PURE__ */ A.jsxs("div", { className: "hidden sm:block text-sm text-neutral-700", children: [
          /* @__PURE__ */ A.jsx("b", { children: `${s} - ${e}` }),
          " dari ",
          t,
          " ",
          l
        ] }),
        /* @__PURE__ */ A.jsxs("div", { className: "flex items-center gap-2", children: [
          n && n.length > 0 && /* @__PURE__ */ A.jsxs("div", { className: "flex items-center gap-2 mr-4", children: [
            /* @__PURE__ */ A.jsx("span", { className: "text-neutral-700 text-sm", children: "Menampilkan" }),
            /* @__PURE__ */ A.jsx(
              Bo,
              {
                value: o == null ? void 0 : o.toString(),
                onChange: (g) => c && c(Number(g)),
                size: "sm",
                className: "w-16",
                fullWidth: !1,
                "aria-label": "Items per page",
                children: n.map((g) => /* @__PURE__ */ A.jsx(sr, { value: g.toString(), children: g }, g))
              }
            ),
            /* @__PURE__ */ A.jsx("span", { className: "text-neutral-700 text-sm", children: "data per halaman" })
          ] }),
          /* @__PURE__ */ A.jsx(
            et,
            {
              variant: "ghost",
              onClick: () => i(s - 1),
              disabled: s === 1,
              className: ve(
                "px-3 py-1 rounded-md text-sm",
                s === 1 ? "text-gray-400 cursor-not-allowed" : "text-gray-700 hover:bg-gray-100"
              ),
              children: /* @__PURE__ */ A.jsx(yt, { size: "18", icon: "mdi:chevron-left" })
            }
          ),
          u.map((g, p) => {
            const f = g === s, x = typeof g == "string" && g === "...";
            return /* @__PURE__ */ A.jsx(
              et,
              {
                variant: "ghost",
                onClick: () => !x && i(g),
                className: ve(
                  "px-3 py-1 rounded-md text-sm",
                  f ? "bg-primary text-white hover:bg-primary" : "text-gray-700",
                  x && "cursor-default"
                ),
                children: g
              },
              p
            );
          }),
          /* @__PURE__ */ A.jsx(
            et,
            {
              variant: "ghost",
              onClick: () => i(s + 1),
              disabled: s === e,
              className: ve(
                "px-3 py-1 rounded-md text-sm",
                s === e ? "text-gray-400 cursor-not-allowed" : "text-gray-700"
              ),
              children: /* @__PURE__ */ A.jsx(yt, { size: "18", icon: "mdi:chevron-right" })
            }
          )
        ] })
      ]
    }
  );
}, zg = ({
  label: s,
  checked: e = !1,
  disabled: t = !1,
  onChange: i,
  name: r,
  value: a
}) => {
  const n = (o) => {
    i && i(o.target.checked);
  };
  return /* @__PURE__ */ A.jsxs(
    "label",
    {
      className: ve(
        "inline-flex items-center cursor-pointer",
        t && "opacity-60 cursor-not-allowed"
      ),
      children: [
        /* @__PURE__ */ A.jsx(
          "input",
          {
            type: "radio",
            className: ve(
              "w-5 h-5 border-2 rounded-full appearance-none",
              "focus:outline-none focus:ring-2 focus:ring-primary/25",
              e ? "border-primary bg-primary" : "border-gray-300 hover:border-primary",
              t && "cursor-not-allowed"
            ),
            checked: e,
            disabled: t,
            onChange: n,
            name: r,
            value: a
          }
        ),
        s && /* @__PURE__ */ A.jsx("span", { className: "ml-2 text-sm text-gray-700 dark:text-gray-300", children: s })
      ]
    }
  );
}, ou = rt(
  "animate-pulse bg-neutral-200",
  {
    variants: {
      variant: {
        default: "bg-neutral-200",
        primary: "bg-primary-200",
        success: "bg-success-200",
        warning: "bg-warning-200",
        danger: "bg-danger-200",
        info: "bg-info-200"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      rounded: "md",
      fullWidth: !1
    }
  }
), lu = ({
  width: s,
  height: e,
  variant: t = "default",
  rounded: i = "md",
  fullWidth: r = !1,
  className: a
}) => /* @__PURE__ */ A.jsx(
  "div",
  {
    className: Q(ou({ variant: t, rounded: i, fullWidth: r }), a),
    style: {
      width: !r && typeof s == "number" ? `${s}px` : s,
      height: typeof e == "number" ? `${e}px` : e
    }
  }
), Fg = ({
  min: s = 0,
  max: e = 100,
  step: t = 1,
  value: i,
  defaultValue: r = s,
  onChange: a,
  className: n,
  disabled: o = !1,
  showValue: l = !1,
  marks: c = []
}) => {
  const [h, d] = Ee(r), [u, g] = Ee(!1), p = Ve(null), f = i !== void 0 ? i : h, x = (k) => {
    if (o) return;
    const S = Math.min(Math.max(k, s), e);
    i === void 0 && d(S), a == null || a(S);
  }, m = (k) => {
    o || (g(!0), y(k));
  }, b = (k) => {
    !u || o || y(k);
  }, w = () => {
    g(!1);
  }, y = (k) => {
    if (!p.current) return;
    const S = p.current.getBoundingClientRect(), M = (k.clientX - S.left) / S.width, R = s + (e - s) * M, P = Math.round(R / t) * t;
    x(P);
  };
  ht(() => (u && (window.addEventListener("mousemove", b), window.addEventListener("mouseup", w)), () => {
    window.removeEventListener("mousemove", b), window.removeEventListener("mouseup", w);
  }), [u]);
  const v = (f - s) / (e - s) * 100;
  return /* @__PURE__ */ A.jsxs("div", { className: ve("relative w-full", n), children: [
    /* @__PURE__ */ A.jsxs(
      "div",
      {
        ref: p,
        className: ve(
          "relative h-2 bg-gray-200 rounded-full cursor-pointer",
          o && "opacity-50 cursor-not-allowed"
        ),
        onMouseDown: m,
        children: [
          /* @__PURE__ */ A.jsx(
            "div",
            {
              className: "absolute h-full bg-primary rounded-full",
              style: { width: `${v}%` }
            }
          ),
          /* @__PURE__ */ A.jsx(
            "div",
            {
              className: ve(
                "absolute top-1/2 -translate-y-1/2 w-4 h-4 bg-white rounded-full shadow-md",
                "border-2 border-primary",
                o && "cursor-not-allowed"
              ),
              style: { left: `${v}%`, transform: "translate(-50%, -50%)" }
            }
          )
        ]
      }
    ),
    c.length > 0 && /* @__PURE__ */ A.jsx("div", { className: "flex justify-between mt-2", children: c.map((k) => /* @__PURE__ */ A.jsx(
      "div",
      {
        className: "text-xs text-gray-500",
        style: { left: `${(k.value - s) / (e - s) * 100}%` },
        children: k.label
      },
      k.value
    )) }),
    l && /* @__PURE__ */ A.jsx("div", { className: "mt-2 text-sm text-gray-600", children: f })
  ] });
}, cu = {
  sm: "w-4 h-4",
  md: "w-6 h-6",
  lg: "w-8 h-8"
}, hu = {
  primary: "text-primary",
  warning: "text-warning-500",
  default: "text-default-400"
}, Ng = ({
  rating: s,
  maxRating: e = 5,
  size: t = "md",
  color: i = "primary",
  readOnly: r = !1,
  onRatingChange: a,
  className: n
}) => {
  const [o, l] = Ee(null), c = (g) => {
    r || l(g);
  }, h = () => {
    r || l(null);
  }, d = (g) => {
    !r && a && a(g);
  }, u = o !== null ? o : s;
  return /* @__PURE__ */ A.jsx("div", { className: Q("flex items-center gap-1", n), children: [...Array(e)].map((g, p) => {
    const f = p + 1, x = f <= u, m = o !== null && f <= o;
    return /* @__PURE__ */ A.jsx(
      "button",
      {
        className: Q(
          "transition-colors duration-200",
          cu[t],
          x || m ? hu[i] : "text-default-200",
          !r && "cursor-pointer"
        ),
        onMouseEnter: () => c(f),
        onMouseLeave: h,
        onClick: () => d(f),
        disabled: r,
        "aria-label": `Rate ${f} out of ${e}`,
        children: /* @__PURE__ */ A.jsx(
          Le,
          {
            icon: x || m ? "mdi:star" : "mdi:star-outline",
            className: "w-full h-full"
          }
        )
      },
      p
    );
  }) });
}, du = {
  active: {
    bgColor: "bg-success-500",
    label: "Active"
  },
  inactive: {
    bgColor: "bg-default-400",
    label: "Inactive"
  },
  pending: {
    bgColor: "bg-warning-500",
    label: "Pending"
  },
  warning: {
    bgColor: "bg-warning-500",
    label: "Warning"
  },
  error: {
    bgColor: "bg-danger-500",
    label: "Error"
  }
}, uu = {
  sm: "w-2 h-2",
  md: "w-3 h-3",
  lg: "w-4 h-4"
}, Dg = ({
  status: s,
  size: e = "md",
  withLabel: t = !1,
  className: i
}) => {
  const { bgColor: r, label: a } = du[s], n = uu[e];
  return /* @__PURE__ */ A.jsxs("div", { className: Q("flex items-center gap-2", i), children: [
    /* @__PURE__ */ A.jsx("div", { className: Q("rounded-full animate-pulse", r, n) }),
    t && /* @__PURE__ */ A.jsx("span", { className: "text-sm", children: a })
  ] });
}, Wo = (s, e) => {
  if (e) return e;
  switch (s) {
    case "completed":
      return "mdi:check";
    case "active":
      return "mdi:circle-medium";
    default:
      return "mdi:circle-outline";
  }
}, Vo = (s) => {
  switch (s) {
    case "completed":
      return "text-white bg-primary-500 ring-4 ring-primary-50";
    case "active":
      return "text-primary-500 bg-primary-50 ring-4 ring-primary-50";
    default:
      return "text-neutral-400 bg-neutral-50 ring-4 ring-neutral-50";
  }
}, gu = ({
  steps: s,
  activeStep: e,
  className: t,
  variant: i = "default"
}) => /* @__PURE__ */ A.jsx("div", { className: Q("flex flex-row items-center w-full justify-between", t), children: s.map((r, a) => {
  const n = a < e ? "completed" : a === e ? "active" : "pending";
  return /* @__PURE__ */ A.jsxs(
    "div",
    {
      className: "flex items-center flex-1",
      children: [
        /* @__PURE__ */ A.jsxs("div", { className: Q(
          "flex flex-col items-center z-10",
          i === "default" ? "gap-4" : "gap-2",
          i === "default" ? "px-5" : "px-3"
        ), children: [
          i === "default" && /* @__PURE__ */ A.jsx(
            "div",
            {
              className: Q(
                "flex h-8 w-8 items-center justify-center rounded-full transition-all duration-200",
                Vo(n)
              ),
              children: /* @__PURE__ */ A.jsx(
                Le,
                {
                  icon: Wo(n, r.icon),
                  className: "h-5 w-5"
                }
              )
            }
          ),
          /* @__PURE__ */ A.jsxs("div", { className: "flex flex-col items-center text-center", children: [
            /* @__PURE__ */ A.jsx(
              "span",
              {
                className: Q(
                  "text-sm font-medium",
                  n === "active" ? "text-primary-500" : n === "completed" ? "text-neutral-900" : "text-neutral-500"
                ),
                children: r.label
              }
            ),
            r.description && /* @__PURE__ */ A.jsx("span", { className: "text-xs text-neutral-500", children: r.description })
          ] })
        ] }),
        a < s.length - 1 && /* @__PURE__ */ A.jsx(
          ru,
          {
            className: Q(
              "transition-all duration-200",
              a < e ? "bg-primary-500" : "bg-neutral-200"
            )
          }
        )
      ]
    },
    a
  );
}) }), fu = ({
  steps: s,
  activeStep: e,
  className: t,
  variant: i = "default"
}) => /* @__PURE__ */ A.jsx("div", { className: Q("flex flex-col items-start gap-8", t), children: s.map((r, a) => {
  const n = a < e ? "completed" : a === e ? "active" : "pending";
  return /* @__PURE__ */ A.jsxs(
    "div",
    {
      className: "flex flex-row w-full items-center relative",
      children: [
        /* @__PURE__ */ A.jsxs("div", { className: Q(
          "flex flex-row items-center z-10",
          i === "default" ? "gap-4" : "gap-2"
        ), children: [
          i === "default" && /* @__PURE__ */ A.jsx(
            "div",
            {
              className: Q(
                "flex h-8 w-8 items-center justify-center rounded-full transition-all duration-200",
                Vo(n)
              ),
              children: /* @__PURE__ */ A.jsx(
                Le,
                {
                  icon: Wo(n, r.icon),
                  className: "h-5 w-5"
                }
              )
            }
          ),
          /* @__PURE__ */ A.jsxs("div", { className: "flex flex-col items-start", children: [
            /* @__PURE__ */ A.jsx(
              "span",
              {
                className: Q(
                  "text-sm font-medium",
                  n === "active" ? "text-primary-500" : n === "completed" ? "text-neutral-900" : "text-neutral-500"
                ),
                children: r.label
              }
            ),
            r.description && /* @__PURE__ */ A.jsx("span", { className: "text-xs text-neutral-500", children: r.description })
          ] })
        ] }),
        a < s.length - 1 && /* @__PURE__ */ A.jsx(
          "div",
          {
            className: Q(
              "absolute transition-all duration-200",
              i === "default" ? "left-4 w-[1px] top-10 bottom-[-24px]" : "left-0 w-[1px] top-6 bottom-[-24px]",
              a < e ? "bg-primary-500" : "bg-neutral-200"
            )
          }
        )
      ]
    },
    a
  );
}) }), Hg = ({
  orientation: s = "horizontal",
  variant: e = "default",
  ...t
}) => s === "vertical" ? /* @__PURE__ */ A.jsx(fu, { variant: e, ...t }) : /* @__PURE__ */ A.jsx(gu, { variant: e, ...t }), jg = ({
  label: s,
  checked: e = !1,
  disabled: t = !1,
  onChange: i,
  size: r = "md"
}) => {
  const a = (l) => {
    i && i(l.target.checked);
  }, n = {
    sm: "w-8 h-4",
    md: "w-11 h-6",
    lg: "w-14 h-7"
  }, o = {
    sm: "w-3 h-3",
    md: "w-5 h-5",
    lg: "w-6 h-6"
  };
  return /* @__PURE__ */ A.jsxs(
    "label",
    {
      className: ve(
        "inline-flex items-center cursor-pointer",
        t && "opacity-60 cursor-not-allowed"
      ),
      children: [
        /* @__PURE__ */ A.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ A.jsx(
            "input",
            {
              type: "checkbox",
              className: "sr-only",
              checked: e,
              disabled: t,
              onChange: a
            }
          ),
          /* @__PURE__ */ A.jsx(
            "div",
            {
              className: ve(
                "block rounded-full transition-colors duration-200 ease-in-out",
                n[r],
                e ? "bg-primary" : "bg-gray-200 dark:bg-gray-700",
                t && "cursor-not-allowed"
              )
            }
          ),
          /* @__PURE__ */ A.jsx(
            "div",
            {
              className: ve(
                "absolute rounded-full bg-white shadow-sm transition-transform duration-200 ease-in-out",
                o[r],
                e ? r === "sm" ? "translate-x-4" : r === "md" ? "translate-x-5" : "translate-x-7" : "translate-x-0.5",
                "top-1/2 -translate-y-1/2"
              )
            }
          )
        ] }),
        s && /* @__PURE__ */ A.jsx("span", { className: "ml-3 text-sm text-gray-700 dark:text-gray-300", children: s })
      ]
    }
  );
}, Yg = ({
  items: s,
  defaultActiveId: e,
  variant: t = "default",
  size: i = "md",
  className: r,
  tabListClassName: a,
  tabClassName: n,
  contentClassName: o,
  onChange: l
}) => {
  var p, f;
  const [c, h] = Ee(e || ((p = s[0]) == null ? void 0 : p.id) || ""), d = bt((x) => {
    h(x), l == null || l(x);
  }, [l]), u = () => {
    switch (i) {
      case "sm":
        return "text-sm px-3 py-1.5";
      case "lg":
        return "text-lg px-6 py-3";
      default:
        return "text-base px-4 py-2";
    }
  }, g = (x, m) => {
    const b = ve(
      "flex items-center space-x-2 transition-colors",
      "font-medium",
      u(),
      m && "opacity-50 cursor-not-allowed",
      !m && "cursor-pointer"
    );
    switch (t) {
      case "pills":
        return ve(
          b,
          "rounded-full",
          x ? "bg-primary text-white" : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
        );
      case "underline":
        return ve(
          b,
          "border-b-2",
          x ? "border-primary text-primary" : "border-transparent text-gray-600 dark:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"
        );
      default:
        return ve(
          b,
          "border-b-2",
          x ? "border-primary text-primary" : "border-transparent text-gray-600 dark:text-gray-300 hover:border-gray-300 dark:hover:border-gray-600"
        );
    }
  };
  return /* @__PURE__ */ A.jsxs("div", { className: ve("w-full", r), children: [
    /* @__PURE__ */ A.jsx(
      "div",
      {
        className: ve(
          "flex space-x-1 border-b border-gray-200 dark:border-gray-700",
          t === "pills" && "space-x-2 border-b-0",
          a
        ),
        children: s.map((x) => {
          const m = x.id === c, b = !!x.disabled;
          return /* @__PURE__ */ A.jsxs(
            "button",
            {
              onClick: () => !b && d(x.id),
              disabled: b,
              className: ve(
                g(m, b),
                n
              ),
              children: [
                x.icon && /* @__PURE__ */ A.jsx(
                  Le,
                  {
                    icon: x.icon,
                    className: "w-5 h-5 flex-shrink-0"
                  }
                ),
                /* @__PURE__ */ A.jsx("span", { children: x.label })
              ]
            },
            x.id
          );
        })
      }
    ),
    /* @__PURE__ */ A.jsx("div", { className: ve("mt-4", o), children: (f = s.find((x) => x.id === c)) == null ? void 0 : f.content })
  ] });
}, Br = ({
  variant: s = "p",
  children: e,
  className: t,
  as: i
}) => {
  const r = {
    h1: "text-4xl font-bold",
    h2: "text-3xl font-bold",
    h3: "text-2xl font-bold",
    h4: "text-xl font-bold",
    h5: "text-lg font-bold",
    h6: "text-base font-bold",
    p: "text-base",
    span: "text-base",
    label: "text-sm font-medium",
    heading3: "text-2xl font-bold",
    body1: "text-base",
    display1: "text-5xl font-bold",
    display2: "text-4xl font-bold",
    heading1: "text-4xl font-bold",
    heading2: "text-3xl font-bold",
    heading4: "text-xl font-bold",
    subtitle1: "text-lg font-medium",
    subtitle2: "text-base font-medium",
    body2: "text-sm",
    caption: "text-xs",
    value: "text-base font-medium"
  }, n = i || ((o) => {
    switch (o) {
      case "display1":
      case "display2":
      case "heading1":
      case "heading2":
      case "heading3":
      case "heading4":
        return "h" + o.slice(-1);
      case "body1":
      case "body2":
      case "subtitle1":
      case "subtitle2":
        return "p";
      case "caption":
      case "value":
        return "span";
      default:
        return o;
    }
  })(s);
  return /* @__PURE__ */ A.jsx(n, { className: Q("text-gray-900", r[s], t), children: e });
}, Wr = "timepicker-dropdown-opened", pu = rt(
  "border bg-white px-3 py-2 ring-0 transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50"
      },
      size: {
        sm: "h-8 px-2 py-1 text-sm",
        md: "h-10 px-3 py-2 text-base",
        lg: "h-12 px-4 py-3 text-lg"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      },
      fullWidth: {
        true: "w-full",
        false: "w-fit"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "md",
      fullWidth: !0
    }
  }
), xu = Ge(
  ({
    value: s,
    onChange: e,
    use24Hour: t = !1,
    variant: i = "default",
    size: r = "md",
    rounded: a = "md",
    disabled: n = !1,
    errorText: o,
    helperText: l,
    label: c,
    required: h = !1,
    labelPlacement: d = "top",
    fullWidth: u = !1,
    className: g,
    placeholder: p = "Select time",
    ...f
  }, x) => {
    const [m, b] = Ee(!1), [w, y] = Ee(s || ""), [v, k] = Ee(0), [S, C] = Ee(0), [M, R] = Ee(!0), P = Ve(null), I = Ve(null), D = Ve(null), z = `timepicker-${He.useId().replace(/:/g, "")}`, L = () => {
      if (m && I.current && D.current) {
        const Y = I.current.getBoundingClientRect(), X = D.current, V = window.innerHeight - Y.bottom, W = Y.top, G = X.offsetHeight, U = Y.bottom + G + 4 >= window.innerHeight, Z = W > V, re = U && Z;
        X.style.position = "fixed", X.style.width = `${Y.width}px`, X.style.left = `${Y.left}px`, re ? (X.style.bottom = `${window.innerHeight - Y.top + 4}px`, X.style.top = "auto", X.style.maxHeight = `${W - 8}px`) : (X.style.top = `${Y.bottom + 4}px`, X.style.bottom = "auto", X.style.maxHeight = `${V - 8}px`);
      }
    };
    ht(() => {
      const Y = () => {
        m && L();
      }, X = () => {
        m && L();
      }, V = (G) => {
        G.detail.id !== z && b(!1);
      }, W = (G) => {
        const U = G.target;
        P.current && D.current && !P.current.contains(U) && !D.current.contains(U) && b(!1);
      };
      return m && (L(), window.addEventListener("scroll", Y, !0), window.addEventListener("resize", X)), document.addEventListener(Wr, V), document.addEventListener("mousedown", W), () => {
        window.removeEventListener("scroll", Y, !0), window.removeEventListener("resize", X), document.removeEventListener(Wr, V), document.removeEventListener("mousedown", W);
      };
    }, [m, z]);
    const T = () => {
      n || (m || document.dispatchEvent(
        new CustomEvent(Wr, {
          detail: { id: z }
        })
      ), b(!m));
    };
    ht(() => {
      if (s) {
        y(s);
        const [Y, X] = s.split(":").map(Number);
        t ? k(Y) : (k(Y % 12 || 12), R(Y < 12)), C(X);
      }
    }, [s, t]);
    const H = () => {
      const X = `${(t || M ? v : v + 12).toString().padStart(2, "0")}:${S.toString().padStart(2, "0")}`;
      y(X), e == null || e(X), b(!1);
    }, B = () => t ? Array.from({ length: 24 }, (Y, X) => X) : Array.from({ length: 12 }, (Y, X) => X + 1), _ = () => Array.from({ length: 60 }, (Y, X) => X), O = () => {
      if (!m) return null;
      const Y = /* @__PURE__ */ A.jsx(
        "div",
        {
          ref: D,
          className: "fixed z-[9999] min-w-[320px] rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5",
          onClick: (X) => X.stopPropagation(),
          children: /* @__PURE__ */ A.jsxs("div", { className: "p-4", children: [
            /* @__PURE__ */ A.jsxs("div", { className: "grid grid-cols-3 gap-4 text-sm font-medium text-gray-500", children: [
              /* @__PURE__ */ A.jsx("span", { children: "Hours" }),
              /* @__PURE__ */ A.jsx("span", { children: "Minutes" }),
              !t && /* @__PURE__ */ A.jsx("span", { children: "AM/PM" })
            ] }),
            /* @__PURE__ */ A.jsxs("div", { className: "flex justify-between gap-4 mt-2", children: [
              /* @__PURE__ */ A.jsx("div", { className: "w-24 flex flex-col", children: /* @__PURE__ */ A.jsx("div", { className: "overflow-y-auto [scrollbar-width:none] [-ms-overflow-style:none] hover:scrollbar-thumb-neutral-200 hover:scrollbar-track-transparent [&::-webkit-scrollbar]:hidden hover:[&::-webkit-scrollbar]:block hover:[&::-webkit-scrollbar]:w-1.5 hover:[&::-webkit-scrollbar-thumb]:rounded-full", style: { maxHeight: "200px" }, children: /* @__PURE__ */ A.jsx("div", { className: "flex flex-col gap-1 py-1", children: B().map((X) => /* @__PURE__ */ A.jsx(
                et,
                {
                  variant: "ghost",
                  onClick: () => k(X),
                  className: Q(
                    "px-3 py-1.5 text-sm rounded hover:bg-gray-100 w-full justify-start",
                    v === X && "bg-primary-100 text-primary-700"
                  ),
                  children: X.toString().padStart(2, "0")
                },
                X
              )) }) }) }),
              /* @__PURE__ */ A.jsx("div", { className: "w-24 flex flex-col", children: /* @__PURE__ */ A.jsx("div", { className: "overflow-y-auto [scrollbar-width:none] [-ms-overflow-style:none] hover:scrollbar-thumb-neutral-200 hover:scrollbar-track-transparent [&::-webkit-scrollbar]:hidden hover:[&::-webkit-scrollbar]:block hover:[&::-webkit-scrollbar]:w-1.5 hover:[&::-webkit-scrollbar-thumb]:rounded-full", style: { maxHeight: "200px" }, children: /* @__PURE__ */ A.jsx("div", { className: "flex flex-col gap-1 py-1", children: _().map((X) => /* @__PURE__ */ A.jsx(
                et,
                {
                  variant: "ghost",
                  onClick: () => C(X),
                  className: Q(
                    "px-3 py-1.5 text-sm rounded hover:bg-gray-100 w-full justify-start",
                    S === X && "bg-primary-100 text-primary-700"
                  ),
                  children: X.toString().padStart(2, "0")
                },
                X
              )) }) }) }),
              !t && /* @__PURE__ */ A.jsxs("div", { className: "w-24 flex flex-col gap-2", children: [
                /* @__PURE__ */ A.jsx(
                  et,
                  {
                    variant: "ghost",
                    onClick: () => R(!0),
                    className: Q(
                      "px-3 py-1.5 text-sm rounded hover:bg-gray-100 w-full justify-start",
                      M && "bg-primary-100 text-primary-700"
                    ),
                    children: "AM"
                  }
                ),
                /* @__PURE__ */ A.jsx(
                  et,
                  {
                    variant: "ghost",
                    onClick: () => R(!1),
                    className: Q(
                      "px-3 py-1.5 text-sm rounded hover:bg-gray-100 w-full justify-start",
                      !M && "bg-primary-100 text-primary-700"
                    ),
                    children: "PM"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ A.jsx("div", { className: "mt-4 flex justify-end", children: /* @__PURE__ */ A.jsx(
              et,
              {
                variant: "primary",
                onClick: H,
                size: "sm",
                children: "Select"
              }
            ) })
          ] })
        }
      );
      return ei(Y, document.body);
    };
    return /* @__PURE__ */ A.jsxs("div", { ref: P, className: Q("relative", u && "w-full", g), children: [
      c && /* @__PURE__ */ A.jsxs(
        "label",
        {
          className: Q(
            "block text-sm font-medium text-gray-700 mb-1",
            d === "left" && "inline-block mr-2"
          ),
          children: [
            c,
            h && /* @__PURE__ */ A.jsx("span", { className: "text-red-500 ml-1", children: "*" })
          ]
        }
      ),
      /* @__PURE__ */ A.jsx("div", { ref: I, children: /* @__PURE__ */ A.jsx(
        "input",
        {
          ref: x,
          type: "text",
          value: w,
          placeholder: p,
          onClick: T,
          readOnly: !0,
          className: Q(pu({ variant: i, size: r, rounded: a, fullWidth: u })),
          disabled: n,
          ...f
        }
      ) }),
      O(),
      o && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-sm text-danger-600", children: o }),
      l && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-sm text-gray-500", children: l })
    ] });
  }
);
xu.displayName = "TimePicker";
const mu = rt(
  "relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      variant: {
        primary: "bg-neutral-200 data-[state=checked]:bg-primary-500 focus-visible:ring-primary-500",
        success: "bg-neutral-200 data-[state=checked]:bg-success-500 focus-visible:ring-success-500",
        warning: "bg-neutral-200 data-[state=checked]:bg-warning-500 focus-visible:ring-warning-500",
        danger: "bg-neutral-200 data-[state=checked]:bg-danger-500 focus-visible:ring-danger-500"
      },
      size: {
        sm: "h-4 w-7",
        md: "h-6 w-11",
        lg: "h-7 w-14"
      }
    },
    defaultVariants: {
      variant: "primary",
      size: "md"
    }
  }
), bu = rt(
  "pointer-events-none block rounded-full bg-white shadow-lg ring-0 transition-transform",
  {
    variants: {
      size: {
        sm: "h-3 w-3 data-[state=checked]:translate-x-3",
        md: "h-5 w-5 data-[state=checked]:translate-x-5",
        lg: "h-6 w-6 data-[state=checked]:translate-x-7"
      }
    },
    defaultVariants: {
      size: "md"
    }
  }
), vu = Ge(
  ({
    checked: s = !1,
    onCheckedChange: e,
    variant: t = "primary",
    size: i = "md",
    label: r,
    required: a = !1,
    helperText: n,
    errorText: o,
    error: l = !1,
    className: c,
    ...h
  }, d) => {
    const u = He.useId(), g = `${u}-helper`, p = `${u}-error`;
    return /* @__PURE__ */ A.jsxs("div", { className: "inline-flex flex-col gap-1.5", children: [
      /* @__PURE__ */ A.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ A.jsx(
          "button",
          {
            type: "button",
            role: "switch",
            "aria-checked": s,
            "data-state": s ? "checked" : "unchecked",
            onClick: () => e == null ? void 0 : e(!s),
            ref: d,
            className: Q(mu({ variant: l ? "danger" : t, size: i }), c),
            "aria-describedby": l ? p : n ? g : void 0,
            "aria-invalid": l,
            "aria-required": a,
            ...h,
            children: /* @__PURE__ */ A.jsx(
              "span",
              {
                "data-state": s ? "checked" : "unchecked",
                className: Q(
                  bu({ size: i }),
                  s ? "translate-x-5" : "translate-x-1"
                )
              }
            )
          }
        ),
        r && /* @__PURE__ */ A.jsxs(
          "label",
          {
            htmlFor: u,
            className: "text-sm text-neutral-900",
            children: [
              r,
              a && /* @__PURE__ */ A.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
            ]
          }
        )
      ] }),
      l && o && /* @__PURE__ */ A.jsx("p", { className: "text-xs text-danger-500", id: p, children: o }),
      !l && n && /* @__PURE__ */ A.jsx("p", { className: "text-xs text-neutral-500", id: g, children: n })
    ] });
  }
);
vu.displayName = "Toggle";
const Xg = ({
  content: s,
  children: e,
  position: t = "top",
  delay: i = 0,
  className: r
}) => {
  const [a, n] = Ee(!1), [o, l] = Ee({ top: 0, left: 0 }), c = Ve(null), h = Ve(null);
  let d;
  const u = () => {
    if (!c.current || !h.current) return;
    const f = h.current.getBoundingClientRect(), x = c.current.getBoundingClientRect();
    let m = 0, b = 0;
    switch (t) {
      case "top":
        m = f.top - x.height - 8, b = f.left + (f.width - x.width) / 2;
        break;
      case "bottom":
        m = f.bottom + 8, b = f.left + (f.width - x.width) / 2;
        break;
      case "left":
        m = f.top + (f.height - x.height) / 2, b = f.left - x.width - 8;
        break;
      case "right":
        m = f.top + (f.height - x.height) / 2, b = f.right + 8;
        break;
    }
    l({ top: m, left: b });
  };
  ht(() => (a && (u(), window.addEventListener("scroll", u), window.addEventListener("resize", u)), () => {
    window.removeEventListener("scroll", u), window.removeEventListener("resize", u);
  }), [a, t]);
  const g = () => {
    d = setTimeout(() => {
      n(!0);
    }, i);
  }, p = () => {
    clearTimeout(d), n(!1);
  };
  return /* @__PURE__ */ A.jsxs(
    "div",
    {
      ref: h,
      className: "relative inline-block",
      onMouseEnter: g,
      onMouseLeave: p,
      children: [
        e,
        a && /* @__PURE__ */ A.jsxs(
          "div",
          {
            ref: c,
            className: ve(
              "absolute z-50 px-3 py-2 text-sm text-white bg-gray-900 rounded-md shadow-lg",
              "transition-opacity duration-200",
              r
            ),
            style: {
              top: `${o.top}px`,
              left: `${o.left}px`
            },
            children: [
              s,
              /* @__PURE__ */ A.jsx(
                "div",
                {
                  className: ve(
                    "absolute w-2 h-2 bg-gray-900 transform rotate-45",
                    t === "top" && "bottom-[-4px] left-1/2 -translate-x-1/2",
                    t === "bottom" && "top-[-4px] left-1/2 -translate-x-1/2",
                    t === "left" && "right-[-4px] top-1/2 -translate-y-1/2",
                    t === "right" && "left-[-4px] top-1/2 -translate-y-1/2"
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}, yu = rt("flex items-center text-sm", {
  variants: {
    variant: {
      default: "text-neutral-600",
      light: "text-neutral-400",
      dark: "text-neutral-800"
    },
    size: {
      sm: "text-xs",
      md: "text-sm",
      lg: "text-base"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "md"
  }
}), wu = Ge(
  ({
    className: s,
    variant: e = "default",
    size: t = "md",
    items: i,
    separator: r = /* @__PURE__ */ A.jsx(yt, { icon: "mdi:slash-forward", className: "h-4 w-4 flex-shrink-0" }),
    activeLastItem: a = !0,
    ...n
  }, o) => /* @__PURE__ */ A.jsx(
    "nav",
    {
      ref: o,
      className: Q(yu({ variant: e, size: t }), s),
      "aria-label": "Breadcrumb",
      ...n,
      children: /* @__PURE__ */ A.jsx("ol", { className: "flex flex-wrap items-center gap-1.5", children: i.map((l, c) => {
        const h = c === i.length - 1, d = h && a;
        return /* @__PURE__ */ A.jsxs(
          "li",
          {
            className: Q(
              "flex items-center gap-1.5",
              d && "text-primary-500 font-medium"
            ),
            children: [
              l.icon && /* @__PURE__ */ A.jsx(
                yt,
                {
                  icon: l.icon,
                  className: Q(
                    "flex-shrink-0",
                    t === "sm" && "h-3.5 w-3.5",
                    t === "md" && "h-4 w-4",
                    t === "lg" && "h-5 w-5"
                  )
                }
              ),
              l.href && !d ? /* @__PURE__ */ A.jsx(
                "a",
                {
                  href: l.href,
                  className: Q(
                    "transition-colors duration-200",
                    "hover:text-primary-500 hover:underline focus:outline-none",
                    "focus-visible:text-primary-500 focus-visible:underline",
                    "active:text-primary-600"
                  ),
                  children: /* @__PURE__ */ A.jsx("span", { className: "truncate max-w-[200px] inline-block align-bottom", children: l.label })
                }
              ) : /* @__PURE__ */ A.jsx("span", { className: Q(
                "truncate max-w-[200px] inline-block",
                d && "text-primary-500"
              ), children: l.label }),
              !h && /* @__PURE__ */ A.jsx("span", { className: Q(
                "text-neutral-400 flex-shrink-0",
                t === "sm" && "scale-90",
                t === "lg" && "scale-110"
              ), children: r })
            ]
          },
          l.label
        );
      }) })
    }
  )
);
wu.displayName = "Breadcrumbs";
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function At(s, e) {
  return typeof s == "function" ? s(e) : s;
}
function it(s, e) {
  return (t) => {
    e.setState((i) => ({
      ...i,
      [s]: At(t, i[s])
    }));
  };
}
function or(s) {
  return s instanceof Function;
}
function ku(s) {
  return Array.isArray(s) && s.every((e) => typeof e == "number");
}
function Su(s, e) {
  const t = [], i = (r) => {
    r.forEach((a) => {
      t.push(a);
      const n = e(a);
      n != null && n.length && i(n);
    });
  };
  return i(s), t;
}
function le(s, e, t) {
  let i = [], r;
  return (a) => {
    let n;
    t.key && t.debug && (n = Date.now());
    const o = s(a);
    if (!(o.length !== i.length || o.some((h, d) => i[d] !== h)))
      return r;
    i = o;
    let c;
    if (t.key && t.debug && (c = Date.now()), r = e(...o), t == null || t.onChange == null || t.onChange(r), t.key && t.debug && t != null && t.debug()) {
      const h = Math.round((Date.now() - n) * 100) / 100, d = Math.round((Date.now() - c) * 100) / 100, u = d / 16, g = (p, f) => {
        for (p = String(p); p.length < f; )
          p = " " + p;
        return p;
      };
      console.info(`%c ${g(d, 5)} /${g(h, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * u, 120))}deg 100% 31%);`, t == null ? void 0 : t.key);
    }
    return r;
  };
}
function ce(s, e, t, i) {
  return {
    debug: () => {
      var r;
      return (r = s == null ? void 0 : s.debugAll) != null ? r : s[e];
    },
    key: process.env.NODE_ENV === "development" && t,
    onChange: i
  };
}
function Cu(s, e, t, i) {
  const r = () => {
    var n;
    return (n = a.getValue()) != null ? n : s.options.renderFallbackValue;
  }, a = {
    id: `${e.id}_${t.id}`,
    row: e,
    column: t,
    getValue: () => e.getValue(i),
    renderValue: r,
    getContext: le(() => [s, t, e, a], (n, o, l, c) => ({
      table: n,
      column: o,
      row: l,
      cell: c,
      getValue: c.getValue,
      renderValue: c.renderValue
    }), ce(s.options, "debugCells", "cell.getContext"))
  };
  return s._features.forEach((n) => {
    n.createCell == null || n.createCell(a, t, e, s);
  }, {}), a;
}
function Au(s, e, t, i) {
  var r, a;
  const o = {
    ...s._getDefaultColumnDef(),
    ...e
  }, l = o.accessorKey;
  let c = (r = (a = o.id) != null ? a : l ? typeof String.prototype.replaceAll == "function" ? l.replaceAll(".", "_") : l.replace(/\./g, "_") : void 0) != null ? r : typeof o.header == "string" ? o.header : void 0, h;
  if (o.accessorFn ? h = o.accessorFn : l && (l.includes(".") ? h = (u) => {
    let g = u;
    for (const f of l.split(".")) {
      var p;
      g = (p = g) == null ? void 0 : p[f], process.env.NODE_ENV !== "production" && g === void 0 && console.warn(`"${f}" in deeply nested key "${l}" returned undefined.`);
    }
    return g;
  } : h = (u) => u[o.accessorKey]), !c)
    throw process.env.NODE_ENV !== "production" ? new Error(o.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header") : new Error();
  let d = {
    id: `${String(c)}`,
    accessorFn: h,
    parent: i,
    depth: t,
    columnDef: o,
    columns: [],
    getFlatColumns: le(() => [!0], () => {
      var u;
      return [d, ...(u = d.columns) == null ? void 0 : u.flatMap((g) => g.getFlatColumns())];
    }, ce(s.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: le(() => [s._getOrderColumnsFn()], (u) => {
      var g;
      if ((g = d.columns) != null && g.length) {
        let p = d.columns.flatMap((f) => f.getLeafColumns());
        return u(p);
      }
      return [d];
    }, ce(s.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const u of s._features)
    u.createColumn == null || u.createColumn(d, s);
  return d;
}
const We = "debugHeaders";
function xn(s, e, t) {
  var i;
  let a = {
    id: (i = t.id) != null ? i : e.id,
    column: e,
    index: t.index,
    isPlaceholder: !!t.isPlaceholder,
    placeholderId: t.placeholderId,
    depth: t.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const n = [], o = (l) => {
        l.subHeaders && l.subHeaders.length && l.subHeaders.map(o), n.push(l);
      };
      return o(a), n;
    },
    getContext: () => ({
      table: s,
      header: a,
      column: e
    })
  };
  return s._features.forEach((n) => {
    n.createHeader == null || n.createHeader(a, s);
  }), a;
}
const Mu = {
  createTable: (s) => {
    s.getHeaderGroups = le(() => [s.getAllColumns(), s.getVisibleLeafColumns(), s.getState().columnPinning.left, s.getState().columnPinning.right], (e, t, i, r) => {
      var a, n;
      const o = (a = i == null ? void 0 : i.map((d) => t.find((u) => u.id === d)).filter(Boolean)) != null ? a : [], l = (n = r == null ? void 0 : r.map((d) => t.find((u) => u.id === d)).filter(Boolean)) != null ? n : [], c = t.filter((d) => !(i != null && i.includes(d.id)) && !(r != null && r.includes(d.id)));
      return ji(e, [...o, ...c, ...l], s);
    }, ce(s.options, We, "getHeaderGroups")), s.getCenterHeaderGroups = le(() => [s.getAllColumns(), s.getVisibleLeafColumns(), s.getState().columnPinning.left, s.getState().columnPinning.right], (e, t, i, r) => (t = t.filter((a) => !(i != null && i.includes(a.id)) && !(r != null && r.includes(a.id))), ji(e, t, s, "center")), ce(s.options, We, "getCenterHeaderGroups")), s.getLeftHeaderGroups = le(() => [s.getAllColumns(), s.getVisibleLeafColumns(), s.getState().columnPinning.left], (e, t, i) => {
      var r;
      const a = (r = i == null ? void 0 : i.map((n) => t.find((o) => o.id === n)).filter(Boolean)) != null ? r : [];
      return ji(e, a, s, "left");
    }, ce(s.options, We, "getLeftHeaderGroups")), s.getRightHeaderGroups = le(() => [s.getAllColumns(), s.getVisibleLeafColumns(), s.getState().columnPinning.right], (e, t, i) => {
      var r;
      const a = (r = i == null ? void 0 : i.map((n) => t.find((o) => o.id === n)).filter(Boolean)) != null ? r : [];
      return ji(e, a, s, "right");
    }, ce(s.options, We, "getRightHeaderGroups")), s.getFooterGroups = le(() => [s.getHeaderGroups()], (e) => [...e].reverse(), ce(s.options, We, "getFooterGroups")), s.getLeftFooterGroups = le(() => [s.getLeftHeaderGroups()], (e) => [...e].reverse(), ce(s.options, We, "getLeftFooterGroups")), s.getCenterFooterGroups = le(() => [s.getCenterHeaderGroups()], (e) => [...e].reverse(), ce(s.options, We, "getCenterFooterGroups")), s.getRightFooterGroups = le(() => [s.getRightHeaderGroups()], (e) => [...e].reverse(), ce(s.options, We, "getRightFooterGroups")), s.getFlatHeaders = le(() => [s.getHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(s.options, We, "getFlatHeaders")), s.getLeftFlatHeaders = le(() => [s.getLeftHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(s.options, We, "getLeftFlatHeaders")), s.getCenterFlatHeaders = le(() => [s.getCenterHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(s.options, We, "getCenterFlatHeaders")), s.getRightFlatHeaders = le(() => [s.getRightHeaderGroups()], (e) => e.map((t) => t.headers).flat(), ce(s.options, We, "getRightFlatHeaders")), s.getCenterLeafHeaders = le(() => [s.getCenterFlatHeaders()], (e) => e.filter((t) => {
      var i;
      return !((i = t.subHeaders) != null && i.length);
    }), ce(s.options, We, "getCenterLeafHeaders")), s.getLeftLeafHeaders = le(() => [s.getLeftFlatHeaders()], (e) => e.filter((t) => {
      var i;
      return !((i = t.subHeaders) != null && i.length);
    }), ce(s.options, We, "getLeftLeafHeaders")), s.getRightLeafHeaders = le(() => [s.getRightFlatHeaders()], (e) => e.filter((t) => {
      var i;
      return !((i = t.subHeaders) != null && i.length);
    }), ce(s.options, We, "getRightLeafHeaders")), s.getLeafHeaders = le(() => [s.getLeftHeaderGroups(), s.getCenterHeaderGroups(), s.getRightHeaderGroups()], (e, t, i) => {
      var r, a, n, o, l, c;
      return [...(r = (a = e[0]) == null ? void 0 : a.headers) != null ? r : [], ...(n = (o = t[0]) == null ? void 0 : o.headers) != null ? n : [], ...(l = (c = i[0]) == null ? void 0 : c.headers) != null ? l : []].map((h) => h.getLeafHeaders()).flat();
    }, ce(s.options, We, "getLeafHeaders"));
  }
};
function ji(s, e, t, i) {
  var r, a;
  let n = 0;
  const o = function(u, g) {
    g === void 0 && (g = 1), n = Math.max(n, g), u.filter((p) => p.getIsVisible()).forEach((p) => {
      var f;
      (f = p.columns) != null && f.length && o(p.columns, g + 1);
    }, 0);
  };
  o(s);
  let l = [];
  const c = (u, g) => {
    const p = {
      depth: g,
      id: [i, `${g}`].filter(Boolean).join("_"),
      headers: []
    }, f = [];
    u.forEach((x) => {
      const m = [...f].reverse()[0], b = x.column.depth === p.depth;
      let w, y = !1;
      if (b && x.column.parent ? w = x.column.parent : (w = x.column, y = !0), m && (m == null ? void 0 : m.column) === w)
        m.subHeaders.push(x);
      else {
        const v = xn(t, w, {
          id: [i, g, w.id, x == null ? void 0 : x.id].filter(Boolean).join("_"),
          isPlaceholder: y,
          placeholderId: y ? `${f.filter((k) => k.column === w).length}` : void 0,
          depth: g,
          index: f.length
        });
        v.subHeaders.push(x), f.push(v);
      }
      p.headers.push(x), x.headerGroup = p;
    }), l.push(p), g > 0 && c(f, g - 1);
  }, h = e.map((u, g) => xn(t, u, {
    depth: n,
    index: g
  }));
  c(h, n - 1), l.reverse();
  const d = (u) => u.filter((p) => p.column.getIsVisible()).map((p) => {
    let f = 0, x = 0, m = [0];
    p.subHeaders && p.subHeaders.length ? (m = [], d(p.subHeaders).forEach((w) => {
      let {
        colSpan: y,
        rowSpan: v
      } = w;
      f += y, m.push(v);
    })) : f = 1;
    const b = Math.min(...m);
    return x = x + b, p.colSpan = f, p.rowSpan = x, {
      colSpan: f,
      rowSpan: x
    };
  });
  return d((r = (a = l[0]) == null ? void 0 : a.headers) != null ? r : []), l;
}
const Ru = (s, e, t, i, r, a, n) => {
  let o = {
    id: e,
    index: i,
    original: t,
    depth: r,
    parentId: n,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (l) => {
      if (o._valuesCache.hasOwnProperty(l))
        return o._valuesCache[l];
      const c = s.getColumn(l);
      if (c != null && c.accessorFn)
        return o._valuesCache[l] = c.accessorFn(o.original, i), o._valuesCache[l];
    },
    getUniqueValues: (l) => {
      if (o._uniqueValuesCache.hasOwnProperty(l))
        return o._uniqueValuesCache[l];
      const c = s.getColumn(l);
      if (c != null && c.accessorFn)
        return c.columnDef.getUniqueValues ? (o._uniqueValuesCache[l] = c.columnDef.getUniqueValues(o.original, i), o._uniqueValuesCache[l]) : (o._uniqueValuesCache[l] = [o.getValue(l)], o._uniqueValuesCache[l]);
    },
    renderValue: (l) => {
      var c;
      return (c = o.getValue(l)) != null ? c : s.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => Su(o.subRows, (l) => l.subRows),
    getParentRow: () => o.parentId ? s.getRow(o.parentId, !0) : void 0,
    getParentRows: () => {
      let l = [], c = o;
      for (; ; ) {
        const h = c.getParentRow();
        if (!h) break;
        l.push(h), c = h;
      }
      return l.reverse();
    },
    getAllCells: le(() => [s.getAllLeafColumns()], (l) => l.map((c) => Cu(s, o, c, c.id)), ce(s.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: le(() => [o.getAllCells()], (l) => l.reduce((c, h) => (c[h.column.id] = h, c), {}), ce(s.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let l = 0; l < s._features.length; l++) {
    const c = s._features[l];
    c == null || c.createRow == null || c.createRow(o, s);
  }
  return o;
}, Pu = {
  createColumn: (s, e) => {
    s._getFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, s.id), s.getFacetedRowModel = () => s._getFacetedRowModel ? s._getFacetedRowModel() : e.getPreFilteredRowModel(), s._getFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, s.id), s.getFacetedUniqueValues = () => s._getFacetedUniqueValues ? s._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), s._getFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, s.id), s.getFacetedMinMaxValues = () => {
      if (s._getFacetedMinMaxValues)
        return s._getFacetedMinMaxValues();
    };
  }
}, Go = (s, e, t) => {
  var i, r;
  const a = t == null || (i = t.toString()) == null ? void 0 : i.toLowerCase();
  return !!(!((r = s.getValue(e)) == null || (r = r.toString()) == null || (r = r.toLowerCase()) == null) && r.includes(a));
};
Go.autoRemove = (s) => ft(s);
const $o = (s, e, t) => {
  var i;
  return !!(!((i = s.getValue(e)) == null || (i = i.toString()) == null) && i.includes(t));
};
$o.autoRemove = (s) => ft(s);
const Uo = (s, e, t) => {
  var i;
  return ((i = s.getValue(e)) == null || (i = i.toString()) == null ? void 0 : i.toLowerCase()) === (t == null ? void 0 : t.toLowerCase());
};
Uo.autoRemove = (s) => ft(s);
const qo = (s, e, t) => {
  var i;
  return (i = s.getValue(e)) == null ? void 0 : i.includes(t);
};
qo.autoRemove = (s) => ft(s);
const Zo = (s, e, t) => !t.some((i) => {
  var r;
  return !((r = s.getValue(e)) != null && r.includes(i));
});
Zo.autoRemove = (s) => ft(s) || !(s != null && s.length);
const Ko = (s, e, t) => t.some((i) => {
  var r;
  return (r = s.getValue(e)) == null ? void 0 : r.includes(i);
});
Ko.autoRemove = (s) => ft(s) || !(s != null && s.length);
const Jo = (s, e, t) => s.getValue(e) === t;
Jo.autoRemove = (s) => ft(s);
const Qo = (s, e, t) => s.getValue(e) == t;
Qo.autoRemove = (s) => ft(s);
const ra = (s, e, t) => {
  let [i, r] = t;
  const a = s.getValue(e);
  return a >= i && a <= r;
};
ra.resolveFilterValue = (s) => {
  let [e, t] = s, i = typeof e != "number" ? parseFloat(e) : e, r = typeof t != "number" ? parseFloat(t) : t, a = e === null || Number.isNaN(i) ? -1 / 0 : i, n = t === null || Number.isNaN(r) ? 1 / 0 : r;
  if (a > n) {
    const o = a;
    a = n, n = o;
  }
  return [a, n];
};
ra.autoRemove = (s) => ft(s) || ft(s[0]) && ft(s[1]);
const mt = {
  includesString: Go,
  includesStringSensitive: $o,
  equalsString: Uo,
  arrIncludes: qo,
  arrIncludesAll: Zo,
  arrIncludesSome: Ko,
  equals: Jo,
  weakEquals: Qo,
  inNumberRange: ra
};
function ft(s) {
  return s == null || s === "";
}
const Lu = {
  getDefaultColumnDef: () => ({
    filterFn: "auto"
  }),
  getInitialState: (s) => ({
    columnFilters: [],
    ...s
  }),
  getDefaultOptions: (s) => ({
    onColumnFiltersChange: it("columnFilters", s),
    filterFromLeafRows: !1,
    maxLeafRowFilterDepth: 100
  }),
  createColumn: (s, e) => {
    s.getAutoFilterFn = () => {
      const t = e.getCoreRowModel().flatRows[0], i = t == null ? void 0 : t.getValue(s.id);
      return typeof i == "string" ? mt.includesString : typeof i == "number" ? mt.inNumberRange : typeof i == "boolean" || i !== null && typeof i == "object" ? mt.equals : Array.isArray(i) ? mt.arrIncludes : mt.weakEquals;
    }, s.getFilterFn = () => {
      var t, i;
      return or(s.columnDef.filterFn) ? s.columnDef.filterFn : s.columnDef.filterFn === "auto" ? s.getAutoFilterFn() : (
        // @ts-ignore
        (t = (i = e.options.filterFns) == null ? void 0 : i[s.columnDef.filterFn]) != null ? t : mt[s.columnDef.filterFn]
      );
    }, s.getCanFilter = () => {
      var t, i, r;
      return ((t = s.columnDef.enableColumnFilter) != null ? t : !0) && ((i = e.options.enableColumnFilters) != null ? i : !0) && ((r = e.options.enableFilters) != null ? r : !0) && !!s.accessorFn;
    }, s.getIsFiltered = () => s.getFilterIndex() > -1, s.getFilterValue = () => {
      var t;
      return (t = e.getState().columnFilters) == null || (t = t.find((i) => i.id === s.id)) == null ? void 0 : t.value;
    }, s.getFilterIndex = () => {
      var t, i;
      return (t = (i = e.getState().columnFilters) == null ? void 0 : i.findIndex((r) => r.id === s.id)) != null ? t : -1;
    }, s.setFilterValue = (t) => {
      e.setColumnFilters((i) => {
        const r = s.getFilterFn(), a = i == null ? void 0 : i.find((h) => h.id === s.id), n = At(t, a ? a.value : void 0);
        if (mn(r, n, s)) {
          var o;
          return (o = i == null ? void 0 : i.filter((h) => h.id !== s.id)) != null ? o : [];
        }
        const l = {
          id: s.id,
          value: n
        };
        if (a) {
          var c;
          return (c = i == null ? void 0 : i.map((h) => h.id === s.id ? l : h)) != null ? c : [];
        }
        return i != null && i.length ? [...i, l] : [l];
      });
    };
  },
  createRow: (s, e) => {
    s.columnFilters = {}, s.columnFiltersMeta = {};
  },
  createTable: (s) => {
    s.setColumnFilters = (e) => {
      const t = s.getAllLeafColumns(), i = (r) => {
        var a;
        return (a = At(e, r)) == null ? void 0 : a.filter((n) => {
          const o = t.find((l) => l.id === n.id);
          if (o) {
            const l = o.getFilterFn();
            if (mn(l, n.value, o))
              return !1;
          }
          return !0;
        });
      };
      s.options.onColumnFiltersChange == null || s.options.onColumnFiltersChange(i);
    }, s.resetColumnFilters = (e) => {
      var t, i;
      s.setColumnFilters(e ? [] : (t = (i = s.initialState) == null ? void 0 : i.columnFilters) != null ? t : []);
    }, s.getPreFilteredRowModel = () => s.getCoreRowModel(), s.getFilteredRowModel = () => (!s._getFilteredRowModel && s.options.getFilteredRowModel && (s._getFilteredRowModel = s.options.getFilteredRowModel(s)), s.options.manualFiltering || !s._getFilteredRowModel ? s.getPreFilteredRowModel() : s._getFilteredRowModel());
  }
};
function mn(s, e, t) {
  return (s && s.autoRemove ? s.autoRemove(e, t) : !1) || typeof e > "u" || typeof e == "string" && !e;
}
const Iu = (s, e, t) => t.reduce((i, r) => {
  const a = r.getValue(s);
  return i + (typeof a == "number" ? a : 0);
}, 0), Eu = (s, e, t) => {
  let i;
  return t.forEach((r) => {
    const a = r.getValue(s);
    a != null && (i > a || i === void 0 && a >= a) && (i = a);
  }), i;
}, Tu = (s, e, t) => {
  let i;
  return t.forEach((r) => {
    const a = r.getValue(s);
    a != null && (i < a || i === void 0 && a >= a) && (i = a);
  }), i;
}, _u = (s, e, t) => {
  let i, r;
  return t.forEach((a) => {
    const n = a.getValue(s);
    n != null && (i === void 0 ? n >= n && (i = r = n) : (i > n && (i = n), r < n && (r = n)));
  }), [i, r];
}, Ou = (s, e) => {
  let t = 0, i = 0;
  if (e.forEach((r) => {
    let a = r.getValue(s);
    a != null && (a = +a) >= a && (++t, i += a);
  }), t) return i / t;
}, zu = (s, e) => {
  if (!e.length)
    return;
  const t = e.map((a) => a.getValue(s));
  if (!ku(t))
    return;
  if (t.length === 1)
    return t[0];
  const i = Math.floor(t.length / 2), r = t.sort((a, n) => a - n);
  return t.length % 2 !== 0 ? r[i] : (r[i - 1] + r[i]) / 2;
}, Fu = (s, e) => Array.from(new Set(e.map((t) => t.getValue(s))).values()), Nu = (s, e) => new Set(e.map((t) => t.getValue(s))).size, Du = (s, e) => e.length, Vr = {
  sum: Iu,
  min: Eu,
  max: Tu,
  extent: _u,
  mean: Ou,
  median: zu,
  unique: Fu,
  uniqueCount: Nu,
  count: Du
}, Hu = {
  getDefaultColumnDef: () => ({
    aggregatedCell: (s) => {
      var e, t;
      return (e = (t = s.getValue()) == null || t.toString == null ? void 0 : t.toString()) != null ? e : null;
    },
    aggregationFn: "auto"
  }),
  getInitialState: (s) => ({
    grouping: [],
    ...s
  }),
  getDefaultOptions: (s) => ({
    onGroupingChange: it("grouping", s),
    groupedColumnMode: "reorder"
  }),
  createColumn: (s, e) => {
    s.toggleGrouping = () => {
      e.setGrouping((t) => t != null && t.includes(s.id) ? t.filter((i) => i !== s.id) : [...t ?? [], s.id]);
    }, s.getCanGroup = () => {
      var t, i;
      return ((t = s.columnDef.enableGrouping) != null ? t : !0) && ((i = e.options.enableGrouping) != null ? i : !0) && (!!s.accessorFn || !!s.columnDef.getGroupingValue);
    }, s.getIsGrouped = () => {
      var t;
      return (t = e.getState().grouping) == null ? void 0 : t.includes(s.id);
    }, s.getGroupedIndex = () => {
      var t;
      return (t = e.getState().grouping) == null ? void 0 : t.indexOf(s.id);
    }, s.getToggleGroupingHandler = () => {
      const t = s.getCanGroup();
      return () => {
        t && s.toggleGrouping();
      };
    }, s.getAutoAggregationFn = () => {
      const t = e.getCoreRowModel().flatRows[0], i = t == null ? void 0 : t.getValue(s.id);
      if (typeof i == "number")
        return Vr.sum;
      if (Object.prototype.toString.call(i) === "[object Date]")
        return Vr.extent;
    }, s.getAggregationFn = () => {
      var t, i;
      if (!s)
        throw new Error();
      return or(s.columnDef.aggregationFn) ? s.columnDef.aggregationFn : s.columnDef.aggregationFn === "auto" ? s.getAutoAggregationFn() : (t = (i = e.options.aggregationFns) == null ? void 0 : i[s.columnDef.aggregationFn]) != null ? t : Vr[s.columnDef.aggregationFn];
    };
  },
  createTable: (s) => {
    s.setGrouping = (e) => s.options.onGroupingChange == null ? void 0 : s.options.onGroupingChange(e), s.resetGrouping = (e) => {
      var t, i;
      s.setGrouping(e ? [] : (t = (i = s.initialState) == null ? void 0 : i.grouping) != null ? t : []);
    }, s.getPreGroupedRowModel = () => s.getFilteredRowModel(), s.getGroupedRowModel = () => (!s._getGroupedRowModel && s.options.getGroupedRowModel && (s._getGroupedRowModel = s.options.getGroupedRowModel(s)), s.options.manualGrouping || !s._getGroupedRowModel ? s.getPreGroupedRowModel() : s._getGroupedRowModel());
  },
  createRow: (s, e) => {
    s.getIsGrouped = () => !!s.groupingColumnId, s.getGroupingValue = (t) => {
      if (s._groupingValuesCache.hasOwnProperty(t))
        return s._groupingValuesCache[t];
      const i = e.getColumn(t);
      return i != null && i.columnDef.getGroupingValue ? (s._groupingValuesCache[t] = i.columnDef.getGroupingValue(s.original), s._groupingValuesCache[t]) : s.getValue(t);
    }, s._groupingValuesCache = {};
  },
  createCell: (s, e, t, i) => {
    s.getIsGrouped = () => e.getIsGrouped() && e.id === t.groupingColumnId, s.getIsPlaceholder = () => !s.getIsGrouped() && e.getIsGrouped(), s.getIsAggregated = () => {
      var r;
      return !s.getIsGrouped() && !s.getIsPlaceholder() && !!((r = t.subRows) != null && r.length);
    };
  }
};
function ju(s, e, t) {
  if (!(e != null && e.length) || !t)
    return s;
  const i = s.filter((a) => !e.includes(a.id));
  return t === "remove" ? i : [...e.map((a) => s.find((n) => n.id === a)).filter(Boolean), ...i];
}
const Yu = {
  getInitialState: (s) => ({
    columnOrder: [],
    ...s
  }),
  getDefaultOptions: (s) => ({
    onColumnOrderChange: it("columnOrder", s)
  }),
  createColumn: (s, e) => {
    s.getIndex = le((t) => [vi(e, t)], (t) => t.findIndex((i) => i.id === s.id), ce(e.options, "debugColumns", "getIndex")), s.getIsFirstColumn = (t) => {
      var i;
      return ((i = vi(e, t)[0]) == null ? void 0 : i.id) === s.id;
    }, s.getIsLastColumn = (t) => {
      var i;
      const r = vi(e, t);
      return ((i = r[r.length - 1]) == null ? void 0 : i.id) === s.id;
    };
  },
  createTable: (s) => {
    s.setColumnOrder = (e) => s.options.onColumnOrderChange == null ? void 0 : s.options.onColumnOrderChange(e), s.resetColumnOrder = (e) => {
      var t;
      s.setColumnOrder(e ? [] : (t = s.initialState.columnOrder) != null ? t : []);
    }, s._getOrderColumnsFn = le(() => [s.getState().columnOrder, s.getState().grouping, s.options.groupedColumnMode], (e, t, i) => (r) => {
      let a = [];
      if (!(e != null && e.length))
        a = r;
      else {
        const n = [...e], o = [...r];
        for (; o.length && n.length; ) {
          const l = n.shift(), c = o.findIndex((h) => h.id === l);
          c > -1 && a.push(o.splice(c, 1)[0]);
        }
        a = [...a, ...o];
      }
      return ju(a, t, i);
    }, ce(s.options, "debugTable", "_getOrderColumnsFn"));
  }
}, Gr = () => ({
  left: [],
  right: []
}), Xu = {
  getInitialState: (s) => ({
    columnPinning: Gr(),
    ...s
  }),
  getDefaultOptions: (s) => ({
    onColumnPinningChange: it("columnPinning", s)
  }),
  createColumn: (s, e) => {
    s.pin = (t) => {
      const i = s.getLeafColumns().map((r) => r.id).filter(Boolean);
      e.setColumnPinning((r) => {
        var a, n;
        if (t === "right") {
          var o, l;
          return {
            left: ((o = r == null ? void 0 : r.left) != null ? o : []).filter((d) => !(i != null && i.includes(d))),
            right: [...((l = r == null ? void 0 : r.right) != null ? l : []).filter((d) => !(i != null && i.includes(d))), ...i]
          };
        }
        if (t === "left") {
          var c, h;
          return {
            left: [...((c = r == null ? void 0 : r.left) != null ? c : []).filter((d) => !(i != null && i.includes(d))), ...i],
            right: ((h = r == null ? void 0 : r.right) != null ? h : []).filter((d) => !(i != null && i.includes(d)))
          };
        }
        return {
          left: ((a = r == null ? void 0 : r.left) != null ? a : []).filter((d) => !(i != null && i.includes(d))),
          right: ((n = r == null ? void 0 : r.right) != null ? n : []).filter((d) => !(i != null && i.includes(d)))
        };
      });
    }, s.getCanPin = () => s.getLeafColumns().some((i) => {
      var r, a, n;
      return ((r = i.columnDef.enablePinning) != null ? r : !0) && ((a = (n = e.options.enableColumnPinning) != null ? n : e.options.enablePinning) != null ? a : !0);
    }), s.getIsPinned = () => {
      const t = s.getLeafColumns().map((o) => o.id), {
        left: i,
        right: r
      } = e.getState().columnPinning, a = t.some((o) => i == null ? void 0 : i.includes(o)), n = t.some((o) => r == null ? void 0 : r.includes(o));
      return a ? "left" : n ? "right" : !1;
    }, s.getPinnedIndex = () => {
      var t, i;
      const r = s.getIsPinned();
      return r ? (t = (i = e.getState().columnPinning) == null || (i = i[r]) == null ? void 0 : i.indexOf(s.id)) != null ? t : -1 : 0;
    };
  },
  createRow: (s, e) => {
    s.getCenterVisibleCells = le(() => [s._getAllVisibleCells(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, i, r) => {
      const a = [...i ?? [], ...r ?? []];
      return t.filter((n) => !a.includes(n.column.id));
    }, ce(e.options, "debugRows", "getCenterVisibleCells")), s.getLeftVisibleCells = le(() => [s._getAllVisibleCells(), e.getState().columnPinning.left], (t, i) => (i ?? []).map((a) => t.find((n) => n.column.id === a)).filter(Boolean).map((a) => ({
      ...a,
      position: "left"
    })), ce(e.options, "debugRows", "getLeftVisibleCells")), s.getRightVisibleCells = le(() => [s._getAllVisibleCells(), e.getState().columnPinning.right], (t, i) => (i ?? []).map((a) => t.find((n) => n.column.id === a)).filter(Boolean).map((a) => ({
      ...a,
      position: "right"
    })), ce(e.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (s) => {
    s.setColumnPinning = (e) => s.options.onColumnPinningChange == null ? void 0 : s.options.onColumnPinningChange(e), s.resetColumnPinning = (e) => {
      var t, i;
      return s.setColumnPinning(e ? Gr() : (t = (i = s.initialState) == null ? void 0 : i.columnPinning) != null ? t : Gr());
    }, s.getIsSomeColumnsPinned = (e) => {
      var t;
      const i = s.getState().columnPinning;
      if (!e) {
        var r, a;
        return !!((r = i.left) != null && r.length || (a = i.right) != null && a.length);
      }
      return !!((t = i[e]) != null && t.length);
    }, s.getLeftLeafColumns = le(() => [s.getAllLeafColumns(), s.getState().columnPinning.left], (e, t) => (t ?? []).map((i) => e.find((r) => r.id === i)).filter(Boolean), ce(s.options, "debugColumns", "getLeftLeafColumns")), s.getRightLeafColumns = le(() => [s.getAllLeafColumns(), s.getState().columnPinning.right], (e, t) => (t ?? []).map((i) => e.find((r) => r.id === i)).filter(Boolean), ce(s.options, "debugColumns", "getRightLeafColumns")), s.getCenterLeafColumns = le(() => [s.getAllLeafColumns(), s.getState().columnPinning.left, s.getState().columnPinning.right], (e, t, i) => {
      const r = [...t ?? [], ...i ?? []];
      return e.filter((a) => !r.includes(a.id));
    }, ce(s.options, "debugColumns", "getCenterLeafColumns"));
  }
};
function Bu(s) {
  return s || (typeof document < "u" ? document : null);
}
const Yi = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
}, $r = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: !1,
  columnSizingStart: []
}), Wu = {
  getDefaultColumnDef: () => Yi,
  getInitialState: (s) => ({
    columnSizing: {},
    columnSizingInfo: $r(),
    ...s
  }),
  getDefaultOptions: (s) => ({
    columnResizeMode: "onEnd",
    columnResizeDirection: "ltr",
    onColumnSizingChange: it("columnSizing", s),
    onColumnSizingInfoChange: it("columnSizingInfo", s)
  }),
  createColumn: (s, e) => {
    s.getSize = () => {
      var t, i, r;
      const a = e.getState().columnSizing[s.id];
      return Math.min(Math.max((t = s.columnDef.minSize) != null ? t : Yi.minSize, (i = a ?? s.columnDef.size) != null ? i : Yi.size), (r = s.columnDef.maxSize) != null ? r : Yi.maxSize);
    }, s.getStart = le((t) => [t, vi(e, t), e.getState().columnSizing], (t, i) => i.slice(0, s.getIndex(t)).reduce((r, a) => r + a.getSize(), 0), ce(e.options, "debugColumns", "getStart")), s.getAfter = le((t) => [t, vi(e, t), e.getState().columnSizing], (t, i) => i.slice(s.getIndex(t) + 1).reduce((r, a) => r + a.getSize(), 0), ce(e.options, "debugColumns", "getAfter")), s.resetSize = () => {
      e.setColumnSizing((t) => {
        let {
          [s.id]: i,
          ...r
        } = t;
        return r;
      });
    }, s.getCanResize = () => {
      var t, i;
      return ((t = s.columnDef.enableResizing) != null ? t : !0) && ((i = e.options.enableColumnResizing) != null ? i : !0);
    }, s.getIsResizing = () => e.getState().columnSizingInfo.isResizingColumn === s.id;
  },
  createHeader: (s, e) => {
    s.getSize = () => {
      let t = 0;
      const i = (r) => {
        if (r.subHeaders.length)
          r.subHeaders.forEach(i);
        else {
          var a;
          t += (a = r.column.getSize()) != null ? a : 0;
        }
      };
      return i(s), t;
    }, s.getStart = () => {
      if (s.index > 0) {
        const t = s.headerGroup.headers[s.index - 1];
        return t.getStart() + t.getSize();
      }
      return 0;
    }, s.getResizeHandler = (t) => {
      const i = e.getColumn(s.column.id), r = i == null ? void 0 : i.getCanResize();
      return (a) => {
        if (!i || !r || (a.persist == null || a.persist(), Ur(a) && a.touches && a.touches.length > 1))
          return;
        const n = s.getSize(), o = s ? s.getLeafHeaders().map((m) => [m.column.id, m.column.getSize()]) : [[i.id, i.getSize()]], l = Ur(a) ? Math.round(a.touches[0].clientX) : a.clientX, c = {}, h = (m, b) => {
          typeof b == "number" && (e.setColumnSizingInfo((w) => {
            var y, v;
            const k = e.options.columnResizeDirection === "rtl" ? -1 : 1, S = (b - ((y = w == null ? void 0 : w.startOffset) != null ? y : 0)) * k, C = Math.max(S / ((v = w == null ? void 0 : w.startSize) != null ? v : 0), -0.999999);
            return w.columnSizingStart.forEach((M) => {
              let [R, P] = M;
              c[R] = Math.round(Math.max(P + P * C, 0) * 100) / 100;
            }), {
              ...w,
              deltaOffset: S,
              deltaPercentage: C
            };
          }), (e.options.columnResizeMode === "onChange" || m === "end") && e.setColumnSizing((w) => ({
            ...w,
            ...c
          })));
        }, d = (m) => h("move", m), u = (m) => {
          h("end", m), e.setColumnSizingInfo((b) => ({
            ...b,
            isResizingColumn: !1,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        }, g = Bu(t), p = {
          moveHandler: (m) => d(m.clientX),
          upHandler: (m) => {
            g == null || g.removeEventListener("mousemove", p.moveHandler), g == null || g.removeEventListener("mouseup", p.upHandler), u(m.clientX);
          }
        }, f = {
          moveHandler: (m) => (m.cancelable && (m.preventDefault(), m.stopPropagation()), d(m.touches[0].clientX), !1),
          upHandler: (m) => {
            var b;
            g == null || g.removeEventListener("touchmove", f.moveHandler), g == null || g.removeEventListener("touchend", f.upHandler), m.cancelable && (m.preventDefault(), m.stopPropagation()), u((b = m.touches[0]) == null ? void 0 : b.clientX);
          }
        }, x = Vu() ? {
          passive: !1
        } : !1;
        Ur(a) ? (g == null || g.addEventListener("touchmove", f.moveHandler, x), g == null || g.addEventListener("touchend", f.upHandler, x)) : (g == null || g.addEventListener("mousemove", p.moveHandler, x), g == null || g.addEventListener("mouseup", p.upHandler, x)), e.setColumnSizingInfo((m) => ({
          ...m,
          startOffset: l,
          startSize: n,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart: o,
          isResizingColumn: i.id
        }));
      };
    };
  },
  createTable: (s) => {
    s.setColumnSizing = (e) => s.options.onColumnSizingChange == null ? void 0 : s.options.onColumnSizingChange(e), s.setColumnSizingInfo = (e) => s.options.onColumnSizingInfoChange == null ? void 0 : s.options.onColumnSizingInfoChange(e), s.resetColumnSizing = (e) => {
      var t;
      s.setColumnSizing(e ? {} : (t = s.initialState.columnSizing) != null ? t : {});
    }, s.resetHeaderSizeInfo = (e) => {
      var t;
      s.setColumnSizingInfo(e ? $r() : (t = s.initialState.columnSizingInfo) != null ? t : $r());
    }, s.getTotalSize = () => {
      var e, t;
      return (e = (t = s.getHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, r) => i + r.getSize(), 0)) != null ? e : 0;
    }, s.getLeftTotalSize = () => {
      var e, t;
      return (e = (t = s.getLeftHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, r) => i + r.getSize(), 0)) != null ? e : 0;
    }, s.getCenterTotalSize = () => {
      var e, t;
      return (e = (t = s.getCenterHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, r) => i + r.getSize(), 0)) != null ? e : 0;
    }, s.getRightTotalSize = () => {
      var e, t;
      return (e = (t = s.getRightHeaderGroups()[0]) == null ? void 0 : t.headers.reduce((i, r) => i + r.getSize(), 0)) != null ? e : 0;
    };
  }
};
let Xi = null;
function Vu() {
  if (typeof Xi == "boolean") return Xi;
  let s = !1;
  try {
    const e = {
      get passive() {
        return s = !0, !1;
      }
    }, t = () => {
    };
    window.addEventListener("test", t, e), window.removeEventListener("test", t);
  } catch {
    s = !1;
  }
  return Xi = s, Xi;
}
function Ur(s) {
  return s.type === "touchstart";
}
const Gu = {
  getInitialState: (s) => ({
    columnVisibility: {},
    ...s
  }),
  getDefaultOptions: (s) => ({
    onColumnVisibilityChange: it("columnVisibility", s)
  }),
  createColumn: (s, e) => {
    s.toggleVisibility = (t) => {
      s.getCanHide() && e.setColumnVisibility((i) => ({
        ...i,
        [s.id]: t ?? !s.getIsVisible()
      }));
    }, s.getIsVisible = () => {
      var t, i;
      const r = s.columns;
      return (t = r.length ? r.some((a) => a.getIsVisible()) : (i = e.getState().columnVisibility) == null ? void 0 : i[s.id]) != null ? t : !0;
    }, s.getCanHide = () => {
      var t, i;
      return ((t = s.columnDef.enableHiding) != null ? t : !0) && ((i = e.options.enableHiding) != null ? i : !0);
    }, s.getToggleVisibilityHandler = () => (t) => {
      s.toggleVisibility == null || s.toggleVisibility(t.target.checked);
    };
  },
  createRow: (s, e) => {
    s._getAllVisibleCells = le(() => [s.getAllCells(), e.getState().columnVisibility], (t) => t.filter((i) => i.column.getIsVisible()), ce(e.options, "debugRows", "_getAllVisibleCells")), s.getVisibleCells = le(() => [s.getLeftVisibleCells(), s.getCenterVisibleCells(), s.getRightVisibleCells()], (t, i, r) => [...t, ...i, ...r], ce(e.options, "debugRows", "getVisibleCells"));
  },
  createTable: (s) => {
    const e = (t, i) => le(() => [i(), i().filter((r) => r.getIsVisible()).map((r) => r.id).join("_")], (r) => r.filter((a) => a.getIsVisible == null ? void 0 : a.getIsVisible()), ce(s.options, "debugColumns", t));
    s.getVisibleFlatColumns = e("getVisibleFlatColumns", () => s.getAllFlatColumns()), s.getVisibleLeafColumns = e("getVisibleLeafColumns", () => s.getAllLeafColumns()), s.getLeftVisibleLeafColumns = e("getLeftVisibleLeafColumns", () => s.getLeftLeafColumns()), s.getRightVisibleLeafColumns = e("getRightVisibleLeafColumns", () => s.getRightLeafColumns()), s.getCenterVisibleLeafColumns = e("getCenterVisibleLeafColumns", () => s.getCenterLeafColumns()), s.setColumnVisibility = (t) => s.options.onColumnVisibilityChange == null ? void 0 : s.options.onColumnVisibilityChange(t), s.resetColumnVisibility = (t) => {
      var i;
      s.setColumnVisibility(t ? {} : (i = s.initialState.columnVisibility) != null ? i : {});
    }, s.toggleAllColumnsVisible = (t) => {
      var i;
      t = (i = t) != null ? i : !s.getIsAllColumnsVisible(), s.setColumnVisibility(s.getAllLeafColumns().reduce((r, a) => ({
        ...r,
        [a.id]: t || !(a.getCanHide != null && a.getCanHide())
      }), {}));
    }, s.getIsAllColumnsVisible = () => !s.getAllLeafColumns().some((t) => !(t.getIsVisible != null && t.getIsVisible())), s.getIsSomeColumnsVisible = () => s.getAllLeafColumns().some((t) => t.getIsVisible == null ? void 0 : t.getIsVisible()), s.getToggleAllColumnsVisibilityHandler = () => (t) => {
      var i;
      s.toggleAllColumnsVisible((i = t.target) == null ? void 0 : i.checked);
    };
  }
};
function vi(s, e) {
  return e ? e === "center" ? s.getCenterVisibleLeafColumns() : e === "left" ? s.getLeftVisibleLeafColumns() : s.getRightVisibleLeafColumns() : s.getVisibleLeafColumns();
}
const $u = {
  createTable: (s) => {
    s._getGlobalFacetedRowModel = s.options.getFacetedRowModel && s.options.getFacetedRowModel(s, "__global__"), s.getGlobalFacetedRowModel = () => s.options.manualFiltering || !s._getGlobalFacetedRowModel ? s.getPreFilteredRowModel() : s._getGlobalFacetedRowModel(), s._getGlobalFacetedUniqueValues = s.options.getFacetedUniqueValues && s.options.getFacetedUniqueValues(s, "__global__"), s.getGlobalFacetedUniqueValues = () => s._getGlobalFacetedUniqueValues ? s._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), s._getGlobalFacetedMinMaxValues = s.options.getFacetedMinMaxValues && s.options.getFacetedMinMaxValues(s, "__global__"), s.getGlobalFacetedMinMaxValues = () => {
      if (s._getGlobalFacetedMinMaxValues)
        return s._getGlobalFacetedMinMaxValues();
    };
  }
}, Uu = {
  getInitialState: (s) => ({
    globalFilter: void 0,
    ...s
  }),
  getDefaultOptions: (s) => ({
    onGlobalFilterChange: it("globalFilter", s),
    globalFilterFn: "auto",
    getColumnCanGlobalFilter: (e) => {
      var t;
      const i = (t = s.getCoreRowModel().flatRows[0]) == null || (t = t._getAllCellsByColumnId()[e.id]) == null ? void 0 : t.getValue();
      return typeof i == "string" || typeof i == "number";
    }
  }),
  createColumn: (s, e) => {
    s.getCanGlobalFilter = () => {
      var t, i, r, a;
      return ((t = s.columnDef.enableGlobalFilter) != null ? t : !0) && ((i = e.options.enableGlobalFilter) != null ? i : !0) && ((r = e.options.enableFilters) != null ? r : !0) && ((a = e.options.getColumnCanGlobalFilter == null ? void 0 : e.options.getColumnCanGlobalFilter(s)) != null ? a : !0) && !!s.accessorFn;
    };
  },
  createTable: (s) => {
    s.getGlobalAutoFilterFn = () => mt.includesString, s.getGlobalFilterFn = () => {
      var e, t;
      const {
        globalFilterFn: i
      } = s.options;
      return or(i) ? i : i === "auto" ? s.getGlobalAutoFilterFn() : (e = (t = s.options.filterFns) == null ? void 0 : t[i]) != null ? e : mt[i];
    }, s.setGlobalFilter = (e) => {
      s.options.onGlobalFilterChange == null || s.options.onGlobalFilterChange(e);
    }, s.resetGlobalFilter = (e) => {
      s.setGlobalFilter(e ? void 0 : s.initialState.globalFilter);
    };
  }
}, qu = {
  getInitialState: (s) => ({
    expanded: {},
    ...s
  }),
  getDefaultOptions: (s) => ({
    onExpandedChange: it("expanded", s),
    paginateExpandedRows: !0
  }),
  createTable: (s) => {
    let e = !1, t = !1;
    s._autoResetExpanded = () => {
      var i, r;
      if (!e) {
        s._queue(() => {
          e = !0;
        });
        return;
      }
      if ((i = (r = s.options.autoResetAll) != null ? r : s.options.autoResetExpanded) != null ? i : !s.options.manualExpanding) {
        if (t) return;
        t = !0, s._queue(() => {
          s.resetExpanded(), t = !1;
        });
      }
    }, s.setExpanded = (i) => s.options.onExpandedChange == null ? void 0 : s.options.onExpandedChange(i), s.toggleAllRowsExpanded = (i) => {
      i ?? !s.getIsAllRowsExpanded() ? s.setExpanded(!0) : s.setExpanded({});
    }, s.resetExpanded = (i) => {
      var r, a;
      s.setExpanded(i ? {} : (r = (a = s.initialState) == null ? void 0 : a.expanded) != null ? r : {});
    }, s.getCanSomeRowsExpand = () => s.getPrePaginationRowModel().flatRows.some((i) => i.getCanExpand()), s.getToggleAllRowsExpandedHandler = () => (i) => {
      i.persist == null || i.persist(), s.toggleAllRowsExpanded();
    }, s.getIsSomeRowsExpanded = () => {
      const i = s.getState().expanded;
      return i === !0 || Object.values(i).some(Boolean);
    }, s.getIsAllRowsExpanded = () => {
      const i = s.getState().expanded;
      return typeof i == "boolean" ? i === !0 : !(!Object.keys(i).length || s.getRowModel().flatRows.some((r) => !r.getIsExpanded()));
    }, s.getExpandedDepth = () => {
      let i = 0;
      return (s.getState().expanded === !0 ? Object.keys(s.getRowModel().rowsById) : Object.keys(s.getState().expanded)).forEach((a) => {
        const n = a.split(".");
        i = Math.max(i, n.length);
      }), i;
    }, s.getPreExpandedRowModel = () => s.getSortedRowModel(), s.getExpandedRowModel = () => (!s._getExpandedRowModel && s.options.getExpandedRowModel && (s._getExpandedRowModel = s.options.getExpandedRowModel(s)), s.options.manualExpanding || !s._getExpandedRowModel ? s.getPreExpandedRowModel() : s._getExpandedRowModel());
  },
  createRow: (s, e) => {
    s.toggleExpanded = (t) => {
      e.setExpanded((i) => {
        var r;
        const a = i === !0 ? !0 : !!(i != null && i[s.id]);
        let n = {};
        if (i === !0 ? Object.keys(e.getRowModel().rowsById).forEach((o) => {
          n[o] = !0;
        }) : n = i, t = (r = t) != null ? r : !a, !a && t)
          return {
            ...n,
            [s.id]: !0
          };
        if (a && !t) {
          const {
            [s.id]: o,
            ...l
          } = n;
          return l;
        }
        return i;
      });
    }, s.getIsExpanded = () => {
      var t;
      const i = e.getState().expanded;
      return !!((t = e.options.getIsRowExpanded == null ? void 0 : e.options.getIsRowExpanded(s)) != null ? t : i === !0 || i != null && i[s.id]);
    }, s.getCanExpand = () => {
      var t, i, r;
      return (t = e.options.getRowCanExpand == null ? void 0 : e.options.getRowCanExpand(s)) != null ? t : ((i = e.options.enableExpanding) != null ? i : !0) && !!((r = s.subRows) != null && r.length);
    }, s.getIsAllParentsExpanded = () => {
      let t = !0, i = s;
      for (; t && i.parentId; )
        i = e.getRow(i.parentId, !0), t = i.getIsExpanded();
      return t;
    }, s.getToggleExpandedHandler = () => {
      const t = s.getCanExpand();
      return () => {
        t && s.toggleExpanded();
      };
    };
  }
}, Ls = 0, Is = 10, qr = () => ({
  pageIndex: Ls,
  pageSize: Is
}), Zu = {
  getInitialState: (s) => ({
    ...s,
    pagination: {
      ...qr(),
      ...s == null ? void 0 : s.pagination
    }
  }),
  getDefaultOptions: (s) => ({
    onPaginationChange: it("pagination", s)
  }),
  createTable: (s) => {
    let e = !1, t = !1;
    s._autoResetPageIndex = () => {
      var i, r;
      if (!e) {
        s._queue(() => {
          e = !0;
        });
        return;
      }
      if ((i = (r = s.options.autoResetAll) != null ? r : s.options.autoResetPageIndex) != null ? i : !s.options.manualPagination) {
        if (t) return;
        t = !0, s._queue(() => {
          s.resetPageIndex(), t = !1;
        });
      }
    }, s.setPagination = (i) => {
      const r = (a) => At(i, a);
      return s.options.onPaginationChange == null ? void 0 : s.options.onPaginationChange(r);
    }, s.resetPagination = (i) => {
      var r;
      s.setPagination(i ? qr() : (r = s.initialState.pagination) != null ? r : qr());
    }, s.setPageIndex = (i) => {
      s.setPagination((r) => {
        let a = At(i, r.pageIndex);
        const n = typeof s.options.pageCount > "u" || s.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : s.options.pageCount - 1;
        return a = Math.max(0, Math.min(a, n)), {
          ...r,
          pageIndex: a
        };
      });
    }, s.resetPageIndex = (i) => {
      var r, a;
      s.setPageIndex(i ? Ls : (r = (a = s.initialState) == null || (a = a.pagination) == null ? void 0 : a.pageIndex) != null ? r : Ls);
    }, s.resetPageSize = (i) => {
      var r, a;
      s.setPageSize(i ? Is : (r = (a = s.initialState) == null || (a = a.pagination) == null ? void 0 : a.pageSize) != null ? r : Is);
    }, s.setPageSize = (i) => {
      s.setPagination((r) => {
        const a = Math.max(1, At(i, r.pageSize)), n = r.pageSize * r.pageIndex, o = Math.floor(n / a);
        return {
          ...r,
          pageIndex: o,
          pageSize: a
        };
      });
    }, s.setPageCount = (i) => s.setPagination((r) => {
      var a;
      let n = At(i, (a = s.options.pageCount) != null ? a : -1);
      return typeof n == "number" && (n = Math.max(-1, n)), {
        ...r,
        pageCount: n
      };
    }), s.getPageOptions = le(() => [s.getPageCount()], (i) => {
      let r = [];
      return i && i > 0 && (r = [...new Array(i)].fill(null).map((a, n) => n)), r;
    }, ce(s.options, "debugTable", "getPageOptions")), s.getCanPreviousPage = () => s.getState().pagination.pageIndex > 0, s.getCanNextPage = () => {
      const {
        pageIndex: i
      } = s.getState().pagination, r = s.getPageCount();
      return r === -1 ? !0 : r === 0 ? !1 : i < r - 1;
    }, s.previousPage = () => s.setPageIndex((i) => i - 1), s.nextPage = () => s.setPageIndex((i) => i + 1), s.firstPage = () => s.setPageIndex(0), s.lastPage = () => s.setPageIndex(s.getPageCount() - 1), s.getPrePaginationRowModel = () => s.getExpandedRowModel(), s.getPaginationRowModel = () => (!s._getPaginationRowModel && s.options.getPaginationRowModel && (s._getPaginationRowModel = s.options.getPaginationRowModel(s)), s.options.manualPagination || !s._getPaginationRowModel ? s.getPrePaginationRowModel() : s._getPaginationRowModel()), s.getPageCount = () => {
      var i;
      return (i = s.options.pageCount) != null ? i : Math.ceil(s.getRowCount() / s.getState().pagination.pageSize);
    }, s.getRowCount = () => {
      var i;
      return (i = s.options.rowCount) != null ? i : s.getPrePaginationRowModel().rows.length;
    };
  }
}, Zr = () => ({
  top: [],
  bottom: []
}), Ku = {
  getInitialState: (s) => ({
    rowPinning: Zr(),
    ...s
  }),
  getDefaultOptions: (s) => ({
    onRowPinningChange: it("rowPinning", s)
  }),
  createRow: (s, e) => {
    s.pin = (t, i, r) => {
      const a = i ? s.getLeafRows().map((l) => {
        let {
          id: c
        } = l;
        return c;
      }) : [], n = r ? s.getParentRows().map((l) => {
        let {
          id: c
        } = l;
        return c;
      }) : [], o = /* @__PURE__ */ new Set([...n, s.id, ...a]);
      e.setRowPinning((l) => {
        var c, h;
        if (t === "bottom") {
          var d, u;
          return {
            top: ((d = l == null ? void 0 : l.top) != null ? d : []).filter((f) => !(o != null && o.has(f))),
            bottom: [...((u = l == null ? void 0 : l.bottom) != null ? u : []).filter((f) => !(o != null && o.has(f))), ...Array.from(o)]
          };
        }
        if (t === "top") {
          var g, p;
          return {
            top: [...((g = l == null ? void 0 : l.top) != null ? g : []).filter((f) => !(o != null && o.has(f))), ...Array.from(o)],
            bottom: ((p = l == null ? void 0 : l.bottom) != null ? p : []).filter((f) => !(o != null && o.has(f)))
          };
        }
        return {
          top: ((c = l == null ? void 0 : l.top) != null ? c : []).filter((f) => !(o != null && o.has(f))),
          bottom: ((h = l == null ? void 0 : l.bottom) != null ? h : []).filter((f) => !(o != null && o.has(f)))
        };
      });
    }, s.getCanPin = () => {
      var t;
      const {
        enableRowPinning: i,
        enablePinning: r
      } = e.options;
      return typeof i == "function" ? i(s) : (t = i ?? r) != null ? t : !0;
    }, s.getIsPinned = () => {
      const t = [s.id], {
        top: i,
        bottom: r
      } = e.getState().rowPinning, a = t.some((o) => i == null ? void 0 : i.includes(o)), n = t.some((o) => r == null ? void 0 : r.includes(o));
      return a ? "top" : n ? "bottom" : !1;
    }, s.getPinnedIndex = () => {
      var t, i;
      const r = s.getIsPinned();
      if (!r) return -1;
      const a = (t = r === "top" ? e.getTopRows() : e.getBottomRows()) == null ? void 0 : t.map((n) => {
        let {
          id: o
        } = n;
        return o;
      });
      return (i = a == null ? void 0 : a.indexOf(s.id)) != null ? i : -1;
    };
  },
  createTable: (s) => {
    s.setRowPinning = (e) => s.options.onRowPinningChange == null ? void 0 : s.options.onRowPinningChange(e), s.resetRowPinning = (e) => {
      var t, i;
      return s.setRowPinning(e ? Zr() : (t = (i = s.initialState) == null ? void 0 : i.rowPinning) != null ? t : Zr());
    }, s.getIsSomeRowsPinned = (e) => {
      var t;
      const i = s.getState().rowPinning;
      if (!e) {
        var r, a;
        return !!((r = i.top) != null && r.length || (a = i.bottom) != null && a.length);
      }
      return !!((t = i[e]) != null && t.length);
    }, s._getPinnedRows = (e, t, i) => {
      var r;
      return ((r = s.options.keepPinnedRows) == null || r ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (t ?? []).map((n) => {
          const o = s.getRow(n, !0);
          return o.getIsAllParentsExpanded() ? o : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (t ?? []).map((n) => e.find((o) => o.id === n))
      )).filter(Boolean).map((n) => ({
        ...n,
        position: i
      }));
    }, s.getTopRows = le(() => [s.getRowModel().rows, s.getState().rowPinning.top], (e, t) => s._getPinnedRows(e, t, "top"), ce(s.options, "debugRows", "getTopRows")), s.getBottomRows = le(() => [s.getRowModel().rows, s.getState().rowPinning.bottom], (e, t) => s._getPinnedRows(e, t, "bottom"), ce(s.options, "debugRows", "getBottomRows")), s.getCenterRows = le(() => [s.getRowModel().rows, s.getState().rowPinning.top, s.getState().rowPinning.bottom], (e, t, i) => {
      const r = /* @__PURE__ */ new Set([...t ?? [], ...i ?? []]);
      return e.filter((a) => !r.has(a.id));
    }, ce(s.options, "debugRows", "getCenterRows"));
  }
}, Ju = {
  getInitialState: (s) => ({
    rowSelection: {},
    ...s
  }),
  getDefaultOptions: (s) => ({
    onRowSelectionChange: it("rowSelection", s),
    enableRowSelection: !0,
    enableMultiRowSelection: !0,
    enableSubRowSelection: !0
    // enableGroupingRowSelection: false,
    // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
    // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
  }),
  createTable: (s) => {
    s.setRowSelection = (e) => s.options.onRowSelectionChange == null ? void 0 : s.options.onRowSelectionChange(e), s.resetRowSelection = (e) => {
      var t;
      return s.setRowSelection(e ? {} : (t = s.initialState.rowSelection) != null ? t : {});
    }, s.toggleAllRowsSelected = (e) => {
      s.setRowSelection((t) => {
        e = typeof e < "u" ? e : !s.getIsAllRowsSelected();
        const i = {
          ...t
        }, r = s.getPreGroupedRowModel().flatRows;
        return e ? r.forEach((a) => {
          a.getCanSelect() && (i[a.id] = !0);
        }) : r.forEach((a) => {
          delete i[a.id];
        }), i;
      });
    }, s.toggleAllPageRowsSelected = (e) => s.setRowSelection((t) => {
      const i = typeof e < "u" ? e : !s.getIsAllPageRowsSelected(), r = {
        ...t
      };
      return s.getRowModel().rows.forEach((a) => {
        Es(r, a.id, i, !0, s);
      }), r;
    }), s.getPreSelectedRowModel = () => s.getCoreRowModel(), s.getSelectedRowModel = le(() => [s.getState().rowSelection, s.getCoreRowModel()], (e, t) => Object.keys(e).length ? Kr(s, t) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, ce(s.options, "debugTable", "getSelectedRowModel")), s.getFilteredSelectedRowModel = le(() => [s.getState().rowSelection, s.getFilteredRowModel()], (e, t) => Object.keys(e).length ? Kr(s, t) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, ce(s.options, "debugTable", "getFilteredSelectedRowModel")), s.getGroupedSelectedRowModel = le(() => [s.getState().rowSelection, s.getSortedRowModel()], (e, t) => Object.keys(e).length ? Kr(s, t) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, ce(s.options, "debugTable", "getGroupedSelectedRowModel")), s.getIsAllRowsSelected = () => {
      const e = s.getFilteredRowModel().flatRows, {
        rowSelection: t
      } = s.getState();
      let i = !!(e.length && Object.keys(t).length);
      return i && e.some((r) => r.getCanSelect() && !t[r.id]) && (i = !1), i;
    }, s.getIsAllPageRowsSelected = () => {
      const e = s.getPaginationRowModel().flatRows.filter((r) => r.getCanSelect()), {
        rowSelection: t
      } = s.getState();
      let i = !!e.length;
      return i && e.some((r) => !t[r.id]) && (i = !1), i;
    }, s.getIsSomeRowsSelected = () => {
      var e;
      const t = Object.keys((e = s.getState().rowSelection) != null ? e : {}).length;
      return t > 0 && t < s.getFilteredRowModel().flatRows.length;
    }, s.getIsSomePageRowsSelected = () => {
      const e = s.getPaginationRowModel().flatRows;
      return s.getIsAllPageRowsSelected() ? !1 : e.filter((t) => t.getCanSelect()).some((t) => t.getIsSelected() || t.getIsSomeSelected());
    }, s.getToggleAllRowsSelectedHandler = () => (e) => {
      s.toggleAllRowsSelected(e.target.checked);
    }, s.getToggleAllPageRowsSelectedHandler = () => (e) => {
      s.toggleAllPageRowsSelected(e.target.checked);
    };
  },
  createRow: (s, e) => {
    s.toggleSelected = (t, i) => {
      const r = s.getIsSelected();
      e.setRowSelection((a) => {
        var n;
        if (t = typeof t < "u" ? t : !r, s.getCanSelect() && r === t)
          return a;
        const o = {
          ...a
        };
        return Es(o, s.id, t, (n = i == null ? void 0 : i.selectChildren) != null ? n : !0, e), o;
      });
    }, s.getIsSelected = () => {
      const {
        rowSelection: t
      } = e.getState();
      return sa(s, t);
    }, s.getIsSomeSelected = () => {
      const {
        rowSelection: t
      } = e.getState();
      return Ts(s, t) === "some";
    }, s.getIsAllSubRowsSelected = () => {
      const {
        rowSelection: t
      } = e.getState();
      return Ts(s, t) === "all";
    }, s.getCanSelect = () => {
      var t;
      return typeof e.options.enableRowSelection == "function" ? e.options.enableRowSelection(s) : (t = e.options.enableRowSelection) != null ? t : !0;
    }, s.getCanSelectSubRows = () => {
      var t;
      return typeof e.options.enableSubRowSelection == "function" ? e.options.enableSubRowSelection(s) : (t = e.options.enableSubRowSelection) != null ? t : !0;
    }, s.getCanMultiSelect = () => {
      var t;
      return typeof e.options.enableMultiRowSelection == "function" ? e.options.enableMultiRowSelection(s) : (t = e.options.enableMultiRowSelection) != null ? t : !0;
    }, s.getToggleSelectedHandler = () => {
      const t = s.getCanSelect();
      return (i) => {
        var r;
        t && s.toggleSelected((r = i.target) == null ? void 0 : r.checked);
      };
    };
  }
}, Es = (s, e, t, i, r) => {
  var a;
  const n = r.getRow(e, !0);
  t ? (n.getCanMultiSelect() || Object.keys(s).forEach((o) => delete s[o]), n.getCanSelect() && (s[e] = !0)) : delete s[e], i && (a = n.subRows) != null && a.length && n.getCanSelectSubRows() && n.subRows.forEach((o) => Es(s, o.id, t, i, r));
};
function Kr(s, e) {
  const t = s.getState().rowSelection, i = [], r = {}, a = function(n, o) {
    return n.map((l) => {
      var c;
      const h = sa(l, t);
      if (h && (i.push(l), r[l.id] = l), (c = l.subRows) != null && c.length && (l = {
        ...l,
        subRows: a(l.subRows)
      }), h)
        return l;
    }).filter(Boolean);
  };
  return {
    rows: a(e.rows),
    flatRows: i,
    rowsById: r
  };
}
function sa(s, e) {
  var t;
  return (t = e[s.id]) != null ? t : !1;
}
function Ts(s, e, t) {
  var i;
  if (!((i = s.subRows) != null && i.length)) return !1;
  let r = !0, a = !1;
  return s.subRows.forEach((n) => {
    if (!(a && !r) && (n.getCanSelect() && (sa(n, e) ? a = !0 : r = !1), n.subRows && n.subRows.length)) {
      const o = Ts(n, e);
      o === "all" ? a = !0 : (o === "some" && (a = !0), r = !1);
    }
  }), r ? "all" : a ? "some" : !1;
}
const _s = /([0-9]+)/gm, Qu = (s, e, t) => el(It(s.getValue(t)).toLowerCase(), It(e.getValue(t)).toLowerCase()), eg = (s, e, t) => el(It(s.getValue(t)), It(e.getValue(t))), tg = (s, e, t) => aa(It(s.getValue(t)).toLowerCase(), It(e.getValue(t)).toLowerCase()), ig = (s, e, t) => aa(It(s.getValue(t)), It(e.getValue(t))), rg = (s, e, t) => {
  const i = s.getValue(t), r = e.getValue(t);
  return i > r ? 1 : i < r ? -1 : 0;
}, sg = (s, e, t) => aa(s.getValue(t), e.getValue(t));
function aa(s, e) {
  return s === e ? 0 : s > e ? 1 : -1;
}
function It(s) {
  return typeof s == "number" ? isNaN(s) || s === 1 / 0 || s === -1 / 0 ? "" : String(s) : typeof s == "string" ? s : "";
}
function el(s, e) {
  const t = s.split(_s).filter(Boolean), i = e.split(_s).filter(Boolean);
  for (; t.length && i.length; ) {
    const r = t.shift(), a = i.shift(), n = parseInt(r, 10), o = parseInt(a, 10), l = [n, o].sort();
    if (isNaN(l[0])) {
      if (r > a)
        return 1;
      if (a > r)
        return -1;
      continue;
    }
    if (isNaN(l[1]))
      return isNaN(n) ? -1 : 1;
    if (n > o)
      return 1;
    if (o > n)
      return -1;
  }
  return t.length - i.length;
}
const gi = {
  alphanumeric: Qu,
  alphanumericCaseSensitive: eg,
  text: tg,
  textCaseSensitive: ig,
  datetime: rg,
  basic: sg
}, ag = {
  getInitialState: (s) => ({
    sorting: [],
    ...s
  }),
  getDefaultColumnDef: () => ({
    sortingFn: "auto",
    sortUndefined: 1
  }),
  getDefaultOptions: (s) => ({
    onSortingChange: it("sorting", s),
    isMultiSortEvent: (e) => e.shiftKey
  }),
  createColumn: (s, e) => {
    s.getAutoSortingFn = () => {
      const t = e.getFilteredRowModel().flatRows.slice(10);
      let i = !1;
      for (const r of t) {
        const a = r == null ? void 0 : r.getValue(s.id);
        if (Object.prototype.toString.call(a) === "[object Date]")
          return gi.datetime;
        if (typeof a == "string" && (i = !0, a.split(_s).length > 1))
          return gi.alphanumeric;
      }
      return i ? gi.text : gi.basic;
    }, s.getAutoSortDir = () => {
      const t = e.getFilteredRowModel().flatRows[0];
      return typeof (t == null ? void 0 : t.getValue(s.id)) == "string" ? "asc" : "desc";
    }, s.getSortingFn = () => {
      var t, i;
      if (!s)
        throw new Error();
      return or(s.columnDef.sortingFn) ? s.columnDef.sortingFn : s.columnDef.sortingFn === "auto" ? s.getAutoSortingFn() : (t = (i = e.options.sortingFns) == null ? void 0 : i[s.columnDef.sortingFn]) != null ? t : gi[s.columnDef.sortingFn];
    }, s.toggleSorting = (t, i) => {
      const r = s.getNextSortingOrder(), a = typeof t < "u" && t !== null;
      e.setSorting((n) => {
        const o = n == null ? void 0 : n.find((g) => g.id === s.id), l = n == null ? void 0 : n.findIndex((g) => g.id === s.id);
        let c = [], h, d = a ? t : r === "desc";
        if (n != null && n.length && s.getCanMultiSort() && i ? o ? h = "toggle" : h = "add" : n != null && n.length && l !== n.length - 1 ? h = "replace" : o ? h = "toggle" : h = "replace", h === "toggle" && (a || r || (h = "remove")), h === "add") {
          var u;
          c = [...n, {
            id: s.id,
            desc: d
          }], c.splice(0, c.length - ((u = e.options.maxMultiSortColCount) != null ? u : Number.MAX_SAFE_INTEGER));
        } else h === "toggle" ? c = n.map((g) => g.id === s.id ? {
          ...g,
          desc: d
        } : g) : h === "remove" ? c = n.filter((g) => g.id !== s.id) : c = [{
          id: s.id,
          desc: d
        }];
        return c;
      });
    }, s.getFirstSortDir = () => {
      var t, i;
      return ((t = (i = s.columnDef.sortDescFirst) != null ? i : e.options.sortDescFirst) != null ? t : s.getAutoSortDir() === "desc") ? "desc" : "asc";
    }, s.getNextSortingOrder = (t) => {
      var i, r;
      const a = s.getFirstSortDir(), n = s.getIsSorted();
      return n ? n !== a && ((i = e.options.enableSortingRemoval) == null || i) && // If enableSortRemove, enable in general
      (!(t && (r = e.options.enableMultiRemove) != null) || r) ? !1 : n === "desc" ? "asc" : "desc" : a;
    }, s.getCanSort = () => {
      var t, i;
      return ((t = s.columnDef.enableSorting) != null ? t : !0) && ((i = e.options.enableSorting) != null ? i : !0) && !!s.accessorFn;
    }, s.getCanMultiSort = () => {
      var t, i;
      return (t = (i = s.columnDef.enableMultiSort) != null ? i : e.options.enableMultiSort) != null ? t : !!s.accessorFn;
    }, s.getIsSorted = () => {
      var t;
      const i = (t = e.getState().sorting) == null ? void 0 : t.find((r) => r.id === s.id);
      return i ? i.desc ? "desc" : "asc" : !1;
    }, s.getSortIndex = () => {
      var t, i;
      return (t = (i = e.getState().sorting) == null ? void 0 : i.findIndex((r) => r.id === s.id)) != null ? t : -1;
    }, s.clearSorting = () => {
      e.setSorting((t) => t != null && t.length ? t.filter((i) => i.id !== s.id) : []);
    }, s.getToggleSortingHandler = () => {
      const t = s.getCanSort();
      return (i) => {
        t && (i.persist == null || i.persist(), s.toggleSorting == null || s.toggleSorting(void 0, s.getCanMultiSort() ? e.options.isMultiSortEvent == null ? void 0 : e.options.isMultiSortEvent(i) : !1));
      };
    };
  },
  createTable: (s) => {
    s.setSorting = (e) => s.options.onSortingChange == null ? void 0 : s.options.onSortingChange(e), s.resetSorting = (e) => {
      var t, i;
      s.setSorting(e ? [] : (t = (i = s.initialState) == null ? void 0 : i.sorting) != null ? t : []);
    }, s.getPreSortedRowModel = () => s.getGroupedRowModel(), s.getSortedRowModel = () => (!s._getSortedRowModel && s.options.getSortedRowModel && (s._getSortedRowModel = s.options.getSortedRowModel(s)), s.options.manualSorting || !s._getSortedRowModel ? s.getPreSortedRowModel() : s._getSortedRowModel());
  }
}, ng = [
  Mu,
  Gu,
  Yu,
  Xu,
  Pu,
  Lu,
  $u,
  //depends on ColumnFaceting
  Uu,
  //depends on ColumnFiltering
  ag,
  Hu,
  //depends on RowSorting
  qu,
  Zu,
  Ku,
  Ju,
  Wu
];
function og(s) {
  var e, t;
  process.env.NODE_ENV !== "production" && (s.debugAll || s.debugTable) && console.info("Creating Table Instance...");
  const i = [...ng, ...(e = s._features) != null ? e : []];
  let r = {
    _features: i
  };
  const a = r._features.reduce((u, g) => Object.assign(u, g.getDefaultOptions == null ? void 0 : g.getDefaultOptions(r)), {}), n = (u) => r.options.mergeOptions ? r.options.mergeOptions(a, u) : {
    ...a,
    ...u
  };
  let l = {
    ...{},
    ...(t = s.initialState) != null ? t : {}
  };
  r._features.forEach((u) => {
    var g;
    l = (g = u.getInitialState == null ? void 0 : u.getInitialState(l)) != null ? g : l;
  });
  const c = [];
  let h = !1;
  const d = {
    _features: i,
    options: {
      ...a,
      ...s
    },
    initialState: l,
    _queue: (u) => {
      c.push(u), h || (h = !0, Promise.resolve().then(() => {
        for (; c.length; )
          c.shift()();
        h = !1;
      }).catch((g) => setTimeout(() => {
        throw g;
      })));
    },
    reset: () => {
      r.setState(r.initialState);
    },
    setOptions: (u) => {
      const g = At(u, r.options);
      r.options = n(g);
    },
    getState: () => r.options.state,
    setState: (u) => {
      r.options.onStateChange == null || r.options.onStateChange(u);
    },
    _getRowId: (u, g, p) => {
      var f;
      return (f = r.options.getRowId == null ? void 0 : r.options.getRowId(u, g, p)) != null ? f : `${p ? [p.id, g].join(".") : g}`;
    },
    getCoreRowModel: () => (r._getCoreRowModel || (r._getCoreRowModel = r.options.getCoreRowModel(r)), r._getCoreRowModel()),
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => r.getPaginationRowModel(),
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (u, g) => {
      let p = (g ? r.getPrePaginationRowModel() : r.getRowModel()).rowsById[u];
      if (!p && (p = r.getCoreRowModel().rowsById[u], !p))
        throw process.env.NODE_ENV !== "production" ? new Error(`getRow could not find row with ID: ${u}`) : new Error();
      return p;
    },
    _getDefaultColumnDef: le(() => [r.options.defaultColumn], (u) => {
      var g;
      return u = (g = u) != null ? g : {}, {
        header: (p) => {
          const f = p.header.column.columnDef;
          return f.accessorKey ? f.accessorKey : f.accessorFn ? f.id : null;
        },
        // footer: props => props.header.column.id,
        cell: (p) => {
          var f, x;
          return (f = (x = p.renderValue()) == null || x.toString == null ? void 0 : x.toString()) != null ? f : null;
        },
        ...r._features.reduce((p, f) => Object.assign(p, f.getDefaultColumnDef == null ? void 0 : f.getDefaultColumnDef()), {}),
        ...u
      };
    }, ce(s, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => r.options.columns,
    getAllColumns: le(() => [r._getColumnDefs()], (u) => {
      const g = function(p, f, x) {
        return x === void 0 && (x = 0), p.map((m) => {
          const b = Au(r, m, x, f), w = m;
          return b.columns = w.columns ? g(w.columns, b, x + 1) : [], b;
        });
      };
      return g(u);
    }, ce(s, "debugColumns", "getAllColumns")),
    getAllFlatColumns: le(() => [r.getAllColumns()], (u) => u.flatMap((g) => g.getFlatColumns()), ce(s, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: le(() => [r.getAllFlatColumns()], (u) => u.reduce((g, p) => (g[p.id] = p, g), {}), ce(s, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: le(() => [r.getAllColumns(), r._getOrderColumnsFn()], (u, g) => {
      let p = u.flatMap((f) => f.getLeafColumns());
      return g(p);
    }, ce(s, "debugColumns", "getAllLeafColumns")),
    getColumn: (u) => {
      const g = r._getAllFlatColumnsById()[u];
      return process.env.NODE_ENV !== "production" && !g && console.error(`[Table] Column with id '${u}' does not exist.`), g;
    }
  };
  Object.assign(r, d);
  for (let u = 0; u < r._features.length; u++) {
    const g = r._features[u];
    g == null || g.createTable == null || g.createTable(r);
  }
  return r;
}
function lg() {
  return (s) => le(() => [s.options.data], (e) => {
    const t = {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, i = function(r, a, n) {
      a === void 0 && (a = 0);
      const o = [];
      for (let c = 0; c < r.length; c++) {
        const h = Ru(s, s._getRowId(r[c], c, n), r[c], c, a, void 0, n == null ? void 0 : n.id);
        if (t.flatRows.push(h), t.rowsById[h.id] = h, o.push(h), s.options.getSubRows) {
          var l;
          h.originalSubRows = s.options.getSubRows(r[c], c), (l = h.originalSubRows) != null && l.length && (h.subRows = i(h.originalSubRows, a + 1, h));
        }
      }
      return o;
    };
    return t.rows = i(e), t;
  }, ce(s.options, "debugTable", "getRowModel", () => s._autoResetPageIndex()));
}
function cg(s) {
  const e = [], t = (i) => {
    var r;
    e.push(i), (r = i.subRows) != null && r.length && i.getIsExpanded() && i.subRows.forEach(t);
  };
  return s.rows.forEach(t), {
    rows: e,
    flatRows: s.flatRows,
    rowsById: s.rowsById
  };
}
function hg(s) {
  return (e) => le(() => [e.getState().pagination, e.getPrePaginationRowModel(), e.options.paginateExpandedRows ? void 0 : e.getState().expanded], (t, i) => {
    if (!i.rows.length)
      return i;
    const {
      pageSize: r,
      pageIndex: a
    } = t;
    let {
      rows: n,
      flatRows: o,
      rowsById: l
    } = i;
    const c = r * a, h = c + r;
    n = n.slice(c, h);
    let d;
    e.options.paginateExpandedRows ? d = {
      rows: n,
      flatRows: o,
      rowsById: l
    } : d = cg({
      rows: n,
      flatRows: o,
      rowsById: l
    }), d.flatRows = [];
    const u = (g) => {
      d.flatRows.push(g), g.subRows.length && g.subRows.forEach(u);
    };
    return d.rows.forEach(u), d;
  }, ce(e.options, "debugTable", "getPaginationRowModel"));
}
function dg() {
  return (s) => le(() => [s.getState().sorting, s.getPreSortedRowModel()], (e, t) => {
    if (!t.rows.length || !(e != null && e.length))
      return t;
    const i = s.getState().sorting, r = [], a = i.filter((l) => {
      var c;
      return (c = s.getColumn(l.id)) == null ? void 0 : c.getCanSort();
    }), n = {};
    a.forEach((l) => {
      const c = s.getColumn(l.id);
      c && (n[l.id] = {
        sortUndefined: c.columnDef.sortUndefined,
        invertSorting: c.columnDef.invertSorting,
        sortingFn: c.getSortingFn()
      });
    });
    const o = (l) => {
      const c = l.map((h) => ({
        ...h
      }));
      return c.sort((h, d) => {
        for (let g = 0; g < a.length; g += 1) {
          var u;
          const p = a[g], f = n[p.id], x = f.sortUndefined, m = (u = p == null ? void 0 : p.desc) != null ? u : !1;
          let b = 0;
          if (x) {
            const w = h.getValue(p.id), y = d.getValue(p.id), v = w === void 0, k = y === void 0;
            if (v || k) {
              if (x === "first") return v ? -1 : 1;
              if (x === "last") return v ? 1 : -1;
              b = v && k ? 0 : v ? x : -x;
            }
          }
          if (b === 0 && (b = f.sortingFn(h, d, p.id)), b !== 0)
            return m && (b *= -1), f.invertSorting && (b *= -1), b;
        }
        return h.index - d.index;
      }), c.forEach((h) => {
        var d;
        r.push(h), (d = h.subRows) != null && d.length && (h.subRows = o(h.subRows));
      }), c;
    };
    return {
      rows: o(t.rows),
      flatRows: r,
      rowsById: t.rowsById
    };
  }, ce(s.options, "debugTable", "getSortedRowModel", () => s._autoResetPageIndex()));
}
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function bn(s, e) {
  return s ? ug(s) ? /* @__PURE__ */ Qr.createElement(s, e) : s : null;
}
function ug(s) {
  return gg(s) || typeof s == "function" || fg(s);
}
function gg(s) {
  return typeof s == "function" && (() => {
    const e = Object.getPrototypeOf(s);
    return e.prototype && e.prototype.isReactComponent;
  })();
}
function fg(s) {
  return typeof s == "object" && typeof s.$$typeof == "symbol" && ["react.memo", "react.forward_ref"].includes(s.$$typeof.description);
}
function pg(s) {
  const e = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...s
  }, [t] = Qr.useState(() => ({
    current: og(e)
  })), [i, r] = Qr.useState(() => t.current.initialState);
  return t.current.setOptions((a) => ({
    ...a,
    ...s,
    state: {
      ...i,
      ...s.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (n) => {
      r(n), s.onStateChange == null || s.onStateChange(n);
    }
  })), t.current;
}
const tl = (s) => {
  const e = {
    header: {
      primary: "bg-primary text-white",
      secondary: "bg-secondary text-white",
      warning: "bg-warning text-white",
      danger: "bg-danger text-white",
      ghost: "bg-gray-100 text-gray-700",
      success: "bg-success text-white"
    },
    row: {
      primary: "hover:bg-primary/5",
      secondary: "hover:bg-secondary/5",
      warning: "hover:bg-warning/5",
      danger: "hover:bg-danger/5",
      ghost: "hover:bg-gray-50",
      success: "hover:bg-success/5"
    },
    border: {
      primary: "border-primary",
      secondary: "border-secondary",
      warning: "border-warning",
      danger: "border-danger",
      ghost: "border-gray-200",
      success: "border-success"
    },
    stripe: {
      primary: "bg-primary/5",
      secondary: "bg-secondary/5",
      warning: "bg-warning/5",
      danger: "bg-danger/5",
      ghost: "bg-gray-50",
      success: "bg-success/5"
    }
  };
  return {
    header: e.header[s],
    row: e.row[s],
    border: e.border[s],
    stripe: e.stripe[s]
  };
}, xg = ({ schema: s, variant: e = "primary" }) => {
  const t = [{ name: "no", label: "No.", accessorKey: "no", type: "number" }, ...s], i = tl(e);
  return /* @__PURE__ */ A.jsx("div", { className: "bg-white rounded-md", children: /* @__PURE__ */ A.jsx("div", { className: "p-0 w-full max-h-[50vh] overflow-auto rounded-t-md [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]", children: /* @__PURE__ */ A.jsxs("table", { className: "w-full border-spacing-0 border-separate", children: [
    /* @__PURE__ */ A.jsx("thead", { className: Q("border-2 sticky top-0 z-10 rounded-t-md", i.border), children: /* @__PURE__ */ A.jsx("tr", { children: t.map((r, a) => /* @__PURE__ */ A.jsx(
      "th",
      {
        className: Q(
          "text-sm text-wrap border-y p-4 text-left",
          i.header,
          {
            "rounded-tl-md": a === 0,
            "rounded-tr-md": a === t.length - 1
          }
        ),
        children: r.label
      },
      a
    )) }) }),
    /* @__PURE__ */ A.jsx("tbody", { className: "max-h-[50vh]", children: [...Array(5)].map((r, a) => /* @__PURE__ */ A.jsx(
      "tr",
      {
        className: Q("p-3", {
          [i.stripe]: a % 2 !== 0,
          "bg-white": a % 2 === 0
        }),
        children: t.map((n, o) => /* @__PURE__ */ A.jsx(
          "td",
          {
            className: "text-left text-nowrap text-sm p-4",
            children: /* @__PURE__ */ A.jsx(lu, { className: "h-10 w-full rounded-md" })
          },
          `${a}-${o}`
        ))
      },
      a
    )) })
  ] }) }) });
}, Bg = ({
  schema: s,
  data: e,
  className: t,
  headerClassName: i,
  rowClassName: r,
  cellClassName: a,
  emptyState: n,
  isLoading: o,
  loadingState: l,
  showIndex: c = !1,
  onPageChange: h,
  onPageSizeChange: d,
  onSortChange: u,
  onRowClick: g,
  showPagination: p = !1,
  variant: f = "primary",
  meta: x = {
    current_page: 1,
    total_page: 1,
    total_data: 0,
    limit_number: 10
  }
}) => {
  const [m, b] = Ee(() => {
    const S = s.find((C) => C.sortable && C.sort);
    return S ? [{
      id: S.accessorKey.toString(),
      desc: S.sort === "desc"
    }] : [];
  }), w = He.useMemo(() => {
    const S = s.map((C) => ({
      accessorKey: C.accessorKey,
      header: C.label,
      enableSorting: !!C.sortable,
      cell: C.render ? ({ row: M }) => {
        var R;
        return (R = C.render) == null ? void 0 : R.call(C, M.original[C.accessorKey], M.original, M.index);
      } : ({ row: M }) => M.original[C.accessorKey] || "-",
      meta: {
        align: C.align || "left"
      }
    }));
    return c ? [{
      accessorKey: "no",
      header: "No.",
      enableSorting: !1,
      cell: ({ row: C }) => (x.current_page - 1) * x.limit_number + C.index + 1,
      meta: {
        align: "left"
      }
    }, ...S] : S;
  }, [s, c, x]), y = pg({
    data: e,
    columns: w,
    state: {
      sorting: m
    },
    onSortingChange: (S) => {
      const C = typeof S == "function" ? S(m) : S;
      b(C), C.length > 0 ? u == null || u(C[0].desc ? "desc" : "asc", C[0].id) : u == null || u("", "");
    },
    getCoreRowModel: lg(),
    getSortedRowModel: dg(),
    getPaginationRowModel: hg(),
    manualPagination: !0,
    pageCount: x.total_page
  }), v = tl(f);
  if (o)
    return l || /* @__PURE__ */ A.jsx(xg, { schema: s, variant: f });
  const k = (S, C, M) => {
    const R = S.target;
    R.tagName === "BUTTON" || R.tagName === "A" || R.tagName === "INPUT" || R.tagName === "SELECT" || R.closest("button") !== null || R.closest("a") !== null || R.closest("input") !== null || R.closest("select") !== null || g == null || g(C, M);
  };
  return /* @__PURE__ */ A.jsxs("div", { className: "bg-white rounded-md", children: [
    /* @__PURE__ */ A.jsx("div", { className: "p-0 w-full max-h-[50vh] overflow-auto rounded-t-md [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]", children: /* @__PURE__ */ A.jsxs("table", { className: Q("w-full border-spacing-0 border-separate", t), children: [
      /* @__PURE__ */ A.jsx("thead", { className: Q("border-2 sticky top-0 z-10 rounded-t-md", v.border), children: y.getHeaderGroups().map((S) => /* @__PURE__ */ A.jsx("tr", { children: S.headers.map((C, M) => {
        var R, P, I;
        return /* @__PURE__ */ A.jsx(
          "th",
          {
            className: Q(
              "text-sm text-wrap border-y p-4",
              v.header,
              {
                "cursor-pointer": C.column.getCanSort(),
                "rounded-tl-md": M === 0,
                "rounded-tr-md": M === S.headers.length - 1,
                "text-left": ((R = C.column.columnDef.meta) == null ? void 0 : R.align) === "left",
                "text-center": ((P = C.column.columnDef.meta) == null ? void 0 : P.align) === "center",
                "text-right": ((I = C.column.columnDef.meta) == null ? void 0 : I.align) === "right"
              },
              i
            ),
            onClick: C.column.getCanSort() ? C.column.getToggleSortingHandler() : void 0,
            children: /* @__PURE__ */ A.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ A.jsx("span", { className: Q({
                "font-semibold": M === 0
              }), children: bn(C.column.columnDef.header, C.getContext()) }),
              C.column.getCanSort() && /* @__PURE__ */ A.jsx(
                yt,
                {
                  icon: C.column.getIsSorted() ? C.column.getIsSorted() === "desc" ? "mdi:keyboard-arrow-up" : "mdi:keyboard-arrow-down" : "mdi:unfold-more-horizontal",
                  className: Q("h-4 w-4", {
                    "text-white": f !== "ghost",
                    "text-gray-700": f === "ghost"
                  })
                }
              )
            ] })
          },
          C.id
        );
      }) }, S.id)) }),
      /* @__PURE__ */ A.jsx("tbody", { className: "max-h-[50vh]", children: y.getRowModel().rows.length === 0 ? /* @__PURE__ */ A.jsx("tr", { children: /* @__PURE__ */ A.jsx(
        "td",
        {
          colSpan: y.getAllColumns().length,
          className: Q(
            "text-center border h-full w-full rounded-b-md"
          ),
          children: n || /* @__PURE__ */ A.jsxs("div", { className: "flex mx-auto w-full text-center justify-center gap-3 items-center", children: [
            /* @__PURE__ */ A.jsx("p", { children: "Data Not Found" }),
            /* @__PURE__ */ A.jsx(yt, { icon: "mdi:face-frown-open", size: 34 })
          ] })
        }
      ) }) : y.getRowModel().rows.map((S, C) => /* @__PURE__ */ A.jsx(
        "tr",
        {
          className: Q(
            "p-3",
            v.row,
            {
              [v.stripe]: C % 2 !== 0,
              "bg-white": C % 2 === 0,
              "cursor-pointer": g
            },
            r
          ),
          onClick: (M) => k(M, S.original, C),
          children: S.getVisibleCells().map((M) => {
            var R, P, I;
            return /* @__PURE__ */ A.jsx(
              "td",
              {
                className: Q(
                  "px-4 py-3 text-sm text-gray-900",
                  {
                    "text-left": ((R = M.column.columnDef.meta) == null ? void 0 : R.align) === "left",
                    "text-center": ((P = M.column.columnDef.meta) == null ? void 0 : P.align) === "center",
                    "text-right": ((I = M.column.columnDef.meta) == null ? void 0 : I.align) === "right"
                  },
                  a
                ),
                children: bn(M.column.columnDef.cell, M.getContext())
              },
              M.id
            );
          })
        },
        S.id
      )) })
    ] }) }),
    !!e.length && p && /* @__PURE__ */ A.jsx("div", { className: "p-4 bg-white rounded-b-md", children: /* @__PURE__ */ A.jsx(
      nu,
      {
        currentPage: x.current_page,
        totalPages: x.total_page,
        totalData: x.total_data,
        onPageChange: h || (() => {
        }),
        perPage: x.limit_number,
        onPerPageChange: d || (() => {
        }),
        perPageOptions: [5, 10, 20, 50, 100],
        siblingCount: 1
      }
    ) })
  ] });
}, mg = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  full: "rounded-full"
}, il = Ge(
  ({
    className: s,
    variant: e = "default",
    rounded: t = "lg",
    title: i,
    description: r,
    onClose: a,
    icon: n,
    showIcon: o = !0,
    showClose: l = !0,
    ...c
  }, h) => {
    const u = n || (o ? {
      default: "mdi:information",
      success: "mdi:check-circle",
      error: "mdi:alert-circle",
      warning: "mdi:alert",
      info: "mdi:information"
    }[e] : void 0), g = i || r;
    return /* @__PURE__ */ A.jsxs(
      "div",
      {
        ref: h,
        className: Q(
          "flex",
          r ? "items-start gap-3 p-4" : "items-center gap-2 py-2.5 px-3",
          "border border-gray-200",
          mg[t],
          {
            "bg-white": e === "default",
            "bg-success-50": e === "success",
            "bg-danger-50": e === "error",
            "bg-warning-50": e === "warning",
            "bg-info-50": e === "info"
          },
          s
        ),
        ...c,
        children: [
          u && /* @__PURE__ */ A.jsx(
            Le,
            {
              icon: u,
              className: Q(
                "flex-shrink-0",
                r ? "h-5 w-5 mt-0.5" : "h-4 w-4",
                {
                  "text-gray-500": e === "default",
                  "text-success-500": e === "success",
                  "text-danger-500": e === "error",
                  "text-warning-500": e === "warning",
                  "text-info-500": e === "info"
                }
              )
            }
          ),
          /* @__PURE__ */ A.jsxs("div", { className: "flex-1", children: [
            i && /* @__PURE__ */ A.jsx(
              "h3",
              {
                className: Q("text-sm font-medium leading-5", {
                  "text-gray-900": e === "default",
                  "text-success-900": e === "success",
                  "text-danger-900": e === "error",
                  "text-warning-900": e === "warning",
                  "text-info-900": e === "info"
                }),
                children: i
              }
            ),
            r && /* @__PURE__ */ A.jsx(
              "p",
              {
                className: Q(i ? "mt-1" : "", "text-sm leading-5", {
                  "text-gray-500": e === "default",
                  "text-success-700": e === "success",
                  "text-danger-700": e === "error",
                  "text-warning-700": e === "warning",
                  "text-info-700": e === "info"
                }),
                children: r
              }
            ),
            !g && /* @__PURE__ */ A.jsx("span", { className: "text-sm leading-5", children: c.children })
          ] }),
          l && a && /* @__PURE__ */ A.jsx(
            et,
            {
              variant: "ghost",
              size: "sm",
              onClick: a,
              className: Q(
                "flex-shrink-0 !p-1",
                r ? "ml-4" : "ml-2",
                {
                  "text-gray-400 hover:text-gray-500": e === "default",
                  "text-success-400 hover:text-success-500": e === "success",
                  "text-danger-400 hover:text-danger-500": e === "error",
                  "text-warning-400 hover:text-warning-500": e === "warning",
                  "text-info-400 hover:text-info-500": e === "info"
                }
              ),
              children: /* @__PURE__ */ A.jsx(Le, { icon: "mdi:close", className: Q(r ? "h-5 w-5" : "h-4 w-4") })
            }
          )
        ]
      }
    );
  }
);
il.displayName = "Toast";
const rl = Pl(void 0), bg = {
  "top-left": "top-4 left-4",
  "top-right": "top-4 right-4",
  "bottom-left": "bottom-4 left-4",
  "bottom-right": "bottom-4 right-4",
  "top-center": "top-4 left-1/2 -translate-x-1/2",
  "bottom-center": "bottom-4 left-1/2 -translate-x-1/2"
}, Wg = ({ children: s }) => {
  const [e, t] = Ee([]), i = bt((n) => {
    t((o) => o.filter((l) => l.id !== n));
  }, []), r = bt((n) => {
    const o = Math.random().toString(36).substr(2, 9), l = n.position || "top-right", c = n.duration || 5e3, h = {
      ...n,
      id: o,
      position: l
    };
    return t((d) => [...d, h]), c > 0 && setTimeout(() => {
      i(o);
    }, c), o;
  }, [i]), a = e.reduce((n, o) => (n[o.position] || (n[o.position] = []), n[o.position].push(o), n), {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": [],
    "top-center": [],
    "bottom-center": []
  });
  return /* @__PURE__ */ A.jsxs(rl.Provider, { value: { showToast: r, removeToast: i }, children: [
    s,
    ei(
      /* @__PURE__ */ A.jsx(A.Fragment, { children: Object.entries(a).map(([n, o]) => /* @__PURE__ */ A.jsx(
        "div",
        {
          className: Q(
            "fixed z-50 flex flex-col gap-2 min-w-[320px] max-w-[420px]",
            bg[n],
            n.includes("bottom") ? "flex-col-reverse" : "flex-col"
          ),
          children: o.map((l) => /* @__PURE__ */ A.jsx(
            il,
            {
              ...l,
              onClose: () => i(l.id),
              className: "animate-slide-in"
            },
            l.id
          ))
        },
        n
      )) }),
      document.body
    )
  ] });
}, Vg = () => {
  const s = Ll(rl);
  if (!s)
    throw new Error("useToast must be used within a ToastProvider");
  return s;
}, vg = ({
  label: s,
  value: e,
  icon: t,
  className: i
}) => /* @__PURE__ */ A.jsxs(Vn, { className: Q(
  "flex items-center gap-4 rounded-lg w-full bg-white p-4 shadow-sm hover:bg-neutral-50 transition-shadow duration-200 justify-between",
  i
), children: [
  /* @__PURE__ */ A.jsxs("div", { children: [
    /* @__PURE__ */ A.jsx("p", { className: "text-sm font-medium text-gray-500", children: s }),
    /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-2xl font-semibold text-gray-900", children: e })
  ] }),
  t && /* @__PURE__ */ A.jsx("div", { className: "flex h-12 w-12 items-center justify-center rounded-lg bg-primary-50", children: /* @__PURE__ */ A.jsx(Le, { icon: t, className: "h-6 w-6 text-primary-600" }) })
] }), yg = {
  400: {
    image: "/img/error.svg",
    message: "Bad request. Please check your input and try again."
  },
  401: {
    image: "/img/error.svg",
    message: "Please sign in to access this resource."
  },
  403: {
    image: "/img/error.svg",
    message: "You do not have permission to access this resource."
  },
  404: {
    image: "/img/page-not-found.svg",
    message: "The page you are looking for does not exist."
  },
  500: {
    image: "/img/error.svg",
    message: "Something went wrong on our end. Please try again later."
  },
  502: {
    image: "/img/error.svg",
    message: "Bad gateway. Our servers are having trouble connecting."
  },
  503: {
    image: "/img/error.svg",
    message: "Service unavailable. We are currently performing maintenance."
  },
  504: {
    image: "/img/error.svg",
    message: "Gateway timeout. The server took too long to respond."
  }
}, sl = {
  NO_INTERNET: {
    image: "/img/no-internet.svg",
    message: "Please check your internet connection and try again."
  },
  DATA_NOT_FOUND: {
    image: "/img/search-not-found.svg",
    message: "No data available for your request."
  },
  UNDER_DEVELOPMENT: {
    image: "/img/under-development.svg",
    message: "This feature is currently under development."
  },
  INFORMATION_UNAVAILABLE: {
    image: "/img/search-not-found.svg",
    message: "The requested information is currently unavailable."
  },
  SUCCESS: {
    image: "/img/payment-success.svg",
    message: "Operation completed successfully."
  },
  CHECKED: {
    image: "/img/payment-success.svg",
    message: "All checks have passed successfully."
  }
}, wg = {
  "no-internet": "NO_INTERNET",
  "data-not-found": "DATA_NOT_FOUND",
  "under-development": "UNDER_DEVELOPMENT",
  "information-unavailable": "INFORMATION_UNAVAILABLE",
  success: "SUCCESS",
  checked: "CHECKED"
}, vn = {
  ...yg,
  ...sl
}, Jr = {
  image: "/img/error.svg",
  message: "An unexpected error occurred. Our team is currently investigating the issue."
}, kg = (s) => typeof s == "object" && s !== null && ("code" in s || "message" in s), Gg = ({ error: s, reload: e, children: t, className: i = "", variant: r }) => {
  if (r) {
    const o = wg[r], l = sl[o];
    return /* @__PURE__ */ A.jsxs("div", { className: `flex flex-col items-center justify-center p-8 text-center gap-4 ${i}`, children: [
      /* @__PURE__ */ A.jsx(
        "img",
        {
          src: l.image,
          alt: "Error illustration",
          className: "max-w-[300px] h-auto"
        }
      ),
      /* @__PURE__ */ A.jsx(Br, { variant: "body1", className: "m-0", children: l.message }),
      e && /* @__PURE__ */ A.jsx(
        et,
        {
          onClick: e,
          rounded: "full",
          variant: "primary",
          size: "md",
          children: "Try Again"
        }
      )
    ] });
  }
  if (!s)
    return t ? /* @__PURE__ */ A.jsx(A.Fragment, { children: t }) : null;
  if (!kg(s))
    return /* @__PURE__ */ A.jsxs("div", { className: `flex flex-col items-center justify-center p-8 text-center gap-4 ${i}`, children: [
      /* @__PURE__ */ A.jsx(
        "img",
        {
          src: Jr.image,
          alt: "Error illustration",
          className: "max-w-[300px] h-auto"
        }
      ),
      /* @__PURE__ */ A.jsx(Br, { variant: "body1", className: "m-0", children: Jr.message }),
      e && /* @__PURE__ */ A.jsx(
        et,
        {
          onClick: e,
          rounded: "full",
          variant: "primary",
          size: "md",
          children: "Try Again"
        }
      )
    ] });
  const a = s.code && vn[s.code] ? vn[s.code] : Jr, n = s.message || a.message;
  return /* @__PURE__ */ A.jsxs("div", { className: `flex flex-col items-center justify-center p-8 text-center gap-4 ${i}`, children: [
    /* @__PURE__ */ A.jsx(
      "img",
      {
        src: a.image,
        alt: "Error illustration",
        className: "max-w-[300px] h-auto"
      }
    ),
    /* @__PURE__ */ A.jsx(Br, { variant: "body1", className: "m-0", children: n }),
    e && /* @__PURE__ */ A.jsx(
      et,
      {
        onClick: e,
        rounded: "full",
        variant: "primary",
        size: "md",
        children: "Try Again"
      }
    )
  ] });
}, Sg = rt(
  "border bg-white flex items-center justify-center aspect-square transition-colors placeholder:text-neutral-500 placeholder:text-sm focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 text-center",
  {
    variants: {
      variant: {
        default: "border-neutral-200 hover:border-primary-300 focus:border-primary-300 hover:bg-primary-50",
        error: "border-danger-500 hover:border-danger-600 focus:border-danger-600 hover:bg-danger-50",
        success: "border-success-500 hover:border-success-600 focus:border-success-600 hover:bg-success-50",
        ghost: "border-transparent bg-transparent hover:bg-primary-50 focus:bg-primary-50",
        underline: "border-0 border-b-2 border-neutral-200 rounded-none bg-transparent hover:border-primary-300 focus:border-primary-300 hover:bg-transparent focus:bg-transparent"
      },
      size: {
        sm: "h-8 w-8 text-sm",
        md: "h-12 w-12 text-lg",
        lg: "h-16 w-16 text-xl"
      },
      rounded: {
        none: "rounded-none",
        sm: "rounded-sm",
        md: "rounded-md",
        lg: "rounded-lg",
        full: "rounded-full"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      rounded: "md"
    }
  }
), Cg = Ge(
  ({
    className: s,
    variant: e = "default",
    size: t = "md",
    rounded: i = "md",
    error: r = !1,
    errorText: a,
    helperText: n,
    label: o,
    bottomLabel: l,
    required: c = !1,
    showSubmitButton: h = !1,
    submitButtonLabel: d = "Submit",
    submitButtonVariant: u = "primary",
    length: g = 6,
    numericOnly: p = !0,
    onComplete: f,
    onChange: x,
    onSubmit: m,
    value: b,
    defaultValue: w = "",
    disabled: y = !1,
    autoFocus: v = !1,
    ...k
  }, S) => {
    const [C, M] = Ee(w || ""), R = Ve([]);
    ht(() => {
      b !== void 0 && M(b);
    }, [b]);
    const P = b !== void 0, I = P ? b : C, D = (O) => {
      P || M(O), x == null || x(O), O.length === g && (f == null || f(O), h || m == null || m(O));
    }, N = (O) => (Y) => {
      R.current[O] = Y;
    }, z = (O) => {
      O.target.select();
    }, L = (O, Y) => {
      var U;
      const X = O.target.value;
      let V = "";
      if (X.length >= 1)
        V = X.slice(-1);
      else if (X.length === 0) {
        const Z = I.split("");
        Z[Y] = "", D(Z.join(""));
        return;
      }
      if (p && !/^\d$/.test(V))
        return;
      const W = I.split("");
      for (; W.length <= Y; )
        W.push("");
      W[Y] = V;
      const G = W.join("");
      D(G), Y < g - 1 && V && ((U = R.current[Y + 1]) == null || U.focus());
    }, T = (O, Y) => {
      var X, V, W;
      if (O.key === "Backspace") {
        const G = I.split("");
        I[Y] ? (O.preventDefault(), G[Y] = "", D(G.join(""))) : Y > 0 && (O.preventDefault(), G[Y - 1] = "", D(G.join("")), (X = R.current[Y - 1]) == null || X.focus());
      } else if (O.key === "Delete") {
        if (I[Y]) {
          O.preventDefault();
          const G = I.split("");
          G[Y] = "", D(G.join(""));
        }
      } else if (O.key === "ArrowLeft" && Y > 0)
        O.preventDefault(), (V = R.current[Y - 1]) == null || V.focus();
      else if (O.key === "ArrowRight" && Y < g - 1)
        O.preventDefault(), (W = R.current[Y + 1]) == null || W.focus();
      else if (!O.ctrlKey && !O.altKey && !O.metaKey && O.key.length === 1 && p && !/^\d$/.test(O.key)) {
        O.preventDefault();
        return;
      }
    }, H = (O) => {
      var G;
      O.preventDefault();
      const Y = O.clipboardData.getData("text/plain").trim();
      if (p && !/^\d+$/.test(Y))
        return;
      const V = Y.slice(0, g).padEnd(I.length, "").slice(0, g);
      D(V);
      const W = V.length < g ? V.length : g - 1;
      (G = R.current[W]) == null || G.focus();
    }, B = () => {
      I.length === g && (m == null || m(I));
    }, _ = I.split("").concat(Array(g - I.length).fill(""));
    return /* @__PURE__ */ A.jsxs("div", { ref: S, className: Q("w-full", s), ...k, children: [
      o && /* @__PURE__ */ A.jsxs("label", { className: "mb-1.5 block text-sm text-neutral-900", children: [
        o,
        c && /* @__PURE__ */ A.jsx("span", { className: "text-danger-500 ml-0.5", children: "*" })
      ] }),
      /* @__PURE__ */ A.jsxs("div", { className: "flex flex-col items-center space-y-4", children: [
        /* @__PURE__ */ A.jsx("div", { className: "flex items-center justify-center gap-2", children: Array.from({ length: g }).map((O, Y) => /* @__PURE__ */ A.jsx(
          "input",
          {
            ref: N(Y),
            type: p ? "tel" : "text",
            inputMode: p ? "numeric" : "text",
            maxLength: 1,
            value: _[Y] || "",
            onChange: (X) => L(X, Y),
            onKeyDown: (X) => T(X, Y),
            onPaste: Y === 0 ? H : void 0,
            onFocus: z,
            disabled: y,
            autoFocus: v && Y === 0,
            className: Q(
              Sg({
                variant: r ? "error" : e,
                size: t,
                rounded: i
              })
            ),
            "aria-invalid": r
          },
          Y
        )) }),
        r && a && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-xs text-danger-500 self-start", children: a }),
        !r && n && /* @__PURE__ */ A.jsx("p", { className: "mt-1 text-xs text-neutral-500 self-start", children: n }),
        l && /* @__PURE__ */ A.jsx("p", { className: "text-sm text-neutral-600", children: l }),
        h && /* @__PURE__ */ A.jsx(
          et,
          {
            variant: u,
            disabled: I.length !== g || y,
            onClick: B,
            className: "mt-4",
            children: d
          }
        )
      ] })
    ] });
  }
);
Cg.displayName = "InputOTP";
const $g = ({
  icon: s,
  variant: e = "number",
  className: t,
  color: i = "#007C99",
  plusIcon: r,
  badgeContent: a = 10,
  position: n = "top-right",
  ...o
}) => {
  let l = "", c = "";
  switch (e === "number" && (r || a && a > 99 ? l = "w-7" : l = (typeof a == "number" ? String(a).length : 1) === 1 ? "w-5" : "w-6"), n) {
    case "top-right":
      c = e === "number" ? "-top-1 -right-2.5" : "-top-1 right-0";
      break;
    case "top-left":
      c = e === "number" ? "-top-1 -left-2.5" : "-top-1 left-0";
      break;
    case "bottom-right":
      c = e === "number" ? "bottom-0 -right-3" : "bottom-0 right-0";
      break;
    case "bottom-left":
      c = e === "number" ? "bottom-0 -left-3" : "bottom-0 left-0";
      break;
  }
  return /* @__PURE__ */ A.jsxs("div", { className: "relative inline-block", children: [
    /* @__PURE__ */ A.jsx(
      Le,
      {
        icon: s,
        className: Q(
          t
        ),
        style: {
          color: i
        },
        height: 32,
        width: 32,
        ...o
      }
    ),
    /* @__PURE__ */ A.jsxs(
      "div",
      {
        className: Q(
          "absolute h-5 rounded-xl flex justify-center items-center text-[10px] bg-[#FF4C4C] text-white font-semiboldbold",
          c,
          e === "number" ? `${l} h-5` : "w-2.5 h-2.5",
          e === "dot" ? "" : "p-1"
        ),
        children: [
          e === "number" && (a && a > 99 ? "99" : a),
          e === "number" && (r || a && a > 99) && "+"
        ]
      }
    )
  ] });
}, Ug = ({
  widgets: s,
  className: e
}) => /* @__PURE__ */ A.jsx("div", { className: Q("w-full grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4", e), children: s.map((t, i) => /* @__PURE__ */ A.jsx(vg, { ...t }, i)) });
export {
  Rg as Accordion,
  ph as AutoComplete,
  Pg as Avatar,
  Lg as Badge,
  $g as BadgeNotif,
  wu as Breadcrumbs,
  et as Button,
  Vn as Card,
  Ig as Chart,
  Eg as Checkbox,
  Tg as Chip,
  Kd as DatePicker,
  Qd as Dialog,
  iu as DialogActions,
  tu as DialogBody,
  Xo as DialogHeader,
  eu as DialogTitle,
  ru as Divider,
  Gg as ErrorWrapper,
  _g as FileUpload,
  yt as Icon,
  Wn as Input,
  Cg as InputOTP,
  Og as Notification,
  nu as Pagination,
  zg as Radio,
  Bo as Select,
  sr as SelectItem,
  lu as Skeleton,
  Fg as Slider,
  Ng as StarRating,
  Dg as StatusIndicator,
  Hg as Stepper,
  jg as Switch,
  Bg as Table,
  Yg as Tabs,
  Br as Text,
  xu as TimePicker,
  il as Toast,
  Wg as ToastProvider,
  vu as Toggle,
  Xg as Tooltip,
  vg as WidgetCard,
  Ug as WidgetCardGroup,
  xh as buttonVariants,
  mh as cardVariants,
  Q as cn,
  Sg as inputOTPVariants,
  mu as toggleVariants,
  Vg as useToast
};
